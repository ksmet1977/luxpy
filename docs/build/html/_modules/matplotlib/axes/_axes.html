

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>matplotlib.axes._axes &mdash; LuxPy 1.5.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> LuxPy
          

          
          </a>

          
            
            
              <div class="version">
                1.5.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License: GPLv3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../required_packages.html">Imported (required) packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../luxpy_structure.html">Luxpy package structure</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">LuxPy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>matplotlib.axes._axes</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for matplotlib.axes._axes</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">collections.abc</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">ma</span>

<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">_preprocess_data</span><span class="p">,</span> <span class="n">rcParams</span>
<span class="kn">import</span> <span class="nn">matplotlib.cbook</span> <span class="k">as</span> <span class="nn">cbook</span>
<span class="kn">import</span> <span class="nn">matplotlib.collections</span> <span class="k">as</span> <span class="nn">mcoll</span>
<span class="kn">import</span> <span class="nn">matplotlib.colors</span> <span class="k">as</span> <span class="nn">mcolors</span>
<span class="kn">import</span> <span class="nn">matplotlib.contour</span> <span class="k">as</span> <span class="nn">mcontour</span>
<span class="kn">import</span> <span class="nn">matplotlib.category</span> <span class="k">as</span> <span class="nn">_</span>  <span class="c1"># &lt;-registers a category unit converter</span>
<span class="kn">import</span> <span class="nn">matplotlib.dates</span> <span class="k">as</span> <span class="nn">_</span>  <span class="c1"># &lt;-registers a date unit converter</span>
<span class="kn">import</span> <span class="nn">matplotlib.docstring</span> <span class="k">as</span> <span class="nn">docstring</span>
<span class="kn">import</span> <span class="nn">matplotlib.image</span> <span class="k">as</span> <span class="nn">mimage</span>
<span class="kn">import</span> <span class="nn">matplotlib.legend</span> <span class="k">as</span> <span class="nn">mlegend</span>
<span class="kn">import</span> <span class="nn">matplotlib.lines</span> <span class="k">as</span> <span class="nn">mlines</span>
<span class="kn">import</span> <span class="nn">matplotlib.markers</span> <span class="k">as</span> <span class="nn">mmarkers</span>
<span class="kn">import</span> <span class="nn">matplotlib.mlab</span> <span class="k">as</span> <span class="nn">mlab</span>
<span class="kn">import</span> <span class="nn">matplotlib.path</span> <span class="k">as</span> <span class="nn">mpath</span>
<span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="k">as</span> <span class="nn">mpatches</span>
<span class="kn">import</span> <span class="nn">matplotlib.quiver</span> <span class="k">as</span> <span class="nn">mquiver</span>
<span class="kn">import</span> <span class="nn">matplotlib.stackplot</span> <span class="k">as</span> <span class="nn">mstack</span>
<span class="kn">import</span> <span class="nn">matplotlib.streamplot</span> <span class="k">as</span> <span class="nn">mstream</span>
<span class="kn">import</span> <span class="nn">matplotlib.table</span> <span class="k">as</span> <span class="nn">mtable</span>
<span class="kn">import</span> <span class="nn">matplotlib.text</span> <span class="k">as</span> <span class="nn">mtext</span>
<span class="kn">import</span> <span class="nn">matplotlib.ticker</span> <span class="k">as</span> <span class="nn">mticker</span>
<span class="kn">import</span> <span class="nn">matplotlib.transforms</span> <span class="k">as</span> <span class="nn">mtransforms</span>
<span class="kn">import</span> <span class="nn">matplotlib.tri</span> <span class="k">as</span> <span class="nn">mtri</span>
<span class="kn">from</span> <span class="nn">matplotlib.container</span> <span class="kn">import</span> <span class="n">BarContainer</span><span class="p">,</span> <span class="n">ErrorbarContainer</span><span class="p">,</span> <span class="n">StemContainer</span>
<span class="kn">from</span> <span class="nn">matplotlib.axes._base</span> <span class="kn">import</span> <span class="n">_AxesBase</span><span class="p">,</span> <span class="n">_process_plot_format</span>
<span class="kn">from</span> <span class="nn">matplotlib.axes._secondary_axes</span> <span class="kn">import</span> <span class="n">SecondaryAxis</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">numpy.lib.histograms</span> <span class="kn">import</span> <span class="n">histogram_bin_edges</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="c1"># this function is new in np 1.15</span>
    <span class="k">def</span> <span class="nf">histogram_bin_edges</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># this in True for 1D arrays, and False for None and str</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">bins</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># rather than backporting the internals, just do the full</span>
            <span class="c1"># computation.  If this is too slow for users, they can</span>
            <span class="c1"># update numpy, or pick a manual number of bins</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">weights</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># hard-code numpy&#39;s default</span>
                <span class="n">bins</span> <span class="o">=</span> <span class="mi">10</span>
            <span class="k">if</span> <span class="nb">range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">*</span><span class="nb">range</span><span class="p">,</span> <span class="n">bins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>


<span class="n">_log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_make_inset_locator</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function to locate inset axes, used in</span>
<span class="sd">    `.Axes.inset_axes`.</span>

<span class="sd">    A locator gets used in `Axes.set_aspect` to override the default</span>
<span class="sd">    locations...  It is a function that takes an axes object and</span>
<span class="sd">    a renderer and tells `set_aspect` where it is to be placed.</span>

<span class="sd">    Here *rect* is a rectangle [l, b, w, h] that specifies the</span>
<span class="sd">    location for the axes in the transform given by *trans* on the</span>
<span class="sd">    *parent*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_bounds</span> <span class="o">=</span> <span class="n">mtransforms</span><span class="o">.</span><span class="n">Bbox</span><span class="o">.</span><span class="n">from_bounds</span><span class="p">(</span><span class="o">*</span><span class="n">bounds</span><span class="p">)</span>
    <span class="n">_trans</span> <span class="o">=</span> <span class="n">trans</span>
    <span class="n">_parent</span> <span class="o">=</span> <span class="n">parent</span>

    <span class="k">def</span> <span class="nf">inset_locator</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">renderer</span><span class="p">):</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="n">_bounds</span>
        <span class="n">bb</span> <span class="o">=</span> <span class="n">mtransforms</span><span class="o">.</span><span class="n">TransformedBbox</span><span class="p">(</span><span class="n">bbox</span><span class="p">,</span> <span class="n">_trans</span><span class="p">)</span>
        <span class="n">tr</span> <span class="o">=</span> <span class="n">_parent</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">transFigure</span><span class="o">.</span><span class="n">inverted</span><span class="p">()</span>
        <span class="n">bb</span> <span class="o">=</span> <span class="n">mtransforms</span><span class="o">.</span><span class="n">TransformedBbox</span><span class="p">(</span><span class="n">bb</span><span class="p">,</span> <span class="n">tr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bb</span>

    <span class="k">return</span> <span class="n">inset_locator</span>


<span class="c1"># The axes module contains all the wrappers to plotting functions.</span>
<span class="c1"># All the other methods should go in the _AxesBase class.</span>


<span class="k">class</span> <span class="nc">Axes</span><span class="p">(</span><span class="n">_AxesBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The :class:`Axes` contains most of the figure elements:</span>
<span class="sd">    :class:`~matplotlib.axis.Axis`, :class:`~matplotlib.axis.Tick`,</span>
<span class="sd">    :class:`~matplotlib.lines.Line2D`, :class:`~matplotlib.text.Text`,</span>
<span class="sd">    :class:`~matplotlib.patches.Polygon`, etc., and sets the</span>
<span class="sd">    coordinate system.</span>

<span class="sd">    The :class:`Axes` instance supports callbacks through a callbacks</span>
<span class="sd">    attribute which is a :class:`~matplotlib.cbook.CallbackRegistry`</span>
<span class="sd">    instance.  The events you can connect to are &#39;xlim_changed&#39; and</span>
<span class="sd">    &#39;ylim_changed&#39; and the callback will be called with func(*ax*)</span>
<span class="sd">    where *ax* is the :class:`Axes` instance.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    dataLim : `.BBox`</span>
<span class="sd">        The bounding box enclosing all data displayed in the Axes.</span>
<span class="sd">    viewLim : `.BBox`</span>
<span class="sd">        The view limits in data coordinates.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">### Labelling, legend and texts</span>

    <span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;3.1&quot;</span><span class="p">)</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">aname</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;Axes&#39;</span>

    <span class="k">def</span> <span class="nf">get_title</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get an axes title.</span>

<span class="sd">        Get one of the three available axes titles. The available titles</span>
<span class="sd">        are positioned above the axes in the center, flush with the left</span>
<span class="sd">        edge, and flush with the right edge.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loc : {&#39;center&#39;, &#39;left&#39;, &#39;right&#39;}, str, optional</span>
<span class="sd">            Which title to get, defaults to &#39;center&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        title : str</span>
<span class="sd">            The title text string.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left_title</span><span class="p">,</span>
                     <span class="s1">&#39;center&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="p">,</span>
                     <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right_title</span><span class="p">}[</span><span class="n">loc</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; is not a valid location&quot;</span> <span class="o">%</span> <span class="n">loc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">title</span><span class="o">.</span><span class="n">get_text</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">set_title</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">fontdict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a title for the axes.</span>

<span class="sd">        Set one of the three available axes titles. The available titles</span>
<span class="sd">        are positioned above the axes in the center, flush with the left</span>
<span class="sd">        edge, and flush with the right edge.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : str</span>
<span class="sd">            Text to use for the title</span>

<span class="sd">        fontdict : dict</span>
<span class="sd">            A dictionary controlling the appearance of the title text,</span>
<span class="sd">            the default `fontdict` is::</span>

<span class="sd">               {&#39;fontsize&#39;: rcParams[&#39;axes.titlesize&#39;],</span>
<span class="sd">                &#39;fontweight&#39; : rcParams[&#39;axes.titleweight&#39;],</span>
<span class="sd">                &#39;verticalalignment&#39;: &#39;baseline&#39;,</span>
<span class="sd">                &#39;horizontalalignment&#39;: loc}</span>

<span class="sd">        loc : {&#39;center&#39;, &#39;left&#39;, &#39;right&#39;}, str, optional</span>
<span class="sd">            Which title to set, defaults to &#39;center&#39;</span>

<span class="sd">        pad : float</span>
<span class="sd">            The offset of the title from the top of the axes, in points.</span>
<span class="sd">            Default is ``None`` to use rcParams[&#39;axes.titlepad&#39;].</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        text : :class:`~matplotlib.text.Text`</span>
<span class="sd">            The matplotlib text instance representing the title</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs : `~matplotlib.text.Text` properties</span>
<span class="sd">            Other keyword arguments are text properties, see</span>
<span class="sd">            :class:`~matplotlib.text.Text` for a list of valid text</span>
<span class="sd">            properties.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left_title</span><span class="p">,</span>
                     <span class="s1">&#39;center&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="p">,</span>
                     <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right_title</span><span class="p">}[</span><span class="n">loc</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; is not a valid location&quot;</span> <span class="o">%</span> <span class="n">loc</span><span class="p">)</span>
        <span class="n">default</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;fontsize&#39;</span><span class="p">:</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;axes.titlesize&#39;</span><span class="p">],</span>
            <span class="s1">&#39;fontweight&#39;</span><span class="p">:</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;axes.titleweight&#39;</span><span class="p">],</span>
            <span class="s1">&#39;verticalalignment&#39;</span><span class="p">:</span> <span class="s1">&#39;baseline&#39;</span><span class="p">,</span>
            <span class="s1">&#39;horizontalalignment&#39;</span><span class="p">:</span> <span class="n">loc</span><span class="o">.</span><span class="n">lower</span><span class="p">()}</span>
        <span class="k">if</span> <span class="n">pad</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pad</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;axes.titlepad&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_title_offset_trans</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">pad</span><span class="p">))</span>
        <span class="n">title</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="n">title</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">default</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fontdict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">title</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fontdict</span><span class="p">)</span>
        <span class="n">title</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">title</span>

    <span class="k">def</span> <span class="nf">get_xlabel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the xlabel text string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">get_label</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">label</span><span class="o">.</span><span class="n">get_text</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">set_xlabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xlabel</span><span class="p">,</span> <span class="n">fontdict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">labelpad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the label for the x-axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xlabel : str</span>
<span class="sd">            The label text.</span>

<span class="sd">        labelpad : scalar, optional, default: None</span>
<span class="sd">            Spacing in points from the axes bounding box including ticks</span>
<span class="sd">            and tick labels.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs : `.Text` properties</span>
<span class="sd">            `.Text` properties control the appearance of the label.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        text : for information on how override and the optional args work</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">labelpad</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">labelpad</span> <span class="o">=</span> <span class="n">labelpad</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_label_text</span><span class="p">(</span><span class="n">xlabel</span><span class="p">,</span> <span class="n">fontdict</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_ylabel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the ylabel text string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">get_label</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">label</span><span class="o">.</span><span class="n">get_text</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">set_ylabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ylabel</span><span class="p">,</span> <span class="n">fontdict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">labelpad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the label for the y-axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ylabel : str</span>
<span class="sd">            The label text.</span>

<span class="sd">        labelpad : scalar, optional, default: None</span>
<span class="sd">            Spacing in points from the axes bounding box including ticks</span>
<span class="sd">            and tick labels.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs : `.Text` properties</span>
<span class="sd">            `.Text` properties control the appearance of the label.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        text : for information on how override and the optional args work</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">labelpad</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">labelpad</span> <span class="o">=</span> <span class="n">labelpad</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_label_text</span><span class="p">(</span><span class="n">ylabel</span><span class="p">,</span> <span class="n">fontdict</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_legend_handles_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">legend_handler_map</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return handles and labels for legend</span>

<span class="sd">        ``ax.legend()`` is equivalent to ::</span>

<span class="sd">          h, l = ax.get_legend_handles_labels()</span>
<span class="sd">          ax.legend(h, l)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># pass through to legend.</span>
        <span class="n">handles</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">mlegend</span><span class="o">.</span><span class="n">_get_legend_handles_labels</span><span class="p">([</span><span class="bp">self</span><span class="p">],</span>
                <span class="n">legend_handler_map</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">handles</span><span class="p">,</span> <span class="n">labels</span>

    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">legend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Place a legend on the axes.</span>

<span class="sd">        Call signatures::</span>

<span class="sd">            legend()</span>
<span class="sd">            legend(labels)</span>
<span class="sd">            legend(handles, labels)</span>

<span class="sd">        The call signatures correspond to three different ways how to use</span>
<span class="sd">        this method.</span>

<span class="sd">        **1. Automatic detection of elements to be shown in the legend**</span>

<span class="sd">        The elements to be added to the legend are automatically determined,</span>
<span class="sd">        when you do not pass in any extra arguments.</span>

<span class="sd">        In this case, the labels are taken from the artist. You can specify</span>
<span class="sd">        them either at artist creation or by calling the</span>
<span class="sd">        :meth:`~.Artist.set_label` method on the artist::</span>

<span class="sd">            line, = ax.plot([1, 2, 3], label=&#39;Inline label&#39;)</span>
<span class="sd">            ax.legend()</span>

<span class="sd">        or::</span>

<span class="sd">            line, = ax.plot([1, 2, 3])</span>
<span class="sd">            line.set_label(&#39;Label via method&#39;)</span>
<span class="sd">            ax.legend()</span>

<span class="sd">        Specific lines can be excluded from the automatic legend element</span>
<span class="sd">        selection by defining a label starting with an underscore.</span>
<span class="sd">        This is default for all artists, so calling `Axes.legend` without</span>
<span class="sd">        any arguments and without setting the labels manually will result in</span>
<span class="sd">        no legend being drawn.</span>


<span class="sd">        **2. Labeling existing plot elements**</span>

<span class="sd">        To make a legend for lines which already exist on the axes</span>
<span class="sd">        (via plot for instance), simply call this function with an iterable</span>
<span class="sd">        of strings, one for each legend item. For example::</span>

<span class="sd">            ax.plot([1, 2, 3])</span>
<span class="sd">            ax.legend([&#39;A simple line&#39;])</span>

<span class="sd">        Note: This way of using is discouraged, because the relation between</span>
<span class="sd">        plot elements and labels is only implicit by their order and can</span>
<span class="sd">        easily be mixed up.</span>


<span class="sd">        **3. Explicitly defining the elements in the legend**</span>

<span class="sd">        For full control of which artists have a legend entry, it is possible</span>
<span class="sd">        to pass an iterable of legend artists followed by an iterable of</span>
<span class="sd">        legend labels respectively::</span>

<span class="sd">            legend((line1, line2, line3), (&#39;label1&#39;, &#39;label2&#39;, &#39;label3&#39;))</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        handles : sequence of `.Artist`, optional</span>
<span class="sd">            A list of Artists (lines, patches) to be added to the legend.</span>
<span class="sd">            Use this together with *labels*, if you need full control on what</span>
<span class="sd">            is shown in the legend and the automatic mechanism described above</span>
<span class="sd">            is not sufficient.</span>

<span class="sd">            The length of handles and labels should be the same in this</span>
<span class="sd">            case. If they are not, they are truncated to the smaller length.</span>

<span class="sd">        labels : sequence of strings, optional</span>
<span class="sd">            A list of labels to show next to the artists.</span>
<span class="sd">            Use this together with *handles*, if you need full control on what</span>
<span class="sd">            is shown in the legend and the automatic mechanism described above</span>
<span class="sd">            is not sufficient.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>

<span class="sd">        %(_legend_kw_doc)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        :class:`matplotlib.legend.Legend` instance</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        Not all kinds of artist are supported by the legend command. See</span>
<span class="sd">        :doc:`/tutorials/intermediate/legend_guide` for details.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        .. plot:: gallery/text_labels_and_annotations/legend.py</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">handles</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">extra_args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">mlegend</span><span class="o">.</span><span class="n">_parse_legend_args</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="p">],</span>
                <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">extra_args</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;legend only accepts two non-keyword arguments&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">legend_</span> <span class="o">=</span> <span class="n">mlegend</span><span class="o">.</span><span class="n">Legend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">handles</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">legend_</span><span class="o">.</span><span class="n">_remove_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_legend</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">legend_</span>

    <span class="k">def</span> <span class="nf">_remove_legend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">legend</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">legend_</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">inset_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a child inset axes to this existing axes.</span>

<span class="sd">        Warnings</span>
<span class="sd">        --------</span>

<span class="sd">        This method is experimental as of 3.0, and the API may change.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        bounds : [x0, y0, width, height]</span>
<span class="sd">            Lower-left corner of inset axes, and its width and height.</span>

<span class="sd">        transform : `.Transform`</span>
<span class="sd">            Defaults to `ax.transAxes`, i.e. the units of *rect* are in</span>
<span class="sd">            axes-relative coordinates.</span>

<span class="sd">        zorder : number</span>
<span class="sd">            Defaults to 5 (same as `.Axes.legend`).  Adjust higher or lower</span>
<span class="sd">            to change whether it is above or below data plotted on the</span>
<span class="sd">            parent axes.</span>

<span class="sd">        **kwargs</span>

<span class="sd">            Other *kwargs* are passed on to the `axes.Axes` child axes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        Axes</span>
<span class="sd">            The created `.axes.Axes` instance.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        This example makes two inset axes, the first is in axes-relative</span>
<span class="sd">        coordinates, and the second in data-coordinates::</span>

<span class="sd">            fig, ax = plt.subplots()</span>
<span class="sd">            ax.plot(range(10))</span>
<span class="sd">            axin1 = ax.inset_axes([0.8, 0.1, 0.15, 0.15])</span>
<span class="sd">            axin2 = ax.inset_axes(</span>
<span class="sd">                    [5, 7, 2.3, 2.3], transform=ax.transData)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">transform</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transAxes</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;inset_axes&#39;</span><span class="p">)</span>

        <span class="c1"># This puts the rectangle into figure-relative coordinates.</span>
        <span class="n">inset_locator</span> <span class="o">=</span> <span class="n">_make_inset_locator</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">bb</span> <span class="o">=</span> <span class="n">inset_locator</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">inset_ax</span> <span class="o">=</span> <span class="n">Axes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">figure</span><span class="p">,</span> <span class="n">bb</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="n">zorder</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># this locator lets the axes move if in data coordinates.</span>
        <span class="c1"># it gets called in `ax.apply_aspect() (of all places)</span>
        <span class="n">inset_ax</span><span class="o">.</span><span class="n">set_axes_locator</span><span class="p">(</span><span class="n">inset_locator</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_child_axes</span><span class="p">(</span><span class="n">inset_ax</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">inset_ax</span>

    <span class="k">def</span> <span class="nf">indicate_inset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">inset_ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;0.5&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">zorder</span><span class="o">=</span><span class="mf">4.99</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an inset indicator to the axes.  This is a rectangle on the plot</span>
<span class="sd">        at the position indicated by *bounds* that optionally has lines that</span>
<span class="sd">        connect the rectangle to an inset axes</span>
<span class="sd">        (`.Axes.inset_axes`).</span>

<span class="sd">        Warnings</span>
<span class="sd">        --------</span>

<span class="sd">        This method is experimental as of 3.0, and the API may change.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        bounds : [x0, y0, width, height]</span>
<span class="sd">            Lower-left corner of rectangle to be marked, and its width</span>
<span class="sd">            and height.</span>

<span class="sd">        inset_ax : `.Axes`</span>
<span class="sd">            An optional inset axes to draw connecting lines to.  Two lines are</span>
<span class="sd">            drawn connecting the indicator box to the inset axes on corners</span>
<span class="sd">            chosen so as to not overlap with the indicator box.</span>

<span class="sd">        transform : `.Transform`</span>
<span class="sd">            Transform for the rectangle co-ordinates. Defaults to</span>
<span class="sd">            `ax.transAxes`, i.e. the units of *rect* are in axes-relative</span>
<span class="sd">            coordinates.</span>

<span class="sd">        facecolor : Matplotlib color</span>
<span class="sd">            Facecolor of the rectangle (default &#39;none&#39;).</span>

<span class="sd">        edgecolor : Matplotlib color</span>
<span class="sd">            Color of the rectangle and color of the connecting lines.  Default</span>
<span class="sd">            is &#39;0.5&#39;.</span>

<span class="sd">        alpha : number</span>
<span class="sd">            Transparency of the rectangle and connector lines.  Default is 0.5.</span>

<span class="sd">        zorder : number</span>
<span class="sd">            Drawing order of the rectangle and connector lines. Default is 4.99</span>
<span class="sd">            (just below the default level of inset axes).</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Other *kwargs* are passed on to the rectangle patch.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        rectangle_patch : `.Patches.Rectangle`</span>
<span class="sd">             Rectangle artist.</span>

<span class="sd">        connector_lines : 4-tuple of `.Patches.ConnectionPatch`</span>
<span class="sd">            One for each of four connector lines.  Two are set with visibility</span>
<span class="sd">            to *False*,  but the user can set the visibility to True if the</span>
<span class="sd">            automatic choice is not deemed correct.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># to make the axes connectors work, we need to apply the aspect to</span>
        <span class="c1"># the parent axes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_aspect</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">transform</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transData</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;indicate_inset&#39;</span><span class="p">)</span>

        <span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">rectpatch</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                <span class="n">facecolor</span><span class="o">=</span><span class="n">facecolor</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="n">edgecolor</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                <span class="n">zorder</span><span class="o">=</span><span class="n">zorder</span><span class="p">,</span>  <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">rectpatch</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inset_ax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># want to connect the indicator to the rect....</span>
            <span class="n">connects</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">xr</span> <span class="o">=</span> <span class="p">[</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
            <span class="n">yr</span> <span class="o">=</span> <span class="p">[</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">xc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">yc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">xyA</span> <span class="o">=</span> <span class="p">(</span><span class="n">xc</span><span class="p">,</span> <span class="n">yc</span><span class="p">)</span>
                    <span class="n">xyB</span> <span class="o">=</span> <span class="p">(</span><span class="n">xr</span><span class="p">[</span><span class="n">xc</span><span class="p">],</span> <span class="n">yr</span><span class="p">[</span><span class="n">yc</span><span class="p">])</span>
                    <span class="n">connects</span> <span class="o">+=</span> <span class="p">[</span><span class="n">mpatches</span><span class="o">.</span><span class="n">ConnectionPatch</span><span class="p">(</span><span class="n">xyA</span><span class="p">,</span> <span class="n">xyB</span><span class="p">,</span>
                            <span class="s1">&#39;axes fraction&#39;</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span>
                            <span class="n">axesA</span><span class="o">=</span><span class="n">inset_ax</span><span class="p">,</span> <span class="n">axesB</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">arrowstyle</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span>
                            <span class="n">zorder</span><span class="o">=</span><span class="n">zorder</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="n">edgecolor</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">connects</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># decide which two of the lines to keep visible....</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">inset_ax</span><span class="o">.</span><span class="n">get_position</span><span class="p">()</span>
            <span class="n">bboxins</span> <span class="o">=</span> <span class="n">pos</span><span class="o">.</span><span class="n">transformed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">transFigure</span><span class="p">)</span>
            <span class="n">rectbbox</span> <span class="o">=</span> <span class="n">mtransforms</span><span class="o">.</span><span class="n">Bbox</span><span class="o">.</span><span class="n">from_bounds</span><span class="p">(</span>
                        <span class="o">*</span><span class="n">bounds</span><span class="p">)</span><span class="o">.</span><span class="n">transformed</span><span class="p">(</span><span class="n">transform</span><span class="p">)</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">rectbbox</span><span class="o">.</span><span class="n">x0</span> <span class="o">&lt;</span> <span class="n">bboxins</span><span class="o">.</span><span class="n">x0</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">rectbbox</span><span class="o">.</span><span class="n">x1</span> <span class="o">&lt;</span> <span class="n">bboxins</span><span class="o">.</span><span class="n">x1</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="n">rectbbox</span><span class="o">.</span><span class="n">y0</span> <span class="o">&lt;</span> <span class="n">bboxins</span><span class="o">.</span><span class="n">y0</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="n">rectbbox</span><span class="o">.</span><span class="n">y1</span> <span class="o">&lt;</span> <span class="n">bboxins</span><span class="o">.</span><span class="n">y1</span>
            <span class="n">connects</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="n">x0</span> <span class="o">^</span> <span class="n">y0</span><span class="p">)</span>
            <span class="n">connects</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="n">x0</span> <span class="o">==</span> <span class="n">y1</span><span class="p">)</span>
            <span class="n">connects</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="n">x1</span> <span class="o">==</span> <span class="n">y0</span><span class="p">)</span>
            <span class="n">connects</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="n">x1</span> <span class="o">^</span> <span class="n">y1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">rectpatch</span><span class="p">,</span> <span class="n">connects</span>

    <span class="k">def</span> <span class="nf">indicate_inset_zoom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inset_ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an inset indicator rectangle to the axes based on the axis</span>
<span class="sd">        limits for an *inset_ax* and draw connectors between *inset_ax*</span>
<span class="sd">        and the rectangle.</span>

<span class="sd">        Warnings</span>
<span class="sd">        --------</span>

<span class="sd">        This method is experimental as of 3.0, and the API may change.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        inset_ax : `.Axes`</span>
<span class="sd">            Inset axes to draw connecting lines to.  Two lines are</span>
<span class="sd">            drawn connecting the indicator box to the inset axes on corners</span>
<span class="sd">            chosen so as to not overlap with the indicator box.</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Other *kwargs* are passed on to `.Axes.inset_rectangle`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        rectangle_patch : `.Patches.Rectangle`</span>
<span class="sd">             Rectangle artist.</span>

<span class="sd">        connector_lines : 4-tuple of `.Patches.ConnectionPatch`</span>
<span class="sd">            One for each of four connector lines.  Two are set with visibility</span>
<span class="sd">            to *False*,  but the user can set the visibility to True if the</span>
<span class="sd">            automatic choice is not deemed correct.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">xlim</span> <span class="o">=</span> <span class="n">inset_ax</span><span class="o">.</span><span class="n">get_xlim</span><span class="p">()</span>
        <span class="n">ylim</span> <span class="o">=</span> <span class="n">inset_ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()</span>
        <span class="n">rect</span> <span class="o">=</span> <span class="p">[</span><span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ylim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ylim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ylim</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">rectpatch</span><span class="p">,</span> <span class="n">connects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indicate_inset</span><span class="p">(</span>
                <span class="n">rect</span><span class="p">,</span> <span class="n">inset_ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">rectpatch</span><span class="p">,</span> <span class="n">connects</span>

    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">secondary_xaxis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">functions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a second x-axis to this axes.</span>

<span class="sd">        For example if we want to have a second scale for the data plotted on</span>
<span class="sd">        the xaxis.</span>

<span class="sd">        %(_secax_docstring)s</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        The main axis shows frequency, and the secondary axis shows period.</span>

<span class="sd">        .. plot::</span>

<span class="sd">            fig, ax = plt.subplots()</span>
<span class="sd">            ax.loglog(range(1, 360, 5), range(1, 360, 5))</span>
<span class="sd">            ax.set_xlabel(&#39;frequency [Hz]&#39;)</span>


<span class="sd">            def invert(x):</span>
<span class="sd">                return 1 / x</span>

<span class="sd">            secax = ax.secondary_xaxis(&#39;top&#39;, functions=(invert, invert))</span>
<span class="sd">            secax.set_xlabel(&#39;Period [s]&#39;)</span>
<span class="sd">            plt.show()</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">location</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="s1">&#39;bottom&#39;</span><span class="p">]</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">Number</span><span class="p">)):</span>
            <span class="n">secondary_ax</span> <span class="o">=</span> <span class="n">SecondaryAxis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">functions</span><span class="p">,</span>
                                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_child_axes</span><span class="p">(</span><span class="n">secondary_ax</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">secondary_ax</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;secondary_xaxis location must be either &#39;</span>
                             <span class="s1">&#39;a float or &quot;top&quot;/&quot;bottom&quot;&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">secondary_yaxis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">functions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a second y-axis to this axes.</span>

<span class="sd">        For example if we want to have a second scale for the data plotted on</span>
<span class="sd">        the yaxis.</span>

<span class="sd">        %(_secax_docstring)s</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Add a secondary axes that converts from radians to degrees</span>

<span class="sd">        .. plot::</span>

<span class="sd">            fig, ax = plt.subplots()</span>
<span class="sd">            ax.plot(range(1, 360, 5), range(1, 360, 5))</span>
<span class="sd">            ax.set_ylabel(&#39;degrees&#39;)</span>
<span class="sd">            secax = ax.secondary_yaxis(&#39;right&#39;, functions=(np.deg2rad,</span>
<span class="sd">                                                           np.rad2deg))</span>
<span class="sd">            secax.set_ylabel(&#39;radians&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">location</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">]</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">Number</span><span class="p">):</span>
            <span class="n">secondary_ax</span> <span class="o">=</span> <span class="n">SecondaryAxis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span>
                                         <span class="n">functions</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_child_axes</span><span class="p">(</span><span class="n">secondary_ax</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">secondary_ax</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;secondary_yaxis location must be either &#39;</span>
                             <span class="s1">&#39;a float or &quot;left&quot;/&quot;right&quot;&#39;</span><span class="p">)</span>

    <span class="nd">@cbook</span><span class="o">.</span><span class="n">_delete_parameter</span><span class="p">(</span><span class="s2">&quot;3.1&quot;</span><span class="p">,</span> <span class="s2">&quot;withdash&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fontdict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">withdash</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add text to the axes.</span>

<span class="sd">        Add the text *s* to the axes at location *x*, *y* in data coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : scalars</span>
<span class="sd">            The position to place the text. By default, this is in data</span>
<span class="sd">            coordinates. The coordinate system can be changed using the</span>
<span class="sd">            *transform* parameter.</span>

<span class="sd">        s : str</span>
<span class="sd">            The text.</span>

<span class="sd">        fontdict : dictionary, optional, default: None</span>
<span class="sd">            A dictionary to override the default text properties. If fontdict</span>
<span class="sd">            is None, the defaults are determined by your rc parameters.</span>

<span class="sd">        withdash : boolean, optional, default: False</span>
<span class="sd">            Creates a `~matplotlib.text.TextWithDash` instance instead of a</span>
<span class="sd">            `~matplotlib.text.Text` instance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        text : `.Text`</span>
<span class="sd">            The created `.Text` instance.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs : `~matplotlib.text.Text` properties.</span>
<span class="sd">            Other miscellaneous text parameters.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Individual keyword arguments can be used to override any given</span>
<span class="sd">        parameter::</span>

<span class="sd">            &gt;&gt;&gt; text(x, y, s, fontsize=12)</span>

<span class="sd">        The default transform specifies that text is in data coords,</span>
<span class="sd">        alternatively, you can specify text in axis coords (0,0 is</span>
<span class="sd">        lower-left and 1,1 is upper-right).  The example below places</span>
<span class="sd">        text in the center of the axes::</span>

<span class="sd">            &gt;&gt;&gt; text(0.5, 0.5, &#39;matplotlib&#39;, horizontalalignment=&#39;center&#39;,</span>
<span class="sd">            ...      verticalalignment=&#39;center&#39;, transform=ax.transAxes)</span>

<span class="sd">        You can put a rectangular box around the text instance (e.g., to</span>
<span class="sd">        set a background color) by using the keyword `bbox`.  `bbox` is</span>
<span class="sd">        a dictionary of `~matplotlib.patches.Rectangle`</span>
<span class="sd">        properties.  For example::</span>

<span class="sd">            &gt;&gt;&gt; text(x, y, s, bbox=dict(facecolor=&#39;red&#39;, alpha=0.5))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fontdict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fontdict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">effective_kwargs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;verticalalignment&#39;</span><span class="p">:</span> <span class="s1">&#39;baseline&#39;</span><span class="p">,</span>
            <span class="s1">&#39;horizontalalignment&#39;</span><span class="p">:</span> <span class="s1">&#39;left&#39;</span><span class="p">,</span>
            <span class="s1">&#39;transform&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span>
            <span class="s1">&#39;clip_on&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="o">**</span><span class="n">fontdict</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># At some point if we feel confident that TextWithDash</span>
        <span class="c1"># is robust as a drop-in replacement for Text and that</span>
        <span class="c1"># the performance impact of the heavier-weight class</span>
        <span class="c1"># isn&#39;t too significant, it may make sense to eliminate</span>
        <span class="c1"># the withdash kwarg and simply delegate whether there&#39;s</span>
        <span class="c1"># a dash to TextWithDash and dashlength.</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">withdash</span>
                <span class="ow">and</span> <span class="n">withdash</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">cbook</span><span class="o">.</span><span class="n">deprecation</span><span class="o">.</span><span class="n">_deprecated_parameter</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">mtext</span><span class="o">.</span><span class="n">TextWithDash</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">mtext</span><span class="o">.</span><span class="n">Text</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">effective_kwargs</span><span class="p">)</span>

        <span class="n">t</span><span class="o">.</span><span class="n">set_clip_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">patch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_text</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t</span>

    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">annotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">xy</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">mtext</span><span class="o">.</span><span class="n">Annotation</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">xy</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">a</span><span class="o">.</span><span class="n">set_transform</span><span class="p">(</span><span class="n">mtransforms</span><span class="o">.</span><span class="n">IdentityTransform</span><span class="p">())</span>
        <span class="k">if</span> <span class="s1">&#39;clip_on&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">set_clip_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">patch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_text</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="n">annotate</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">mtext</span><span class="o">.</span><span class="n">Annotation</span><span class="o">.</span><span class="fm">__init__</span><span class="o">.</span><span class="vm">__doc__</span>
    <span class="c1">#### Lines and spans</span>

    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">axhline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a horizontal line across the axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : scalar, optional, default: 0</span>
<span class="sd">            y position in data coordinates of the horizontal line.</span>

<span class="sd">        xmin : scalar, optional, default: 0</span>
<span class="sd">            Should be between 0 and 1, 0 being the far left of the plot, 1 the</span>
<span class="sd">            far right of the plot.</span>

<span class="sd">        xmax : scalar, optional, default: 1</span>
<span class="sd">            Should be between 0 and 1, 0 being the far left of the plot, 1 the</span>
<span class="sd">            far right of the plot.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        line : :class:`~matplotlib.lines.Line2D`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Valid kwargs are :class:`~matplotlib.lines.Line2D` properties,</span>
<span class="sd">            with the exception of &#39;transform&#39;:</span>

<span class="sd">        %(_Line2D_docstr)s</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        hlines : Add horizontal lines in data coordinates.</span>
<span class="sd">        axhspan : Add a horizontal span (rectangle) across the axis.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        * draw a thick red hline at &#39;y&#39; = 0 that spans the xrange::</span>

<span class="sd">            &gt;&gt;&gt; axhline(linewidth=4, color=&#39;r&#39;)</span>

<span class="sd">        * draw a default hline at &#39;y&#39; = 1 that spans the xrange::</span>

<span class="sd">            &gt;&gt;&gt; axhline(y=1)</span>

<span class="sd">        * draw a default hline at &#39;y&#39; = .5 that spans the middle half of</span>
<span class="sd">          the xrange::</span>

<span class="sd">            &gt;&gt;&gt; axhline(y=.5, xmin=0.25, xmax=0.75)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;transform&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;transform&#39; is not allowed as a kwarg;&quot;</span>
                <span class="o">+</span> <span class="s2">&quot;axhline generates its own transform.&quot;</span><span class="p">)</span>
        <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ybound</span><span class="p">()</span>

        <span class="c1"># We need to strip away the units for comparison with</span>
        <span class="c1"># non-unitized bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">ydata</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">yy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">scaley</span> <span class="o">=</span> <span class="p">(</span><span class="n">yy</span> <span class="o">&lt;</span> <span class="n">ymin</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">yy</span> <span class="o">&gt;</span> <span class="n">ymax</span><span class="p">)</span>

        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_yaxis_transform</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s1">&#39;grid&#39;</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">],</span> <span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">transform</span><span class="o">=</span><span class="n">trans</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">(</span><span class="n">scalex</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">scaley</span><span class="o">=</span><span class="n">scaley</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">l</span>

    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">axvline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a vertical line across the axes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : scalar, optional, default: 0</span>
<span class="sd">            x position in data coordinates of the vertical line.</span>

<span class="sd">        ymin : scalar, optional, default: 0</span>
<span class="sd">            Should be between 0 and 1, 0 being the bottom of the plot, 1 the</span>
<span class="sd">            top of the plot.</span>

<span class="sd">        ymax : scalar, optional, default: 1</span>
<span class="sd">            Should be between 0 and 1, 0 being the bottom of the plot, 1 the</span>
<span class="sd">            top of the plot.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        line : :class:`~matplotlib.lines.Line2D`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Valid kwargs are :class:`~matplotlib.lines.Line2D` properties,</span>
<span class="sd">            with the exception of &#39;transform&#39;:</span>

<span class="sd">        %(_Line2D_docstr)s</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        * draw a thick red vline at *x* = 0 that spans the yrange::</span>

<span class="sd">            &gt;&gt;&gt; axvline(linewidth=4, color=&#39;r&#39;)</span>

<span class="sd">        * draw a default vline at *x* = 1 that spans the yrange::</span>

<span class="sd">            &gt;&gt;&gt; axvline(x=1)</span>

<span class="sd">        * draw a default vline at *x* = .5 that spans the middle half of</span>
<span class="sd">          the yrange::</span>

<span class="sd">            &gt;&gt;&gt; axvline(x=.5, ymin=0.25, ymax=0.75)</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        vlines : Add vertical lines in data coordinates.</span>
<span class="sd">        axvspan : Add a vertical span (rectangle) across the axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;transform&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;transform&#39; is not allowed as a kwarg;&quot;</span>
                <span class="o">+</span> <span class="s2">&quot;axvline generates its own transform.&quot;</span><span class="p">)</span>
        <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xbound</span><span class="p">()</span>

        <span class="c1"># We need to strip away the units for comparison with</span>
        <span class="c1"># non-unitized bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">xx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">scalex</span> <span class="o">=</span> <span class="p">(</span><span class="n">xx</span> <span class="o">&lt;</span> <span class="n">xmin</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">xx</span> <span class="o">&gt;</span> <span class="n">xmax</span><span class="p">)</span>

        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xaxis_transform</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s1">&#39;grid&#39;</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="p">[</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">],</span> <span class="n">transform</span><span class="o">=</span><span class="n">trans</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">(</span><span class="n">scalex</span><span class="o">=</span><span class="n">scalex</span><span class="p">,</span> <span class="n">scaley</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">l</span>

    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">axhspan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a horizontal span (rectangle) across the axis.</span>

<span class="sd">        Draw a horizontal span (rectangle) from *ymin* to *ymax*.</span>
<span class="sd">        With the default values of *xmin* = 0 and *xmax* = 1, this</span>
<span class="sd">        always spans the xrange, regardless of the xlim settings, even</span>
<span class="sd">        if you change them, e.g., with the :meth:`set_xlim` command.</span>
<span class="sd">        That is, the horizontal extent is in axes coords: 0=left,</span>
<span class="sd">        0.5=middle, 1.0=right but the *y* location is in data</span>
<span class="sd">        coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ymin : float</span>
<span class="sd">               Lower limit of the horizontal span in data units.</span>
<span class="sd">        ymax : float</span>
<span class="sd">               Upper limit of the horizontal span in data units.</span>
<span class="sd">        xmin : float, optional, default: 0</span>
<span class="sd">               Lower limit of the vertical span in axes (relative</span>
<span class="sd">               0-1) units.</span>
<span class="sd">        xmax : float, optional, default: 1</span>
<span class="sd">               Upper limit of the vertical span in axes (relative</span>
<span class="sd">               0-1) units.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Polygon : `~matplotlib.patches.Polygon`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs : `~matplotlib.patches.Polygon` properties.</span>

<span class="sd">        %(Polygon)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        axvspan : Add a vertical span across the axes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_yaxis_transform</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s1">&#39;grid&#39;</span><span class="p">)</span>

        <span class="c1"># process the unit information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">],</span> <span class="p">[</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">],</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># first we need to strip away the units</span>
        <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">])</span>
        <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">([</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">])</span>

        <span class="n">verts</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">),</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">),</span> <span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span><span class="p">),</span> <span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">set_transform</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">(</span><span class="n">scalex</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">p</span>

    <span class="k">def</span> <span class="nf">axvspan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a vertical span (rectangle) across the axes.</span>

<span class="sd">        Draw a vertical span (rectangle) from `xmin` to `xmax`.  With</span>
<span class="sd">        the default values of `ymin` = 0 and `ymax` = 1. This always</span>
<span class="sd">        spans the yrange, regardless of the ylim settings, even if you</span>
<span class="sd">        change them, e.g., with the :meth:`set_ylim` command.  That is,</span>
<span class="sd">        the vertical extent is in axes coords: 0=bottom, 0.5=middle,</span>
<span class="sd">        1.0=top but the x location is in data coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xmin : scalar</span>
<span class="sd">            Number indicating the first X-axis coordinate of the vertical</span>
<span class="sd">            span rectangle in data units.</span>
<span class="sd">        xmax : scalar</span>
<span class="sd">            Number indicating the second X-axis coordinate of the vertical</span>
<span class="sd">            span rectangle in data units.</span>
<span class="sd">        ymin : scalar, optional</span>
<span class="sd">            Number indicating the first Y-axis coordinate of the vertical</span>
<span class="sd">            span rectangle in relative Y-axis units (0-1). Default to 0.</span>
<span class="sd">        ymax : scalar, optional</span>
<span class="sd">            Number indicating the second Y-axis coordinate of the vertical</span>
<span class="sd">            span rectangle in relative Y-axis units (0-1). Default to 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rectangle : `~matplotlib.patches.Polygon`</span>
<span class="sd">            Vertical span (rectangle) from (xmin, ymin) to (xmax, ymax).</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Optional parameters are properties of the class `.Polygon`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        axhspan : Add a horizontal span across the axes.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Draw a vertical, green, translucent rectangle from x = 1.25 to</span>
<span class="sd">        x = 1.55 that spans the yrange of the axes.</span>

<span class="sd">        &gt;&gt;&gt; axvspan(1.25, 1.55, facecolor=&#39;g&#39;, alpha=0.5)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xaxis_transform</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s1">&#39;grid&#39;</span><span class="p">)</span>

        <span class="c1"># process the unit information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">],</span> <span class="p">[</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">],</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># first we need to strip away the units</span>
        <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">])</span>
        <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">([</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">])</span>

        <span class="n">verts</span> <span class="o">=</span> <span class="p">[(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">),</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">),</span> <span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span><span class="p">),</span> <span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">)]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">set_transform</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">(</span><span class="n">scaley</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">p</span>

    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;xmin&quot;</span><span class="p">,</span> <span class="s2">&quot;xmax&quot;</span><span class="p">,</span> <span class="s2">&quot;colors&quot;</span><span class="p">],</span>
                      <span class="n">label_namer</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">hlines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;solid&#39;</span><span class="p">,</span>
               <span class="n">label</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot horizontal lines at each *y* from *xmin* to *xmax*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : scalar or sequence of scalar</span>
<span class="sd">            y-indexes where to plot the lines.</span>

<span class="sd">        xmin, xmax : scalar or 1D array_like</span>
<span class="sd">            Respective beginning and end of each line. If scalars are</span>
<span class="sd">            provided, all lines will have same length.</span>

<span class="sd">        colors : array_like of colors, optional, default: &#39;k&#39;</span>

<span class="sd">        linestyles : {&#39;solid&#39;, &#39;dashed&#39;, &#39;dashdot&#39;, &#39;dotted&#39;}, optional</span>

<span class="sd">        label : string, optional, default: &#39;&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lines : `~matplotlib.collections.LineCollection`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs :  `~matplotlib.collections.LineCollection` properties.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        vlines : vertical lines</span>
<span class="sd">        axhline: horizontal line across the axes</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># We do the conversion first since not all unitized data is uniform</span>
        <span class="c1"># process the unit information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">],</span> <span class="n">y</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">xmin</span><span class="p">)</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">xmax</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">xmin</span><span class="p">):</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="p">[</span><span class="n">xmin</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">xmax</span><span class="p">):</span>
            <span class="n">xmax</span> <span class="o">=</span> <span class="p">[</span><span class="n">xmax</span><span class="p">]</span>

        <span class="n">y</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">delete_masked_points</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">)</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">verts</span> <span class="o">=</span> <span class="p">[((</span><span class="n">thisxmin</span><span class="p">,</span> <span class="n">thisy</span><span class="p">),</span> <span class="p">(</span><span class="n">thisxmax</span><span class="p">,</span> <span class="n">thisy</span><span class="p">))</span>
                 <span class="k">for</span> <span class="n">thisxmin</span><span class="p">,</span> <span class="n">thisxmax</span><span class="p">,</span> <span class="n">thisy</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">LineCollection</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span>
                                     <span class="n">linestyles</span><span class="o">=</span><span class="n">linestyles</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">minx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">xmin</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">xmax</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
            <span class="n">maxx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">xmin</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">xmax</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
            <span class="n">miny</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">maxy</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

            <span class="n">corners</span> <span class="o">=</span> <span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">),</span> <span class="p">(</span><span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">lines</span>

    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;ymin&quot;</span><span class="p">,</span> <span class="s2">&quot;ymax&quot;</span><span class="p">,</span> <span class="s2">&quot;colors&quot;</span><span class="p">],</span>
                      <span class="n">label_namer</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">vlines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;solid&#39;</span><span class="p">,</span>
               <span class="n">label</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot vertical lines.</span>

<span class="sd">        Plot vertical lines at each *x* from *ymin* to *ymax*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : scalar or 1D array_like</span>
<span class="sd">            x-indexes where to plot the lines.</span>

<span class="sd">        ymin, ymax : scalar or 1D array_like</span>
<span class="sd">            Respective beginning and end of each line. If scalars are</span>
<span class="sd">            provided, all lines will have same length.</span>

<span class="sd">        colors : array_like of colors, optional, default: &#39;k&#39;</span>

<span class="sd">        linestyles : {&#39;solid&#39;, &#39;dashed&#39;, &#39;dashdot&#39;, &#39;dotted&#39;}, optional</span>

<span class="sd">        label : string, optional, default: &#39;&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lines : `~matplotlib.collections.LineCollection`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs : `~matplotlib.collections.LineCollection` properties.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        hlines : horizontal lines</span>
<span class="sd">        axvline: vertical line across the axes</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="p">[</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">],</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># We do the conversion first since not all unitized data is uniform</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">ymin</span><span class="p">)</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">ymax</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">ymin</span><span class="p">):</span>
            <span class="n">ymin</span> <span class="o">=</span> <span class="p">[</span><span class="n">ymin</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">ymax</span><span class="p">):</span>
            <span class="n">ymax</span> <span class="o">=</span> <span class="p">[</span><span class="n">ymax</span><span class="p">]</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">delete_masked_points</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">ymax</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">verts</span> <span class="o">=</span> <span class="p">[((</span><span class="n">thisx</span><span class="p">,</span> <span class="n">thisymin</span><span class="p">),</span> <span class="p">(</span><span class="n">thisx</span><span class="p">,</span> <span class="n">thisymax</span><span class="p">))</span>
                 <span class="k">for</span> <span class="n">thisx</span><span class="p">,</span> <span class="n">thisymin</span><span class="p">,</span> <span class="n">thisymax</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">)]</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">LineCollection</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span>
                                     <span class="n">linestyles</span><span class="o">=</span><span class="n">linestyles</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">minx</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">maxx</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">miny</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ymin</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">ymax</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
            <span class="n">maxy</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ymin</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">ymax</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>

            <span class="n">corners</span> <span class="o">=</span> <span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">),</span> <span class="p">(</span><span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">lines</span>

    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;positions&quot;</span><span class="p">,</span> <span class="s2">&quot;lineoffsets&quot;</span><span class="p">,</span>
                                     <span class="s2">&quot;linelengths&quot;</span><span class="p">,</span> <span class="s2">&quot;linewidths&quot;</span><span class="p">,</span>
                                     <span class="s2">&quot;colors&quot;</span><span class="p">,</span> <span class="s2">&quot;linestyles&quot;</span><span class="p">])</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">eventplot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;horizontal&#39;</span><span class="p">,</span> <span class="n">lineoffsets</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                  <span class="n">linelengths</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;solid&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot identical parallel lines at the given positions.</span>

<span class="sd">        *positions* should be a 1D or 2D array-like object, with each row</span>
<span class="sd">        corresponding to a row or column of lines.</span>

<span class="sd">        This type of plot is commonly used in neuroscience for representing</span>
<span class="sd">        neural events, where it is usually called a spike raster, dot raster,</span>
<span class="sd">        or raster plot.</span>

<span class="sd">        However, it is useful in any situation where you wish to show the</span>
<span class="sd">        timing or position of multiple sets of discrete events, such as the</span>
<span class="sd">        arrival times of people to a business on each day of the month or the</span>
<span class="sd">        date of hurricanes each year of the last century.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        positions : 1D or 2D array-like object</span>
<span class="sd">            Each value is an event. If *positions* is a 2D array-like, each</span>
<span class="sd">            row corresponds to a row or a column of lines (depending on the</span>
<span class="sd">            *orientation* parameter).</span>

<span class="sd">        orientation : {&#39;horizontal&#39;, &#39;vertical&#39;}, optional</span>
<span class="sd">            Controls the direction of the event collections:</span>

<span class="sd">                - &#39;horizontal&#39; : the lines are arranged horizontally in rows,</span>
<span class="sd">                  and are vertical.</span>
<span class="sd">                - &#39;vertical&#39; : the lines are arranged vertically in columns,</span>
<span class="sd">                  and are horizontal.</span>

<span class="sd">        lineoffsets : scalar or sequence of scalars, optional, default: 1</span>
<span class="sd">            The offset of the center of the lines from the origin, in the</span>
<span class="sd">            direction orthogonal to *orientation*.</span>

<span class="sd">        linelengths : scalar or sequence of scalars, optional, default: 1</span>
<span class="sd">            The total height of the lines (i.e. the lines stretches from</span>
<span class="sd">            ``lineoffset - linelength/2`` to ``lineoffset + linelength/2``).</span>

<span class="sd">        linewidths : scalar, scalar sequence or None, optional, default: None</span>
<span class="sd">            The line width(s) of the event lines, in points. If it is None,</span>
<span class="sd">            defaults to its rcParams setting.</span>

<span class="sd">        colors : color, sequence of colors or None, optional, default: None</span>
<span class="sd">            The color(s) of the event lines. If it is None, defaults to its</span>
<span class="sd">            rcParams setting.</span>

<span class="sd">        linestyles : str or tuple or a sequence of such values, optional</span>
<span class="sd">            Default is &#39;solid&#39;. Valid strings are [&#39;solid&#39;, &#39;dashed&#39;,</span>
<span class="sd">            &#39;dashdot&#39;, &#39;dotted&#39;, &#39;-&#39;, &#39;--&#39;, &#39;-.&#39;, &#39;:&#39;]. Dash tuples</span>
<span class="sd">            should be of the form::</span>

<span class="sd">                (offset, onoffseq),</span>

<span class="sd">            where *onoffseq* is an even length tuple of on and off ink</span>
<span class="sd">            in points.</span>

<span class="sd">        **kwargs : optional</span>
<span class="sd">            Other keyword arguments are line collection properties.  See</span>
<span class="sd">            :class:`~matplotlib.collections.LineCollection` for a list of</span>
<span class="sd">            the valid properties.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        list : A list of :class:`~.collections.EventCollection` objects.</span>
<span class="sd">            Contains the :class:`~.collections.EventCollection` that</span>
<span class="sd">            were added.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        For *linelengths*, *linewidths*, *colors*, and *linestyles*, if only</span>
<span class="sd">        a single value is given, that value is applied to all lines.  If an</span>
<span class="sd">        array-like is given, it must have the same length as *positions*, and</span>
<span class="sd">        each value will be applied to the corresponding row of the array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        .. plot:: gallery/lines_bars_and_markers/eventplot_demo.py</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">positions</span><span class="p">,</span>
                                <span class="n">ydata</span><span class="o">=</span><span class="p">[</span><span class="n">lineoffsets</span><span class="p">,</span> <span class="n">linelengths</span><span class="p">],</span>
                                <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># We do the conversion first since not all unitized data is uniform</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
        <span class="n">lineoffsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">lineoffsets</span><span class="p">)</span>
        <span class="n">linelengths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">linelengths</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="p">[</span><span class="n">positions</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="k">for</span> <span class="n">position</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">):</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="k">for</span> <span class="n">position</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">positions</span><span class="p">)]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="c1"># prevent &#39;singular&#39; keys from **kwargs dict from overriding the effect</span>
        <span class="c1"># of &#39;plural&#39; keyword arguments (e.g. &#39;color&#39; overriding &#39;colors&#39;)</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">local_over_kwdict</span><span class="p">(</span><span class="n">colors</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">)</span>
        <span class="n">linewidths</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">local_over_kwdict</span><span class="p">(</span><span class="n">linewidths</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="s1">&#39;linewidth&#39;</span><span class="p">)</span>
        <span class="n">linestyles</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">local_over_kwdict</span><span class="p">(</span><span class="n">linestyles</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="s1">&#39;linestyle&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">lineoffsets</span><span class="p">):</span>
            <span class="n">lineoffsets</span> <span class="o">=</span> <span class="p">[</span><span class="n">lineoffsets</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">linelengths</span><span class="p">):</span>
            <span class="n">linelengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">linelengths</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">linewidths</span><span class="p">):</span>
            <span class="n">linewidths</span> <span class="o">=</span> <span class="p">[</span><span class="n">linewidths</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">colors</span><span class="p">):</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">colors</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">linestyles</span><span class="p">,</span> <span class="s1">&#39;lower&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">linestyles</span><span class="p">):</span>
            <span class="n">linestyles</span> <span class="o">=</span> <span class="p">[</span><span class="n">linestyles</span><span class="p">]</span>

        <span class="n">lineoffsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lineoffsets</span><span class="p">)</span>
        <span class="n">linelengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">linelengths</span><span class="p">)</span>
        <span class="n">linewidths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lineoffsets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lineoffsets</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linelengths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">linelengths</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lineoffsets</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lineoffsets</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Early conversion of the colors into RGBA values to take care</span>
            <span class="c1"># of cases like colors=&#39;0.5&#39; or colors=&#39;C1&#39;.  (Issue #8193)</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">to_rgba_array</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># Will fail if any element of *colors* is None. But as long</span>
            <span class="c1"># as len(colors) == 1 or len(positions), the rest of the</span>
            <span class="c1"># code should process *colors* properly.</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lineoffsets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">lineoffsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">lineoffsets</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">))</span>
            <span class="n">lineoffsets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">lineoffsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">lineoffsets</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linelengths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">linelengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">linelengths</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">linewidths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">linewidths</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="n">colors</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linestyles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">linestyles</span> <span class="o">=</span> <span class="p">[</span><span class="n">linestyles</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lineoffsets</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;lineoffsets and positions are unequal sized &#39;</span>
                             <span class="s1">&#39;sequences&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linelengths</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;linelengths and positions are unequal sized &#39;</span>
                             <span class="s1">&#39;sequences&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;linewidths and positions are unequal sized &#39;</span>
                             <span class="s1">&#39;sequences&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;colors and positions are unequal sized &#39;</span>
                             <span class="s1">&#39;sequences&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linestyles</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;linestyles and positions are unequal sized &#39;</span>
                             <span class="s1">&#39;sequences&#39;</span><span class="p">)</span>

        <span class="n">colls</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">position</span><span class="p">,</span> <span class="n">lineoffset</span><span class="p">,</span> <span class="n">linelength</span><span class="p">,</span> <span class="n">linewidth</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">linestyle</span> <span class="ow">in</span> \
            <span class="nb">zip</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">lineoffsets</span><span class="p">,</span> <span class="n">linelengths</span><span class="p">,</span> <span class="n">linewidths</span><span class="p">,</span>
                           <span class="n">colors</span><span class="p">,</span> <span class="n">linestyles</span><span class="p">):</span>
            <span class="n">coll</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">EventCollection</span><span class="p">(</span><span class="n">position</span><span class="p">,</span>
                                         <span class="n">orientation</span><span class="o">=</span><span class="n">orientation</span><span class="p">,</span>
                                         <span class="n">lineoffset</span><span class="o">=</span><span class="n">lineoffset</span><span class="p">,</span>
                                         <span class="n">linelength</span><span class="o">=</span><span class="n">linelength</span><span class="p">,</span>
                                         <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span><span class="p">,</span>
                                         <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                                         <span class="n">linestyle</span><span class="o">=</span><span class="n">linestyle</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">coll</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">coll</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">colls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coll</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># try to get min/max</span>
            <span class="n">min_max</span> <span class="o">=</span> <span class="p">[(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">_p</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">_p</span><span class="p">))</span> <span class="k">for</span> <span class="n">_p</span> <span class="ow">in</span> <span class="n">positions</span>
                       <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_p</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
            <span class="c1"># if we have any non-empty positions, try to autoscale</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">min_max</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mins</span><span class="p">,</span> <span class="n">maxes</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">min_max</span><span class="p">)</span>
                <span class="n">minpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">mins</span><span class="p">)</span>
                <span class="n">maxpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">maxes</span><span class="p">)</span>

                <span class="n">minline</span> <span class="o">=</span> <span class="p">(</span><span class="n">lineoffsets</span> <span class="o">-</span> <span class="n">linelengths</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                <span class="n">maxline</span> <span class="o">=</span> <span class="p">(</span><span class="n">lineoffsets</span> <span class="o">+</span> <span class="n">linelengths</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">orientation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                        <span class="n">orientation</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;vertical&quot;</span><span class="p">):</span>
                    <span class="n">corners</span> <span class="o">=</span> <span class="p">(</span><span class="n">minline</span><span class="p">,</span> <span class="n">minpos</span><span class="p">),</span> <span class="p">(</span><span class="n">maxline</span><span class="p">,</span> <span class="n">maxpos</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># &quot;horizontal&quot;, None or &quot;none&quot; (see EventCollection)</span>
                    <span class="n">corners</span> <span class="o">=</span> <span class="p">(</span><span class="n">minpos</span><span class="p">,</span> <span class="n">minline</span><span class="p">),</span> <span class="p">(</span><span class="n">maxpos</span><span class="p">,</span> <span class="n">maxline</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">colls</span>

    <span class="c1">#### Basic plotting</span>

    <span class="c1"># Uses a custom implementation of data-kwarg handling in</span>
    <span class="c1"># _process_plot_var_args.</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">scalex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">scaley</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot y versus x as lines and/or markers.</span>

<span class="sd">        Call signatures::</span>

<span class="sd">            plot([x], y, [fmt], *, data=None, **kwargs)</span>
<span class="sd">            plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)</span>

<span class="sd">        The coordinates of the points or line nodes are given by *x*, *y*.</span>

<span class="sd">        The optional parameter *fmt* is a convenient way for defining basic</span>
<span class="sd">        formatting like color, marker and linestyle. It&#39;s a shortcut string</span>
<span class="sd">        notation described in the *Notes* section below.</span>

<span class="sd">        &gt;&gt;&gt; plot(x, y)        # plot x and y using default line style and color</span>
<span class="sd">        &gt;&gt;&gt; plot(x, y, &#39;bo&#39;)  # plot x and y using blue circle markers</span>
<span class="sd">        &gt;&gt;&gt; plot(y)           # plot y using x as index array 0..N-1</span>
<span class="sd">        &gt;&gt;&gt; plot(y, &#39;r+&#39;)     # ditto, but with red plusses</span>

<span class="sd">        You can use `.Line2D` properties as keyword arguments for more</span>
<span class="sd">        control on the appearance. Line properties and *fmt* can be mixed.</span>
<span class="sd">        The following two calls yield identical results:</span>

<span class="sd">        &gt;&gt;&gt; plot(x, y, &#39;go--&#39;, linewidth=2, markersize=12)</span>
<span class="sd">        &gt;&gt;&gt; plot(x, y, color=&#39;green&#39;, marker=&#39;o&#39;, linestyle=&#39;dashed&#39;,</span>
<span class="sd">        ...      linewidth=2, markersize=12)</span>

<span class="sd">        When conflicting with *fmt*, keyword arguments take precedence.</span>


<span class="sd">        **Plotting labelled data**</span>

<span class="sd">        There&#39;s a convenient way for plotting objects with labelled data (i.e.</span>
<span class="sd">        data that can be accessed by index ``obj[&#39;y&#39;]``). Instead of giving</span>
<span class="sd">        the data in *x* and *y*, you can provide the object in the *data*</span>
<span class="sd">        parameter and just give the labels for *x* and *y*::</span>

<span class="sd">        &gt;&gt;&gt; plot(&#39;xlabel&#39;, &#39;ylabel&#39;, data=obj)</span>

<span class="sd">        All indexable objects are supported. This could e.g. be a `dict`, a</span>
<span class="sd">        `pandas.DataFame` or a structured numpy array.</span>


<span class="sd">        **Plotting multiple sets of data**</span>

<span class="sd">        There are various ways to plot multiple sets of data.</span>

<span class="sd">        - The most straight forward way is just to call `plot` multiple times.</span>
<span class="sd">          Example:</span>

<span class="sd">          &gt;&gt;&gt; plot(x1, y1, &#39;bo&#39;)</span>
<span class="sd">          &gt;&gt;&gt; plot(x2, y2, &#39;go&#39;)</span>

<span class="sd">        - Alternatively, if your data is already a 2d array, you can pass it</span>
<span class="sd">          directly to *x*, *y*. A separate data set will be drawn for every</span>
<span class="sd">          column.</span>

<span class="sd">          Example: an array ``a`` where the first column represents the *x*</span>
<span class="sd">          values and the other columns are the *y* columns::</span>

<span class="sd">          &gt;&gt;&gt; plot(a[0], a[1:])</span>

<span class="sd">        - The third way is to specify multiple sets of *[x]*, *y*, *[fmt]*</span>
<span class="sd">          groups::</span>

<span class="sd">          &gt;&gt;&gt; plot(x1, y1, &#39;g^&#39;, x2, y2, &#39;g-&#39;)</span>

<span class="sd">          In this case, any additional keyword argument applies to all</span>
<span class="sd">          datasets. Also this syntax cannot be combined with the *data*</span>
<span class="sd">          parameter.</span>

<span class="sd">        By default, each line is assigned a different style specified by a</span>
<span class="sd">        &#39;style cycle&#39;. The *fmt* and line property parameters are only</span>
<span class="sd">        necessary if you want explicit deviations from these defaults.</span>
<span class="sd">        Alternatively, you can also change the style cycle using the</span>
<span class="sd">        &#39;axes.prop_cycle&#39; rcParam.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : array-like or scalar</span>
<span class="sd">            The horizontal / vertical coordinates of the data points.</span>
<span class="sd">            *x* values are optional and default to `range(len(y))`.</span>

<span class="sd">            Commonly, these parameters are 1D arrays.</span>

<span class="sd">            They can also be scalars, or two-dimensional (in that case, the</span>
<span class="sd">            columns represent separate data sets).</span>

<span class="sd">            These arguments cannot be passed as keywords.</span>

<span class="sd">        fmt : str, optional</span>
<span class="sd">            A format string, e.g. &#39;ro&#39; for red circles. See the *Notes*</span>
<span class="sd">            section for a full description of the format strings.</span>

<span class="sd">            Format strings are just an abbreviation for quickly setting</span>
<span class="sd">            basic line properties. All of these and more can also be</span>
<span class="sd">            controlled by keyword arguments.</span>

<span class="sd">            This argument cannot be passed as keyword.</span>

<span class="sd">        data : indexable object, optional</span>
<span class="sd">            An object with labelled data. If given, provide the label names to</span>
<span class="sd">            plot in *x* and *y*.</span>

<span class="sd">            .. note::</span>
<span class="sd">                Technically there&#39;s a slight ambiguity in calls where the</span>
<span class="sd">                second label is a valid *fmt*. `plot(&#39;n&#39;, &#39;o&#39;, data=obj)`</span>
<span class="sd">                could be `plt(x, y)` or `plt(y, fmt)`. In such cases,</span>
<span class="sd">                the former interpretation is chosen, but a warning is issued.</span>
<span class="sd">                You may suppress the warning by adding an empty format string</span>
<span class="sd">                `plot(&#39;n&#39;, &#39;o&#39;, &#39;&#39;, data=obj)`.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        scalex, scaley : bool, optional, default: True</span>
<span class="sd">            These parameters determined if the view limits are adapted to</span>
<span class="sd">            the data limits. The values are passed on to `autoscale_view`.</span>

<span class="sd">        **kwargs : `.Line2D` properties, optional</span>
<span class="sd">            *kwargs* are used to specify properties like a line label (for</span>
<span class="sd">            auto legends), linewidth, antialiasing, marker face color.</span>
<span class="sd">            Example::</span>

<span class="sd">            &gt;&gt;&gt; plot([1,2,3], [1,2,3], &#39;go-&#39;, label=&#39;line 1&#39;, linewidth=2)</span>
<span class="sd">            &gt;&gt;&gt; plot([1,2,3], [1,4,9], &#39;rs&#39;,  label=&#39;line 2&#39;)</span>

<span class="sd">            If you make multiple lines with one plot command, the kwargs</span>
<span class="sd">            apply to all those lines.</span>

<span class="sd">            Here is a list of available `.Line2D` properties:</span>

<span class="sd">        %(_Line2D_docstr)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lines</span>
<span class="sd">            A list of `.Line2D` objects representing the plotted data.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        scatter : XY scatter plot with markers of varying size and/or color (</span>
<span class="sd">            sometimes also called bubble chart).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        **Format Strings**</span>

<span class="sd">        A format string consists of a part for color, marker and line::</span>

<span class="sd">            fmt = &#39;[marker][line][color]&#39;</span>

<span class="sd">        Each of them is optional. If not provided, the value from the style</span>
<span class="sd">        cycle is used. Exception: If ``line`` is given, but no ``marker``,</span>
<span class="sd">        the data will be a line without markers.</span>

<span class="sd">        Other combinations such as ``[color][marker][line]`` are also</span>
<span class="sd">        supported, but note that their parsing may be ambiguous.</span>

<span class="sd">        **Markers**</span>

<span class="sd">        =============    ===============================</span>
<span class="sd">        character        description</span>
<span class="sd">        =============    ===============================</span>
<span class="sd">        ``&#39;.&#39;``          point marker</span>
<span class="sd">        ``&#39;,&#39;``          pixel marker</span>
<span class="sd">        ``&#39;o&#39;``          circle marker</span>
<span class="sd">        ``&#39;v&#39;``          triangle_down marker</span>
<span class="sd">        ``&#39;^&#39;``          triangle_up marker</span>
<span class="sd">        ``&#39;&lt;&#39;``          triangle_left marker</span>
<span class="sd">        ``&#39;&gt;&#39;``          triangle_right marker</span>
<span class="sd">        ``&#39;1&#39;``          tri_down marker</span>
<span class="sd">        ``&#39;2&#39;``          tri_up marker</span>
<span class="sd">        ``&#39;3&#39;``          tri_left marker</span>
<span class="sd">        ``&#39;4&#39;``          tri_right marker</span>
<span class="sd">        ``&#39;s&#39;``          square marker</span>
<span class="sd">        ``&#39;p&#39;``          pentagon marker</span>
<span class="sd">        ``&#39;*&#39;``          star marker</span>
<span class="sd">        ``&#39;h&#39;``          hexagon1 marker</span>
<span class="sd">        ``&#39;H&#39;``          hexagon2 marker</span>
<span class="sd">        ``&#39;+&#39;``          plus marker</span>
<span class="sd">        ``&#39;x&#39;``          x marker</span>
<span class="sd">        ``&#39;D&#39;``          diamond marker</span>
<span class="sd">        ``&#39;d&#39;``          thin_diamond marker</span>
<span class="sd">        ``&#39;|&#39;``          vline marker</span>
<span class="sd">        ``&#39;_&#39;``          hline marker</span>
<span class="sd">        =============    ===============================</span>

<span class="sd">        **Line Styles**</span>

<span class="sd">        =============    ===============================</span>
<span class="sd">        character        description</span>
<span class="sd">        =============    ===============================</span>
<span class="sd">        ``&#39;-&#39;``          solid line style</span>
<span class="sd">        ``&#39;--&#39;``         dashed line style</span>
<span class="sd">        ``&#39;-.&#39;``         dash-dot line style</span>
<span class="sd">        ``&#39;:&#39;``          dotted line style</span>
<span class="sd">        =============    ===============================</span>

<span class="sd">        Example format strings::</span>

<span class="sd">            &#39;b&#39;    # blue markers with default shape</span>
<span class="sd">            &#39;or&#39;   # red circles</span>
<span class="sd">            &#39;-g&#39;   # green solid line</span>
<span class="sd">            &#39;--&#39;   # dashed line with default color</span>
<span class="sd">            &#39;^k:&#39;  # black triangle_up markers connected by a dotted line</span>

<span class="sd">        **Colors**</span>

<span class="sd">        The supported color abbreviations are the single letter codes</span>

<span class="sd">        =============    ===============================</span>
<span class="sd">        character        color</span>
<span class="sd">        =============    ===============================</span>
<span class="sd">        ``&#39;b&#39;``          blue</span>
<span class="sd">        ``&#39;g&#39;``          green</span>
<span class="sd">        ``&#39;r&#39;``          red</span>
<span class="sd">        ``&#39;c&#39;``          cyan</span>
<span class="sd">        ``&#39;m&#39;``          magenta</span>
<span class="sd">        ``&#39;y&#39;``          yellow</span>
<span class="sd">        ``&#39;k&#39;``          black</span>
<span class="sd">        ``&#39;w&#39;``          white</span>
<span class="sd">        =============    ===============================</span>

<span class="sd">        and the ``&#39;CN&#39;`` colors that index into the default property cycle.</span>

<span class="sd">        If the color is the only part of the format string, you can</span>
<span class="sd">        additionally use any  `matplotlib.colors` spec, e.g. full names</span>
<span class="sd">        (``&#39;green&#39;``) or hex strings (``&#39;#008000&#39;``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">normalize_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="o">.</span><span class="n">_alias_map</span><span class="p">)</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_lines</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">(</span><span class="n">scalex</span><span class="o">=</span><span class="n">scalex</span><span class="p">,</span> <span class="n">scaley</span><span class="o">=</span><span class="n">scaley</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lines</span>

    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">plot_date</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xdate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ydate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot data that contains dates.</span>

<span class="sd">        Similar to `.plot`, this plots *y* vs. *x* as lines or markers.</span>
<span class="sd">        However, the axis labels are formatted as dates depending on *xdate*</span>
<span class="sd">        and *ydate*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : array-like</span>
<span class="sd">            The coordinates of the data points. If *xdate* or *ydate* is</span>
<span class="sd">            *True*, the respective values *x* or *y* are interpreted as</span>
<span class="sd">            :ref:`Matplotlib dates &lt;date-format&gt;`.</span>

<span class="sd">        fmt : str, optional</span>
<span class="sd">            The plot format string. For details, see the corresponding</span>
<span class="sd">            parameter in `.plot`.</span>

<span class="sd">        tz : [ *None* | timezone string | :class:`tzinfo` instance]</span>
<span class="sd">            The time zone to use in labeling dates. If *None*, defaults to</span>
<span class="sd">            rcParam ``timezone``.</span>

<span class="sd">        xdate : bool, optional, default: True</span>
<span class="sd">            If *True*, the *x*-axis will be interpreted as Matplotlib dates.</span>

<span class="sd">        ydate : bool, optional, default: False</span>
<span class="sd">            If *True*, the *y*-axis will be interpreted as Matplotlib dates.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lines</span>
<span class="sd">            A list of `~.Line2D` objects representing the plotted data.</span>


<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments control the :class:`~matplotlib.lines.Line2D`</span>
<span class="sd">            properties:</span>

<span class="sd">        %(_Line2D_docstr)s</span>


<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        matplotlib.dates : Helper functions on dates.</span>
<span class="sd">        matplotlib.dates.date2num : Convert dates to num.</span>
<span class="sd">        matplotlib.dates.num2date : Convert num to dates.</span>
<span class="sd">        matplotlib.dates.drange : Create an equally spaced sequence of dates.</span>


<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If you are using custom date tickers and formatters, it may be</span>
<span class="sd">        necessary to set the formatters/locators after the call to</span>
<span class="sd">        `.plot_date`. `.plot_date` will set the default tick locator to</span>
<span class="sd">        `.AutoDateLocator` (if the tick locator is not already set to a</span>
<span class="sd">        `.DateLocator` instance) and the default tick formatter to</span>
<span class="sd">        `.AutoDateFormatter` (if the tick formatter is not already set to a</span>
<span class="sd">        `.DateFormatter` instance).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">xdate</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xaxis_date</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ydate</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">yaxis_date</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">ret</span>

    <span class="c1"># @_preprocess_data() # let &#39;plot&#39; do the unpacking..</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">loglog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a plot with log scaling on both the x and y axis.</span>

<span class="sd">        Call signatures::</span>

<span class="sd">            loglog([x], y, [fmt], data=None, **kwargs)</span>
<span class="sd">            loglog([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)</span>

<span class="sd">        This is just a thin wrapper around `.plot` which additionally changes</span>
<span class="sd">        both the x-axis and the y-axis to log scaling. All of the concepts and</span>
<span class="sd">        parameters of plot can be used here as well.</span>

<span class="sd">        The additional parameters *basex/y*, *subsx/y* and *nonposx/y* control</span>
<span class="sd">        the x/y-axis properties. They are just forwarded to `.Axes.set_xscale`</span>
<span class="sd">        and `.Axes.set_yscale`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        basex, basey : scalar, optional, default 10</span>
<span class="sd">            Base of the x/y logarithm.</span>

<span class="sd">        subsx, subsy : sequence, optional</span>
<span class="sd">            The location of the minor x/y ticks. If *None*, reasonable</span>
<span class="sd">            locations are automatically chosen depending on the number of</span>
<span class="sd">            decades in the plot.</span>
<span class="sd">            See `.Axes.set_xscale` / `.Axes.set_yscale` for details.</span>

<span class="sd">        nonposx, nonposy : {&#39;mask&#39;, &#39;clip&#39;}, optional, default &#39;mask&#39;</span>
<span class="sd">            Non-positive values in x or y can be masked as invalid, or clipped</span>
<span class="sd">            to a very small positive number.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lines</span>
<span class="sd">            A list of `~.Line2D` objects representing the plotted data.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            All parameters supported by `.plot`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;basex&#39;</span><span class="p">,</span> <span class="s1">&#39;subsx&#39;</span><span class="p">,</span> <span class="s1">&#39;nonposx&#39;</span><span class="p">]</span>
              <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">}</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;basey&#39;</span><span class="p">,</span> <span class="s1">&#39;subsy&#39;</span><span class="p">,</span> <span class="s1">&#39;nonposy&#39;</span><span class="p">]</span>
              <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">dx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">dy</span><span class="p">)</span>

        <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">l</span>

    <span class="c1"># @_preprocess_data() # let &#39;plot&#39; do the unpacking..</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">semilogx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a plot with log scaling on the x axis.</span>

<span class="sd">        Call signatures::</span>

<span class="sd">            semilogx([x], y, [fmt], data=None, **kwargs)</span>
<span class="sd">            semilogx([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)</span>

<span class="sd">        This is just a thin wrapper around `.plot` which additionally changes</span>
<span class="sd">        the x-axis to log scaling. All of the concepts and parameters of plot</span>
<span class="sd">        can be used here as well.</span>

<span class="sd">        The additional parameters *basex*, *subsx* and *nonposx* control the</span>
<span class="sd">        x-axis properties. They are just forwarded to `.Axes.set_xscale`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        basex : scalar, optional, default 10</span>
<span class="sd">            Base of the x logarithm.</span>

<span class="sd">        subsx : array_like, optional</span>
<span class="sd">            The location of the minor xticks. If *None*, reasonable locations</span>
<span class="sd">            are automatically chosen depending on the number of decades in the</span>
<span class="sd">            plot. See `.Axes.set_xscale` for details.</span>

<span class="sd">        nonposx : {&#39;mask&#39;, &#39;clip&#39;}, optional, default &#39;mask&#39;</span>
<span class="sd">            Non-positive values in x can be masked as invalid, or clipped to a</span>
<span class="sd">            very small positive number.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lines</span>
<span class="sd">            A list of `~.Line2D` objects representing the plotted data.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            All parameters supported by `.plot`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;basex&#39;</span><span class="p">,</span> <span class="s1">&#39;subsx&#39;</span><span class="p">,</span> <span class="s1">&#39;nonposx&#39;</span><span class="p">]</span>
             <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">l</span>

    <span class="c1"># @_preprocess_data() # let &#39;plot&#39; do the unpacking..</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">semilogy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a plot with log scaling on the y axis.</span>

<span class="sd">        Call signatures::</span>

<span class="sd">            semilogy([x], y, [fmt], data=None, **kwargs)</span>
<span class="sd">            semilogy([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)</span>

<span class="sd">        This is just a thin wrapper around `.plot` which additionally changes</span>
<span class="sd">        the y-axis to log scaling. All of the concepts and parameters of plot</span>
<span class="sd">        can be used here as well.</span>

<span class="sd">        The additional parameters *basey*, *subsy* and *nonposy* control the</span>
<span class="sd">        y-axis properties. They are just forwarded to `.Axes.set_yscale`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        basey : scalar, optional, default 10</span>
<span class="sd">            Base of the y logarithm.</span>

<span class="sd">        subsy : array_like, optional</span>
<span class="sd">            The location of the minor yticks. If *None*, reasonable locations</span>
<span class="sd">            are automatically chosen depending on the number of decades in the</span>
<span class="sd">            plot. See `.Axes.set_yscale` for details.</span>

<span class="sd">        nonposy : {&#39;mask&#39;, &#39;clip&#39;}, optional, default &#39;mask&#39;</span>
<span class="sd">            Non-positive values in y can be masked as invalid, or clipped to a</span>
<span class="sd">            very small positive number.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lines</span>
<span class="sd">            A list of `~.Line2D` objects representing the plotted data.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            All parameters supported by `.plot`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;basey&#39;</span><span class="p">,</span> <span class="s1">&#39;subsy&#39;</span><span class="p">,</span> <span class="s1">&#39;nonposy&#39;</span><span class="p">]</span>
             <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">l</span>

    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">acorr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the autocorrelation of *x*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like</span>

<span class="sd">        detrend : callable, optional, default: `mlab.detrend_none`</span>
<span class="sd">            *x* is detrended by the *detrend* callable. This must be a</span>
<span class="sd">            function ``x = detrend(x)`` accepting and returning an</span>
<span class="sd">            `numpy.array`. Default is no normalization.</span>

<span class="sd">        normed : bool, optional, default: True</span>
<span class="sd">            If ``True``, input vectors are normalised to unit length.</span>

<span class="sd">        usevlines : bool, optional, default: True</span>
<span class="sd">            Determines the plot style.</span>

<span class="sd">            If ``True``, vertical lines are plotted from 0 to the acorr value</span>
<span class="sd">            using `Axes.vlines`. Additionally, a horizontal line is plotted</span>
<span class="sd">            at y=0 using `Axes.axhline`.</span>

<span class="sd">            If ``False``, markers are plotted at the acorr values using</span>
<span class="sd">            `Axes.plot`.</span>

<span class="sd">        maxlags : int, optional, default: 10</span>
<span class="sd">            Number of lags to show. If ``None``, will return all</span>
<span class="sd">            ``2 * len(x) - 1`` lags.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lags : array (length ``2*maxlags+1``)</span>
<span class="sd">            The lag vector.</span>
<span class="sd">        c : array  (length ``2*maxlags+1``)</span>
<span class="sd">            The auto correlation vector.</span>
<span class="sd">        line : `.LineCollection` or `.Line2D`</span>
<span class="sd">            `.Artist` added to the axes of the correlation:</span>

<span class="sd">            - `.LineCollection` if *usevlines* is True.</span>
<span class="sd">            - `.Line2D` if *usevlines* is False.</span>
<span class="sd">        b : `.Line2D` or None</span>
<span class="sd">            Horizontal line at 0 if *usevlines* is True</span>
<span class="sd">            None *usevlines* is False.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        linestyle : `.Line2D` property, optional</span>
<span class="sd">            The linestyle for plotting the data points.</span>
<span class="sd">            Only used if *usevlines* is ``False``.</span>

<span class="sd">        marker : str, optional, default: &#39;o&#39;</span>
<span class="sd">            The marker for plotting the data points.</span>
<span class="sd">            Only used if *usevlines* is ``False``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The cross correlation is performed with :func:`numpy.correlate` with</span>
<span class="sd">        ``mode = &quot;full&quot;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xcorr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">xcorr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">mlab</span><span class="o">.</span><span class="n">detrend_none</span><span class="p">,</span>
              <span class="n">usevlines</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">maxlags</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the cross correlation between *x* and *y*.</span>

<span class="sd">        The correlation with lag k is defined as</span>
<span class="sd">        :math:`\sum_n x[n+k] \cdot y^*[n]`, where :math:`y^*` is the complex</span>
<span class="sd">        conjugate of :math:`y`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like of length n</span>

<span class="sd">        y : array-like of length n</span>

<span class="sd">        detrend : callable, optional, default: `mlab.detrend_none`</span>
<span class="sd">            *x* and *y* are detrended by the *detrend* callable. This must be a</span>
<span class="sd">            function ``x = detrend(x)`` accepting and returning an</span>
<span class="sd">            `numpy.array`. Default is no normalization.</span>

<span class="sd">        normed : bool, optional, default: True</span>
<span class="sd">            If ``True``, input vectors are normalised to unit length.</span>

<span class="sd">        usevlines : bool, optional, default: True</span>
<span class="sd">            Determines the plot style.</span>

<span class="sd">            If ``True``, vertical lines are plotted from 0 to the xcorr value</span>
<span class="sd">            using `Axes.vlines`. Additionally, a horizontal line is plotted</span>
<span class="sd">            at y=0 using `Axes.axhline`.</span>

<span class="sd">            If ``False``, markers are plotted at the xcorr values using</span>
<span class="sd">            `Axes.plot`.</span>

<span class="sd">        maxlags : int, optional, default: 10</span>
<span class="sd">            Number of lags to show. If None, will return all ``2 * len(x) - 1``</span>
<span class="sd">            lags.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lags : array (length ``2*maxlags+1``)</span>
<span class="sd">            The lag vector.</span>
<span class="sd">        c : array  (length ``2*maxlags+1``)</span>
<span class="sd">            The auto correlation vector.</span>
<span class="sd">        line : `.LineCollection` or `.Line2D`</span>
<span class="sd">            `.Artist` added to the axes of the correlation:</span>

<span class="sd">            - `.LineCollection` if *usevlines* is True.</span>
<span class="sd">            - `.Line2D` if *usevlines* is False.</span>
<span class="sd">        b : `.Line2D` or None</span>
<span class="sd">            Horizontal line at 0 if *usevlines* is True</span>
<span class="sd">            None *usevlines* is False.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        linestyle : `.Line2D` property, optional</span>
<span class="sd">            The linestyle for plotting the data points.</span>
<span class="sd">            Only used if *usevlines* is ``False``.</span>

<span class="sd">        marker : str, optional, default: &#39;o&#39;</span>
<span class="sd">            The marker for plotting the data points.</span>
<span class="sd">            Only used if *usevlines* is ``False``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The cross correlation is performed with :func:`numpy.correlate` with</span>
<span class="sd">        ``mode = &quot;full&quot;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Nx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Nx</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;x and y must be equal length&#39;</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">detrend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">detrend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>

        <span class="n">correls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;full&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">normed</span><span class="p">:</span>
            <span class="n">correls</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">maxlags</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">maxlags</span> <span class="o">=</span> <span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">maxlags</span> <span class="o">&gt;=</span> <span class="n">Nx</span> <span class="ow">or</span> <span class="n">maxlags</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;maxlags must be None or strictly &#39;</span>
                             <span class="s1">&#39;positive &lt; </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">Nx</span><span class="p">)</span>

        <span class="n">lags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">maxlags</span><span class="p">,</span> <span class="n">maxlags</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">correls</span> <span class="o">=</span> <span class="n">correls</span><span class="p">[</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">maxlags</span><span class="p">:</span><span class="n">Nx</span> <span class="o">+</span> <span class="n">maxlags</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">usevlines</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">lags</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">correls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="c1"># Make label empty so only vertical lines get a legend entry</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;marker&#39;</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;linestyle&#39;</span><span class="p">,</span> <span class="s1">&#39;None&#39;</span><span class="p">)</span>
            <span class="n">a</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lags</span><span class="p">,</span> <span class="n">correls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">lags</span><span class="p">,</span> <span class="n">correls</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>

    <span class="c1">#### Specialized plotting</span>

    <span class="c1"># @_preprocess_data() # let &#39;plot&#39; do the unpacking..</span>
    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s1">&#39;pre&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a step plot.</span>

<span class="sd">        Call signatures::</span>

<span class="sd">            step(x, y, [fmt], *, data=None, where=&#39;pre&#39;, **kwargs)</span>
<span class="sd">            step(x, y, [fmt], x2, y2, [fmt2], ..., *, where=&#39;pre&#39;, **kwargs)</span>

<span class="sd">        This is just a thin wrapper around `.plot` which changes some</span>
<span class="sd">        formatting options. Most of the concepts and parameters of plot can be</span>
<span class="sd">        used here as well.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            1-D sequence of x positions. It is assumed, but not checked, that</span>
<span class="sd">            it is uniformly increasing.</span>

<span class="sd">        y : array_like</span>
<span class="sd">            1-D sequence of y levels.</span>

<span class="sd">        fmt : str, optional</span>
<span class="sd">            A format string, e.g. &#39;g&#39; for a green line. See `.plot` for a more</span>
<span class="sd">            detailed description.</span>

<span class="sd">            Note: While full format strings are accepted, it is recommended to</span>
<span class="sd">            only specify the color. Line styles are currently ignored (use</span>
<span class="sd">            the keyword argument *linestyle* instead). Markers are accepted</span>
<span class="sd">            and plotted on the given positions, however, this is a rarely</span>
<span class="sd">            needed feature for step plots.</span>

<span class="sd">        data : indexable object, optional</span>
<span class="sd">            An object with labelled data. If given, provide the label names to</span>
<span class="sd">            plot in *x* and *y*.</span>

<span class="sd">        where : {&#39;pre&#39;, &#39;post&#39;, &#39;mid&#39;}, optional, default &#39;pre&#39;</span>
<span class="sd">            Define where the steps should be placed:</span>

<span class="sd">            - &#39;pre&#39;: The y value is continued constantly to the left from</span>
<span class="sd">              every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the</span>
<span class="sd">              value ``y[i]``.</span>
<span class="sd">            - &#39;post&#39;: The y value is continued constantly to the right from</span>
<span class="sd">              every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the</span>
<span class="sd">              value ``y[i]``.</span>
<span class="sd">            - &#39;mid&#39;: Steps occur half-way between the *x* positions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lines</span>
<span class="sd">            A list of `.Line2D` objects representing the plotted data.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional parameters are the same as those for `.plot`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. [notes section required to get data note injection right]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">where</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;pre&#39;</span><span class="p">,</span> <span class="s1">&#39;post&#39;</span><span class="p">,</span> <span class="s1">&#39;mid&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;where&#39; argument to step must be &quot;</span>
                             <span class="s2">&quot;&#39;pre&#39;, &#39;post&#39; or &#39;mid&#39;&quot;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;drawstyle&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;steps-&#39;</span> <span class="o">+</span> <span class="n">where</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_convert_dx</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">xconv</span><span class="p">,</span> <span class="n">convert</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Small helper to do logic of width conversion flexibly.</span>

<span class="sd">        *dx* and *x0* have units, but *xconv* has already been converted</span>
<span class="sd">        to unitless (and is an ndarray).  This allows the *dx* to have units</span>
<span class="sd">        that are different from *x0*, but are still accepted by the</span>
<span class="sd">        ``__add__`` operator of *x0*.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># x should be an array...</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">xconv</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>

        <span class="k">if</span> <span class="n">xconv</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># xconv has already been converted, but maybe empty...</span>
            <span class="k">return</span> <span class="n">convert</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># attempt to add the width to x0; this works for</span>
            <span class="c1"># datetime+timedelta, for instance</span>

            <span class="c1"># only use the first element of x and x0.  This saves</span>
            <span class="c1"># having to be sure addition works across the whole</span>
            <span class="c1"># vector.  This is particularly an issue if</span>
            <span class="c1"># x0 and dx are lists so x0 + dx just concatenates the lists.</span>
            <span class="c1"># We can&#39;t just cast x0 and dx to numpy arrays because that</span>
            <span class="c1"># removes the units from unit packages like `pint` that</span>
            <span class="c1"># wrap numpy arrays.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">x0</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safe_first_element</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
                <span class="n">x0</span> <span class="o">=</span> <span class="n">x0</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safe_first_element</span><span class="p">(</span><span class="n">xconv</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">xconv</span>

            <span class="n">delist</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">dx</span><span class="p">):</span>
                <span class="n">dx</span> <span class="o">=</span> <span class="p">[</span><span class="n">dx</span><span class="p">]</span>
                <span class="n">delist</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="p">[</span><span class="n">convert</span><span class="p">(</span><span class="n">x0</span> <span class="o">+</span> <span class="n">ddx</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span> <span class="k">for</span> <span class="n">ddx</span> <span class="ow">in</span> <span class="n">dx</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">delist</span><span class="p">:</span>
                <span class="n">dx</span> <span class="o">=</span> <span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="c1"># if the above fails (for any reason) just fallback to what</span>
            <span class="c1"># we do by default and convert dx by itself.</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">convert</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dx</span>

    <span class="nd">@_preprocess_data</span><span class="p">()</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a bar plot.</span>

<span class="sd">        The bars are positioned at *x* with the given *align*\ment. Their</span>
<span class="sd">        dimensions are given by *width* and *height*. The vertical baseline</span>
<span class="sd">        is *bottom* (default 0).</span>

<span class="sd">        Each of *x*, *height*, *width*, and *bottom* may either be a scalar</span>
<span class="sd">        applying to all bars, or it may be a sequence of length N providing a</span>
<span class="sd">        separate value for each bar.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : sequence of scalars</span>
<span class="sd">            The x coordinates of the bars. See also *align* for the</span>
<span class="sd">            alignment of the bars to the coordinates.</span>

<span class="sd">        height : scalar or sequence of scalars</span>
<span class="sd">            The height(s) of the bars.</span>

<span class="sd">        width : scalar or array-like, optional</span>
<span class="sd">            The width(s) of the bars (default: 0.8).</span>

<span class="sd">        bottom : scalar or array-like, optional</span>
<span class="sd">            The y coordinate(s) of the bars bases (default: 0).</span>

<span class="sd">        align : {&#39;center&#39;, &#39;edge&#39;}, optional, default: &#39;center&#39;</span>
<span class="sd">            Alignment of the bars to the *x* coordinates:</span>

<span class="sd">            - &#39;center&#39;: Center the base on the *x* positions.</span>
<span class="sd">            - &#39;edge&#39;: Align the left edges of the bars with the *x* positions.</span>

<span class="sd">            To align the bars on the right edge pass a negative *width* and</span>
<span class="sd">            ``align=&#39;edge&#39;``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        container : `.BarContainer`</span>
<span class="sd">            Container with all the bars and optionally errorbars.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        color : scalar or array-like, optional</span>
<span class="sd">            The colors of the bar faces.</span>

<span class="sd">        edgecolor : scalar or array-like, optional</span>
<span class="sd">            The colors of the bar edges.</span>

<span class="sd">        linewidth : scalar or array-like, optional</span>
<span class="sd">            Width of the bar edge(s). If 0, don&#39;t draw edges.</span>

<span class="sd">        tick_label : string or array-like, optional</span>
<span class="sd">            The tick labels of the bars.</span>
<span class="sd">            Default: None (Use default numeric labels.)</span>

<span class="sd">        xerr, yerr : scalar or array-like of shape(N,) or shape(2,N), optional</span>
<span class="sd">            If not *None*, add horizontal / vertical errorbars to the bar tips.</span>
<span class="sd">            The values are +/- sizes relative to the data:</span>

<span class="sd">            - scalar: symmetric +/- values for all bars</span>
<span class="sd">            - shape(N,): symmetric +/- values for each bar</span>
<span class="sd">            - shape(2,N): Separate - and + values for each bar. First row</span>
<span class="sd">                contains the lower errors, the second row contains the</span>
<span class="sd">                upper errors.</span>
<span class="sd">            - *None*: No errorbar. (Default)</span>

<span class="sd">            See :doc:`/gallery/statistics/errorbar_features`</span>
<span class="sd">            for an example on the usage of ``xerr`` and ``yerr``.</span>

<span class="sd">        ecolor : scalar or array-like, optional, default: &#39;black&#39;</span>
<span class="sd">            The line color of the errorbars.</span>

<span class="sd">        capsize : scalar, optional</span>
<span class="sd">           The length of the error bar caps in points.</span>
<span class="sd">           Default: None, which will take the value from</span>
<span class="sd">           :rc:`errorbar.capsize`.</span>

<span class="sd">        error_kw : dict, optional</span>
<span class="sd">            Dictionary of kwargs to be passed to the `~.Axes.errorbar`</span>
<span class="sd">            method. Values of *ecolor* or *capsize* defined here take</span>
<span class="sd">            precedence over the independent kwargs.</span>

<span class="sd">        log : bool, optional, default: False</span>
<span class="sd">            If *True*, set the y-axis to be log scale.</span>

<span class="sd">        orientation : {&#39;vertical&#39;,  &#39;horizontal&#39;}, optional</span>
<span class="sd">            *This is for internal use only.* Please use `barh` for</span>
<span class="sd">            horizontal bar plots. Default: &#39;vertical&#39;.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        barh: Plot a horizontal bar plot.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The optional arguments *color*, *edgecolor*, *linewidth*,</span>
<span class="sd">        *xerr*, and *yerr* can be either scalars or sequences of</span>
<span class="sd">        length equal to the number of bars.  This enables you to use</span>
<span class="sd">        bar as the basis for stacked bar charts, or candlestick plots.</span>
<span class="sd">        Detail: *xerr* and *yerr* are passed directly to</span>
<span class="sd">        :meth:`errorbar`, so they can also have shape 2xN for</span>
<span class="sd">        independent specification of lower and upper errors.</span>

<span class="sd">        Other optional kwargs:</span>

<span class="sd">        %(Rectangle)s</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">normalize_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Patch</span><span class="o">.</span><span class="n">_alias_map</span><span class="p">)</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_patches_for_fill</span><span class="o">.</span><span class="n">get_next_color</span><span class="p">()</span>
        <span class="n">edgecolor</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;edgecolor&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">linewidth</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;linewidth&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Because xerr and yerr will be passed to errorbar, most dimension</span>
        <span class="c1"># checking and processing will be left to the errorbar method.</span>
        <span class="n">xerr</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;xerr&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">yerr</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;yerr&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">error_kw</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;error_kw&#39;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">ezorder</span> <span class="o">=</span> <span class="n">error_kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;zorder&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ezorder</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ezorder</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;zorder&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ezorder</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># If using the bar zorder, increment slightly to make sure</span>
                <span class="c1"># errorbars are drawn on top of bars</span>
                <span class="n">ezorder</span> <span class="o">+=</span> <span class="mf">0.01</span>
        <span class="n">error_kw</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;zorder&#39;</span><span class="p">,</span> <span class="n">ezorder</span><span class="p">)</span>
        <span class="n">ecolor</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;ecolor&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">)</span>
        <span class="n">capsize</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;capsize&#39;</span><span class="p">,</span> <span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;errorbar.capsize&quot;</span><span class="p">])</span>
        <span class="n">error_kw</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ecolor&#39;</span><span class="p">,</span> <span class="n">ecolor</span><span class="p">)</span>
        <span class="n">error_kw</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;capsize&#39;</span><span class="p">,</span> <span class="n">capsize</span><span class="p">)</span>

        <span class="n">orientation</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;orientation&#39;</span><span class="p">,</span> <span class="s1">&#39;vertical&#39;</span><span class="p">)</span>
        <span class="n">log</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">tick_labels</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;tick_label&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">adjust_ylim</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">adjust_xlim</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">bottom</span>  <span class="c1"># Matches barh call signature.</span>
        <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;vertical&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bottom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_yscale</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
                    <span class="n">adjust_ylim</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">elif</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xscale</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
                    <span class="n">adjust_xlim</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;vertical&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="n">height</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">nonposy</span><span class="o">=</span><span class="s1">&#39;clip&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">width</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">nonposx</span><span class="o">=</span><span class="s1">&#39;clip&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid orientation: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">orientation</span><span class="p">)</span>

        <span class="c1"># lets do some conversions now since some types cannot be</span>
        <span class="c1"># subtracted uniformly</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">x</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="n">width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_dx</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">xerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">xerr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_dx</span><span class="p">(</span><span class="n">xerr</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="n">y</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
            <span class="n">height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_dx</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">yerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">yerr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_dx</span><span class="p">(</span><span class="n">yerr</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">)</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">linewidth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span>
            <span class="c1"># Make args iterable too.</span>
            <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">linewidth</span><span class="p">)</span>

        <span class="c1"># Now that units have been converted, set the tick locations.</span>
        <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;vertical&#39;</span><span class="p">:</span>
            <span class="n">tick_label_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span>
            <span class="n">tick_label_position</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">elif</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">:</span>
            <span class="n">tick_label_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span>
            <span class="n">tick_label_position</span> <span class="o">=</span> <span class="n">y</span>

        <span class="n">linewidth</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">linewidth</span><span class="p">))</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">(</span><span class="n">mcolors</span><span class="o">.</span><span class="n">to_rgba_array</span><span class="p">(</span><span class="n">color</span><span class="p">)),</span>
                                <span class="c1"># Fallback if color == &quot;none&quot;.</span>
                                <span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">edgecolor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edgecolor</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edgecolor</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
                <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">(</span><span class="n">mcolors</span><span class="o">.</span><span class="n">to_rgba_array</span><span class="p">(</span><span class="n">edgecolor</span><span class="p">)),</span>
                <span class="c1"># Fallback if edgecolor == &quot;none&quot;.</span>
                <span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">))</span>

        <span class="c1"># We will now resolve the alignment and really have</span>
        <span class="c1"># left, bottom, width, height vectors</span>
        <span class="k">if</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">&#39;center&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;vertical&#39;</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">left</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">width</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;the dtypes of parameters x (</span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s1">) &#39;</span>
                                    <span class="sa">f</span><span class="s1">&#39;and width (</span><span class="si">{</span><span class="n">width</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s1">) &#39;</span>
                                    <span class="sa">f</span><span class="s1">&#39;are incompatible&#39;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
                <span class="n">bottom</span> <span class="o">=</span> <span class="n">y</span>
            <span class="k">elif</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">bottom</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">height</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;the dtypes of parameters y (</span><span class="si">{</span><span class="n">y</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s1">) &#39;</span>
                                    <span class="sa">f</span><span class="s1">&#39;and height (</span><span class="si">{</span><span class="n">height</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s1">) &#39;</span>
                                    <span class="sa">f</span><span class="s1">&#39;are incompatible&#39;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">elif</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">&#39;edge&#39;</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">x</span>
            <span class="n">bottom</span> <span class="o">=</span> <span class="n">y</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid alignment: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">align</span><span class="p">)</span>

        <span class="n">patches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">edgecolor</span><span class="p">,</span> <span class="n">linewidth</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">lw</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span>
                <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
                <span class="n">facecolor</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
                <span class="n">edgecolor</span><span class="o">=</span><span class="n">e</span><span class="p">,</span>
                <span class="n">linewidth</span><span class="o">=</span><span class="n">lw</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="s1">&#39;_nolegend_&#39;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">r</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">r</span><span class="o">.</span><span class="n">get_path</span><span class="p">()</span><span class="o">.</span><span class="n">_interpolation_steps</span> <span class="o">=</span> <span class="mi">100</span>
            <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;vertical&#39;</span><span class="p">:</span>
                <span class="n">r</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">:</span>
                <span class="n">r</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="n">patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">xerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">yerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;vertical&#39;</span><span class="p">:</span>
                <span class="c1"># using list comps rather than arrays to preserve unit info</span>
                <span class="n">ex</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">w</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">width</span><span class="p">)]</span>
                <span class="n">ey</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="n">h</span> <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bottom</span><span class="p">,</span> <span class="n">height</span><span class="p">)]</span>

            <span class="k">elif</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">:</span>
                <span class="c1"># using list comps rather than arrays to preserve unit info</span>
                <span class="n">ex</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="n">w</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">width</span><span class="p">)]</span>
                <span class="n">ey</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">h</span> <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bottom</span><span class="p">,</span> <span class="n">height</span><span class="p">)]</span>

            <span class="n">error_kw</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="s1">&#39;_nolegend_&#39;</span><span class="p">)</span>

            <span class="n">errorbar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="n">ey</span><span class="p">,</span>
                                     <span class="n">yerr</span><span class="o">=</span><span class="n">yerr</span><span class="p">,</span> <span class="n">xerr</span><span class="o">=</span><span class="n">xerr</span><span class="p">,</span>
                                     <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">error_kw</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">errorbar</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">adjust_xlim</span><span class="p">:</span>
            <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataLim</span><span class="o">.</span><span class="n">intervalx</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">width</span> <span class="k">if</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">xerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">xmin</span> <span class="o">=</span> <span class="n">xmin</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xerr</span><span class="p">)</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">xmin</span> <span class="o">*</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">1e-100</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dataLim</span><span class="o">.</span><span class="n">intervalx</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">adjust_ylim</span><span class="p">:</span>
            <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataLim</span><span class="o">.</span><span class="n">intervaly</span>
            <span class="n">ymin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">h</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">height</span> <span class="k">if</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">yerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ymin</span> <span class="o">=</span> <span class="n">ymin</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">yerr</span><span class="p">)</span>
            <span class="n">ymin</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ymin</span> <span class="o">*</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">1e-100</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dataLim</span><span class="o">.</span><span class="n">intervaly</span> <span class="o">=</span> <span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>

        <span class="n">bar_container</span> <span class="o">=</span> <span class="n">BarContainer</span><span class="p">(</span><span class="n">patches</span><span class="p">,</span> <span class="n">errorbar</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_container</span><span class="p">(</span><span class="n">bar_container</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">tick_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tick_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">tick_labels</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">patches</span><span class="p">))</span>
            <span class="n">tick_label_axis</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">(</span><span class="n">tick_label_position</span><span class="p">)</span>
            <span class="n">tick_label_axis</span><span class="o">.</span><span class="n">set_ticklabels</span><span class="p">(</span><span class="n">tick_labels</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">bar_container</span>

    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">barh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span>
             <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a horizontal bar plot.</span>

<span class="sd">        The bars are positioned at *y* with the given *align*\ment. Their</span>
<span class="sd">        dimensions are given by *width* and *height*. The horizontal baseline</span>
<span class="sd">        is *left* (default 0).</span>

<span class="sd">        Each of *y*, *width*, *height*, and *left* may either be a scalar</span>
<span class="sd">        applying to all bars, or it may be a sequence of length N providing a</span>
<span class="sd">        separate value for each bar.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : scalar or array-like</span>
<span class="sd">            The y coordinates of the bars. See also *align* for the</span>
<span class="sd">            alignment of the bars to the coordinates.</span>

<span class="sd">        width : scalar or array-like</span>
<span class="sd">            The width(s) of the bars.</span>

<span class="sd">        height : sequence of scalars, optional, default: 0.8</span>
<span class="sd">            The heights of the bars.</span>

<span class="sd">        left : sequence of scalars</span>
<span class="sd">            The x coordinates of the left sides of the bars (default: 0).</span>

<span class="sd">        align : {&#39;center&#39;, &#39;edge&#39;}, optional, default: &#39;center&#39;</span>
<span class="sd">            Alignment of the base to the *y* coordinates*:</span>

<span class="sd">            - &#39;center&#39;: Center the bars on the *y* positions.</span>
<span class="sd">            - &#39;edge&#39;: Align the bottom edges of the bars with the *y*</span>
<span class="sd">              positions.</span>

<span class="sd">            To align the bars on the top edge pass a negative *height* and</span>
<span class="sd">            ``align=&#39;edge&#39;``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        container : `.BarContainer`</span>
<span class="sd">            Container with all the bars and optionally errorbars.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        color : scalar or array-like, optional</span>
<span class="sd">            The colors of the bar faces.</span>

<span class="sd">        edgecolor : scalar or array-like, optional</span>
<span class="sd">            The colors of the bar edges.</span>

<span class="sd">        linewidth : scalar or array-like, optional</span>
<span class="sd">            Width of the bar edge(s). If 0, don&#39;t draw edges.</span>

<span class="sd">        tick_label : string or array-like, optional</span>
<span class="sd">            The tick labels of the bars.</span>
<span class="sd">            Default: None (Use default numeric labels.)</span>

<span class="sd">        xerr, yerr : scalar or array-like of shape(N,) or shape(2,N), optional</span>
<span class="sd">            If not ``None``, add horizontal / vertical errorbars to the</span>
<span class="sd">            bar tips. The values are +/- sizes relative to the data:</span>

<span class="sd">            - scalar: symmetric +/- values for all bars</span>
<span class="sd">            - shape(N,): symmetric +/- values for each bar</span>
<span class="sd">            - shape(2,N): Separate - and + values for each bar. First row</span>
<span class="sd">                contains the lower errors, the second row contains the</span>
<span class="sd">                upper errors.</span>
<span class="sd">            - *None*: No errorbar. (default)</span>

<span class="sd">            See :doc:`/gallery/statistics/errorbar_features`</span>
<span class="sd">            for an example on the usage of ``xerr`` and ``yerr``.</span>

<span class="sd">        ecolor : scalar or array-like, optional, default: &#39;black&#39;</span>
<span class="sd">            The line color of the errorbars.</span>

<span class="sd">        capsize : scalar, optional</span>
<span class="sd">           The length of the error bar caps in points.</span>
<span class="sd">           Default: None, which will take the value from</span>
<span class="sd">           :rc:`errorbar.capsize`.</span>

<span class="sd">        error_kw : dict, optional</span>
<span class="sd">            Dictionary of kwargs to be passed to the `~.Axes.errorbar`</span>
<span class="sd">            method. Values of *ecolor* or *capsize* defined here take</span>
<span class="sd">            precedence over the independent kwargs.</span>

<span class="sd">        log : bool, optional, default: False</span>
<span class="sd">            If ``True``, set the x-axis to be log scale.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        bar: Plot a vertical bar plot.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The optional arguments *color*, *edgecolor*, *linewidth*,</span>
<span class="sd">        *xerr*, and *yerr* can be either scalars or sequences of</span>
<span class="sd">        length equal to the number of bars.  This enables you to use</span>
<span class="sd">        bar as the basis for stacked bar charts, or candlestick plots.</span>
<span class="sd">        Detail: *xerr* and *yerr* are passed directly to</span>
<span class="sd">        :meth:`errorbar`, so they can also have shape 2xN for</span>
<span class="sd">        independent specification of lower and upper errors.</span>

<span class="sd">        Other optional kwargs:</span>

<span class="sd">        %(Rectangle)s</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;orientation&#39;</span><span class="p">,</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">)</span>
        <span class="n">patches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">left</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
                           <span class="n">align</span><span class="o">=</span><span class="n">align</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">patches</span>

    <span class="nd">@_preprocess_data</span><span class="p">()</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">broken_barh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xranges</span><span class="p">,</span> <span class="n">yrange</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot a horizontal sequence of rectangles.</span>

<span class="sd">        A rectangle is drawn for each element of *xranges*. All rectangles</span>
<span class="sd">        have the same vertical position and size defined by *yrange*.</span>

<span class="sd">        This is a convenience function for instantiating a</span>
<span class="sd">        `.BrokenBarHCollection`, adding it to the axes and autoscaling the</span>
<span class="sd">        view.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xranges : sequence of tuples (*xmin*, *xwidth*)</span>
<span class="sd">            The x-positions and extends of the rectangles. For each tuple</span>
<span class="sd">            (*xmin*, *xwidth*) a rectangle is drawn from *xmin* to *xmin* +</span>
<span class="sd">            *xwidth*.</span>
<span class="sd">        yranges : (*ymin*, *ymax*)</span>
<span class="sd">            The y-position and extend for all the rectangles.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs : :class:`.BrokenBarHCollection` properties</span>

<span class="sd">            Each *kwarg* can be either a single argument applying to all</span>
<span class="sd">            rectangles, e.g.::</span>

<span class="sd">                facecolors=&#39;black&#39;</span>

<span class="sd">            or a sequence of arguments over which is cycled, e.g.::</span>

<span class="sd">                facecolors=(&#39;black&#39;, &#39;blue&#39;)</span>

<span class="sd">            would create interleaving black and blue rectangles.</span>

<span class="sd">            Supported keywords:</span>

<span class="sd">            %(BrokenBarHCollection)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        collection : A :class:`~.collections.BrokenBarHCollection`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># process the unit information</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xranges</span><span class="p">):</span>
            <span class="n">xdata</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safe_first_element</span><span class="p">(</span><span class="n">xranges</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xdata</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">yrange</span><span class="p">):</span>
            <span class="n">ydata</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safe_first_element</span><span class="p">(</span><span class="n">yrange</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ydata</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">xdata</span><span class="p">,</span>
                                <span class="n">ydata</span><span class="o">=</span><span class="n">ydata</span><span class="p">,</span>
                                <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">xranges_conv</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">xr</span> <span class="ow">in</span> <span class="n">xranges</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xr</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;each range in xrange must be a sequence &#39;</span>
                                 <span class="s1">&#39;with two elements (i.e. an Nx2 array)&#39;</span><span class="p">)</span>
            <span class="c1"># convert the absolute values, not the x and dx...</span>
            <span class="n">x_conv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">xr</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_dx</span><span class="p">(</span><span class="n">xr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">xr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_conv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">)</span>
            <span class="n">xranges_conv</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x_conv</span><span class="p">,</span> <span class="n">x1</span><span class="p">))</span>

        <span class="n">yrange_conv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">yrange</span><span class="p">)</span>

        <span class="n">col</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">BrokenBarHCollection</span><span class="p">(</span><span class="n">xranges_conv</span><span class="p">,</span> <span class="n">yrange_conv</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">col</span>

    <span class="nd">@_preprocess_data</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">stem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">linefmt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">markerfmt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">basefmt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
             <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_line_collection</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a stem plot.</span>

<span class="sd">        A stem plot plots vertical lines at each *x* location from the baseline</span>
<span class="sd">        to *y*, and places a marker there.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          stem([x,] y, linefmt=None, markerfmt=None, basefmt=None)</span>

<span class="sd">        The x-positions are optional. The formats may be provided either as</span>
<span class="sd">        positional or as keyword-arguments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like, optional</span>
<span class="sd">            The x-positions of the stems. Default: (0, 1, ..., len(y) - 1).</span>

<span class="sd">        y : array-like</span>
<span class="sd">            The y-values of the stem heads.</span>

<span class="sd">        linefmt : str, optional</span>
<span class="sd">            A string defining the properties of the vertical lines. Usually,</span>
<span class="sd">            this will be a color or a color and a linestyle:</span>

<span class="sd">            =========  =============</span>
<span class="sd">            Character  Line Style</span>
<span class="sd">            =========  =============</span>
<span class="sd">            ``&#39;-&#39;``    solid line</span>
<span class="sd">            ``&#39;--&#39;``   dashed line</span>
<span class="sd">            ``&#39;-.&#39;``   dash-dot line</span>
<span class="sd">            ``&#39;:&#39;``    dotted line</span>
<span class="sd">            =========  =============</span>

<span class="sd">            Default: &#39;C0-&#39;, i.e. solid line with the first color of the color</span>
<span class="sd">            cycle.</span>

<span class="sd">            Note: While it is technically possible to specify valid formats</span>
<span class="sd">            other than color or color and linestyle (e.g. &#39;rx&#39; or &#39;-.&#39;), this</span>
<span class="sd">            is beyond the intention of the method and will most likely not</span>
<span class="sd">            result in a reasonable reasonable plot.</span>

<span class="sd">        markerfmt : str, optional</span>
<span class="sd">            A string defining the properties of the markers at the stem heads.</span>
<span class="sd">            Default: &#39;C0o&#39;, i.e. filled circles with the first color of the</span>
<span class="sd">            color cycle.</span>

<span class="sd">        basefmt : str, optional</span>
<span class="sd">            A format string defining the properties of the baseline.</span>

<span class="sd">            Default: &#39;C3-&#39; (&#39;C2-&#39; in classic mode).</span>

<span class="sd">        bottom : float, optional, default: 0</span>
<span class="sd">            The y-position of the baseline.</span>

<span class="sd">        label : str, optional, default: None</span>
<span class="sd">            The label to use for the stems in legends.</span>

<span class="sd">        use_line_collection : bool, optional, default: False</span>
<span class="sd">            If ``True``, store and plot the stem lines as a</span>
<span class="sd">            `~.collections.LineCollection` instead of individual lines. This</span>
<span class="sd">            significantly increases performance, and will become the default</span>
<span class="sd">            option in Matplotlib 3.3. If ``False``, defaults to the old</span>
<span class="sd">            behavior of using a list of `.Line2D` objects.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        container : :class:`~matplotlib.container.StemContainer`</span>
<span class="sd">            The container may be treated like a tuple</span>
<span class="sd">            (*markerline*, *stemlines*, *baseline*)</span>


<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        .. seealso::</span>
<span class="sd">            The MATLAB function</span>
<span class="sd">            `stem &lt;http://www.mathworks.com/help/techdoc/ref/stem.html&gt;`_</span>
<span class="sd">            which inspired this method.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;stem expected between 1 and 5 positional &#39;</span>
                            <span class="s1">&#39;arguments, got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="c1"># Try a second one</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">y</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="c1"># defaults for formats</span>
        <span class="k">if</span> <span class="n">linefmt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># fallback to positional argument</span>
                <span class="n">linefmt</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="n">linecolor</span> <span class="o">=</span> <span class="s1">&#39;C0&#39;</span>
                <span class="n">linemarker</span> <span class="o">=</span> <span class="s1">&#39;None&#39;</span>
                <span class="n">linestyle</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">linestyle</span><span class="p">,</span> <span class="n">linemarker</span><span class="p">,</span> <span class="n">linecolor</span> <span class="o">=</span> \
                    <span class="n">_process_plot_format</span><span class="p">(</span><span class="n">linefmt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">linestyle</span><span class="p">,</span> <span class="n">linemarker</span><span class="p">,</span> <span class="n">linecolor</span> <span class="o">=</span> <span class="n">_process_plot_format</span><span class="p">(</span><span class="n">linefmt</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">markerfmt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># fallback to positional argument</span>
                <span class="n">markerfmt</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="n">markercolor</span> <span class="o">=</span> <span class="s1">&#39;C0&#39;</span>
                <span class="n">markermarker</span> <span class="o">=</span> <span class="s1">&#39;o&#39;</span>
                <span class="n">markerstyle</span> <span class="o">=</span> <span class="s1">&#39;None&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">markerstyle</span><span class="p">,</span> <span class="n">markermarker</span><span class="p">,</span> <span class="n">markercolor</span> <span class="o">=</span> \
                    <span class="n">_process_plot_format</span><span class="p">(</span><span class="n">markerfmt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">markerstyle</span><span class="p">,</span> <span class="n">markermarker</span><span class="p">,</span> <span class="n">markercolor</span> <span class="o">=</span> \
                <span class="n">_process_plot_format</span><span class="p">(</span><span class="n">markerfmt</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">basefmt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># fallback to positional argument</span>
                <span class="n">basefmt</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;_internal.classic_mode&#39;</span><span class="p">]:</span>
                    <span class="n">basecolor</span> <span class="o">=</span> <span class="s1">&#39;C2&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">basecolor</span> <span class="o">=</span> <span class="s1">&#39;C3&#39;</span>
                <span class="n">basemarker</span> <span class="o">=</span> <span class="s1">&#39;None&#39;</span>
                <span class="n">basestyle</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">basestyle</span><span class="p">,</span> <span class="n">basemarker</span><span class="p">,</span> <span class="n">basecolor</span> <span class="o">=</span> \
                    <span class="n">_process_plot_format</span><span class="p">(</span><span class="n">basefmt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">basestyle</span><span class="p">,</span> <span class="n">basemarker</span><span class="p">,</span> <span class="n">basecolor</span> <span class="o">=</span> <span class="n">_process_plot_format</span><span class="p">(</span><span class="n">basefmt</span><span class="p">)</span>

        <span class="c1"># New behaviour in 3.1 is to use a LineCollection for the stemlines</span>
        <span class="k">if</span> <span class="n">use_line_collection</span><span class="p">:</span>
            <span class="n">stemlines</span> <span class="o">=</span> <span class="p">[((</span><span class="n">xi</span><span class="p">,</span> <span class="n">bottom</span><span class="p">),</span> <span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">))</span> <span class="k">for</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">linestyle</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">linestyle</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;lines.linestyle&#39;</span><span class="p">]</span>
            <span class="n">stemlines</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">LineCollection</span><span class="p">(</span><span class="n">stemlines</span><span class="p">,</span> <span class="n">linestyles</span><span class="o">=</span><span class="n">linestyle</span><span class="p">,</span>
                                             <span class="n">colors</span><span class="o">=</span><span class="n">linecolor</span><span class="p">,</span>
                                             <span class="n">label</span><span class="o">=</span><span class="s1">&#39;_nolegend_&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">stemlines</span><span class="p">)</span>
        <span class="c1"># Old behaviour is to plot each of the lines individually</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cbook</span><span class="o">.</span><span class="n">_warn_external</span><span class="p">(</span>
                <span class="s1">&#39;In Matplotlib 3.3 individual lines on a stem plot will be &#39;</span>
                <span class="s1">&#39;added as a LineCollection instead of individual lines. &#39;</span>
                <span class="s1">&#39;This significantly improves the performance of a stem plot. &#39;</span>
                <span class="s1">&#39;To remove this warning and switch to the new behaviour, &#39;</span>
                <span class="s1">&#39;set the &quot;use_line_collection&quot; keyword argument to True.&#39;</span><span class="p">)</span>
            <span class="n">stemlines</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
                <span class="n">l</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">xi</span><span class="p">,</span> <span class="n">xi</span><span class="p">],</span> <span class="p">[</span><span class="n">bottom</span><span class="p">,</span> <span class="n">yi</span><span class="p">],</span>
                               <span class="n">color</span><span class="o">=</span><span class="n">linecolor</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="n">linestyle</span><span class="p">,</span>
                               <span class="n">marker</span><span class="o">=</span><span class="n">linemarker</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;_nolegend_&quot;</span><span class="p">)</span>
                <span class="n">stemlines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

        <span class="n">markerline</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">markercolor</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="n">markerstyle</span><span class="p">,</span>
                                <span class="n">marker</span><span class="o">=</span><span class="n">markermarker</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;_nolegend_&quot;</span><span class="p">)</span>

        <span class="n">baseline</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">)],</span> <span class="p">[</span><span class="n">bottom</span><span class="p">,</span> <span class="n">bottom</span><span class="p">],</span>
                              <span class="n">color</span><span class="o">=</span><span class="n">basecolor</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="n">basestyle</span><span class="p">,</span>
                              <span class="n">marker</span><span class="o">=</span><span class="n">basemarker</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;_nolegend_&quot;</span><span class="p">)</span>

        <span class="n">stem_container</span> <span class="o">=</span> <span class="n">StemContainer</span><span class="p">((</span><span class="n">markerline</span><span class="p">,</span> <span class="n">stemlines</span><span class="p">,</span> <span class="n">baseline</span><span class="p">),</span>
                                       <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_container</span><span class="p">(</span><span class="n">stem_container</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stem_container</span>

    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;explode&quot;</span><span class="p">,</span> <span class="s2">&quot;labels&quot;</span><span class="p">,</span> <span class="s2">&quot;colors&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">pie</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">explode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">autopct</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pctdistance</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">shadow</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">labeldistance</span><span class="o">=</span><span class="mf">1.1</span><span class="p">,</span>
            <span class="n">startangle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">counterclock</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">wedgeprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">textprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="n">frame</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rotatelabels</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot a pie chart.</span>

<span class="sd">        Make a pie chart of array *x*.  The fractional area of each wedge is</span>
<span class="sd">        given by ``x/sum(x)``.  If ``sum(x) &lt; 1``, then the values of *x* give</span>
<span class="sd">        the fractional area directly and the array will not be normalized. The</span>
<span class="sd">        resulting pie will have an empty wedge of size ``1 - sum(x)``.</span>

<span class="sd">        The wedges are plotted counterclockwise, by default starting from the</span>
<span class="sd">        x-axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like</span>
<span class="sd">            The wedge sizes.</span>

<span class="sd">        explode : array-like, optional, default: None</span>
<span class="sd">            If not *None*, is a ``len(x)`` array which specifies the fraction</span>
<span class="sd">            of the radius with which to offset each wedge.</span>

<span class="sd">        labels : list, optional, default: None</span>
<span class="sd">            A sequence of strings providing the labels for each wedge</span>

<span class="sd">        colors : array-like, optional, default: None</span>
<span class="sd">            A sequence of matplotlib color args through which the pie chart</span>
<span class="sd">            will cycle.  If *None*, will use the colors in the currently</span>
<span class="sd">            active cycle.</span>

<span class="sd">        autopct : None (default), string, or function, optional</span>
<span class="sd">            If not *None*, is a string or function used to label the wedges</span>
<span class="sd">            with their numeric value.  The label will be placed inside the</span>
<span class="sd">            wedge.  If it is a format string, the label will be ``fmt%pct``.</span>
<span class="sd">            If it is a function, it will be called.</span>

<span class="sd">        pctdistance : float, optional, default: 0.6</span>
<span class="sd">            The ratio between the center of each pie slice and the start of</span>
<span class="sd">            the text generated by *autopct*.  Ignored if *autopct* is *None*.</span>

<span class="sd">        shadow : bool, optional, default: False</span>
<span class="sd">            Draw a shadow beneath the pie.</span>

<span class="sd">        labeldistance : float or None, optional, default: 1.1</span>
<span class="sd">            The radial distance at which the pie labels are drawn.</span>
<span class="sd">            If set to ``None``, label are not drawn, but are stored for use in</span>
<span class="sd">            ``legend()``</span>

<span class="sd">        startangle : float, optional, default: None</span>
<span class="sd">            If not *None*, rotates the start of the pie chart by *angle*</span>
<span class="sd">            degrees counterclockwise from the x-axis.</span>

<span class="sd">        radius : float, optional, default: None</span>
<span class="sd">            The radius of the pie, if *radius* is *None* it will be set to 1.</span>

<span class="sd">        counterclock : bool, optional, default: True</span>
<span class="sd">            Specify fractions direction, clockwise or counterclockwise.</span>

<span class="sd">        wedgeprops : dict, optional, default: None</span>
<span class="sd">            Dict of arguments passed to the wedge objects making the pie.</span>
<span class="sd">            For example, you can pass in ``wedgeprops = {&#39;linewidth&#39;: 3}``</span>
<span class="sd">            to set the width of the wedge border lines equal to 3.</span>
<span class="sd">            For more details, look at the doc/arguments of the wedge object.</span>
<span class="sd">            By default ``clip_on=False``.</span>

<span class="sd">        textprops : dict, optional, default: None</span>
<span class="sd">            Dict of arguments to pass to the text objects.</span>

<span class="sd">        center :  list of float, optional, default: (0, 0)</span>
<span class="sd">            Center position of the chart. Takes value (0, 0) or is a sequence</span>
<span class="sd">            of 2 scalars.</span>

<span class="sd">        frame : bool, optional, default: False</span>
<span class="sd">            Plot axes frame with the chart if true.</span>

<span class="sd">        rotatelabels : bool, optional, default: False</span>
<span class="sd">            Rotate each label to the angle of the corresponding slice if true.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        patches : list</span>
<span class="sd">            A sequence of :class:`matplotlib.patches.Wedge` instances</span>

<span class="sd">        texts : list</span>
<span class="sd">            A list of the label :class:`matplotlib.text.Text` instances.</span>

<span class="sd">        autotexts : list</span>
<span class="sd">            A list of :class:`~matplotlib.text.Text` instances for the numeric</span>
<span class="sd">            labels. This will only be returned if the parameter *autopct* is</span>
<span class="sd">            not *None*.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The pie chart will probably look best if the figure and axes are</span>
<span class="sd">        square, or the Axes aspect is equal.</span>
<span class="sd">        This method sets the aspect ratio of the axis to &quot;equal&quot;.</span>
<span class="sd">        The axes aspect ratio can be controlled with `Axes.set_aspect`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="c1"># The use of float32 is &quot;historical&quot;, but can&#39;t be changed without</span>
        <span class="c1"># regenerating the test baselines.</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">cbook</span><span class="o">.</span><span class="n">warn_deprecated</span><span class="p">(</span>
                <span class="s2">&quot;3.1&quot;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Non-1D inputs to pie() are currently &quot;</span>
                <span class="s2">&quot;squeeze()d, but this behavior is deprecated since </span><span class="si">%(since)s</span><span class="s2"> &quot;</span>
                <span class="s2">&quot;and will be removed </span><span class="si">%(removal)s</span><span class="s2">; pass a 1D array instead.&quot;</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">squeeze</span><span class="p">())</span>

        <span class="n">sx</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">sx</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">sx</span>

        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">explode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">explode</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;label&#39; must be of length &#39;x&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">explode</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;explode&#39; must be of length &#39;x&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">colors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">get_next_color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_patches_for_fill</span><span class="o">.</span><span class="n">get_next_color</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">color_cycle</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">get_next_color</span><span class="p">():</span>
                <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">color_cycle</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Starting theta1 is the start fraction of the circle</span>
        <span class="k">if</span> <span class="n">startangle</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">theta1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">theta1</span> <span class="o">=</span> <span class="n">startangle</span> <span class="o">/</span> <span class="mf">360.0</span>

        <span class="c1"># set default values in wedge_prop</span>
        <span class="k">if</span> <span class="n">wedgeprops</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wedgeprops</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">wedgeprops</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;clip_on&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">textprops</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">textprops</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">textprops</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;clip_on&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">texts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">autotexts</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">frac</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">expl</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">explode</span><span class="p">):</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">center</span>
            <span class="n">theta2</span> <span class="o">=</span> <span class="p">(</span><span class="n">theta1</span> <span class="o">+</span> <span class="n">frac</span><span class="p">)</span> <span class="k">if</span> <span class="n">counterclock</span> <span class="k">else</span> <span class="p">(</span><span class="n">theta1</span> <span class="o">-</span> <span class="n">frac</span><span class="p">)</span>
            <span class="n">thetam</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">theta1</span> <span class="o">+</span> <span class="n">theta2</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">+=</span> <span class="n">expl</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetam</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">+=</span> <span class="n">expl</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetam</span><span class="p">)</span>

            <span class="n">w</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Wedge</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">radius</span><span class="p">,</span> <span class="mf">360.</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="n">theta1</span><span class="p">,</span> <span class="n">theta2</span><span class="p">),</span>
                               <span class="mf">360.</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">theta1</span><span class="p">,</span> <span class="n">theta2</span><span class="p">),</span>
                               <span class="n">facecolor</span><span class="o">=</span><span class="n">get_next_color</span><span class="p">(),</span>
                               <span class="o">**</span><span class="n">wedgeprops</span><span class="p">)</span>
            <span class="n">slices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="n">w</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">shadow</span><span class="p">:</span>
                <span class="c1"># make sure to add a shadow after the call to</span>
                <span class="c1"># add_patch so the figure and transform props will be</span>
                <span class="c1"># set</span>
                <span class="n">shad</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Shadow</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.02</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.02</span><span class="p">)</span>
                <span class="n">shad</span><span class="o">.</span><span class="n">set_zorder</span><span class="p">(</span><span class="mf">0.9</span> <span class="o">*</span> <span class="n">w</span><span class="o">.</span><span class="n">get_zorder</span><span class="p">())</span>
                <span class="n">shad</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s1">&#39;_nolegend_&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">shad</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">labeldistance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">xt</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">labeldistance</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetam</span><span class="p">)</span>
                <span class="n">yt</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">labeldistance</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetam</span><span class="p">)</span>
                <span class="n">label_alignment_h</span> <span class="o">=</span> <span class="n">xt</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="s1">&#39;left&#39;</span> <span class="ow">or</span> <span class="s1">&#39;right&#39;</span>
                <span class="n">label_alignment_v</span> <span class="o">=</span> <span class="s1">&#39;center&#39;</span>
                <span class="n">label_rotation</span> <span class="o">=</span> <span class="s1">&#39;horizontal&#39;</span>
                <span class="k">if</span> <span class="n">rotatelabels</span><span class="p">:</span>
                    <span class="n">label_alignment_v</span> <span class="o">=</span> <span class="n">yt</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="s1">&#39;bottom&#39;</span> <span class="ow">or</span> <span class="s1">&#39;top&#39;</span>
                    <span class="n">label_rotation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">thetam</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">0</span> <span class="k">if</span> <span class="n">xt</span> <span class="o">&gt;</span> <span class="mi">0</span>
                                                             <span class="k">else</span> <span class="mi">180</span><span class="p">)</span>
                <span class="n">props</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">horizontalalignment</span><span class="o">=</span><span class="n">label_alignment_h</span><span class="p">,</span>
                            <span class="n">verticalalignment</span><span class="o">=</span><span class="n">label_alignment_v</span><span class="p">,</span>
                            <span class="n">rotation</span><span class="o">=</span><span class="n">label_rotation</span><span class="p">,</span>
                            <span class="n">size</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;xtick.labelsize&#39;</span><span class="p">])</span>
                <span class="n">props</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">textprops</span><span class="p">)</span>

                <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">xt</span><span class="p">,</span> <span class="n">yt</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="o">**</span><span class="n">props</span><span class="p">)</span>

                <span class="n">texts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">autopct</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">xt</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">pctdistance</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetam</span><span class="p">)</span>
                <span class="n">yt</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">pctdistance</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetam</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">autopct</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">autopct</span> <span class="o">%</span> <span class="p">(</span><span class="mf">100.</span> <span class="o">*</span> <span class="n">frac</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">autopct</span><span class="p">):</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">autopct</span><span class="p">(</span><span class="mf">100.</span> <span class="o">*</span> <span class="n">frac</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s1">&#39;autopct must be callable or a format string&#39;</span><span class="p">)</span>

                <span class="n">props</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">horizontalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
                             <span class="n">verticalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>
                <span class="n">props</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">textprops</span><span class="p">)</span>
                <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">xt</span><span class="p">,</span> <span class="n">yt</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="o">**</span><span class="n">props</span><span class="p">)</span>

                <span class="n">autotexts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

            <span class="n">theta1</span> <span class="o">=</span> <span class="n">theta2</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">frame</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_frame_on</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">((</span><span class="o">-</span><span class="mf">1.25</span> <span class="o">+</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                           <span class="mf">1.25</span> <span class="o">+</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">((</span><span class="o">-</span><span class="mf">1.25</span> <span class="o">+</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                           <span class="mf">1.25</span> <span class="o">+</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>

        <span class="k">if</span> <span class="n">autopct</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">slices</span><span class="p">,</span> <span class="n">texts</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">slices</span><span class="p">,</span> <span class="n">texts</span><span class="p">,</span> <span class="n">autotexts</span>

    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;xerr&quot;</span><span class="p">,</span> <span class="s2">&quot;yerr&quot;</span><span class="p">],</span>
                      <span class="n">label_namer</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">errorbar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">yerr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xerr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">ecolor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">elinewidth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">capsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">barsabove</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lolims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">uplims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">xlolims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">xuplims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">errorevery</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">capthick</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot y versus x as lines and/or markers with attached errorbars.</span>

<span class="sd">        *x*, *y* define the data locations, *xerr*, *yerr* define the errorbar</span>
<span class="sd">        sizes. By default, this draws the data markers/lines as well the</span>
<span class="sd">        errorbars. Use fmt=&#39;none&#39; to draw errorbars without any data markers.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : scalar or array-like</span>
<span class="sd">            The data positions.</span>

<span class="sd">        xerr, yerr : scalar or array-like, shape(N,) or shape(2,N), optional</span>
<span class="sd">            The errorbar sizes:</span>

<span class="sd">            - scalar: Symmetric +/- values for all data points.</span>
<span class="sd">            - shape(N,): Symmetric +/-values for each data point.</span>
<span class="sd">            - shape(2,N): Separate - and + values for each bar. First row</span>
<span class="sd">                contains the lower errors, the second row contains the</span>
<span class="sd">                upper errors.</span>
<span class="sd">            - *None*: No errorbar.</span>

<span class="sd">            Note that all error arrays should have *positive* values.</span>

<span class="sd">            See :doc:`/gallery/statistics/errorbar_features`</span>
<span class="sd">            for an example on the usage of ``xerr`` and ``yerr``.</span>

<span class="sd">        fmt : plot format string, optional, default: &#39;&#39;</span>
<span class="sd">            The format for the data points / data lines. See `.plot` for</span>
<span class="sd">            details.</span>

<span class="sd">            Use &#39;none&#39; (case insensitive) to plot errorbars without any data</span>
<span class="sd">            markers.</span>

<span class="sd">        ecolor : mpl color, optional, default: None</span>
<span class="sd">            A matplotlib color arg which gives the color the errorbar lines.</span>
<span class="sd">            If None, use the color of the line connecting the markers.</span>

<span class="sd">        elinewidth : scalar, optional, default: None</span>
<span class="sd">            The linewidth of the errorbar lines. If None, the linewidth of</span>
<span class="sd">            the current style is used.</span>

<span class="sd">        capsize : scalar, optional, default: None</span>
<span class="sd">            The length of the error bar caps in points. If None, it will take</span>
<span class="sd">            the value from :rc:`errorbar.capsize`.</span>

<span class="sd">        capthick : scalar, optional, default: None</span>
<span class="sd">            An alias to the keyword argument *markeredgewidth* (a.k.a. *mew*).</span>
<span class="sd">            This setting is a more sensible name for the property that</span>
<span class="sd">            controls the thickness of the error bar cap in points. For</span>
<span class="sd">            backwards compatibility, if *mew* or *markeredgewidth* are given,</span>
<span class="sd">            then they will over-ride *capthick*. This may change in future</span>
<span class="sd">            releases.</span>

<span class="sd">        barsabove : bool, optional, default: False</span>
<span class="sd">            If True, will plot the errorbars above the plot</span>
<span class="sd">            symbols. Default is below.</span>

<span class="sd">        lolims, uplims, xlolims, xuplims : bool, optional, default: False</span>
<span class="sd">            These arguments can be used to indicate that a value gives only</span>
<span class="sd">            upper/lower limits. In that case a caret symbol is used to</span>
<span class="sd">            indicate this. *lims*-arguments may be of the same type as *xerr*</span>
<span class="sd">            and *yerr*.  To use limits with inverted axes, :meth:`set_xlim`</span>
<span class="sd">            or :meth:`set_ylim` must be called before :meth:`errorbar`.</span>

<span class="sd">        errorevery : positive integer, optional, default: 1</span>
<span class="sd">            Subsamples the errorbars. e.g., if errorevery=5, errorbars for</span>
<span class="sd">            every 5-th datapoint will be plotted. The data plot itself still</span>
<span class="sd">            shows all data points.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        container : :class:`~.container.ErrorbarContainer`</span>
<span class="sd">            The container contains:</span>

<span class="sd">            - plotline: :class:`~matplotlib.lines.Line2D` instance of</span>
<span class="sd">              x, y plot markers and/or line.</span>
<span class="sd">            - caplines: A tuple of :class:`~matplotlib.lines.Line2D` instances</span>
<span class="sd">              of the error bar caps.</span>
<span class="sd">            - barlinecols: A tuple of</span>
<span class="sd">              :class:`~matplotlib.collections.LineCollection` with the</span>
<span class="sd">              horizontal and vertical error ranges.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            All other keyword arguments are passed on to the plot</span>
<span class="sd">            command for the markers. For example, this code makes big red</span>
<span class="sd">            squares with thick green edges::</span>

<span class="sd">                x,y,yerr = rand(3,10)</span>
<span class="sd">                errorbar(x, y, yerr, marker=&#39;s&#39;, mfc=&#39;red&#39;,</span>
<span class="sd">                         mec=&#39;green&#39;, ms=20, mew=4)</span>

<span class="sd">            where *mfc*, *mec*, *ms* and *mew* are aliases for the longer</span>
<span class="sd">            property names, *markerfacecolor*, *markeredgecolor*, *markersize*</span>
<span class="sd">            and *markeredgewidth*.</span>

<span class="sd">            Valid kwargs for the marker properties are `.Lines2D` properties:</span>

<span class="sd">        %(_Line2D_docstr)s</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">normalize_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="o">.</span><span class="n">_alias_map</span><span class="p">)</span>
        <span class="c1"># anything that comes in as &#39;None&#39;, drop so the default thing</span>
        <span class="c1"># happens down stream</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;zorder&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">errorevery</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;errorevery has to be a strictly positive integer&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">plot_line</span> <span class="o">=</span> <span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s1">&#39;none&#39;</span><span class="p">)</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">fmt_style_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fmt_style_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span>
                                <span class="nb">zip</span><span class="p">((</span><span class="s1">&#39;linestyle&#39;</span><span class="p">,</span> <span class="s1">&#39;marker&#39;</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">),</span>
                                    <span class="n">_process_plot_format</span><span class="p">(</span><span class="n">fmt</span><span class="p">))</span>
                                <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
            <span class="c1"># Remove alpha=0 color that _process_plot_format returns</span>
            <span class="n">fmt_style_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;color&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;color&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">or</span> <span class="s1">&#39;color&#39;</span> <span class="ow">in</span> <span class="n">fmt_style_kwargs</span> <span class="ow">or</span>
                <span class="n">ecolor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">base_style</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="s1">&#39;color&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">base_style</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;color&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">base_style</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_lines</span><span class="o">.</span><span class="n">prop_cycler</span><span class="p">)</span>

        <span class="n">base_style</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;_nolegend_&#39;</span>
        <span class="n">base_style</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fmt_style_kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;color&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">base_style</span><span class="p">:</span>
            <span class="n">base_style</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;C0&#39;</span>
        <span class="k">if</span> <span class="n">ecolor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ecolor</span> <span class="o">=</span> <span class="n">base_style</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span>
        <span class="c1"># make sure all the args are iterable; use lists not arrays to</span>
        <span class="c1"># preserve units</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">xerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">xerr</span><span class="p">):</span>
                <span class="n">xerr</span> <span class="o">=</span> <span class="p">[</span><span class="n">xerr</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">yerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">yerr</span><span class="p">):</span>
                <span class="n">yerr</span> <span class="o">=</span> <span class="p">[</span><span class="n">yerr</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="c1"># make the style dict for the &#39;normal&#39; plot line</span>
        <span class="n">plot_line_style</span> <span class="o">=</span> <span class="p">{</span>
            <span class="o">**</span><span class="n">base_style</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="s1">&#39;zorder&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;zorder&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="o">.</span><span class="mi">1</span> <span class="k">if</span> <span class="n">barsabove</span> <span class="k">else</span>
                       <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;zorder&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="o">.</span><span class="mi">1</span><span class="p">),</span>
        <span class="p">}</span>

        <span class="c1"># make the style dict for the line collections (the bars)</span>
        <span class="n">eb_lines_style</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">base_style</span><span class="p">)</span>
        <span class="n">eb_lines_style</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;marker&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">eb_lines_style</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;linestyle&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">eb_lines_style</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ecolor</span>

        <span class="k">if</span> <span class="n">elinewidth</span><span class="p">:</span>
            <span class="n">eb_lines_style</span><span class="p">[</span><span class="s1">&#39;linewidth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">elinewidth</span>
        <span class="k">elif</span> <span class="s1">&#39;linewidth&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">eb_lines_style</span><span class="p">[</span><span class="s1">&#39;linewidth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;linewidth&#39;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;transform&#39;</span><span class="p">,</span> <span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="s1">&#39;zorder&#39;</span><span class="p">,</span> <span class="s1">&#39;rasterized&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">eb_lines_style</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="c1"># set up cap style dictionary</span>
        <span class="n">eb_cap_style</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">base_style</span><span class="p">)</span>
        <span class="c1"># eject any marker information from format string</span>
        <span class="n">eb_cap_style</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;marker&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">eb_lines_style</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;markerfacecolor&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">eb_lines_style</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;markeredgewidth&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">eb_lines_style</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;markeredgecolor&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">eb_cap_style</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;ls&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">eb_cap_style</span><span class="p">[</span><span class="s1">&#39;linestyle&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="k">if</span> <span class="n">capsize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">capsize</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;errorbar.capsize&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">capsize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">eb_cap_style</span><span class="p">[</span><span class="s1">&#39;markersize&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">capsize</span>
        <span class="k">if</span> <span class="n">capthick</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">eb_cap_style</span><span class="p">[</span><span class="s1">&#39;markeredgewidth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">capthick</span>

        <span class="c1"># For backwards-compat, allow explicit setting of</span>
        <span class="c1"># &#39;markeredgewidth&#39; to over-ride capthick.</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;markeredgewidth&#39;</span><span class="p">,</span> <span class="s1">&#39;transform&#39;</span><span class="p">,</span> <span class="s1">&#39;alpha&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;zorder&#39;</span><span class="p">,</span> <span class="s1">&#39;rasterized&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">eb_cap_style</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="n">eb_cap_style</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ecolor</span>

        <span class="n">data_line</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">plot_line</span><span class="p">:</span>
            <span class="n">data_line</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_line_style</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">data_line</span><span class="p">)</span>

        <span class="n">barcols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">caplines</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># arrays fine here, they are booleans and hence not units</span>
        <span class="n">lolims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">lolims</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">uplims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">uplims</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">xlolims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">xlolims</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">xuplims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">xuplims</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>

        <span class="n">everymask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">%</span> <span class="n">errorevery</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">xywhere</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            return xs[mask], ys[mask] where mask is True but xs and</span>
<span class="sd">            ys are not arrays</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="n">thisx</span> <span class="k">for</span> <span class="n">thisx</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span> <span class="k">if</span> <span class="n">b</span><span class="p">]</span>
            <span class="n">ys</span> <span class="o">=</span> <span class="p">[</span><span class="n">thisy</span> <span class="k">for</span> <span class="n">thisy</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span> <span class="k">if</span> <span class="n">b</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span>

        <span class="k">def</span> <span class="nf">extract_err</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Private function to parse *err* and subtract/add it to *data*.</span>

<span class="sd">            Both *err* and *data* are already iterables at this point.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">try</span><span class="p">:</span>  <span class="c1"># Asymmetric error: pair of 1D iterables.</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">err</span>
                <span class="nb">iter</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="nb">iter</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="n">err</span>  <span class="c1"># Symmetric error: 1D iterable.</span>
            <span class="c1"># This could just be `np.ndim(a) &gt; 1 and np.ndim(b) &gt; 1`, except</span>
            <span class="c1"># for the (undocumented, but tested) support for (n, 1) arrays.</span>
            <span class="n">a_sh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">b_sh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a_sh</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a_sh</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">a_sh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">b_sh</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b_sh</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">b_sh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;err must be a scalar or a 1D or (2, n) array-like&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_sh</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">b_sh</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">cbook</span><span class="o">.</span><span class="n">warn_deprecated</span><span class="p">(</span>
                    <span class="s2">&quot;3.1&quot;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Support for passing a (n, 1)-shaped error &quot;</span>
                    <span class="s2">&quot;array to errorbar() is deprecated since Matplotlib &quot;</span>
                    <span class="s2">&quot;</span><span class="si">%(since)s</span><span class="s2"> and will be removed </span><span class="si">%(removal)s</span><span class="s2">; pass a 1D &quot;</span>
                    <span class="s2">&quot;array instead.&quot;</span><span class="p">)</span>
            <span class="c1"># Using list comprehensions rather than arrays to preserve units.</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;The lengths of the data (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">) and the &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;error </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2"> do not match&quot;</span><span class="p">)</span>
            <span class="n">low</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="o">-</span> <span class="n">e</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">a</span><span class="p">)]</span>
            <span class="n">high</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="o">+</span> <span class="n">e</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">b</span><span class="p">)]</span>
            <span class="k">return</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span>

        <span class="k">if</span> <span class="n">xerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">extract_err</span><span class="p">(</span><span class="n">xerr</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="c1"># select points without upper/lower limits in x and</span>
            <span class="c1"># draw normal errorbars for these points</span>
            <span class="n">noxlims</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">xlolims</span> <span class="o">|</span> <span class="n">xuplims</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">noxlims</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">noxlims</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">yo</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">noxlims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">lo</span><span class="p">,</span> <span class="n">ro</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">noxlims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">barcols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="n">yo</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">ro</span><span class="p">,</span> <span class="o">**</span><span class="n">eb_lines_style</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">capsize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">caplines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;|&#39;</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="n">eb_cap_style</span><span class="p">))</span>
                    <span class="n">caplines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">ro</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;|&#39;</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="n">eb_cap_style</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">xlolims</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">yo</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">xlolims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">lo</span><span class="p">,</span> <span class="n">ro</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">xlolims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">barcols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="n">yo</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">ro</span><span class="p">,</span> <span class="o">**</span><span class="n">eb_lines_style</span><span class="p">))</span>
                <span class="n">rightup</span><span class="p">,</span> <span class="n">yup</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xlolims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xaxis_inverted</span><span class="p">():</span>
                    <span class="n">marker</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">CARETLEFTBASE</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">marker</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">CARETRIGHTBASE</span>
                <span class="n">caplines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">rightup</span><span class="p">,</span> <span class="n">yup</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span>
                                  <span class="o">**</span><span class="n">eb_cap_style</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">capsize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">xlo</span><span class="p">,</span> <span class="n">ylo</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xlolims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                    <span class="n">caplines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">xlo</span><span class="p">,</span> <span class="n">ylo</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;|&#39;</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="n">eb_cap_style</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">xuplims</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">yo</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">xuplims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">lo</span><span class="p">,</span> <span class="n">ro</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">xuplims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">barcols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="n">yo</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">ro</span><span class="p">,</span> <span class="o">**</span><span class="n">eb_lines_style</span><span class="p">))</span>
                <span class="n">leftlo</span><span class="p">,</span> <span class="n">ylo</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xuplims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xaxis_inverted</span><span class="p">():</span>
                    <span class="n">marker</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">CARETRIGHTBASE</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">marker</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">CARETLEFTBASE</span>
                <span class="n">caplines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">leftlo</span><span class="p">,</span> <span class="n">ylo</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span>
                                  <span class="o">**</span><span class="n">eb_cap_style</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">capsize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">xup</span><span class="p">,</span> <span class="n">yup</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xuplims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                    <span class="n">caplines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">xup</span><span class="p">,</span> <span class="n">yup</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;|&#39;</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="n">eb_cap_style</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">yerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">extract_err</span><span class="p">(</span><span class="n">yerr</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="c1"># select points without upper/lower limits in y and</span>
            <span class="c1"># draw normal errorbars for these points</span>
            <span class="n">noylims</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">lolims</span> <span class="o">|</span> <span class="n">uplims</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">noylims</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">noylims</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">xo</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">noylims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">lo</span><span class="p">,</span> <span class="n">uo</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">noylims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">barcols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">xo</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">uo</span><span class="p">,</span> <span class="o">**</span><span class="n">eb_lines_style</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">capsize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">caplines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">xo</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="n">eb_cap_style</span><span class="p">))</span>
                    <span class="n">caplines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">xo</span><span class="p">,</span> <span class="n">uo</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="n">eb_cap_style</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">lolims</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">xo</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">lolims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">lo</span><span class="p">,</span> <span class="n">uo</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">lolims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">barcols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">xo</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">uo</span><span class="p">,</span> <span class="o">**</span><span class="n">eb_lines_style</span><span class="p">))</span>
                <span class="n">xup</span><span class="p">,</span> <span class="n">upperup</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">lolims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">yaxis_inverted</span><span class="p">():</span>
                    <span class="n">marker</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">CARETDOWNBASE</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">marker</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">CARETUPBASE</span>
                <span class="n">caplines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">xup</span><span class="p">,</span> <span class="n">upperup</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span>
                                  <span class="o">**</span><span class="n">eb_cap_style</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">capsize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">xlo</span><span class="p">,</span> <span class="n">ylo</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">lolims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                    <span class="n">caplines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">xlo</span><span class="p">,</span> <span class="n">ylo</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="n">eb_cap_style</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">uplims</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">xo</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">uplims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">lo</span><span class="p">,</span> <span class="n">uo</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">uplims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">barcols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">xo</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">uo</span><span class="p">,</span> <span class="o">**</span><span class="n">eb_lines_style</span><span class="p">))</span>
                <span class="n">xlo</span><span class="p">,</span> <span class="n">lowerlo</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">uplims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">yaxis_inverted</span><span class="p">():</span>
                    <span class="n">marker</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">CARETUPBASE</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">marker</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">CARETDOWNBASE</span>
                <span class="n">caplines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">xlo</span><span class="p">,</span> <span class="n">lowerlo</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span>
                                  <span class="o">**</span><span class="n">eb_cap_style</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">capsize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">xup</span><span class="p">,</span> <span class="n">yup</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">uplims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                    <span class="n">caplines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">xup</span><span class="p">,</span> <span class="n">yup</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="n">eb_cap_style</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">caplines</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>
        <span class="n">errorbar_container</span> <span class="o">=</span> <span class="n">ErrorbarContainer</span><span class="p">((</span><span class="n">data_line</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">caplines</span><span class="p">),</span>
                                                <span class="nb">tuple</span><span class="p">(</span><span class="n">barcols</span><span class="p">)),</span>
                                               <span class="n">has_xerr</span><span class="o">=</span><span class="p">(</span><span class="n">xerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">),</span>
                                               <span class="n">has_yerr</span><span class="o">=</span><span class="p">(</span><span class="n">yerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">),</span>
                                               <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">containers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">errorbar_container</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">errorbar_container</span>  <span class="c1"># (l0, caplines, barcols)</span>

    <span class="nd">@cbook</span><span class="o">.</span><span class="n">_rename_parameter</span><span class="p">(</span><span class="s2">&quot;3.1&quot;</span><span class="p">,</span> <span class="s2">&quot;manage_xticks&quot;</span><span class="p">,</span> <span class="s2">&quot;manage_ticks&quot;</span><span class="p">)</span>
    <span class="nd">@_preprocess_data</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">boxplot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">notch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sym</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vert</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">whis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">positions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">patch_artist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">bootstrap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">usermedians</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">conf_intervals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">meanline</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">showmeans</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">showcaps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">showbox</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">showfliers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">boxprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flierprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">medianprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">meanprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">capprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">whiskerprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">manage_ticks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">autorange</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a box and whisker plot.</span>

<span class="sd">        Make a box and whisker plot for each column of ``x`` or each</span>
<span class="sd">        vector in sequence ``x``.  The box extends from the lower to</span>
<span class="sd">        upper quartile values of the data, with a line at the median.</span>
<span class="sd">        The whiskers extend from the box to show the range of the</span>
<span class="sd">        data.  Flier points are those past the end of the whiskers.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : Array or a sequence of vectors.</span>
<span class="sd">            The input data.</span>

<span class="sd">        notch : bool, optional (False)</span>
<span class="sd">            If `True`, will produce a notched box plot. Otherwise, a</span>
<span class="sd">            rectangular boxplot is produced. The notches represent the</span>
<span class="sd">            confidence interval (CI) around the median. See the entry</span>
<span class="sd">            for the ``bootstrap`` parameter for information regarding</span>
<span class="sd">            how the locations of the notches are computed.</span>

<span class="sd">            .. note::</span>

<span class="sd">                In cases where the values of the CI are less than the</span>
<span class="sd">                lower quartile or greater than the upper quartile, the</span>
<span class="sd">                notches will extend beyond the box, giving it a</span>
<span class="sd">                distinctive &quot;flipped&quot; appearance. This is expected</span>
<span class="sd">                behavior and consistent with other statistical</span>
<span class="sd">                visualization packages.</span>

<span class="sd">        sym : str, optional</span>
<span class="sd">            The default symbol for flier points. Enter an empty string</span>
<span class="sd">            (&#39;&#39;) if you don&#39;t want to show fliers. If `None`, then the</span>
<span class="sd">            fliers default to &#39;b+&#39;  If you want more control use the</span>
<span class="sd">            flierprops kwarg.</span>

<span class="sd">        vert : bool, optional (True)</span>
<span class="sd">            If `True` (default), makes the boxes vertical. If `False`,</span>
<span class="sd">            everything is drawn horizontally.</span>

<span class="sd">        whis : float, sequence, or string (default = 1.5)</span>
<span class="sd">            As a float, determines the reach of the whiskers to the beyond the</span>
<span class="sd">            first and third quartiles. In other words, where IQR is the</span>
<span class="sd">            interquartile range (`Q3-Q1`), the upper whisker will extend to</span>
<span class="sd">            last datum less than `Q3 + whis*IQR`). Similarly, the lower whisker</span>
<span class="sd">            will extend to the first datum greater than `Q1 - whis*IQR`.</span>
<span class="sd">            Beyond the whiskers, data</span>
<span class="sd">            are considered outliers and are plotted as individual</span>
<span class="sd">            points. Set this to an unreasonably high value to force the</span>
<span class="sd">            whiskers to show the min and max values. Alternatively, set</span>
<span class="sd">            this to an ascending sequence of percentile (e.g., [5, 95])</span>
<span class="sd">            to set the whiskers at specific percentiles of the data.</span>
<span class="sd">            Finally, ``whis`` can be the string ``&#39;range&#39;`` to force the</span>
<span class="sd">            whiskers to the min and max of the data.</span>

<span class="sd">        bootstrap : int, optional</span>
<span class="sd">            Specifies whether to bootstrap the confidence intervals</span>
<span class="sd">            around the median for notched boxplots. If ``bootstrap`` is</span>
<span class="sd">            None, no bootstrapping is performed, and notches are</span>
<span class="sd">            calculated using a Gaussian-based asymptotic approximation</span>
<span class="sd">            (see McGill, R., Tukey, J.W., and Larsen, W.A., 1978, and</span>
<span class="sd">            Kendall and Stuart, 1967). Otherwise, bootstrap specifies</span>
<span class="sd">            the number of times to bootstrap the median to determine its</span>
<span class="sd">            95% confidence intervals. Values between 1000 and 10000 are</span>
<span class="sd">            recommended.</span>

<span class="sd">        usermedians : array-like, optional</span>
<span class="sd">            An array or sequence whose first dimension (or length) is</span>
<span class="sd">            compatible with ``x``. This overrides the medians computed</span>
<span class="sd">            by matplotlib for each element of ``usermedians`` that is not</span>
<span class="sd">            `None`. When an element of ``usermedians`` is None, the median</span>
<span class="sd">            will be computed by matplotlib as normal.</span>

<span class="sd">        conf_intervals : array-like, optional</span>
<span class="sd">            Array or sequence whose first dimension (or length) is</span>
<span class="sd">            compatible with ``x`` and whose second dimension is 2. When</span>
<span class="sd">            the an element of ``conf_intervals`` is not None, the</span>
<span class="sd">            notch locations computed by matplotlib are overridden</span>
<span class="sd">            (provided ``notch`` is `True`). When an element of</span>
<span class="sd">            ``conf_intervals`` is `None`, the notches are computed by the</span>
<span class="sd">            method specified by the other kwargs (e.g., ``bootstrap``).</span>

<span class="sd">        positions : array-like, optional</span>
<span class="sd">            Sets the positions of the boxes. The ticks and limits are</span>
<span class="sd">            automatically set to match the positions. Defaults to</span>
<span class="sd">            `range(1, N+1)` where N is the number of boxes to be drawn.</span>

<span class="sd">        widths : scalar or array-like</span>
<span class="sd">            Sets the width of each box either with a scalar or a</span>
<span class="sd">            sequence. The default is 0.5, or ``0.15*(distance between</span>
<span class="sd">            extreme positions)``, if that is smaller.</span>

<span class="sd">        patch_artist : bool, optional (False)</span>
<span class="sd">            If `False` produces boxes with the Line2D artist. Otherwise,</span>
<span class="sd">            boxes and drawn with Patch artists.</span>

<span class="sd">        labels : sequence, optional</span>
<span class="sd">            Labels for each dataset. Length must be compatible with</span>
<span class="sd">            dimensions of ``x``.</span>

<span class="sd">        manage_ticks : bool, optional (True)</span>
<span class="sd">            If True, the tick locations and labels will be adjusted to match</span>
<span class="sd">            the boxplot positions.</span>

<span class="sd">        autorange : bool, optional (False)</span>
<span class="sd">            When `True` and the data are distributed such that the 25th and</span>
<span class="sd">            75th percentiles are equal, ``whis`` is set to ``&#39;range&#39;`` such</span>
<span class="sd">            that the whisker ends are at the minimum and maximum of the data.</span>

<span class="sd">        meanline : bool, optional (False)</span>
<span class="sd">            If `True` (and ``showmeans`` is `True`), will try to render</span>
<span class="sd">            the mean as a line spanning the full width of the box</span>
<span class="sd">            according to ``meanprops`` (see below). Not recommended if</span>
<span class="sd">            ``shownotches`` is also True. Otherwise, means will be shown</span>
<span class="sd">            as points.</span>

<span class="sd">        zorder : scalar, optional (None)</span>
<span class="sd">            Sets the zorder of the boxplot.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        showcaps : bool, optional (True)</span>
<span class="sd">            Show the caps on the ends of whiskers.</span>
<span class="sd">        showbox : bool, optional (True)</span>
<span class="sd">            Show the central box.</span>
<span class="sd">        showfliers : bool, optional (True)</span>
<span class="sd">            Show the outliers beyond the caps.</span>
<span class="sd">        showmeans : bool, optional (False)</span>
<span class="sd">            Show the arithmetic means.</span>
<span class="sd">        capprops : dict, optional (None)</span>
<span class="sd">            Specifies the style of the caps.</span>
<span class="sd">        boxprops : dict, optional (None)</span>
<span class="sd">            Specifies the style of the box.</span>
<span class="sd">        whiskerprops : dict, optional (None)</span>
<span class="sd">            Specifies the style of the whiskers.</span>
<span class="sd">        flierprops : dict, optional (None)</span>
<span class="sd">            Specifies the style of the fliers.</span>
<span class="sd">        medianprops : dict, optional (None)</span>
<span class="sd">            Specifies the style of the median.</span>
<span class="sd">        meanprops : dict, optional (None)</span>
<span class="sd">            Specifies the style of the mean.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : dict</span>
<span class="sd">          A dictionary mapping each component of the boxplot to a list</span>
<span class="sd">          of the :class:`matplotlib.lines.Line2D` instances</span>
<span class="sd">          created. That dictionary has the following keys (assuming</span>
<span class="sd">          vertical boxplots):</span>

<span class="sd">          - ``boxes``: the main body of the boxplot showing the</span>
<span class="sd">            quartiles and the median&#39;s confidence intervals if</span>
<span class="sd">            enabled.</span>

<span class="sd">          - ``medians``: horizontal lines at the median of each box.</span>

<span class="sd">          - ``whiskers``: the vertical lines extending to the most</span>
<span class="sd">            extreme, non-outlier data points.</span>

<span class="sd">          - ``caps``: the horizontal lines at the ends of the</span>
<span class="sd">            whiskers.</span>

<span class="sd">          - ``fliers``: points representing data that extend beyond</span>
<span class="sd">            the whiskers (fliers).</span>

<span class="sd">          - ``means``: points or lines representing the means.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Missing arguments default to rcParams.</span>
        <span class="k">if</span> <span class="n">whis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">whis</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.whiskers&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">bootstrap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bootstrap</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.bootstrap&#39;</span><span class="p">]</span>

        <span class="n">bxpstats</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">boxplot_stats</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">whis</span><span class="o">=</span><span class="n">whis</span><span class="p">,</span> <span class="n">bootstrap</span><span class="o">=</span><span class="n">bootstrap</span><span class="p">,</span>
                                       <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">autorange</span><span class="o">=</span><span class="n">autorange</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">notch</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">notch</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.notch&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">vert</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vert</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.vertical&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">patch_artist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">patch_artist</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.patchartist&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">meanline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">meanline</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.meanline&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">showmeans</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">showmeans</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.showmeans&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">showcaps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">showcaps</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.showcaps&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">showbox</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">showbox</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.showbox&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">showfliers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">showfliers</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.showfliers&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">boxprops</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">boxprops</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">whiskerprops</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">whiskerprops</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">capprops</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">capprops</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">medianprops</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">medianprops</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">meanprops</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">meanprops</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">flierprops</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flierprops</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">patch_artist</span><span class="p">:</span>
            <span class="n">boxprops</span><span class="p">[</span><span class="s1">&#39;linestyle&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;solid&#39;</span>  <span class="c1"># Not consistent with bxp.</span>
            <span class="k">if</span> <span class="s1">&#39;color&#39;</span> <span class="ow">in</span> <span class="n">boxprops</span><span class="p">:</span>
                <span class="n">boxprops</span><span class="p">[</span><span class="s1">&#39;edgecolor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">boxprops</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;color&#39;</span><span class="p">)</span>

        <span class="c1"># if non-default sym value, put it into the flier dictionary</span>
        <span class="c1"># the logic for providing the default symbol (&#39;b+&#39;) now lives</span>
        <span class="c1"># in bxp in the initial value of final_flierprops</span>
        <span class="c1"># handle all of the `sym` related logic here so we only have to pass</span>
        <span class="c1"># on the flierprops dict.</span>
        <span class="k">if</span> <span class="n">sym</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># no-flier case, which should really be done with</span>
            <span class="c1"># &#39;showfliers=False&#39; but none-the-less deal with it to keep back</span>
            <span class="c1"># compatibility</span>
            <span class="k">if</span> <span class="n">sym</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="c1"># blow away existing dict and make one for invisible markers</span>
                <span class="n">flierprops</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
                <span class="c1"># turn the fliers off just to be safe</span>
                <span class="n">showfliers</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># now process the symbol string</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># process the symbol string</span>
                <span class="c1"># discarded linestyle</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">marker</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="n">_process_plot_format</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>
                <span class="c1"># if we have a marker, use it</span>
                <span class="k">if</span> <span class="n">marker</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">flierprops</span><span class="p">[</span><span class="s1">&#39;marker&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">marker</span>
                <span class="c1"># if we have a color, use it</span>
                <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># assume that if color is passed in the user want</span>
                    <span class="c1"># filled symbol, if the users want more control use</span>
                    <span class="c1"># flierprops</span>
                    <span class="n">flierprops</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span>
                    <span class="n">flierprops</span><span class="p">[</span><span class="s1">&#39;markerfacecolor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span>
                    <span class="n">flierprops</span><span class="p">[</span><span class="s1">&#39;markeredgecolor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span>

        <span class="c1"># replace medians if necessary:</span>
        <span class="k">if</span> <span class="n">usermedians</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">usermedians</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bxpstats</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">usermedians</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bxpstats</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;usermedians length not compatible with x&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># reassign medians as necessary</span>
                <span class="k">for</span> <span class="n">stats</span><span class="p">,</span> <span class="n">med</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bxpstats</span><span class="p">,</span> <span class="n">usermedians</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">med</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;med&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">med</span>

        <span class="k">if</span> <span class="n">conf_intervals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">conf_intervals</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bxpstats</span><span class="p">):</span>
                <span class="n">err_mess</span> <span class="o">=</span> <span class="s1">&#39;conf_intervals length not compatible with x&#39;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_mess</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">stats</span><span class="p">,</span> <span class="n">ci</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bxpstats</span><span class="p">,</span> <span class="n">conf_intervals</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">ci</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ci</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;each confidence interval must &#39;</span>
                                             <span class="s1">&#39;have two values&#39;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">ci</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;cilo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ci</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">ci</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;cihi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ci</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">artists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bxp</span><span class="p">(</span><span class="n">bxpstats</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="n">positions</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span><span class="n">widths</span><span class="p">,</span>
                           <span class="n">vert</span><span class="o">=</span><span class="n">vert</span><span class="p">,</span> <span class="n">patch_artist</span><span class="o">=</span><span class="n">patch_artist</span><span class="p">,</span>
                           <span class="n">shownotches</span><span class="o">=</span><span class="n">notch</span><span class="p">,</span> <span class="n">showmeans</span><span class="o">=</span><span class="n">showmeans</span><span class="p">,</span>
                           <span class="n">showcaps</span><span class="o">=</span><span class="n">showcaps</span><span class="p">,</span> <span class="n">showbox</span><span class="o">=</span><span class="n">showbox</span><span class="p">,</span>
                           <span class="n">boxprops</span><span class="o">=</span><span class="n">boxprops</span><span class="p">,</span> <span class="n">flierprops</span><span class="o">=</span><span class="n">flierprops</span><span class="p">,</span>
                           <span class="n">medianprops</span><span class="o">=</span><span class="n">medianprops</span><span class="p">,</span> <span class="n">meanprops</span><span class="o">=</span><span class="n">meanprops</span><span class="p">,</span>
                           <span class="n">meanline</span><span class="o">=</span><span class="n">meanline</span><span class="p">,</span> <span class="n">showfliers</span><span class="o">=</span><span class="n">showfliers</span><span class="p">,</span>
                           <span class="n">capprops</span><span class="o">=</span><span class="n">capprops</span><span class="p">,</span> <span class="n">whiskerprops</span><span class="o">=</span><span class="n">whiskerprops</span><span class="p">,</span>
                           <span class="n">manage_ticks</span><span class="o">=</span><span class="n">manage_ticks</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="n">zorder</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">artists</span>

    <span class="nd">@cbook</span><span class="o">.</span><span class="n">_rename_parameter</span><span class="p">(</span><span class="s2">&quot;3.1&quot;</span><span class="p">,</span> <span class="s2">&quot;manage_xticks&quot;</span><span class="p">,</span> <span class="s2">&quot;manage_ticks&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">bxp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bxpstats</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vert</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">patch_artist</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">shownotches</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">showmeans</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">showcaps</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">showbox</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">showfliers</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">boxprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">whiskerprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flierprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">medianprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">capprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">meanprops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">meanline</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">manage_ticks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Drawing function for box and whisker plots.</span>

<span class="sd">        Make a box and whisker plot for each column of *x* or each</span>
<span class="sd">        vector in sequence *x*.  The box extends from the lower to</span>
<span class="sd">        upper quartile values of the data, with a line at the median.</span>
<span class="sd">        The whiskers extend from the box to show the range of the</span>
<span class="sd">        data.  Flier points are those past the end of the whiskers.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        bxpstats : list of dicts</span>
<span class="sd">          A list of dictionaries containing stats for each boxplot.</span>
<span class="sd">          Required keys are:</span>

<span class="sd">          - ``med``: The median (scalar float).</span>

<span class="sd">          - ``q1``: The first quartile (25th percentile) (scalar</span>
<span class="sd">            float).</span>

<span class="sd">          - ``q3``: The third quartile (75th percentile) (scalar</span>
<span class="sd">            float).</span>

<span class="sd">          - ``whislo``: Lower bound of the lower whisker (scalar</span>
<span class="sd">            float).</span>

<span class="sd">          - ``whishi``: Upper bound of the upper whisker (scalar</span>
<span class="sd">            float).</span>

<span class="sd">          Optional keys are:</span>

<span class="sd">          - ``mean``: The mean (scalar float). Needed if</span>
<span class="sd">            ``showmeans=True``.</span>

<span class="sd">          - ``fliers``: Data beyond the whiskers (sequence of floats).</span>
<span class="sd">            Needed if ``showfliers=True``.</span>

<span class="sd">          - ``cilo`` &amp; ``cihi``: Lower and upper confidence intervals</span>
<span class="sd">            about the median. Needed if ``shownotches=True``.</span>

<span class="sd">          - ``label``: Name of the dataset (string). If available,</span>
<span class="sd">            this will be used a tick label for the boxplot</span>

<span class="sd">        positions : array-like, default = [1, 2, ..., n]</span>
<span class="sd">          Sets the positions of the boxes. The ticks and limits</span>
<span class="sd">          are automatically set to match the positions.</span>

<span class="sd">        widths : array-like, default = None</span>
<span class="sd">          Either a scalar or a vector and sets the width of each</span>
<span class="sd">          box. The default is ``0.15*(distance between extreme</span>
<span class="sd">          positions)``, clipped to no less than 0.15 and no more than</span>
<span class="sd">          0.5.</span>

<span class="sd">        vert : bool, default = True</span>
<span class="sd">          If `True` (default), makes the boxes vertical.  If `False`,</span>
<span class="sd">          makes horizontal boxes.</span>

<span class="sd">        patch_artist : bool, default = False</span>
<span class="sd">          If `False` produces boxes with the</span>
<span class="sd">          `~matplotlib.lines.Line2D` artist.  If `True` produces boxes</span>
<span class="sd">          with the `~matplotlib.patches.Patch` artist.</span>

<span class="sd">        shownotches : bool, default = False</span>
<span class="sd">          If `False` (default), produces a rectangular box plot.</span>
<span class="sd">          If `True`, will produce a notched box plot</span>

<span class="sd">        showmeans : bool, default = False</span>
<span class="sd">          If `True`, will toggle on the rendering of the means</span>

<span class="sd">        showcaps  : bool, default = True</span>
<span class="sd">          If `True`, will toggle on the rendering of the caps</span>

<span class="sd">        showbox  : bool, default = True</span>
<span class="sd">          If `True`, will toggle on the rendering of the box</span>

<span class="sd">        showfliers : bool, default = True</span>
<span class="sd">          If `True`, will toggle on the rendering of the fliers</span>

<span class="sd">        boxprops : dict or None (default)</span>
<span class="sd">          If provided, will set the plotting style of the boxes</span>

<span class="sd">        whiskerprops : dict or None (default)</span>
<span class="sd">          If provided, will set the plotting style of the whiskers</span>

<span class="sd">        capprops : dict or None (default)</span>
<span class="sd">          If provided, will set the plotting style of the caps</span>

<span class="sd">        flierprops : dict or None (default)</span>
<span class="sd">          If provided will set the plotting style of the fliers</span>

<span class="sd">        medianprops : dict or None (default)</span>
<span class="sd">          If provided, will set the plotting style of the medians</span>

<span class="sd">        meanprops : dict or None (default)</span>
<span class="sd">          If provided, will set the plotting style of the means</span>

<span class="sd">        meanline : bool, default = False</span>
<span class="sd">          If `True` (and *showmeans* is `True`), will try to render the mean</span>
<span class="sd">          as a line spanning the full width of the box according to</span>
<span class="sd">          *meanprops*. Not recommended if *shownotches* is also True.</span>
<span class="sd">          Otherwise, means will be shown as points.</span>

<span class="sd">        manage_ticks : bool, default = True</span>
<span class="sd">          If True, the tick locations and labels will be adjusted to match the</span>
<span class="sd">          boxplot positions.</span>

<span class="sd">        zorder : scalar, default = None</span>
<span class="sd">          The zorder of the resulting boxplot.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : dict</span>
<span class="sd">          A dictionary mapping each component of the boxplot to a list</span>
<span class="sd">          of the :class:`matplotlib.lines.Line2D` instances</span>
<span class="sd">          created. That dictionary has the following keys (assuming</span>
<span class="sd">          vertical boxplots):</span>

<span class="sd">          - ``boxes``: the main body of the boxplot showing the</span>
<span class="sd">            quartiles and the median&#39;s confidence intervals if</span>
<span class="sd">            enabled.</span>

<span class="sd">          - ``medians``: horizontal lines at the median of each box.</span>

<span class="sd">          - ``whiskers``: the vertical lines extending to the most</span>
<span class="sd">            extreme, non-outlier data points.</span>

<span class="sd">          - ``caps``: the horizontal lines at the ends of the</span>
<span class="sd">            whiskers.</span>

<span class="sd">          - ``fliers``: points representing data that extend beyond</span>
<span class="sd">            the whiskers (fliers).</span>

<span class="sd">          - ``means``: points or lines representing the means.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        .. plot:: gallery/statistics/bxp.py</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># lists of artists to be output</span>
        <span class="n">whiskers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">caps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">boxes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">medians</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">means</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fliers</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># empty list of xticklabels</span>
        <span class="n">datalabels</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Use default zorder if none specified</span>
        <span class="k">if</span> <span class="n">zorder</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">zorder</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="o">.</span><span class="n">zorder</span>

        <span class="n">zdelta</span> <span class="o">=</span> <span class="mf">0.1</span>

        <span class="k">def</span> <span class="nf">line_props_with_rcdefaults</span><span class="p">(</span><span class="n">subkey</span><span class="p">,</span> <span class="n">explicit</span><span class="p">,</span> <span class="n">zdelta</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">rcParams</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                 <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;boxplot.</span><span class="si">{</span><span class="n">subkey</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)}</span>
            <span class="n">d</span><span class="p">[</span><span class="s1">&#39;zorder&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">zorder</span> <span class="o">+</span> <span class="n">zdelta</span>
            <span class="k">if</span> <span class="n">explicit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="n">cbook</span><span class="o">.</span><span class="n">normalize_kwargs</span><span class="p">(</span><span class="n">explicit</span><span class="p">,</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="o">.</span><span class="n">_alias_map</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">d</span>

        <span class="c1"># box properties</span>
        <span class="k">if</span> <span class="n">patch_artist</span><span class="p">:</span>
            <span class="n">final_boxprops</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">linestyle</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.boxprops.linestyle&#39;</span><span class="p">],</span>
                <span class="n">linewidth</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.boxprops.linewidth&#39;</span><span class="p">],</span>
                <span class="n">edgecolor</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.boxprops.color&#39;</span><span class="p">],</span>
                <span class="n">facecolor</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;white&#39;</span> <span class="k">if</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;_internal.classic_mode&#39;</span><span class="p">]</span> <span class="k">else</span>
                           <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;patch.facecolor&#39;</span><span class="p">]),</span>
                <span class="n">zorder</span><span class="o">=</span><span class="n">zorder</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">boxprops</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">final_boxprops</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="n">cbook</span><span class="o">.</span><span class="n">normalize_kwargs</span><span class="p">(</span>
                        <span class="n">boxprops</span><span class="p">,</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">PathPatch</span><span class="o">.</span><span class="n">_alias_map</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">final_boxprops</span> <span class="o">=</span> <span class="n">line_props_with_rcdefaults</span><span class="p">(</span><span class="s1">&#39;boxprops&#39;</span><span class="p">,</span> <span class="n">boxprops</span><span class="p">)</span>
        <span class="n">final_whiskerprops</span> <span class="o">=</span> <span class="n">line_props_with_rcdefaults</span><span class="p">(</span>
            <span class="s1">&#39;whiskerprops&#39;</span><span class="p">,</span> <span class="n">whiskerprops</span><span class="p">)</span>
        <span class="n">final_capprops</span> <span class="o">=</span> <span class="n">line_props_with_rcdefaults</span><span class="p">(</span>
            <span class="s1">&#39;capprops&#39;</span><span class="p">,</span> <span class="n">capprops</span><span class="p">)</span>
        <span class="n">final_flierprops</span> <span class="o">=</span> <span class="n">line_props_with_rcdefaults</span><span class="p">(</span>
            <span class="s1">&#39;flierprops&#39;</span><span class="p">,</span> <span class="n">flierprops</span><span class="p">)</span>
        <span class="n">final_medianprops</span> <span class="o">=</span> <span class="n">line_props_with_rcdefaults</span><span class="p">(</span>
            <span class="s1">&#39;medianprops&#39;</span><span class="p">,</span> <span class="n">medianprops</span><span class="p">,</span> <span class="n">zdelta</span><span class="p">)</span>
        <span class="n">final_meanprops</span> <span class="o">=</span> <span class="n">line_props_with_rcdefaults</span><span class="p">(</span>
            <span class="s1">&#39;meanprops&#39;</span><span class="p">,</span> <span class="n">meanprops</span><span class="p">,</span> <span class="n">zdelta</span><span class="p">)</span>
        <span class="n">removed_prop</span> <span class="o">=</span> <span class="s1">&#39;marker&#39;</span> <span class="k">if</span> <span class="n">meanline</span> <span class="k">else</span> <span class="s1">&#39;linestyle&#39;</span>
        <span class="c1"># Only remove the property if it&#39;s not set explicitly as a parameter.</span>
        <span class="k">if</span> <span class="n">meanprops</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">removed_prop</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">meanprops</span><span class="p">:</span>
            <span class="n">final_meanprops</span><span class="p">[</span><span class="n">removed_prop</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="k">def</span> <span class="nf">to_vc</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">):</span>
            <span class="c1"># convert arguments to verts and codes, append (0, 0) (ignored).</span>
            <span class="n">verts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">]),</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">codes</span> <span class="o">=</span> <span class="p">([</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">MOVETO</span><span class="p">]</span>
                     <span class="o">+</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">LINETO</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
                     <span class="o">+</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">CLOSEPOLY</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">verts</span><span class="p">,</span> <span class="n">codes</span>

        <span class="k">def</span> <span class="nf">patch_list</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">verts</span><span class="p">,</span> <span class="n">codes</span> <span class="o">=</span> <span class="n">to_vc</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">codes</span><span class="p">)</span>
            <span class="n">patch</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">PathPatch</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">patch</span><span class="p">]</span>

        <span class="c1"># vertical or horizontal plot?</span>
        <span class="k">if</span> <span class="n">vert</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">doplot</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">dopatch</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">patch_list</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">doplot</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="n">shuffled</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="n">shuffled</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">args</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">shuffled</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">dopatch</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span> <span class="o">=</span> <span class="n">ys</span><span class="p">,</span> <span class="n">xs</span>  <span class="c1"># flip X, Y</span>
                <span class="k">return</span> <span class="n">patch_list</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># input validation</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bxpstats</span><span class="p">)</span>
        <span class="n">datashape_message</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;List of boxplot statistics and `</span><span class="si">{0}</span><span class="s2">` &quot;</span>
                             <span class="s2">&quot;values must have same the length&quot;</span><span class="p">)</span>
        <span class="c1"># check position</span>
        <span class="k">if</span> <span class="n">positions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">!=</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">datashape_message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;positions&quot;</span><span class="p">))</span>

        <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">positions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Number</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;positions should be an iterable of numbers&quot;</span><span class="p">)</span>

        <span class="c1"># width</span>
        <span class="k">if</span> <span class="n">widths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">widths</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mf">0.15</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">positions</span><span class="p">),</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)]</span> <span class="o">*</span> <span class="n">N</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">widths</span><span class="p">):</span>
            <span class="n">widths</span> <span class="o">=</span> <span class="p">[</span><span class="n">widths</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span> <span class="o">!=</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">datashape_message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;widths&quot;</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">stats</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">bxpstats</span><span class="p">):</span>
            <span class="c1"># try to find a new label</span>
            <span class="n">datalabels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="n">pos</span><span class="p">))</span>

            <span class="c1"># whisker coords</span>
            <span class="n">whisker_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">pos</span>
            <span class="n">whiskerlo_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q1&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;whislo&#39;</span><span class="p">]])</span>
            <span class="n">whiskerhi_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q3&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;whishi&#39;</span><span class="p">]])</span>

            <span class="c1"># cap coords</span>
            <span class="n">cap_left</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">width</span> <span class="o">*</span> <span class="mf">0.25</span>
            <span class="n">cap_right</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">width</span> <span class="o">*</span> <span class="mf">0.25</span>
            <span class="n">cap_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cap_left</span><span class="p">,</span> <span class="n">cap_right</span><span class="p">])</span>
            <span class="n">cap_lo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;whislo&#39;</span><span class="p">]</span>
            <span class="n">cap_hi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;whishi&#39;</span><span class="p">]</span>

            <span class="c1"># box and median coords</span>
            <span class="n">box_left</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">width</span> <span class="o">*</span> <span class="mf">0.5</span>
            <span class="n">box_right</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">width</span> <span class="o">*</span> <span class="mf">0.5</span>
            <span class="n">med_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;med&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;med&#39;</span><span class="p">]]</span>

            <span class="c1"># notched boxes</span>
            <span class="k">if</span> <span class="n">shownotches</span><span class="p">:</span>
                <span class="n">box_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">box_left</span><span class="p">,</span> <span class="n">box_right</span><span class="p">,</span> <span class="n">box_right</span><span class="p">,</span> <span class="n">cap_right</span><span class="p">,</span> <span class="n">box_right</span><span class="p">,</span>
                         <span class="n">box_right</span><span class="p">,</span> <span class="n">box_left</span><span class="p">,</span> <span class="n">box_left</span><span class="p">,</span> <span class="n">cap_left</span><span class="p">,</span> <span class="n">box_left</span><span class="p">,</span>
                         <span class="n">box_left</span><span class="p">]</span>
                <span class="n">box_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q1&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q1&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;cilo&#39;</span><span class="p">],</span>
                         <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;med&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;cihi&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q3&#39;</span><span class="p">],</span>
                         <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q3&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;cihi&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;med&#39;</span><span class="p">],</span>
                         <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;cilo&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q1&#39;</span><span class="p">]]</span>
                <span class="n">med_x</span> <span class="o">=</span> <span class="n">cap_x</span>

            <span class="c1"># plain boxes</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">box_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">box_left</span><span class="p">,</span> <span class="n">box_right</span><span class="p">,</span> <span class="n">box_right</span><span class="p">,</span> <span class="n">box_left</span><span class="p">,</span> <span class="n">box_left</span><span class="p">]</span>
                <span class="n">box_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q1&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q1&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q3&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q3&#39;</span><span class="p">],</span>
                         <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q1&#39;</span><span class="p">]]</span>
                <span class="n">med_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">box_left</span><span class="p">,</span> <span class="n">box_right</span><span class="p">]</span>

            <span class="c1"># maybe draw the box:</span>
            <span class="k">if</span> <span class="n">showbox</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">patch_artist</span><span class="p">:</span>
                    <span class="n">boxes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">dopatch</span><span class="p">(</span><span class="n">box_x</span><span class="p">,</span> <span class="n">box_y</span><span class="p">,</span> <span class="o">**</span><span class="n">final_boxprops</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">boxes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">doplot</span><span class="p">(</span><span class="n">box_x</span><span class="p">,</span> <span class="n">box_y</span><span class="p">,</span> <span class="o">**</span><span class="n">final_boxprops</span><span class="p">))</span>

            <span class="c1"># draw the whiskers</span>
            <span class="n">whiskers</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">doplot</span><span class="p">(</span>
                <span class="n">whisker_x</span><span class="p">,</span> <span class="n">whiskerlo_y</span><span class="p">,</span> <span class="o">**</span><span class="n">final_whiskerprops</span>
            <span class="p">))</span>
            <span class="n">whiskers</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">doplot</span><span class="p">(</span>
                <span class="n">whisker_x</span><span class="p">,</span> <span class="n">whiskerhi_y</span><span class="p">,</span> <span class="o">**</span><span class="n">final_whiskerprops</span>
            <span class="p">))</span>

            <span class="c1"># maybe draw the caps:</span>
            <span class="k">if</span> <span class="n">showcaps</span><span class="p">:</span>
                <span class="n">caps</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">doplot</span><span class="p">(</span><span class="n">cap_x</span><span class="p">,</span> <span class="n">cap_lo</span><span class="p">,</span> <span class="o">**</span><span class="n">final_capprops</span><span class="p">))</span>
                <span class="n">caps</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">doplot</span><span class="p">(</span><span class="n">cap_x</span><span class="p">,</span> <span class="n">cap_hi</span><span class="p">,</span> <span class="o">**</span><span class="n">final_capprops</span><span class="p">))</span>

            <span class="c1"># draw the medians</span>
            <span class="n">medians</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">doplot</span><span class="p">(</span><span class="n">med_x</span><span class="p">,</span> <span class="n">med_y</span><span class="p">,</span> <span class="o">**</span><span class="n">final_medianprops</span><span class="p">))</span>

            <span class="c1"># maybe draw the means</span>
            <span class="k">if</span> <span class="n">showmeans</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">meanline</span><span class="p">:</span>
                    <span class="n">means</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">doplot</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">box_left</span><span class="p">,</span> <span class="n">box_right</span><span class="p">],</span> <span class="p">[</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">]],</span>
                        <span class="o">**</span><span class="n">final_meanprops</span>
                    <span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">means</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">doplot</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="p">[</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">]],</span> <span class="o">**</span><span class="n">final_meanprops</span>
                    <span class="p">))</span>

            <span class="c1"># maybe draw the fliers</span>
            <span class="k">if</span> <span class="n">showfliers</span><span class="p">:</span>
                <span class="c1"># fliers coords</span>
                <span class="n">flier_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;fliers&#39;</span><span class="p">]),</span> <span class="n">pos</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="n">flier_y</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;fliers&#39;</span><span class="p">]</span>

                <span class="n">fliers</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">doplot</span><span class="p">(</span>
                    <span class="n">flier_x</span><span class="p">,</span> <span class="n">flier_y</span><span class="p">,</span> <span class="o">**</span><span class="n">final_flierprops</span>
                <span class="p">))</span>

        <span class="k">if</span> <span class="n">manage_ticks</span><span class="p">:</span>
            <span class="n">axis_name</span> <span class="o">=</span> <span class="s2">&quot;x&quot;</span> <span class="k">if</span> <span class="n">vert</span> <span class="k">else</span> <span class="s2">&quot;y&quot;</span>
            <span class="n">interval</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataLim</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;interval</span><span class="si">{</span><span class="n">axis_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">axis_name</span><span class="si">}</span><span class="s2">axis&quot;</span><span class="p">)</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">convert_units</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
            <span class="c1"># The 0.5 additional padding ensures reasonable-looking boxes</span>
            <span class="c1"># even when drawing a single box.  We set the sticky edge to</span>
            <span class="c1"># prevent margins expansion, in order to match old behavior (back</span>
            <span class="c1"># when separate calls to boxplot() would completely reset the axis</span>
            <span class="c1"># limits regardless of what was drawn before).  The sticky edges</span>
            <span class="c1"># are attached to the median lines, as they are always present.</span>
            <span class="n">interval</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">-</span> <span class="o">.</span><span class="mi">5</span><span class="p">),</span>
                           <span class="nb">max</span><span class="p">(</span><span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">max</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">+</span> <span class="o">.</span><span class="mi">5</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">median</span><span class="p">,</span> <span class="n">position</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">medians</span><span class="p">,</span> <span class="n">positions</span><span class="p">):</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">median</span><span class="o">.</span><span class="n">sticky_edges</span><span class="p">,</span> <span class="n">axis_name</span><span class="p">)</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">position</span> <span class="o">-</span> <span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="n">position</span> <span class="o">+</span> <span class="o">.</span><span class="mi">5</span><span class="p">])</span>
            <span class="c1"># Modified from Axis.set_ticks and Axis.set_ticklabels.</span>
            <span class="n">locator</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">get_major_locator</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="o">.</span><span class="n">get_major_locator</span><span class="p">(),</span>
                              <span class="n">mticker</span><span class="o">.</span><span class="n">FixedLocator</span><span class="p">):</span>
                <span class="n">locator</span> <span class="o">=</span> <span class="n">mticker</span><span class="o">.</span><span class="n">FixedLocator</span><span class="p">([])</span>
                <span class="n">axis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">locator</span><span class="p">)</span>
            <span class="n">locator</span><span class="o">.</span><span class="n">locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">*</span><span class="n">locator</span><span class="o">.</span><span class="n">locs</span><span class="p">,</span> <span class="o">*</span><span class="n">positions</span><span class="p">])</span>
            <span class="n">formatter</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">get_major_formatter</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="o">.</span><span class="n">get_major_formatter</span><span class="p">(),</span>
                              <span class="n">mticker</span><span class="o">.</span><span class="n">FixedFormatter</span><span class="p">):</span>
                <span class="n">formatter</span> <span class="o">=</span> <span class="n">mticker</span><span class="o">.</span><span class="n">FixedFormatter</span><span class="p">([])</span>
                <span class="n">axis</span><span class="o">.</span><span class="n">set_major_formatter</span><span class="p">(</span><span class="n">formatter</span><span class="p">)</span>
            <span class="n">formatter</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">formatter</span><span class="o">.</span><span class="n">seq</span><span class="p">,</span> <span class="o">*</span><span class="n">datalabels</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">(</span>
                <span class="n">scalex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_autoscaleXon</span><span class="p">,</span> <span class="n">scaley</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_autoscaleYon</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">whiskers</span><span class="o">=</span><span class="n">whiskers</span><span class="p">,</span> <span class="n">caps</span><span class="o">=</span><span class="n">caps</span><span class="p">,</span> <span class="n">boxes</span><span class="o">=</span><span class="n">boxes</span><span class="p">,</span>
                    <span class="n">medians</span><span class="o">=</span><span class="n">medians</span><span class="p">,</span> <span class="n">fliers</span><span class="o">=</span><span class="n">fliers</span><span class="p">,</span> <span class="n">means</span><span class="o">=</span><span class="n">means</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_parse_scatter_color_args</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">edgecolors</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">xshape</span><span class="p">,</span> <span class="n">yshape</span><span class="p">,</span>
                                  <span class="n">get_next_color_func</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to process color related arguments of `.Axes.scatter`.</span>

<span class="sd">        Argument precedence for facecolors:</span>

<span class="sd">        - c (if not None)</span>
<span class="sd">        - kwargs[&#39;facecolors&#39;]</span>
<span class="sd">        - kwargs[&#39;facecolor&#39;]</span>
<span class="sd">        - kwargs[&#39;color&#39;] (==kwcolor)</span>
<span class="sd">        - &#39;b&#39; if in classic mode else the result of ``get_next_color_func()``</span>

<span class="sd">        Argument precedence for edgecolors:</span>

<span class="sd">        - edgecolors (is an explicit kw argument in scatter())</span>
<span class="sd">        - kwargs[&#39;edgecolor&#39;]</span>
<span class="sd">        - kwargs[&#39;color&#39;] (==kwcolor)</span>
<span class="sd">        - &#39;face&#39; if not in classic mode else None</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c : color or sequence or sequence of color or None</span>
<span class="sd">            See argument description of `.Axes.scatter`.</span>
<span class="sd">        edgecolors : color or sequence of color or {&#39;face&#39;, &#39;none&#39;} or None</span>
<span class="sd">            See argument description of `.Axes.scatter`.</span>
<span class="sd">        kwargs : dict</span>
<span class="sd">            Additional kwargs. If these keys exist, we pop and process them:</span>
<span class="sd">            &#39;facecolors&#39;, &#39;facecolor&#39;, &#39;edgecolor&#39;, &#39;color&#39;</span>
<span class="sd">            Note: The dict is modified by this function.</span>
<span class="sd">        xshape, yshape : tuple of int</span>
<span class="sd">            The shape of the x and y arrays passed to `.Axes.scatter`.</span>
<span class="sd">        get_next_color_func : callable</span>
<span class="sd">            A callable that returns a color. This color is used as facecolor</span>
<span class="sd">            if no other color is provided.</span>

<span class="sd">            Note, that this is a function rather than a fixed color value to</span>
<span class="sd">            support conditional evaluation of the next color.  As of the</span>
<span class="sd">            current implementation obtaining the next color from the</span>
<span class="sd">            property cycle advances the cycle. This must only happen if we</span>
<span class="sd">            actually use the color, which will only be decided within this</span>
<span class="sd">            method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        c</span>
<span class="sd">            The input *c* if it was not *None*, else some color specification</span>
<span class="sd">            derived from the other inputs or defaults.</span>
<span class="sd">        colors : array(N, 4) or None</span>
<span class="sd">            The facecolors as RGBA values or *None* if a colormap is used.</span>
<span class="sd">        edgecolors</span>
<span class="sd">            The edgecolor specification.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xsize</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="n">xshape</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ysize</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="n">yshape</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">facecolors</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;facecolors&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">facecolors</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;facecolor&#39;</span><span class="p">,</span> <span class="n">facecolors</span><span class="p">)</span>
        <span class="n">edgecolors</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;edgecolor&#39;</span><span class="p">,</span> <span class="n">edgecolors</span><span class="p">)</span>

        <span class="n">kwcolor</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwcolor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Supply a &#39;c&#39; argument or a &#39;color&#39;&quot;</span>
                             <span class="s2">&quot; kwarg but not both; they differ but&quot;</span>
                             <span class="s2">&quot; their functionalities overlap.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwcolor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">mcolors</span><span class="o">.</span><span class="n">to_rgba_array</span><span class="p">(</span><span class="n">kwcolor</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;color&#39; kwarg must be an mpl color&quot;</span>
                                 <span class="s2">&quot; spec or sequence of color specs.</span><span class="se">\n</span><span class="s2">&quot;</span>
                                 <span class="s2">&quot;For a sequence of values to be color-mapped,&quot;</span>
                                 <span class="s2">&quot; use the &#39;c&#39; argument instead.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">edgecolors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">edgecolors</span> <span class="o">=</span> <span class="n">kwcolor</span>
            <span class="k">if</span> <span class="n">facecolors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">facecolors</span> <span class="o">=</span> <span class="n">kwcolor</span>

        <span class="k">if</span> <span class="n">edgecolors</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;_internal.classic_mode&#39;</span><span class="p">]:</span>
            <span class="n">edgecolors</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;scatter.edgecolors&#39;</span><span class="p">]</span>

        <span class="n">c_was_none</span> <span class="o">=</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">facecolors</span> <span class="k">if</span> <span class="n">facecolors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                 <span class="k">else</span> <span class="s2">&quot;b&quot;</span> <span class="k">if</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;_internal.classic_mode&#39;</span><span class="p">]</span>
                 <span class="k">else</span> <span class="n">get_next_color_func</span><span class="p">())</span>

        <span class="c1"># After this block, c_array will be None unless</span>
        <span class="c1"># c is an array for mapping.  The potential ambiguity</span>
        <span class="c1"># with a sequence of 3 or 4 numbers is resolved in</span>
        <span class="c1"># favor of mapping, not rgb or rgba.</span>
        <span class="c1"># Convenience vars to track shape mismatch *and* conversion failures.</span>
        <span class="n">valid_shape</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># will be put to the test!</span>
        <span class="n">n_elem</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># used only for (some) exceptions</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">c_was_none</span> <span class="ow">or</span>
                <span class="n">kwcolor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span>
                     <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span>
                     <span class="nb">isinstance</span><span class="p">(</span><span class="n">cbook</span><span class="o">.</span><span class="n">safe_first_element</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="nb">str</span><span class="p">))):</span>
            <span class="n">c_array</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>  <span class="c1"># First, does &#39;c&#39; look suitable for value-mapping?</span>
                <span class="n">c_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="n">n_elem</span> <span class="o">=</span> <span class="n">c_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">c_array</span><span class="o">.</span><span class="n">shape</span> <span class="ow">in</span> <span class="p">[</span><span class="n">xshape</span><span class="p">,</span> <span class="n">yshape</span><span class="p">]:</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">c_array</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">c_array</span><span class="o">.</span><span class="n">shape</span> <span class="ow">in</span> <span class="p">((</span><span class="mi">3</span><span class="p">,),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,)):</span>
                        <span class="n">_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                            <span class="s2">&quot;&#39;c&#39; argument looks like a single numeric RGB or &quot;</span>
                            <span class="s2">&quot;RGBA sequence, which should be avoided as value-&quot;</span>
                            <span class="s2">&quot;mapping will have precedence in case its length &quot;</span>
                            <span class="s2">&quot;matches with &#39;x&#39; &amp; &#39;y&#39;.  Please use a 2-D array &quot;</span>
                            <span class="s2">&quot;with a single row if you really want to specify &quot;</span>
                            <span class="s2">&quot;the same RGB or RGBA value for all points.&quot;</span><span class="p">)</span>
                    <span class="c1"># Wrong size; it must not be intended for mapping.</span>
                    <span class="n">valid_shape</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">c_array</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># Failed to make a floating-point array; c must be color specs.</span>
                <span class="n">c_array</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">c_array</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>  <span class="c1"># Then is &#39;c&#39; acceptable as PathCollection facecolors?</span>
                <span class="n">colors</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">to_rgba_array</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="n">n_elem</span> <span class="o">=</span> <span class="n">colors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">colors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">xsize</span><span class="p">,</span> <span class="n">ysize</span><span class="p">):</span>
                    <span class="c1"># NB: remember that a single color is also acceptable.</span>
                    <span class="c1"># Besides *colors* will be an empty array if c == &#39;none&#39;.</span>
                    <span class="n">valid_shape</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">valid_shape</span><span class="p">:</span>  <span class="c1"># but at least one conversion succeeded.</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;&#39;c&#39; argument has </span><span class="si">{nc}</span><span class="s2"> elements, which is not &quot;</span>
                        <span class="s2">&quot;acceptable for use with &#39;x&#39; with size </span><span class="si">{xs}</span><span class="s2">, &quot;</span>
                        <span class="s2">&quot;&#39;y&#39; with size </span><span class="si">{ys}</span><span class="s2">.&quot;</span>
                            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nc</span><span class="o">=</span><span class="n">n_elem</span><span class="p">,</span> <span class="n">xs</span><span class="o">=</span><span class="n">xsize</span><span class="p">,</span> <span class="n">ys</span><span class="o">=</span><span class="n">ysize</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Both the mapping *and* the RGBA conversion failed: pretty</span>
                    <span class="c1"># severe failure =&gt; one may appreciate a verbose feedback.</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;&#39;c&#39; argument must be a mpl color, a sequence of mpl &quot;</span>
                        <span class="s2">&quot;colors or a sequence of numbers, not </span><span class="si">{}</span><span class="s2">.&quot;</span>
                            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>  <span class="c1"># note: could be long depending on c</span>
                    <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># use cmap, norm after collection is created</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">edgecolors</span>

    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="s2">&quot;linewidths&quot;</span><span class="p">,</span>
                                     <span class="s2">&quot;edgecolors&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;facecolor&quot;</span><span class="p">,</span>
                                     <span class="s2">&quot;facecolors&quot;</span><span class="p">,</span> <span class="s2">&quot;color&quot;</span><span class="p">],</span>
                      <span class="n">label_namer</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">scatter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">verts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">plotnonfinite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A scatter plot of *y* vs *x* with varying marker size and/or color.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : array_like, shape (n, )</span>
<span class="sd">            The data positions.</span>

<span class="sd">        s : scalar or array_like, shape (n, ), optional</span>
<span class="sd">            The marker size in points**2.</span>
<span class="sd">            Default is ``rcParams[&#39;lines.markersize&#39;] ** 2``.</span>

<span class="sd">        c : color, sequence, or sequence of color, optional</span>
<span class="sd">            The marker color. Possible values:</span>

<span class="sd">            - A single color format string.</span>
<span class="sd">            - A sequence of color specifications of length n.</span>
<span class="sd">            - A sequence of n numbers to be mapped to colors using *cmap* and</span>
<span class="sd">              *norm*.</span>
<span class="sd">            - A 2-D array in which the rows are RGB or RGBA.</span>

<span class="sd">            Note that *c* should not be a single numeric RGB or RGBA sequence</span>
<span class="sd">            because that is indistinguishable from an array of values to be</span>
<span class="sd">            colormapped. If you want to specify the same RGB or RGBA value for</span>
<span class="sd">            all points, use a 2-D array with a single row.  Otherwise, value-</span>
<span class="sd">            matching will have precedence in case of a size matching with *x*</span>
<span class="sd">            and *y*.</span>

<span class="sd">            Defaults to ``None``. In that case the marker color is determined</span>
<span class="sd">            by the value of ``color``, ``facecolor`` or ``facecolors``. In case</span>
<span class="sd">            those are not specified or ``None``, the marker color is determined</span>
<span class="sd">            by the next color of the ``Axes``&#39; current &quot;shape and fill&quot; color</span>
<span class="sd">            cycle. This cycle defaults to :rc:`axes.prop_cycle`.</span>

<span class="sd">        marker : `~matplotlib.markers.MarkerStyle`, optional</span>
<span class="sd">            The marker style. *marker* can be either an instance of the class</span>
<span class="sd">            or the text shorthand for a particular marker.</span>
<span class="sd">            Defaults to ``None``, in which case it takes the value of</span>
<span class="sd">            :rc:`scatter.marker` = &#39;o&#39;.</span>
<span class="sd">            See `~matplotlib.markers` for more information about marker styles.</span>

<span class="sd">        cmap : `~matplotlib.colors.Colormap`, optional, default: None</span>
<span class="sd">            A `.Colormap` instance or registered colormap name. *cmap* is only</span>
<span class="sd">            used if *c* is an array of floats. If ``None``, defaults to rc</span>
<span class="sd">            ``image.cmap``.</span>

<span class="sd">        norm : `~matplotlib.colors.Normalize`, optional, default: None</span>
<span class="sd">            A `.Normalize` instance is used to scale luminance data to 0, 1.</span>
<span class="sd">            *norm* is only used if *c* is an array of floats. If *None*, use</span>
<span class="sd">            the default `.colors.Normalize`.</span>

<span class="sd">        vmin, vmax : scalar, optional, default: None</span>
<span class="sd">            *vmin* and *vmax* are used in conjunction with *norm* to normalize</span>
<span class="sd">            luminance data. If None, the respective min and max of the color</span>
<span class="sd">            array is used. *vmin* and *vmax* are ignored if you pass a *norm*</span>
<span class="sd">            instance.</span>

<span class="sd">        alpha : scalar, optional, default: None</span>
<span class="sd">            The alpha blending value, between 0 (transparent) and 1 (opaque).</span>

<span class="sd">        linewidths : scalar or array_like, optional, default: None</span>
<span class="sd">            The linewidth of the marker edges. Note: The default *edgecolors*</span>
<span class="sd">            is &#39;face&#39;. You may want to change this as well.</span>
<span class="sd">            If *None*, defaults to rcParams ``lines.linewidth``.</span>

<span class="sd">        edgecolors : {&#39;face&#39;, &#39;none&#39;, *None*} or color or sequence of color, \</span>
<span class="sd">optional.</span>
<span class="sd">            The edge color of the marker. Possible values:</span>

<span class="sd">            - &#39;face&#39;: The edge color will always be the same as the face color.</span>
<span class="sd">            - &#39;none&#39;: No patch boundary will be drawn.</span>
<span class="sd">            - A Matplotlib color or sequence of color.</span>

<span class="sd">            Defaults to ``None``, in which case it takes the value of</span>
<span class="sd">            :rc:`scatter.edgecolors` = &#39;face&#39;.</span>

<span class="sd">            For non-filled markers, the *edgecolors* kwarg is ignored and</span>
<span class="sd">            forced to &#39;face&#39; internally.</span>

<span class="sd">        plotnonfinite : boolean, optional, default: False</span>
<span class="sd">            Set to plot points with nonfinite *c*, in conjunction with</span>
<span class="sd">            `~matplotlib.colors.Colormap.set_bad`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        paths : `~matplotlib.collections.PathCollection`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs : `~matplotlib.collections.Collection` properties</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        plot : To plot scatter plots when markers are identical in size and</span>
<span class="sd">            color.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        * The `.plot` function will be faster for scatterplots where markers</span>
<span class="sd">          don&#39;t vary in size or color.</span>

<span class="sd">        * Any or all of *x*, *y*, *s*, and *c* may be masked arrays, in which</span>
<span class="sd">          case all masks will be combined and only unmasked points will be</span>
<span class="sd">          plotted.</span>

<span class="sd">        * Fundamentally, scatter works with 1-D arrays; *x*, *y*, *s*, and *c*</span>
<span class="sd">          may be input as 2-D arrays, but within scatter they will be</span>
<span class="sd">          flattened. The exception is *c*, which will be flattened only if its</span>
<span class="sd">          size matches the size of *x* and *y*.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Process **kwargs to handle aliases, conflicts with explicit kwargs:</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="c1"># np.ma.ravel yields an ndarray, not a masked array,</span>
        <span class="c1"># unless its argument is a masked array.</span>
        <span class="n">xshape</span><span class="p">,</span> <span class="n">yshape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x and y must be the same size&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="mi">20</span> <span class="k">if</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;_internal.classic_mode&#39;</span><span class="p">]</span> <span class="k">else</span>
                 <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;lines.markersize&#39;</span><span class="p">]</span> <span class="o">**</span> <span class="mf">2.0</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># This doesn&#39;t have to match x, y in size.</span>

        <span class="n">c</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">edgecolors</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_parse_scatter_color_args</span><span class="p">(</span>
                <span class="n">c</span><span class="p">,</span> <span class="n">edgecolors</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">xshape</span><span class="p">,</span> <span class="n">yshape</span><span class="p">,</span>
                <span class="n">get_next_color_func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_patches_for_fill</span><span class="o">.</span><span class="n">get_next_color</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plotnonfinite</span> <span class="ow">and</span> <span class="n">colors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">edgecolors</span><span class="p">,</span> <span class="n">linewidths</span> <span class="o">=</span> \
                <span class="n">cbook</span><span class="o">.</span><span class="n">_combine_masks</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">edgecolors</span><span class="p">,</span> <span class="n">linewidths</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">edgecolors</span><span class="p">,</span> <span class="n">linewidths</span> <span class="o">=</span> \
                <span class="n">cbook</span><span class="o">.</span><span class="n">_combine_masks</span><span class="p">(</span>
                    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">edgecolors</span><span class="p">,</span> <span class="n">linewidths</span><span class="p">)</span>

        <span class="n">scales</span> <span class="o">=</span> <span class="n">s</span>   <span class="c1"># Renamed for readability below.</span>

        <span class="c1"># to be API compatible</span>
        <span class="k">if</span> <span class="n">verts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cbook</span><span class="o">.</span><span class="n">warn_deprecated</span><span class="p">(</span><span class="s2">&quot;3.0&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;&#39;verts&#39;&quot;</span><span class="p">,</span> <span class="n">obj_type</span><span class="o">=</span><span class="s2">&quot;kwarg&quot;</span><span class="p">,</span>
                                  <span class="n">alternative</span><span class="o">=</span><span class="s2">&quot;&#39;marker&#39;&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">marker</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">marker</span> <span class="o">=</span> <span class="n">verts</span>

        <span class="c1"># load default marker from rcParams</span>
        <span class="k">if</span> <span class="n">marker</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">marker</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;scatter.marker&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">marker</span><span class="p">,</span> <span class="n">mmarkers</span><span class="o">.</span><span class="n">MarkerStyle</span><span class="p">):</span>
            <span class="n">marker_obj</span> <span class="o">=</span> <span class="n">marker</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">marker_obj</span> <span class="o">=</span> <span class="n">mmarkers</span><span class="o">.</span><span class="n">MarkerStyle</span><span class="p">(</span><span class="n">marker</span><span class="p">)</span>

        <span class="n">path</span> <span class="o">=</span> <span class="n">marker_obj</span><span class="o">.</span><span class="n">get_path</span><span class="p">()</span><span class="o">.</span><span class="n">transformed</span><span class="p">(</span>
            <span class="n">marker_obj</span><span class="o">.</span><span class="n">get_transform</span><span class="p">())</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">marker_obj</span><span class="o">.</span><span class="n">is_filled</span><span class="p">():</span>
            <span class="n">edgecolors</span> <span class="o">=</span> <span class="s1">&#39;face&#39;</span>
            <span class="n">linewidths</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;lines.linewidth&#39;</span><span class="p">]</span>

        <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="n">collection</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">PathCollection</span><span class="p">(</span>
                <span class="p">(</span><span class="n">path</span><span class="p">,),</span> <span class="n">scales</span><span class="p">,</span>
                <span class="n">facecolors</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span>
                <span class="n">edgecolors</span><span class="o">=</span><span class="n">edgecolors</span><span class="p">,</span>
                <span class="n">linewidths</span><span class="o">=</span><span class="n">linewidths</span><span class="p">,</span>
                <span class="n">offsets</span><span class="o">=</span><span class="n">offsets</span><span class="p">,</span>
                <span class="n">transOffset</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;transform&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transData</span><span class="p">),</span>
                <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span>
                <span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_transform</span><span class="p">(</span><span class="n">mtransforms</span><span class="o">.</span><span class="n">IdentityTransform</span><span class="p">())</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">colors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;&#39;norm&#39; must be an instance of &#39;mcolors.Normalize&#39;&quot;</span><span class="p">)</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">set_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">vmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">collection</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">collection</span><span class="o">.</span><span class="n">autoscale_None</span><span class="p">()</span>

        <span class="c1"># Classic mode only:</span>
        <span class="c1"># ensure there are margins to allow for the</span>
        <span class="c1"># finite size of the symbols.  In v2.x, margins</span>
        <span class="c1"># are present by default, so we disable this</span>
        <span class="c1"># scatter-specific override.</span>
        <span class="k">if</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;_internal.classic_mode&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xmargin</span> <span class="o">&lt;</span> <span class="mf">0.05</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_xmargin</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ymargin</span> <span class="o">&lt;</span> <span class="mf">0.05</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_ymargin</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">collection</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">collection</span>

    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">hexbin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gridsize</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">xscale</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">yscale</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;face&#39;</span><span class="p">,</span>
               <span class="n">reduce_C_function</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">mincnt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">marginals</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a 2D hexagonal binning plot of points *x*, *y*.</span>

<span class="sd">        If *C* is *None*, the value of the hexagon is determined by the number</span>
<span class="sd">        of points in the hexagon. Otherwise, *C* specifies values at the</span>
<span class="sd">        coordinate (x[i], y[i]). For each hexagon, these values are reduced</span>
<span class="sd">        using *reduce_C_function*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : array-like</span>
<span class="sd">            The data positions. *x* and *y* must be of the same length.</span>

<span class="sd">        C : array-like, optional</span>
<span class="sd">            If given, these values are accumulated in the bins. Otherwise,</span>
<span class="sd">            every point has a value of 1. Must be of the same length as *x*</span>
<span class="sd">            and *y*.</span>

<span class="sd">        gridsize : int or (int, int), default: 100</span>
<span class="sd">            If a single int, the number of hexagons in the *x*-direction.</span>
<span class="sd">            The number of hexagons in the *y*-direction is chosen such that</span>
<span class="sd">            the hexagons are approximately regular.</span>

<span class="sd">            Alternatively, if a tuple (*nx*, *ny*), the number of hexagons</span>
<span class="sd">            in the *x*-direction and the *y*-direction.</span>

<span class="sd">        bins : &#39;log&#39; or int or sequence, default: *None*</span>
<span class="sd">            Discretization of the hexagon values.</span>

<span class="sd">            - If *None*, no binning is applied; the color of each hexagon</span>
<span class="sd">              directly corresponds to its count value.</span>
<span class="sd">            - If &#39;log&#39;, use a logarithmic scale for the color map.</span>
<span class="sd">              Internally, :math:`log_{10}(i+1)` is used to determine the</span>
<span class="sd">              hexagon color. This is equivalent to ``norm=LogNorm()``.</span>
<span class="sd">            - If an integer, divide the counts in the specified number</span>
<span class="sd">              of bins, and color the hexagons accordingly.</span>
<span class="sd">            - If a sequence of values, the values of the lower bound of</span>
<span class="sd">              the bins to be used.</span>

<span class="sd">        xscale : {&#39;linear&#39;, &#39;log&#39;}, default: &#39;linear&#39;</span>
<span class="sd">            Use a linear or log10 scale on the horizontal axis.</span>

<span class="sd">        yscale : {&#39;linear&#39;, &#39;log&#39;}, default: &#39;linear&#39;</span>
<span class="sd">            Use a linear or log10 scale on the vertical axis.</span>

<span class="sd">        mincnt : int &gt; 0, default: *None*</span>
<span class="sd">            If not *None*, only display cells with more than *mincnt*</span>
<span class="sd">            number of points in the cell.</span>

<span class="sd">        marginals : bool, default: *False*</span>
<span class="sd">            If marginals is *True*, plot the marginal density as</span>
<span class="sd">            colormapped rectangles along the bottom of the x-axis and</span>
<span class="sd">            left of the y-axis.</span>

<span class="sd">        extent : float, default: *None*</span>
<span class="sd">            The limits of the bins. The default assigns the limits</span>
<span class="sd">            based on *gridsize*, *x*, *y*, *xscale* and *yscale*.</span>

<span class="sd">            If *xscale* or *yscale* is set to &#39;log&#39;, the limits are</span>
<span class="sd">            expected to be the exponent for a power of 10. E.g. for</span>
<span class="sd">            x-limits of 1 and 50 in &#39;linear&#39; scale and y-limits</span>
<span class="sd">            of 10 and 1000 in &#39;log&#39; scale, enter (1, 50, 1, 3).</span>

<span class="sd">            Order of scalars is (left, right, bottom, top).</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        cmap : str or `~matplotlib.colors.Colormap`, optional</span>
<span class="sd">            The Colormap instance or registered colormap name used to map</span>
<span class="sd">            the bin values to colors. Defaults to :rc:`image.cmap`.</span>

<span class="sd">        norm : `~matplotlib.colors.Normalize`, optional</span>
<span class="sd">            The Normalize instance scales the bin values to the canonical</span>
<span class="sd">            colormap range [0, 1] for mapping to colors. By default, the data</span>
<span class="sd">            range is mapped to the colorbar range using linear scaling.</span>

<span class="sd">        vmin, vmax : float, optional, default: None</span>
<span class="sd">            The colorbar range. If *None*, suitable min/max values are</span>
<span class="sd">            automatically chosen by the `~.Normalize` instance (defaults to</span>
<span class="sd">            the respective min/max values of the bins in case of the default</span>
<span class="sd">            linear scaling). This is ignored if *norm* is given.</span>

<span class="sd">        alpha : float between 0 and 1, optional</span>
<span class="sd">            The alpha blending value, between 0 (transparent) and 1 (opaque).</span>

<span class="sd">        linewidths : float, default: *None*</span>
<span class="sd">            If *None*, defaults to 1.0.</span>

<span class="sd">        edgecolors : {&#39;face&#39;, &#39;none&#39;, *None*} or color, default: &#39;face&#39;</span>
<span class="sd">            The color of the hexagon edges. Possible values are:</span>

<span class="sd">            - &#39;face&#39;: Draw the edges in the same color as the fill color.</span>
<span class="sd">            - &#39;none&#39;: No edges are drawn. This can sometimes lead to unsightly</span>
<span class="sd">              unpainted pixels between the hexagons.</span>
<span class="sd">            - *None*: Draw outlines in the default color.</span>
<span class="sd">            - An explicit matplotlib color.</span>

<span class="sd">        reduce_C_function : callable, default is `numpy.mean`</span>
<span class="sd">            The function to aggregate *C* within the bins. It is ignored if</span>
<span class="sd">            *C* is not given. This must have the signature::</span>

<span class="sd">                def reduce_C_function(C: array) -&gt; float</span>

<span class="sd">            Commonly used functions are:</span>

<span class="sd">            - `numpy.mean`: average of the points</span>
<span class="sd">            - `numpy.sum`: integral of the point values</span>
<span class="sd">            - `numpy.max`: value taken from the largest point</span>

<span class="sd">        **kwargs : `~matplotlib.collections.PolyCollection` properties</span>
<span class="sd">            All other keyword arguments are passed on to `.PolyCollection`:</span>

<span class="sd">            %(PolyCollection)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        polycollection : `~matplotlib.collections.PolyCollection`</span>
<span class="sd">            A `.PolyCollection` defining the hexagonal bins.</span>

<span class="sd">            - `.PolyCollection.get_offset` contains a Mx2 array containing</span>
<span class="sd">              the x, y positions of the M hexagon centers.</span>
<span class="sd">            - `.PolyCollection.get_array` contains the values of the M</span>
<span class="sd">              hexagons.</span>

<span class="sd">            If *marginals* is *True*, horizontal</span>
<span class="sd">            bar and vertical bar (both PolyCollections) will be attached</span>
<span class="sd">            to the return collection as attributes *hbar* and *vbar*.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">delete_masked_points</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>

        <span class="c1"># Set the size of the hexagon grid</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">gridsize</span><span class="p">):</span>
            <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">gridsize</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nx</span> <span class="o">=</span> <span class="n">gridsize</span>
            <span class="n">ny</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nx</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
        <span class="c1"># Count the number of data in each hexagon</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xscale</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x contains non-positive values, so can not&quot;</span>
                                 <span class="s2">&quot; be log-scaled&quot;</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">yscale</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">y</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;y contains non-positive values, so can not&quot;</span>
                                 <span class="s2">&quot; be log-scaled&quot;</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">extent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">extent</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># to avoid issues with singular data, expand the min/max pairs</span>
            <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="n">mtransforms</span><span class="o">.</span><span class="n">nonsingular</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">expander</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
            <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">mtransforms</span><span class="o">.</span><span class="n">nonsingular</span><span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">expander</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

        <span class="c1"># In the x-direction, the hexagons exactly cover the region from</span>
        <span class="c1"># xmin to xmax. Need some padding to avoid roundoff errors.</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="mf">1.e-9</span> <span class="o">*</span> <span class="p">(</span><span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span>
        <span class="n">xmin</span> <span class="o">-=</span> <span class="n">padding</span>
        <span class="n">xmax</span> <span class="o">+=</span> <span class="n">padding</span>
        <span class="n">sx</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span> <span class="o">/</span> <span class="n">nx</span>
        <span class="n">sy</span> <span class="o">=</span> <span class="p">(</span><span class="n">ymax</span> <span class="o">-</span> <span class="n">ymin</span><span class="p">)</span> <span class="o">/</span> <span class="n">ny</span>

        <span class="k">if</span> <span class="n">marginals</span><span class="p">:</span>
            <span class="n">xorig</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">yorig</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span> <span class="o">/</span> <span class="n">sx</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">ymin</span><span class="p">)</span> <span class="o">/</span> <span class="n">sy</span>
        <span class="n">ix1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">iy1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">ix2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">iy2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="n">nx1</span> <span class="o">=</span> <span class="n">nx</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">ny1</span> <span class="o">=</span> <span class="n">ny</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">nx2</span> <span class="o">=</span> <span class="n">nx</span>
        <span class="n">ny2</span> <span class="o">=</span> <span class="n">ny</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">nx1</span> <span class="o">*</span> <span class="n">ny1</span> <span class="o">+</span> <span class="n">nx2</span> <span class="o">*</span> <span class="n">ny2</span>

        <span class="n">d1</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">ix1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">iy1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">d2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">ix2</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">iy2</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">bdist</span> <span class="o">=</span> <span class="p">(</span><span class="n">d1</span> <span class="o">&lt;</span> <span class="n">d2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">C</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lattice1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nx1</span><span class="p">,</span> <span class="n">ny1</span><span class="p">))</span>
            <span class="n">lattice2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nx2</span><span class="p">,</span> <span class="n">ny2</span><span class="p">))</span>

            <span class="n">cond1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ix1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">ix1</span> <span class="o">&lt;</span> <span class="n">nx1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">iy1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">iy1</span> <span class="o">&lt;</span> <span class="n">ny1</span><span class="p">)</span>
            <span class="n">cond2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ix2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">ix2</span> <span class="o">&lt;</span> <span class="n">nx2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">iy2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">iy2</span> <span class="o">&lt;</span> <span class="n">ny2</span><span class="p">)</span>

            <span class="n">cond1</span> <span class="o">*=</span> <span class="n">bdist</span>
            <span class="n">cond2</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">bdist</span><span class="p">)</span>
            <span class="n">ix1</span><span class="p">,</span> <span class="n">iy1</span> <span class="o">=</span> <span class="n">ix1</span><span class="p">[</span><span class="n">cond1</span><span class="p">],</span> <span class="n">iy1</span><span class="p">[</span><span class="n">cond1</span><span class="p">]</span>
            <span class="n">ix2</span><span class="p">,</span> <span class="n">iy2</span> <span class="o">=</span> <span class="n">ix2</span><span class="p">[</span><span class="n">cond2</span><span class="p">],</span> <span class="n">iy2</span><span class="p">[</span><span class="n">cond2</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ix1</span><span class="p">,</span> <span class="n">iy1</span><span class="p">):</span>
                <span class="n">lattice1</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ix2</span><span class="p">,</span> <span class="n">iy2</span><span class="p">):</span>
                <span class="n">lattice2</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># threshold</span>
            <span class="k">if</span> <span class="n">mincnt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">lattice1</span><span class="p">[</span><span class="n">lattice1</span> <span class="o">&lt;</span> <span class="n">mincnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">lattice2</span><span class="p">[</span><span class="n">lattice2</span> <span class="o">&lt;</span> <span class="n">mincnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">accum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">lattice1</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                               <span class="n">lattice2</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>
            <span class="n">good_idxs</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">accum</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mincnt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mincnt</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># create accumulation arrays</span>
            <span class="n">lattice1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nx1</span><span class="p">,</span> <span class="n">ny1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny1</span><span class="p">):</span>
                    <span class="n">lattice1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">lattice2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nx2</span><span class="p">,</span> <span class="n">ny2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx2</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny2</span><span class="p">):</span>
                    <span class="n">lattice2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">bdist</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ix1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nx1</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">iy1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ny1</span><span class="p">:</span>
                        <span class="n">lattice1</span><span class="p">[</span><span class="n">ix1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">iy1</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ix2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nx2</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">iy2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ny2</span><span class="p">:</span>
                        <span class="n">lattice2</span><span class="p">[</span><span class="n">ix2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">iy2</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny1</span><span class="p">):</span>
                    <span class="n">vals</span> <span class="o">=</span> <span class="n">lattice1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">mincnt</span><span class="p">:</span>
                        <span class="n">lattice1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce_C_function</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lattice1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx2</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny2</span><span class="p">):</span>
                    <span class="n">vals</span> <span class="o">=</span> <span class="n">lattice2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">mincnt</span><span class="p">:</span>
                        <span class="n">lattice2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce_C_function</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lattice2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="n">accum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">lattice1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                               <span class="n">lattice2</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>
            <span class="n">good_idxs</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">accum</span><span class="p">)</span>

        <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">offsets</span><span class="p">[:</span><span class="n">nx1</span> <span class="o">*</span> <span class="n">ny1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nx1</span><span class="p">),</span> <span class="n">ny1</span><span class="p">)</span>
        <span class="n">offsets</span><span class="p">[:</span><span class="n">nx1</span> <span class="o">*</span> <span class="n">ny1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ny1</span><span class="p">),</span> <span class="n">nx1</span><span class="p">)</span>
        <span class="n">offsets</span><span class="p">[</span><span class="n">nx1</span> <span class="o">*</span> <span class="n">ny1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nx2</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">ny2</span><span class="p">)</span>
        <span class="n">offsets</span><span class="p">[</span><span class="n">nx1</span> <span class="o">*</span> <span class="n">ny1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ny2</span><span class="p">),</span> <span class="n">nx2</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span>
        <span class="n">offsets</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="n">sx</span>
        <span class="n">offsets</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="n">sy</span>
        <span class="n">offsets</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">xmin</span>
        <span class="n">offsets</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ymin</span>
        <span class="c1"># remove accumulation bins with no data</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="n">offsets</span><span class="p">[</span><span class="n">good_idxs</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">accum</span> <span class="o">=</span> <span class="n">accum</span><span class="p">[</span><span class="n">good_idxs</span><span class="p">]</span>

        <span class="n">polygon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">polygon</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sx</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
        <span class="n">polygon</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sy</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">])</span> <span class="o">/</span> <span class="mf">3.0</span>

        <span class="k">if</span> <span class="n">linewidths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">linewidths</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">xscale</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span> <span class="ow">or</span> <span class="n">yscale</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
            <span class="n">polygons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">offsets</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">xscale</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
                <span class="n">polygons</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">**</span> <span class="n">polygons</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">xmin</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">**</span> <span class="n">xmin</span>
                <span class="n">xmax</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">**</span> <span class="n">xmax</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="n">xscale</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">yscale</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
                <span class="n">polygons</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">**</span> <span class="n">polygons</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">ymin</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">**</span> <span class="n">ymin</span>
                <span class="n">ymax</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">**</span> <span class="n">ymax</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="n">yscale</span><span class="p">)</span>
            <span class="n">collection</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">PolyCollection</span><span class="p">(</span>
                <span class="n">polygons</span><span class="p">,</span>
                <span class="n">edgecolors</span><span class="o">=</span><span class="n">edgecolors</span><span class="p">,</span>
                <span class="n">linewidths</span><span class="o">=</span><span class="n">linewidths</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">collection</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">PolyCollection</span><span class="p">(</span>
                <span class="p">[</span><span class="n">polygon</span><span class="p">],</span>
                <span class="n">edgecolors</span><span class="o">=</span><span class="n">edgecolors</span><span class="p">,</span>
                <span class="n">linewidths</span><span class="o">=</span><span class="n">linewidths</span><span class="p">,</span>
                <span class="n">offsets</span><span class="o">=</span><span class="n">offsets</span><span class="p">,</span>
                <span class="n">transOffset</span><span class="o">=</span><span class="n">mtransforms</span><span class="o">.</span><span class="n">IdentityTransform</span><span class="p">(),</span>
                <span class="n">offset_position</span><span class="o">=</span><span class="s2">&quot;data&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Check for valid norm</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&#39;norm&#39; must be an instance of &#39;mcolors.Normalize&#39;&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># Set normalizer if bins is &#39;log&#39;</span>
        <span class="k">if</span> <span class="n">bins</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cbook</span><span class="o">.</span><span class="n">_warn_external</span><span class="p">(</span><span class="s2">&quot;Only one of &#39;bins&#39; and &#39;norm&#39; &quot;</span>
                                     <span class="s2">&quot;arguments can be supplied, ignoring &quot;</span>
                                     <span class="s2">&quot;bins=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bins</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">LogNorm</span><span class="p">()</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">LogNorm</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">accum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="c1"># make sure we have no zeros</span>
                <span class="n">accum</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># autoscale the norm with curren accum values if it hasn&#39;t</span>
        <span class="c1"># been set</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">norm</span><span class="o">.</span><span class="n">vmin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">norm</span><span class="o">.</span><span class="n">vmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">norm</span><span class="o">.</span><span class="n">autoscale</span><span class="p">(</span><span class="n">accum</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">bins</span><span class="p">):</span>
                <span class="n">minimum</span><span class="p">,</span> <span class="n">maximum</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">accum</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">accum</span><span class="p">)</span>
                <span class="n">bins</span> <span class="o">-=</span> <span class="mi">1</span>  <span class="c1"># one less edge than bins</span>
                <span class="n">bins</span> <span class="o">=</span> <span class="n">minimum</span> <span class="o">+</span> <span class="p">(</span><span class="n">maximum</span> <span class="o">-</span> <span class="n">minimum</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">/</span> <span class="n">bins</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
            <span class="n">accum</span> <span class="o">=</span> <span class="n">bins</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">accum</span><span class="p">)</span>

        <span class="n">collection</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">accum</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">vmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">autoscale_None</span><span class="p">()</span>

        <span class="n">corners</span> <span class="o">=</span> <span class="p">((</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">),</span> <span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">x</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">]</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">y</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">(</span><span class="n">tight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># add the collection last</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">marginals</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">collection</span>

        <span class="k">if</span> <span class="n">C</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">coarse_bin</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">coarse</span><span class="p">):</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">coarse</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">coarse</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">mus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coarse</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coarse</span><span class="p">)):</span>
                <span class="n">yi</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">ind</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">yi</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">mu</span> <span class="o">=</span> <span class="n">reduce_C_function</span><span class="p">(</span><span class="n">yi</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">mus</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mu</span>
            <span class="k">return</span> <span class="n">mus</span>

        <span class="n">coarse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">gridsize</span><span class="p">)</span>

        <span class="n">xcoarse</span> <span class="o">=</span> <span class="n">coarse_bin</span><span class="p">(</span><span class="n">xorig</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">coarse</span><span class="p">)</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">xcoarse</span><span class="p">)</span>
        <span class="n">verts</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xcoarse</span><span class="p">):</span>
            <span class="n">thismin</span> <span class="o">=</span> <span class="n">coarse</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">coarse</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">thismax</span> <span class="o">=</span> <span class="n">coarse</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">thismax</span> <span class="o">=</span> <span class="n">thismin</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">coarse</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="n">verts</span><span class="o">.</span><span class="n">append</span><span class="p">([(</span><span class="n">thismin</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                          <span class="p">(</span><span class="n">thismin</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">),</span>
                          <span class="p">(</span><span class="n">thismax</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">),</span>
                          <span class="p">(</span><span class="n">thismax</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xaxis_transform</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s1">&#39;grid&#39;</span><span class="p">)</span>

        <span class="n">hbar</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">PolyCollection</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">trans</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;face&#39;</span><span class="p">)</span>

        <span class="n">hbar</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">hbar</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">hbar</span><span class="o">.</span><span class="n">set_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
        <span class="n">hbar</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">hbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">hbar</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">coarse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">gridsize</span><span class="p">)</span>
        <span class="n">ycoarse</span> <span class="o">=</span> <span class="n">coarse_bin</span><span class="p">(</span><span class="n">yorig</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">coarse</span><span class="p">)</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ycoarse</span><span class="p">)</span>
        <span class="n">verts</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ycoarse</span><span class="p">):</span>
            <span class="n">thismin</span> <span class="o">=</span> <span class="n">coarse</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">coarse</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">thismax</span> <span class="o">=</span> <span class="n">coarse</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">thismax</span> <span class="o">=</span> <span class="n">thismin</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">coarse</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="n">verts</span><span class="o">.</span><span class="n">append</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="n">thismin</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">thismax</span><span class="p">),</span>
                          <span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">thismax</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">thismin</span><span class="p">)])</span>
            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_yaxis_transform</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s1">&#39;grid&#39;</span><span class="p">)</span>

        <span class="n">vbar</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">PolyCollection</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">trans</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;face&#39;</span><span class="p">)</span>
        <span class="n">vbar</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">vbar</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">vbar</span><span class="o">.</span><span class="n">set_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
        <span class="n">vbar</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">vbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">vbar</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">collection</span><span class="o">.</span><span class="n">hbar</span> <span class="o">=</span> <span class="n">hbar</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">vbar</span> <span class="o">=</span> <span class="n">vbar</span>

        <span class="k">def</span> <span class="nf">on_changed</span><span class="p">(</span><span class="n">collection</span><span class="p">):</span>
            <span class="n">hbar</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">collection</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">())</span>
            <span class="n">hbar</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="n">collection</span><span class="o">.</span><span class="n">get_clim</span><span class="p">())</span>
            <span class="n">vbar</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">collection</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">())</span>
            <span class="n">vbar</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="n">collection</span><span class="o">.</span><span class="n">get_clim</span><span class="p">())</span>

        <span class="n">collection</span><span class="o">.</span><span class="n">callbacksSM</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;changed&#39;</span><span class="p">,</span> <span class="n">on_changed</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">collection</span>

    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">arrow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an arrow to the axes.</span>

<span class="sd">        This draws an arrow from ``(x, y)`` to ``(x+dx, y+dy)``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : float</span>
<span class="sd">            The x and y coordinates of the arrow base.</span>
<span class="sd">        dx, dy : float</span>
<span class="sd">            The length of the arrow along x and y direction.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        arrow : `.FancyArrow`</span>
<span class="sd">            The created `.FancyArrow` object.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Optional kwargs (inherited from `.FancyArrow` patch) control the</span>
<span class="sd">            arrow construction and properties:</span>

<span class="sd">        %(FancyArrow)s</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The resulting arrow is affected by the axes aspect ratio and limits.</span>
<span class="sd">        This may produce an arrow whose head is not square with its stem. To</span>
<span class="sd">        create an arrow whose head is square with its stem,</span>
<span class="sd">        use :meth:`annotate` for example:</span>

<span class="sd">        &gt;&gt;&gt; ax.annotate(&quot;&quot;, xy=(0.5, 0.5), xytext=(0, 0),</span>
<span class="sd">        ...             arrowprops=dict(arrowstyle=&quot;-&gt;&quot;))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Strip away units for the underlying patch since units</span>
        <span class="c1"># do not make sense to most patch-like code</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">dy</span><span class="p">)</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">FancyArrow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span>

    <span class="k">def</span> <span class="nf">quiverkey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">qk</span> <span class="o">=</span> <span class="n">mquiver</span><span class="o">.</span><span class="n">QuiverKey</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">qk</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">qk</span>
    <span class="n">quiverkey</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">mquiver</span><span class="o">.</span><span class="n">QuiverKey</span><span class="o">.</span><span class="n">quiverkey_doc</span>

    <span class="c1"># Handle units for x and y, if they&#39;ve been passed</span>
    <span class="k">def</span> <span class="nf">_quiver_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kw</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kw</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">args</span>

    <span class="c1"># args can by a combination if X, Y, U, V, C and all should be replaced</span>
    <span class="nd">@_preprocess_data</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">quiver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="c1"># Make sure units are handled for x and y values</span>
        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quiver_units</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kw</span><span class="p">)</span>

        <span class="n">q</span> <span class="o">=</span> <span class="n">mquiver</span><span class="o">.</span><span class="n">Quiver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">q</span>
    <span class="n">quiver</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">mquiver</span><span class="o">.</span><span class="n">Quiver</span><span class="o">.</span><span class="n">quiver_doc</span>

    <span class="c1"># args can be some combination of X, Y, U, V, C and all should be replaced</span>
    <span class="nd">@_preprocess_data</span><span class="p">()</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">barbs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        %(barbs_doc)s</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure units are handled for x and y values</span>
        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quiver_units</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kw</span><span class="p">)</span>

        <span class="n">b</span> <span class="o">=</span> <span class="n">mquiver</span><span class="o">.</span><span class="n">Barbs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">b</span>

    <span class="c1"># Uses a custom implementation of data-kwarg handling in</span>
    <span class="c1"># _process_plot_var_args.</span>
    <span class="k">def</span> <span class="nf">fill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot filled polygons.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *args : sequence of x, y, [color]</span>
<span class="sd">            Each polygon is defined by the lists of *x* and *y* positions of</span>
<span class="sd">            its nodes, optionally followed by a *color* specifier. See</span>
<span class="sd">            :mod:`matplotlib.colors` for supported color specifiers. The</span>
<span class="sd">            standard color cycle is used for polygons without a color</span>
<span class="sd">            specifier.</span>

<span class="sd">            You can plot multiple polygons by providing multiple *x*, *y*,</span>
<span class="sd">            *[color]* groups.</span>

<span class="sd">            For example, each of the following is legal::</span>

<span class="sd">                ax.fill(x, y)                    # a polygon with default color</span>
<span class="sd">                ax.fill(x, y, &quot;b&quot;)               # a blue polygon</span>
<span class="sd">                ax.fill(x, y, x2, y2)            # two polygons</span>
<span class="sd">                ax.fill(x, y, &quot;b&quot;, x2, y2, &quot;r&quot;)  # a blue and a red polygon</span>

<span class="sd">        data : indexable object, optional</span>
<span class="sd">            An object with labelled data. If given, provide the label names to</span>
<span class="sd">            plot in *x* and *y*, e.g.::</span>

<span class="sd">                ax.fill(&quot;time&quot;, &quot;signal&quot;,</span>
<span class="sd">                        data={&quot;time&quot;: [0, 1, 2], &quot;signal&quot;: [0, 1, 0]})</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        a list of :class:`~matplotlib.patches.Polygon`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs : :class:`~matplotlib.patches.Polygon` properties</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Use :meth:`fill_between` if you would like to fill the region between</span>
<span class="sd">        two curves.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># For compatibility(!), get aliases from Line2D rather than Patch.</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">normalize_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="o">.</span><span class="n">_alias_map</span><span class="p">)</span>

        <span class="n">patches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_patches_for_fill</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
            <span class="n">patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">patches</span>

    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y1&quot;</span><span class="p">,</span> <span class="s2">&quot;y2&quot;</span><span class="p">,</span> <span class="s2">&quot;where&quot;</span><span class="p">])</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">fill_between</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fill the area between two horizontal curves.</span>

<span class="sd">        The curves are defined by the points (*x*, *y1*) and (*x*, *y2*). This</span>
<span class="sd">        creates one or multiple polygons describing the filled area.</span>

<span class="sd">        You may exclude some horizontal sections from filling using *where*.</span>

<span class="sd">        By default, the edges connect the given points directly. Use *step* if</span>
<span class="sd">        the filling should be a step function, i.e. constant in between *x*.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array (length N)</span>
<span class="sd">            The x coordinates of the nodes defining the curves.</span>

<span class="sd">        y1 : array (length N) or scalar</span>
<span class="sd">            The y coordinates of the nodes defining the first curve.</span>

<span class="sd">        y2 : array (length N) or scalar, optional, default: 0</span>
<span class="sd">            The y coordinates of the nodes defining the second curve.</span>

<span class="sd">        where : array of bool (length N), optional, default: None</span>
<span class="sd">            Define *where* to exclude some horizontal regions from being</span>
<span class="sd">            filled. The filled regions are defined by the coordinates</span>
<span class="sd">            ``x[where]``.  More precisely, fill between ``x[i]`` and ``x[i+1]``</span>
<span class="sd">            if ``where[i] and where[i+1]``.  Note that this definition implies</span>
<span class="sd">            that an isolated *True* value between two *False* values in</span>
<span class="sd">            *where* will not result in filling.  Both sides of the *True*</span>
<span class="sd">            position remain unfilled due to the adjacent *False* values.</span>

<span class="sd">        interpolate : bool, optional</span>
<span class="sd">            This option is only relevant if *where* is used and the two curves</span>
<span class="sd">            are crossing each other.</span>

<span class="sd">            Semantically, *where* is often used for *y1* &gt; *y2* or similar.</span>
<span class="sd">            By default, the nodes of the polygon defining the filled region</span>
<span class="sd">            will only be placed at the positions in the *x* array.  Such a</span>
<span class="sd">            polygon cannot describe the above semantics close to the</span>
<span class="sd">            intersection.  The x-sections containing the intersection are</span>
<span class="sd">            simply clipped.</span>

<span class="sd">            Setting *interpolate* to *True* will calculate the actual</span>
<span class="sd">            intersection point and extend the filled region up to this point.</span>

<span class="sd">        step : {&#39;pre&#39;, &#39;post&#39;, &#39;mid&#39;}, optional</span>
<span class="sd">            Define *step* if the filling should be a step function,</span>
<span class="sd">            i.e. constant in between *x*. The value determines where the</span>
<span class="sd">            step will occur:</span>

<span class="sd">            - &#39;pre&#39;: The y value is continued constantly to the left from</span>
<span class="sd">              every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the</span>
<span class="sd">              value ``y[i]``.</span>
<span class="sd">            - &#39;post&#39;: The y value is continued constantly to the right from</span>
<span class="sd">              every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the</span>
<span class="sd">              value ``y[i]``.</span>
<span class="sd">            - &#39;mid&#39;: Steps occur half-way between the *x* positions.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            All other keyword arguments are passed on to `.PolyCollection`.</span>
<span class="sd">            They control the `.Polygon` properties:</span>

<span class="sd">            %(PolyCollection)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `.PolyCollection`</span>
<span class="sd">            A `.PolyCollection` containing the plotted polygons.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        fill_betweenx : Fill between two sets of x-values.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. [notes section required to get data note injection right]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;_internal.classic_mode&#39;</span><span class="p">]:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">normalize_kwargs</span><span class="p">(</span>
                <span class="n">kwargs</span><span class="p">,</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">Collection</span><span class="o">.</span><span class="n">_alias_map</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">c</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="s1">&#39;facecolor&#39;</span><span class="p">)):</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;facecolor&#39;</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">_get_patches_for_fill</span><span class="o">.</span><span class="n">get_next_color</span><span class="p">()</span>

        <span class="c1"># Handle united data, such as dates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="n">y1</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">ydata</span><span class="o">=</span><span class="n">y2</span><span class="p">)</span>

        <span class="c1"># Convert the arrays so we can work with them</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">y1</span><span class="p">))</span>
        <span class="n">y2</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">y2</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">array</span> <span class="ow">in</span> <span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y1&#39;</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y2&#39;</span><span class="p">,</span> <span class="n">y2</span><span class="p">)]:</span>
            <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input passed into argument &quot;</span><span class="si">%r</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">name</span> <span class="o">+</span>
                                 <span class="s1">&#39;is not 1-dimensional.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">where</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">where</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">where</span> <span class="o">=</span> <span class="n">where</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">,</span>
                                          <span class="nb">map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmask</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">]))</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span>

        <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ind0</span><span class="p">,</span> <span class="n">ind1</span> <span class="ow">in</span> <span class="n">cbook</span><span class="o">.</span><span class="n">contiguous_regions</span><span class="p">(</span><span class="n">where</span><span class="p">):</span>
            <span class="n">xslice</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ind0</span><span class="p">:</span><span class="n">ind1</span><span class="p">]</span>
            <span class="n">y1slice</span> <span class="o">=</span> <span class="n">y1</span><span class="p">[</span><span class="n">ind0</span><span class="p">:</span><span class="n">ind1</span><span class="p">]</span>
            <span class="n">y2slice</span> <span class="o">=</span> <span class="n">y2</span><span class="p">[</span><span class="n">ind0</span><span class="p">:</span><span class="n">ind1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">step_func</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">STEP_LOOKUP_MAP</span><span class="p">[</span><span class="s2">&quot;steps-&quot;</span> <span class="o">+</span> <span class="n">step</span><span class="p">]</span>
                <span class="n">xslice</span><span class="p">,</span> <span class="n">y1slice</span><span class="p">,</span> <span class="n">y2slice</span> <span class="o">=</span> <span class="n">step_func</span><span class="p">(</span><span class="n">xslice</span><span class="p">,</span> <span class="n">y1slice</span><span class="p">,</span> <span class="n">y2slice</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">xslice</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xslice</span><span class="p">)</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">interpolate</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">get_interp_point</span><span class="p">(</span><span class="n">ind</span><span class="p">):</span>
                    <span class="n">im1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ind</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">x_values</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">im1</span><span class="p">:</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">diff_values</span> <span class="o">=</span> <span class="n">y1</span><span class="p">[</span><span class="n">im1</span><span class="p">:</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y2</span><span class="p">[</span><span class="n">im1</span><span class="p">:</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">y1_values</span> <span class="o">=</span> <span class="n">y1</span><span class="p">[</span><span class="n">im1</span><span class="p">:</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff_values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">diff_values</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">im1</span><span class="p">],</span> <span class="n">y1</span><span class="p">[</span><span class="n">im1</span><span class="p">]</span>
                        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">diff_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">y1</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>

                    <span class="n">diff_order</span> <span class="o">=</span> <span class="n">diff_values</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
                    <span class="n">diff_root_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                        <span class="mi">0</span><span class="p">,</span> <span class="n">diff_values</span><span class="p">[</span><span class="n">diff_order</span><span class="p">],</span> <span class="n">x_values</span><span class="p">[</span><span class="n">diff_order</span><span class="p">])</span>
                    <span class="n">x_order</span> <span class="o">=</span> <span class="n">x_values</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
                    <span class="n">diff_root_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">diff_root_x</span><span class="p">,</span> <span class="n">x_values</span><span class="p">[</span><span class="n">x_order</span><span class="p">],</span>
                                            <span class="n">y1_values</span><span class="p">[</span><span class="n">x_order</span><span class="p">])</span>
                    <span class="k">return</span> <span class="n">diff_root_x</span><span class="p">,</span> <span class="n">diff_root_y</span>

                <span class="n">start</span> <span class="o">=</span> <span class="n">get_interp_point</span><span class="p">(</span><span class="n">ind0</span><span class="p">)</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">get_interp_point</span><span class="p">(</span><span class="n">ind1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># the purpose of the next two lines is for when y2 is a</span>
                <span class="c1"># scalar like 0 and we want the fill to go all the way</span>
                <span class="c1"># down to 0 even if none of the y1 sample points do</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">xslice</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y2slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">xslice</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">y2slice</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span>
            <span class="n">X</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">end</span>

            <span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xslice</span>
            <span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y1slice</span>
            <span class="n">X</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xslice</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">X</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y2slice</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="n">collection</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">PolyCollection</span><span class="p">(</span><span class="n">polys</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># now update the datalim and autoscale</span>
        <span class="n">XY1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="n">where</span><span class="p">],</span> <span class="n">y1</span><span class="p">[</span><span class="n">where</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">XY2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="n">where</span><span class="p">],</span> <span class="n">y2</span><span class="p">[</span><span class="n">where</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataLim</span><span class="o">.</span><span class="n">update_from_data_xy</span><span class="p">(</span><span class="n">XY1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_existing_data_limits</span><span class="p">,</span>
                                         <span class="n">updatex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">updatey</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignore_existing_data_limits</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataLim</span><span class="o">.</span><span class="n">update_from_data_xy</span><span class="p">(</span><span class="n">XY2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_existing_data_limits</span><span class="p">,</span>
                                         <span class="n">updatex</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">updatey</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">collection</span>

    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;x1&quot;</span><span class="p">,</span> <span class="s2">&quot;x2&quot;</span><span class="p">,</span> <span class="s2">&quot;where&quot;</span><span class="p">])</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">fill_betweenx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fill the area between two vertical curves.</span>

<span class="sd">        The curves are defined by the points (*x1*, *y*) and (*x2*, *y*). This</span>
<span class="sd">        creates one or multiple polygons describing the filled area.</span>

<span class="sd">        You may exclude some vertical sections from filling using *where*.</span>

<span class="sd">        By default, the edges connect the given points directly. Use *step* if</span>
<span class="sd">        the filling should be a step function, i.e. constant in between *y*.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : array (length N)</span>
<span class="sd">            The y coordinates of the nodes defining the curves.</span>

<span class="sd">        x1 : array (length N) or scalar</span>
<span class="sd">            The x coordinates of the nodes defining the first curve.</span>

<span class="sd">        x2 : array (length N) or scalar, optional, default: 0</span>
<span class="sd">            The x coordinates of the nodes defining the second curve.</span>

<span class="sd">        where : array of bool (length N), optional, default: None</span>
<span class="sd">            Define *where* to exclude some vertical regions from being</span>
<span class="sd">            filled. The filled regions are defined by the coordinates</span>
<span class="sd">            ``y[where]``.  More precisely, fill between ``y[i]`` and ``y[i+1]``</span>
<span class="sd">            if ``where[i] and where[i+1]``.  Note that this definition implies</span>
<span class="sd">            that an isolated *True* value between two *False* values in</span>
<span class="sd">            *where* will not result in filling.  Both sides of the *True*</span>
<span class="sd">            position remain unfilled due to the adjacent *False* values.</span>

<span class="sd">        interpolate : bool, optional</span>
<span class="sd">            This option is only relevant if *where* is used and the two curves</span>
<span class="sd">            are crossing each other.</span>

<span class="sd">            Semantically, *where* is often used for *x1* &gt; *x2* or similar.</span>
<span class="sd">            By default, the nodes of the polygon defining the filled region</span>
<span class="sd">            will only be placed at the positions in the *y* array.  Such a</span>
<span class="sd">            polygon cannot describe the above semantics close to the</span>
<span class="sd">            intersection.  The y-sections containing the intersection are</span>
<span class="sd">            simply clipped.</span>

<span class="sd">            Setting *interpolate* to *True* will calculate the actual</span>
<span class="sd">            intersection point and extend the filled region up to this point.</span>

<span class="sd">        step : {&#39;pre&#39;, &#39;post&#39;, &#39;mid&#39;}, optional</span>
<span class="sd">            Define *step* if the filling should be a step function,</span>
<span class="sd">            i.e. constant in between *y*. The value determines where the</span>
<span class="sd">            step will occur:</span>

<span class="sd">            - &#39;pre&#39;: The y value is continued constantly to the left from</span>
<span class="sd">              every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the</span>
<span class="sd">              value ``y[i]``.</span>
<span class="sd">            - &#39;post&#39;: The y value is continued constantly to the right from</span>
<span class="sd">              every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the</span>
<span class="sd">              value ``y[i]``.</span>
<span class="sd">            - &#39;mid&#39;: Steps occur half-way between the *x* positions.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            All other keyword arguments are passed on to `.PolyCollection`.</span>
<span class="sd">            They control the `.Polygon` properties:</span>

<span class="sd">            %(PolyCollection)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `.PolyCollection`</span>
<span class="sd">            A `.PolyCollection` containing the plotted polygons.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        fill_between : Fill between two sets of y-values.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. [notes section required to get data note injection right]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;_internal.classic_mode&#39;</span><span class="p">]:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">normalize_kwargs</span><span class="p">(</span>
                <span class="n">kwargs</span><span class="p">,</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">Collection</span><span class="o">.</span><span class="n">_alias_map</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">c</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="s1">&#39;facecolor&#39;</span><span class="p">)):</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;facecolor&#39;</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">_get_patches_for_fill</span><span class="o">.</span><span class="n">get_next_color</span><span class="p">()</span>

        <span class="c1"># Handle united data, such as dates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">ydata</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">xdata</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">x2</span><span class="p">)</span>

        <span class="c1"># Convert the arrays so we can work with them</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">x1</span><span class="p">))</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">x2</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">array</span> <span class="ow">in</span> <span class="p">[(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;x1&#39;</span><span class="p">,</span> <span class="n">x1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;x2&#39;</span><span class="p">,</span> <span class="n">x2</span><span class="p">)]:</span>
            <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input passed into argument &quot;</span><span class="si">%r</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">name</span> <span class="o">+</span>
                                 <span class="s1">&#39;is not 1-dimensional.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">where</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">where</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">where</span> <span class="o">=</span> <span class="n">where</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">,</span>
                                          <span class="nb">map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmask</span><span class="p">,</span> <span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">]))</span>

        <span class="n">y</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>

        <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ind0</span><span class="p">,</span> <span class="n">ind1</span> <span class="ow">in</span> <span class="n">cbook</span><span class="o">.</span><span class="n">contiguous_regions</span><span class="p">(</span><span class="n">where</span><span class="p">):</span>
            <span class="n">yslice</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">ind0</span><span class="p">:</span><span class="n">ind1</span><span class="p">]</span>
            <span class="n">x1slice</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="n">ind0</span><span class="p">:</span><span class="n">ind1</span><span class="p">]</span>
            <span class="n">x2slice</span> <span class="o">=</span> <span class="n">x2</span><span class="p">[</span><span class="n">ind0</span><span class="p">:</span><span class="n">ind1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">step_func</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">STEP_LOOKUP_MAP</span><span class="p">[</span><span class="s2">&quot;steps-&quot;</span> <span class="o">+</span> <span class="n">step</span><span class="p">]</span>
                <span class="n">yslice</span><span class="p">,</span> <span class="n">x1slice</span><span class="p">,</span> <span class="n">x2slice</span> <span class="o">=</span> <span class="n">step_func</span><span class="p">(</span><span class="n">yslice</span><span class="p">,</span> <span class="n">x1slice</span><span class="p">,</span> <span class="n">x2slice</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">yslice</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">yslice</span><span class="p">)</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">interpolate</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">get_interp_point</span><span class="p">(</span><span class="n">ind</span><span class="p">):</span>
                    <span class="n">im1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ind</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">y_values</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">im1</span><span class="p">:</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">diff_values</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="n">im1</span><span class="p">:</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x2</span><span class="p">[</span><span class="n">im1</span><span class="p">:</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">x1_values</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="n">im1</span><span class="p">:</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff_values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">diff_values</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                            <span class="k">return</span> <span class="n">x1</span><span class="p">[</span><span class="n">im1</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">im1</span><span class="p">]</span>
                        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">diff_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                            <span class="k">return</span> <span class="n">x1</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>

                    <span class="n">diff_order</span> <span class="o">=</span> <span class="n">diff_values</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
                    <span class="n">diff_root_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                        <span class="mi">0</span><span class="p">,</span> <span class="n">diff_values</span><span class="p">[</span><span class="n">diff_order</span><span class="p">],</span> <span class="n">y_values</span><span class="p">[</span><span class="n">diff_order</span><span class="p">])</span>
                    <span class="n">y_order</span> <span class="o">=</span> <span class="n">y_values</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
                    <span class="n">diff_root_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">diff_root_y</span><span class="p">,</span> <span class="n">y_values</span><span class="p">[</span><span class="n">y_order</span><span class="p">],</span>
                                            <span class="n">x1_values</span><span class="p">[</span><span class="n">y_order</span><span class="p">])</span>
                    <span class="k">return</span> <span class="n">diff_root_x</span><span class="p">,</span> <span class="n">diff_root_y</span>

                <span class="n">start</span> <span class="o">=</span> <span class="n">get_interp_point</span><span class="p">(</span><span class="n">ind0</span><span class="p">)</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">get_interp_point</span><span class="p">(</span><span class="n">ind1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># the purpose of the next two lines is for when x2 is a</span>
                <span class="c1"># scalar like 0 and we want the fill to go all the way</span>
                <span class="c1"># down to 0 even if none of the x1 sample points do</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">x2slice</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">yslice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">x2slice</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">yslice</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">Y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span>
            <span class="n">Y</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">end</span>

            <span class="n">Y</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x1slice</span>
            <span class="n">Y</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">yslice</span>
            <span class="n">Y</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x2slice</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">Y</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">yslice</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>

        <span class="n">collection</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">PolyCollection</span><span class="p">(</span><span class="n">polys</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># now update the datalim and autoscale</span>
        <span class="n">X1Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x1</span><span class="p">[</span><span class="n">where</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">where</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">X2Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x2</span><span class="p">[</span><span class="n">where</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">where</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataLim</span><span class="o">.</span><span class="n">update_from_data_xy</span><span class="p">(</span><span class="n">X1Y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_existing_data_limits</span><span class="p">,</span>
                                         <span class="n">updatex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">updatey</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignore_existing_data_limits</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataLim</span><span class="o">.</span><span class="n">update_from_data_xy</span><span class="p">(</span><span class="n">X2Y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_existing_data_limits</span><span class="p">,</span>
                                         <span class="n">updatex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">updatey</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">collection</span>

    <span class="c1">#### plotting z(x,y): imshow, pcolor and relatives, contour</span>
    <span class="nd">@_preprocess_data</span><span class="p">()</span>
    <span class="nd">@cbook</span><span class="o">.</span><span class="n">_delete_parameter</span><span class="p">(</span><span class="s2">&quot;3.1&quot;</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">)</span>
    <span class="nd">@cbook</span><span class="o">.</span><span class="n">_delete_parameter</span><span class="p">(</span><span class="s2">&quot;3.1&quot;</span><span class="p">,</span> <span class="s2">&quot;imlim&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">imshow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">interpolation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filternorm</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
               <span class="n">filterrad</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span> <span class="n">imlim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">url</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display an image, i.e. data on a 2D regular raster.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array-like or PIL image</span>
<span class="sd">            The image data. Supported array shapes are:</span>

<span class="sd">            - (M, N): an image with scalar data. The data is visualized</span>
<span class="sd">              using a colormap.</span>
<span class="sd">            - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).</span>
<span class="sd">            - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),</span>
<span class="sd">              i.e. including transparency.</span>

<span class="sd">            The first two dimensions (M, N) define the rows and columns of</span>
<span class="sd">            the image.</span>

<span class="sd">            Out-of-range RGB(A) values are clipped.</span>

<span class="sd">        cmap : str or `~matplotlib.colors.Colormap`, optional</span>
<span class="sd">            The Colormap instance or registered colormap name used to map</span>
<span class="sd">            scalar data to colors. This parameter is ignored for RGB(A) data.</span>
<span class="sd">            Defaults to :rc:`image.cmap`.</span>

<span class="sd">        norm : `~matplotlib.colors.Normalize`, optional</span>
<span class="sd">            The `Normalize` instance used to scale scalar data to the [0, 1]</span>
<span class="sd">            range before mapping to colors using *cmap*. By default, a linear</span>
<span class="sd">            scaling mapping the lowest value to 0 and the highest to 1 is used.</span>
<span class="sd">            This parameter is ignored for RGB(A) data.</span>

<span class="sd">        aspect : {&#39;equal&#39;, &#39;auto&#39;} or float, optional</span>
<span class="sd">            Controls the aspect ratio of the axes. The aspect is of particular</span>
<span class="sd">            relevance for images since it may distort the image, i.e. pixel</span>
<span class="sd">            will not be square.</span>

<span class="sd">            This parameter is a shortcut for explicitly calling</span>
<span class="sd">            `.Axes.set_aspect`. See there for further details.</span>

<span class="sd">            - &#39;equal&#39;: Ensures an aspect ratio of 1. Pixels will be square</span>
<span class="sd">              (unless pixel sizes are explicitly made non-square in data</span>
<span class="sd">              coordinates using *extent*).</span>
<span class="sd">            - &#39;auto&#39;: The axes is kept fixed and the aspect is adjusted so</span>
<span class="sd">              that the data fit in the axes. In general, this will result in</span>
<span class="sd">              non-square pixels.</span>

<span class="sd">            If not given, use :rc:`image.aspect` (default: &#39;equal&#39;).</span>

<span class="sd">        interpolation : str, optional</span>
<span class="sd">            The interpolation method used. If *None*</span>
<span class="sd">            :rc:`image.interpolation` is used, which defaults to &#39;nearest&#39;.</span>

<span class="sd">            Supported values are &#39;none&#39;, &#39;nearest&#39;, &#39;bilinear&#39;, &#39;bicubic&#39;,</span>
<span class="sd">            &#39;spline16&#39;, &#39;spline36&#39;, &#39;hanning&#39;, &#39;hamming&#39;, &#39;hermite&#39;, &#39;kaiser&#39;,</span>
<span class="sd">            &#39;quadric&#39;, &#39;catrom&#39;, &#39;gaussian&#39;, &#39;bessel&#39;, &#39;mitchell&#39;, &#39;sinc&#39;,</span>
<span class="sd">            &#39;lanczos&#39;.</span>

<span class="sd">            If *interpolation* is &#39;none&#39;, then no interpolation is performed</span>
<span class="sd">            on the Agg, ps, pdf and svg backends. Other backends will fall back</span>
<span class="sd">            to &#39;nearest&#39;. Note that most SVG renders perform interpolation at</span>
<span class="sd">            rendering and that the default interpolation method they implement</span>
<span class="sd">            may differ.</span>

<span class="sd">            See</span>
<span class="sd">            :doc:`/gallery/images_contours_and_fields/interpolation_methods`</span>
<span class="sd">            for an overview of the supported interpolation methods.</span>

<span class="sd">            Some interpolation methods require an additional radius parameter,</span>
<span class="sd">            which can be set by *filterrad*. Additionally, the antigrain image</span>
<span class="sd">            resize filter is controlled by the parameter *filternorm*.</span>

<span class="sd">        alpha : scalar, optional</span>
<span class="sd">            The alpha blending value, between 0 (transparent) and 1 (opaque).</span>
<span class="sd">            This parameter is ignored for RGBA input data.</span>

<span class="sd">        vmin, vmax : scalar, optional</span>
<span class="sd">            When using scalar data and no explicit *norm*, *vmin* and *vmax*</span>
<span class="sd">            define the data range that the colormap covers. By default,</span>
<span class="sd">            the colormap covers the complete value range of the supplied</span>
<span class="sd">            data. *vmin*, *vmax* are ignored if the *norm* parameter is used.</span>

<span class="sd">        origin : {&#39;upper&#39;, &#39;lower&#39;}, optional</span>
<span class="sd">            Place the [0,0] index of the array in the upper left or lower left</span>
<span class="sd">            corner of the axes. The convention &#39;upper&#39; is typically used for</span>
<span class="sd">            matrices and images.</span>
<span class="sd">            If not given, :rc:`image.origin` is used, defaulting to &#39;upper&#39;.</span>

<span class="sd">            Note that the vertical axes points upward for &#39;lower&#39;</span>
<span class="sd">            but downward for &#39;upper&#39;.</span>

<span class="sd">            See the :doc:`/tutorials/intermediate/imshow_extent` tutorial for</span>
<span class="sd">            examples and a more detailed description.</span>

<span class="sd">        extent : scalars (left, right, bottom, top), optional</span>
<span class="sd">            The bounding box in data coordinates that the image will fill.</span>
<span class="sd">            The image is stretched individually along x and y to fill the box.</span>

<span class="sd">            The default extent is determined by the following conditions.</span>
<span class="sd">            Pixels have unit size in data coordinates. Their centers are on</span>
<span class="sd">            integer coordinates, and their center coordinates range from 0 to</span>
<span class="sd">            columns-1 horizontally and from 0 to rows-1 vertically.</span>

<span class="sd">            Note that the direction of the vertical axis and thus the default</span>
<span class="sd">            values for top and bottom depend on *origin*:</span>

<span class="sd">            - For ``origin == &#39;upper&#39;`` the default is</span>
<span class="sd">              ``(-0.5, numcols-0.5, numrows-0.5, -0.5)``.</span>
<span class="sd">            - For ``origin == &#39;lower&#39;`` the default is</span>
<span class="sd">              ``(-0.5, numcols-0.5, -0.5, numrows-0.5)``.</span>

<span class="sd">            See the :doc:`/tutorials/intermediate/imshow_extent` tutorial for</span>
<span class="sd">            examples and a more detailed description.</span>

<span class="sd">        filternorm : bool, optional, default: True</span>
<span class="sd">            A parameter for the antigrain image resize filter (see the</span>
<span class="sd">            antigrain documentation).  If *filternorm* is set, the filter</span>
<span class="sd">            normalizes integer values and corrects the rounding errors. It</span>
<span class="sd">            doesn&#39;t do anything with the source floating point values, it</span>
<span class="sd">            corrects only integers according to the rule of 1.0 which means</span>
<span class="sd">            that any sum of pixel weights must be equal to 1.0.  So, the</span>
<span class="sd">            filter function must produce a graph of the proper shape.</span>

<span class="sd">        filterrad : float &gt; 0, optional, default: 4.0</span>
<span class="sd">            The filter radius for filters that have a radius parameter, i.e.</span>
<span class="sd">            when interpolation is one of: &#39;sinc&#39;, &#39;lanczos&#39; or &#39;blackman&#39;.</span>

<span class="sd">        resample : bool, optional</span>
<span class="sd">            When *True*, use a full resampling method.  When *False*, only</span>
<span class="sd">            resample when the output image is larger than the input image.</span>

<span class="sd">        url : str, optional</span>
<span class="sd">            Set the url of the created `.AxesImage`. See `.Artist.set_url`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        image : `~matplotlib.image.AxesImage`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs : `~matplotlib.artist.Artist` properties</span>
<span class="sd">            These parameters are passed on to the constructor of the</span>
<span class="sd">            `.AxesImage` artist.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        matshow : Plot a matrix or an array as an image.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Unless *extent* is used, pixel centers will be located at integer</span>
<span class="sd">        coordinates. In other words: the origin will coincide with the center</span>
<span class="sd">        of pixel (0, 0).</span>

<span class="sd">        There are two common representations for RGB images with an alpha</span>
<span class="sd">        channel:</span>

<span class="sd">        -   Straight (unassociated) alpha: R, G, and B channels represent the</span>
<span class="sd">            color of the pixel, disregarding its opacity.</span>
<span class="sd">        -   Premultiplied (associated) alpha: R, G, and B channels represent</span>
<span class="sd">            the color of the pixel, adjusted for its opacity by multiplication.</span>

<span class="sd">        `~matplotlib.pyplot.imshow` expects RGB images adopting the straight</span>
<span class="sd">        (unassociated) alpha representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;norm&#39; must be an instance of &#39;mcolors.Normalize&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">aspect</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">aspect</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;image.aspect&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="n">aspect</span><span class="p">)</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">mimage</span><span class="o">.</span><span class="n">AxesImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">interpolation</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">extent</span><span class="p">,</span>
                              <span class="n">filternorm</span><span class="o">=</span><span class="n">filternorm</span><span class="p">,</span> <span class="n">filterrad</span><span class="o">=</span><span class="n">filterrad</span><span class="p">,</span>
                              <span class="n">resample</span><span class="o">=</span><span class="n">resample</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">im</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">im</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">get_clip_path</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># image does not already have clipping set, clip to axes patch</span>
            <span class="n">im</span><span class="o">.</span><span class="n">set_clip_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">patch</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">im</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">im</span><span class="o">.</span><span class="n">autoscale_None</span><span class="p">()</span>
        <span class="n">im</span><span class="o">.</span><span class="n">set_url</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>

        <span class="c1"># update ax.dataLim, and, if autoscaling, set viewLim</span>
        <span class="c1"># to tightly fit the image, regardless of dataLim.</span>
        <span class="n">im</span><span class="o">.</span><span class="n">set_extent</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">get_extent</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_image</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">im</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_pcolorargs</span><span class="p">(</span><span class="n">funcname</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">allmatch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># If allmatch is True, then the incoming X, Y, C must have matching</span>
        <span class="c1"># dimensions, taking into account that X and Y can be 1-D rather than</span>
        <span class="c1"># 2-D.  This perfect match is required for Gouraud shading.  For flat</span>
        <span class="c1"># shading, X and Y specify boundaries, so we need one more boundary</span>
        <span class="c1"># than color in each direction.  For convenience, and consistent with</span>
        <span class="c1"># Matlab, we discard the last row and/or column of C if necessary to</span>
        <span class="c1"># meet this condition.  This is done if allmatch is False.</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">numRows</span><span class="p">,</span> <span class="n">numCols</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="n">allmatch</span><span class="p">:</span>
                <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numCols</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numRows</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numCols</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                                   <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numRows</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safe_masked_invalid</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">C</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># Check x and y for bad data...</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="p">[</span><span class="n">cbook</span><span class="o">.</span><span class="n">safe_masked_invalid</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[:</span><span class="mi">2</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">funcname</span> <span class="o">==</span> <span class="s1">&#39;pcolormesh&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">Y</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;x and y arguments to pcolormesh cannot have &#39;</span>
                        <span class="s1">&#39;non-finite values or be of type &#39;</span>
                        <span class="s1">&#39;numpy.ma.core.MaskedArray with masked values&#39;</span><span class="p">)</span>
                <span class="c1"># safe_masked_invalid() returns an ndarray for dtypes other</span>
                <span class="c1"># than floating point.</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
                    <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">data</span>  <span class="c1"># strip mask as downstream doesn&#39;t like it...</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
                    <span class="n">Y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">data</span>
            <span class="n">numRows</span><span class="p">,</span> <span class="n">numCols</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;Illegal arguments to </span><span class="si">%s</span><span class="s1">; see help(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">funcname</span><span class="p">,</span> <span class="n">funcname</span><span class="p">))</span>

        <span class="n">Nx</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Ny</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">)</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">Ny</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Ny</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;Incompatible X, Y inputs to </span><span class="si">%s</span><span class="s1">; see help(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">funcname</span><span class="p">,</span> <span class="n">funcname</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">allmatch</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">numCols</span><span class="p">,</span> <span class="n">numRows</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Dimensions of C </span><span class="si">%s</span><span class="s1"> are incompatible with&#39;</span>
                                <span class="s1">&#39; X (</span><span class="si">%d</span><span class="s1">) and/or Y (</span><span class="si">%d</span><span class="s1">); see help(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span>
                                    <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">funcname</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">numCols</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">numRows</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Ny</span><span class="p">,</span> <span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Dimensions of C </span><span class="si">%s</span><span class="s1"> are incompatible with&#39;</span>
                                <span class="s1">&#39; X (</span><span class="si">%d</span><span class="s1">) and/or Y (</span><span class="si">%d</span><span class="s1">); see help(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span>
                                    <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">funcname</span><span class="p">))</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">C</span><span class="p">[:</span><span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safe_masked_invalid</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">C</span>

    <span class="nd">@_preprocess_data</span><span class="p">()</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">pcolor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a pseudocolor plot with a non-regular rectangular grid.</span>

<span class="sd">        Call signature::</span>

<span class="sd">            pcolor([X, Y,] C, **kwargs)</span>

<span class="sd">        *X* and *Y* can be used to specify the corners of the quadrilaterals.</span>

<span class="sd">        .. hint::</span>

<span class="sd">            ``pcolor()`` can be very slow for large arrays. In most</span>
<span class="sd">            cases you should use the similar but much faster</span>
<span class="sd">            `~.Axes.pcolormesh` instead. See there for a discussion of the</span>
<span class="sd">            differences.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        C : array_like</span>
<span class="sd">            A scalar 2-D array. The values will be color-mapped.</span>

<span class="sd">        X, Y : array_like, optional</span>
<span class="sd">            The coordinates of the quadrilateral corners. The quadrilateral</span>
<span class="sd">            for ``C[i,j]`` has corners at::</span>

<span class="sd">                (X[i+1, j], Y[i+1, j])          (X[i+1, j+1], Y[i+1, j+1])</span>
<span class="sd">                                      +--------+</span>
<span class="sd">                                      | C[i,j] |</span>
<span class="sd">                                      +--------+</span>
<span class="sd">                    (X[i, j], Y[i, j])          (X[i, j+1], Y[i, j+1]),</span>

<span class="sd">            Note that the column index corresponds to the</span>
<span class="sd">            x-coordinate, and the row index corresponds to y. For</span>
<span class="sd">            details, see the :ref:`Notes &lt;axes-pcolor-grid-orientation&gt;`</span>
<span class="sd">            section below.</span>

<span class="sd">            The dimensions of *X* and *Y* should be one greater than those of</span>
<span class="sd">            *C*. Alternatively, *X*, *Y* and *C* may have equal dimensions, in</span>
<span class="sd">            which case the last row and column of *C* will be ignored.</span>

<span class="sd">            If *X* and/or *Y* are 1-D arrays or column vectors they will be</span>
<span class="sd">            expanded as needed into the appropriate 2-D arrays, making a</span>
<span class="sd">            rectangular grid.</span>

<span class="sd">        cmap : str or `~matplotlib.colors.Colormap`, optional</span>
<span class="sd">            A Colormap instance or registered colormap name. The colormap</span>
<span class="sd">            maps the *C* values to colors. Defaults to :rc:`image.cmap`.</span>

<span class="sd">        norm : `~matplotlib.colors.Normalize`, optional</span>
<span class="sd">            The Normalize instance scales the data values to the canonical</span>
<span class="sd">            colormap range [0, 1] for mapping to colors. By default, the data</span>
<span class="sd">            range is mapped to the colorbar range using linear scaling.</span>

<span class="sd">        vmin, vmax : scalar, optional, default: None</span>
<span class="sd">            The colorbar range. If *None*, suitable min/max values are</span>
<span class="sd">            automatically chosen by the `~.Normalize` instance (defaults to</span>
<span class="sd">            the respective min/max values of *C* in case of the default linear</span>
<span class="sd">            scaling).</span>

<span class="sd">        edgecolors : {&#39;none&#39;, None, &#39;face&#39;, color, color sequence}, optional</span>
<span class="sd">            The color of the edges. Defaults to &#39;none&#39;. Possible values:</span>

<span class="sd">            - &#39;none&#39; or &#39;&#39;: No edge.</span>
<span class="sd">            - *None*: :rc:`patch.edgecolor` will be used. Note that currently</span>
<span class="sd">              :rc:`patch.force_edgecolor` has to be True for this to work.</span>
<span class="sd">            - &#39;face&#39;: Use the adjacent face color.</span>
<span class="sd">            - An mpl color or sequence of colors will set the edge color.</span>

<span class="sd">            The singular form *edgecolor* works as an alias.</span>

<span class="sd">        alpha : scalar, optional, default: None</span>
<span class="sd">            The alpha blending value of the face color, between 0 (transparent)</span>
<span class="sd">            and 1 (opaque). Note: The edgecolor is currently not affected by</span>
<span class="sd">            this.</span>

<span class="sd">        snap : bool, optional, default: False</span>
<span class="sd">            Whether to snap the mesh to pixel boundaries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        collection : `matplotlib.collections.Collection`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        antialiaseds : bool, optional, default: False</span>
<span class="sd">            The default *antialiaseds* is False if the default</span>
<span class="sd">            *edgecolors*\ =&quot;none&quot; is used.  This eliminates artificial lines</span>
<span class="sd">            at patch boundaries, and works regardless of the value of alpha.</span>
<span class="sd">            If *edgecolors* is not &quot;none&quot;, then the default *antialiaseds*</span>
<span class="sd">            is taken from :rc:`patch.antialiased`, which defaults to True.</span>
<span class="sd">            Stroking the edges may be preferred if *alpha* is 1, but will</span>
<span class="sd">            cause artifacts otherwise.</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Additionally, the following arguments are allowed. They are passed</span>
<span class="sd">            along to the `~matplotlib.collections.PolyCollection` constructor:</span>

<span class="sd">        %(PolyCollection)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pcolormesh : for an explanation of the differences between</span>
<span class="sd">            pcolor and pcolormesh.</span>
<span class="sd">        imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a</span>
<span class="sd">            faster alternative.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        **Masked arrays**</span>

<span class="sd">        *X*, *Y* and *C* may be masked arrays. If either ``C[i, j]``, or one</span>
<span class="sd">        of the vertices surrounding ``C[i,j]`` (*X* or *Y* at</span>
<span class="sd">        ``[i, j], [i+1, j], [i, j+1], [i+1, j+1]``) is masked, nothing is</span>
<span class="sd">        plotted.</span>

<span class="sd">        .. _axes-pcolor-grid-orientation:</span>

<span class="sd">        **Grid orientation**</span>

<span class="sd">        The grid orientation follows the standard matrix convention: An array</span>
<span class="sd">        *C* with shape (nrows, ncolumns) is plotted with the column number as</span>
<span class="sd">        *X* and the row number as *Y*.</span>

<span class="sd">        **Handling of pcolor() end-cases**</span>

<span class="sd">        ``pcolor()`` displays all columns of *C* if *X* and *Y* are not</span>
<span class="sd">        specified, or if *X* and *Y* have one more column than *C*.</span>
<span class="sd">        If *X* and *Y* have the same number of columns as *C* then the last</span>
<span class="sd">        column of *C* is dropped. Similarly for the rows.</span>

<span class="sd">        Note: This behavior is different from MATLAB&#39;s ``pcolor()``, which</span>
<span class="sd">        always discards the last row and column of *C*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pcolorargs</span><span class="p">(</span><span class="s1">&#39;pcolor&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">allmatch</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># unit conversion allows e.g. datetime objects as axis values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>

        <span class="c1"># convert to MA, if necessary.</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
        <span class="n">xymask</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">+</span>
                  <span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># don&#39;t plot if C or any of the surrounding vertices are masked.</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="o">+</span> <span class="n">xymask</span>

        <span class="n">unmask</span> <span class="o">=</span> <span class="o">~</span><span class="n">mask</span>
        <span class="n">X1</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">X</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="n">unmask</span><span class="p">]</span>
        <span class="n">Y1</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">Y</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="n">unmask</span><span class="p">]</span>
        <span class="n">X2</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="n">unmask</span><span class="p">]</span>
        <span class="n">Y2</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="n">unmask</span><span class="p">]</span>
        <span class="n">X3</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:])[</span><span class="n">unmask</span><span class="p">]</span>
        <span class="n">Y3</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:])[</span><span class="n">unmask</span><span class="p">]</span>
        <span class="n">X4</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">X</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:])[</span><span class="n">unmask</span><span class="p">]</span>
        <span class="n">Y4</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">Y</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:])[</span><span class="n">unmask</span><span class="p">]</span>
        <span class="n">npoly</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X1</span><span class="p">)</span>

        <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">X1</span><span class="p">,</span> <span class="n">Y1</span><span class="p">,</span> <span class="n">X2</span><span class="p">,</span> <span class="n">Y2</span><span class="p">,</span> <span class="n">X3</span><span class="p">,</span> <span class="n">Y3</span><span class="p">,</span> <span class="n">X4</span><span class="p">,</span> <span class="n">Y4</span><span class="p">,</span> <span class="n">X1</span><span class="p">,</span> <span class="n">Y1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">verts</span> <span class="o">=</span> <span class="n">xy</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">npoly</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="n">C</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">C</span><span class="p">[:</span><span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])[</span><span class="n">unmask</span><span class="p">]</span>

        <span class="n">linewidths</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.25</span><span class="p">,)</span>
        <span class="k">if</span> <span class="s1">&#39;linewidth&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;linewidths&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;linewidth&#39;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;linewidths&#39;</span><span class="p">,</span> <span class="n">linewidths</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;edgecolor&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edgecolors&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;edgecolor&#39;</span><span class="p">)</span>
        <span class="n">ec</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;edgecolors&#39;</span><span class="p">,</span> <span class="s1">&#39;none&#39;</span><span class="p">)</span>

        <span class="c1"># aa setting will default via collections to patch.antialiased</span>
        <span class="c1"># unless the boundary is not stroked, in which case the</span>
        <span class="c1"># default will be False; with unstroked boundaries, aa</span>
        <span class="c1"># makes artifacts that are often disturbing.</span>
        <span class="k">if</span> <span class="s1">&#39;antialiased&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;antialiaseds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;antialiased&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;antialiaseds&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">cbook</span><span class="o">.</span><span class="n">_str_lower_equal</span><span class="p">(</span><span class="n">ec</span><span class="p">,</span> <span class="s2">&quot;none&quot;</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;antialiaseds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;snap&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">collection</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">PolyCollection</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">collection</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;norm&#39; must be an instance of &#39;mcolors.Normalize&#39;&quot;</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">autoscale_None</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>

        <span class="c1"># Transform from native to data coordinates?</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">_transform</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">mtransforms</span><span class="o">.</span><span class="n">Transform</span><span class="p">)</span> <span class="ow">and</span>
            <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;_as_mpl_transform&#39;</span><span class="p">)):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">_as_mpl_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">t</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">contains_branch_seperately</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transData</span><span class="p">)):</span>
            <span class="n">trans_to_data</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">transData</span>
            <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">transformed_pts</span> <span class="o">=</span> <span class="n">trans_to_data</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">transformed_pts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">transformed_pts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">minx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">maxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">miny</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">maxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">x</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">minx</span><span class="p">,</span> <span class="n">maxx</span><span class="p">]</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">y</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">miny</span><span class="p">,</span> <span class="n">maxy</span><span class="p">]</span>
        <span class="n">corners</span> <span class="o">=</span> <span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">),</span> <span class="p">(</span><span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">collection</span>

    <span class="nd">@_preprocess_data</span><span class="p">()</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">pcolormesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="s1">&#39;flat&#39;</span><span class="p">,</span> <span class="n">antialiased</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a pseudocolor plot with a non-regular rectangular grid.</span>

<span class="sd">        Call signature::</span>

<span class="sd">            pcolor([X, Y,] C, **kwargs)</span>

<span class="sd">        *X* and *Y* can be used to specify the corners of the quadrilaterals.</span>

<span class="sd">        .. note::</span>

<span class="sd">           ``pcolormesh()`` is similar to :func:`~Axes.pcolor`. It&#39;s much</span>
<span class="sd">           faster and preferred in most cases. For a detailed discussion on</span>
<span class="sd">           the differences see</span>
<span class="sd">           :ref:`Differences between pcolor() and pcolormesh()</span>
<span class="sd">           &lt;differences-pcolor-pcolormesh&gt;`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        C : array_like</span>
<span class="sd">            A scalar 2-D array. The values will be color-mapped.</span>

<span class="sd">        X, Y : array_like, optional</span>
<span class="sd">            The coordinates of the quadrilateral corners. The quadrilateral</span>
<span class="sd">            for ``C[i,j]`` has corners at::</span>

<span class="sd">                (X[i+1, j], Y[i+1, j])          (X[i+1, j+1], Y[i+1, j+1])</span>
<span class="sd">                                      +--------+</span>
<span class="sd">                                      | C[i,j] |</span>
<span class="sd">                                      +--------+</span>
<span class="sd">                    (X[i, j], Y[i, j])          (X[i, j+1], Y[i, j+1]),</span>

<span class="sd">            Note that the column index corresponds to the</span>
<span class="sd">            x-coordinate, and the row index corresponds to y. For</span>
<span class="sd">            details, see the :ref:`Notes &lt;axes-pcolormesh-grid-orientation&gt;`</span>
<span class="sd">            section below.</span>

<span class="sd">            The dimensions of *X* and *Y* should be one greater than those of</span>
<span class="sd">            *C*. Alternatively, *X*, *Y* and *C* may have equal dimensions, in</span>
<span class="sd">            which case the last row and column of *C* will be ignored.</span>

<span class="sd">            If *X* and/or *Y* are 1-D arrays or column vectors they will be</span>
<span class="sd">            expanded as needed into the appropriate 2-D arrays, making a</span>
<span class="sd">            rectangular grid.</span>

<span class="sd">        cmap : str or `~matplotlib.colors.Colormap`, optional</span>
<span class="sd">            A Colormap instance or registered colormap name. The colormap</span>
<span class="sd">            maps the *C* values to colors. Defaults to :rc:`image.cmap`.</span>

<span class="sd">        norm : `~matplotlib.colors.Normalize`, optional</span>
<span class="sd">            The Normalize instance scales the data values to the canonical</span>
<span class="sd">            colormap range [0, 1] for mapping to colors. By default, the data</span>
<span class="sd">            range is mapped to the colorbar range using linear scaling.</span>

<span class="sd">        vmin, vmax : scalar, optional, default: None</span>
<span class="sd">            The colorbar range. If *None*, suitable min/max values are</span>
<span class="sd">            automatically chosen by the `~.Normalize` instance (defaults to</span>
<span class="sd">            the respective min/max values of *C* in case of the default linear</span>
<span class="sd">            scaling).</span>

<span class="sd">        edgecolors : {&#39;none&#39;, None, &#39;face&#39;, color, color sequence}, optional</span>
<span class="sd">            The color of the edges. Defaults to &#39;none&#39;. Possible values:</span>

<span class="sd">            - &#39;none&#39; or &#39;&#39;: No edge.</span>
<span class="sd">            - *None*: :rc:`patch.edgecolor` will be used. Note that currently</span>
<span class="sd">              :rc:`patch.force_edgecolor` has to be True for this to work.</span>
<span class="sd">            - &#39;face&#39;: Use the adjacent face color.</span>
<span class="sd">            - An mpl color or sequence of colors will set the edge color.</span>

<span class="sd">            The singular form *edgecolor* works as an alias.</span>

<span class="sd">        alpha : scalar, optional, default: None</span>
<span class="sd">            The alpha blending value, between 0 (transparent) and 1 (opaque).</span>

<span class="sd">        shading : {&#39;flat&#39;, &#39;gouraud&#39;}, optional</span>
<span class="sd">            The fill style, Possible values:</span>

<span class="sd">            - &#39;flat&#39;: A solid color is used for each quad. The color of the</span>
<span class="sd">              quad (i, j), (i+1, j), (i, j+1), (i+1, j+1) is given by</span>
<span class="sd">              ``C[i,j]``.</span>
<span class="sd">            - &#39;gouraud&#39;: Each quad will be Gouraud shaded: The color of the</span>
<span class="sd">              corners (i&#39;, j&#39;) are given by ``C[i&#39;,j&#39;]``. The color values of</span>
<span class="sd">              the area in between is interpolated from the corner values.</span>
<span class="sd">              When Gouraud shading is used, *edgecolors* is ignored.</span>

<span class="sd">        snap : bool, optional, default: False</span>
<span class="sd">            Whether to snap the mesh to pixel boundaries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mesh : `matplotlib.collections.QuadMesh`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additionally, the following arguments are allowed. They are passed</span>
<span class="sd">            along to the `~matplotlib.collections.QuadMesh` constructor:</span>

<span class="sd">        %(QuadMesh)s</span>


<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pcolor : An alternative implementation with slightly different</span>
<span class="sd">            features. For a detailed discussion on the differences see</span>
<span class="sd">            :ref:`Differences between pcolor() and pcolormesh()</span>
<span class="sd">            &lt;differences-pcolor-pcolormesh&gt;`.</span>
<span class="sd">        imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a</span>
<span class="sd">            faster alternative.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        **Masked arrays**</span>

<span class="sd">        *C* may be a masked array. If ``C[i, j]`` is masked, the corresponding</span>
<span class="sd">        quadrilateral will be transparent. Masking of *X* and *Y* is not</span>
<span class="sd">        supported. Use `~.Axes.pcolor` if you need this functionality.</span>

<span class="sd">        .. _axes-pcolormesh-grid-orientation:</span>

<span class="sd">        **Grid orientation**</span>

<span class="sd">        The grid orientation follows the standard matrix convention: An array</span>
<span class="sd">        *C* with shape (nrows, ncolumns) is plotted with the column number as</span>
<span class="sd">        *X* and the row number as *Y*.</span>

<span class="sd">        .. _differences-pcolor-pcolormesh:</span>

<span class="sd">        **Differences between pcolor() and pcolormesh()**</span>

<span class="sd">        Both methods are used to create a pseudocolor plot of a 2-D array</span>
<span class="sd">        using quadrilaterals.</span>

<span class="sd">        The main difference lies in the created object and internal data</span>
<span class="sd">        handling:</span>
<span class="sd">        While `~.Axes.pcolor` returns a `.PolyCollection`, `~.Axes.pcolormesh`</span>
<span class="sd">        returns a `.QuadMesh`. The latter is more specialized for the given</span>
<span class="sd">        purpose and thus is faster. It should almost always be preferred.</span>

<span class="sd">        There is also a slight difference in the handling of masked arrays.</span>
<span class="sd">        Both `~.Axes.pcolor` and `~.Axes.pcolormesh` support masked arrays</span>
<span class="sd">        for *C*. However, only `~.Axes.pcolor` supports masked arrays for *X*</span>
<span class="sd">        and *Y*. The reason lies in the internal handling of the masked values.</span>
<span class="sd">        `~.Axes.pcolor` leaves out the respective polygons from the</span>
<span class="sd">        PolyCollection. `~.Axes.pcolormesh` sets the facecolor of the masked</span>
<span class="sd">        elements to transparent. You can see the difference when using</span>
<span class="sd">        edgecolors. While all edges are drawn irrespective of masking in a</span>
<span class="sd">        QuadMesh, the edge between two adjacent masked quadrilaterals in</span>
<span class="sd">        `~.Axes.pcolor` is not drawn as the corresponding polygons do not</span>
<span class="sd">        exist in the PolyCollection.</span>

<span class="sd">        Another difference is the support of Gouraud shading in</span>
<span class="sd">        `~.Axes.pcolormesh`, which is not available with `~.Axes.pcolor`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shading</span> <span class="o">=</span> <span class="n">shading</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;edgecolors&#39;</span><span class="p">,</span> <span class="s1">&#39;None&#39;</span><span class="p">)</span>

        <span class="n">allmatch</span> <span class="o">=</span> <span class="p">(</span><span class="n">shading</span> <span class="o">==</span> <span class="s1">&#39;gouraud&#39;</span><span class="p">)</span>

        <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pcolorargs</span><span class="p">(</span><span class="s1">&#39;pcolormesh&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">allmatch</span><span class="o">=</span><span class="n">allmatch</span><span class="p">)</span>
        <span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="c1"># unit conversion allows e.g. datetime objects as axis values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>

        <span class="c1"># convert to one dimensional arrays</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">collection</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">QuadMesh</span><span class="p">(</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span>
                                    <span class="n">antialiased</span><span class="o">=</span><span class="n">antialiased</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="n">shading</span><span class="p">,</span>
                                    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;norm&#39; must be an instance of &#39;mcolors.Normalize&#39;&quot;</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">autoscale_None</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Transform from native to data coordinates?</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">_transform</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">mtransforms</span><span class="o">.</span><span class="n">Transform</span><span class="p">)</span> <span class="ow">and</span>
            <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;_as_mpl_transform&#39;</span><span class="p">)):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">_as_mpl_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">t</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">contains_branch_seperately</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transData</span><span class="p">)):</span>
            <span class="n">trans_to_data</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">transData</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">trans_to_data</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">x</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">minx</span><span class="p">,</span> <span class="n">maxx</span><span class="p">]</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">y</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">miny</span><span class="p">,</span> <span class="n">maxy</span><span class="p">]</span>
        <span class="n">corners</span> <span class="o">=</span> <span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">),</span> <span class="p">(</span><span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">collection</span>

    <span class="nd">@_preprocess_data</span><span class="p">()</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">pcolorfast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a pseudocolor plot with a non-regular rectangular grid.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          ax.pcolorfast([X, Y], C, /, **kwargs)</span>

<span class="sd">        This method is similar to ~.Axes.pcolor` and `~.Axes.pcolormesh`.</span>
<span class="sd">        It&#39;s designed to provide the fastest pcolor-type plotting with the</span>
<span class="sd">        Agg backend. To achieve this, it uses different algorithms internally</span>
<span class="sd">        depending on the complexity of the input grid (regular rectangular,</span>
<span class="sd">        non-regular rectangular or arbitrary quadrilateral).</span>

<span class="sd">        .. warning::</span>

<span class="sd">           This method is experimental. Compared to `~.Axes.pcolor` or</span>
<span class="sd">           `~.Axes.pcolormesh` it has some limitations:</span>

<span class="sd">           - It supports only flat shading (no outlines)</span>
<span class="sd">           - It lacks support for log scaling of the axes.</span>
<span class="sd">           - It does not have a have a pyplot wrapper.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        C : array-like(M, N)</span>
<span class="sd">            A 2D array or masked array. The values will be color-mapped.</span>
<span class="sd">            This argument can only be passed positionally.</span>

<span class="sd">            C can in some cases be 3D with the last dimension as rgb(a).</span>
<span class="sd">            This is available when C qualifies for image or pcolorimage type,</span>
<span class="sd">            will throw a TypeError if C is 3D and quadmesh.</span>

<span class="sd">        X, Y : tuple or array-like, default: ``(0, N)``, ``(0, M)``</span>
<span class="sd">            *X* and *Y* are used to specify the coordinates of the</span>
<span class="sd">            quadrilaterals. There are different ways to do this:</span>

<span class="sd">            - Use tuples ``X=(xmin, xmax)`` and ``Y=(ymin, ymax)`` to define</span>
<span class="sd">              a *uniform rectangular grid*.</span>

<span class="sd">              The tuples define the outer edges of the grid. All individual</span>
<span class="sd">              quadrilaterals will be of the same size. This is the fastest</span>
<span class="sd">              version.</span>

<span class="sd">            - Use 1D arrays *X*, *Y* to specify a *non-uniform rectangular</span>
<span class="sd">              grid*.</span>

<span class="sd">              In this case *X* and *Y* have to be monotonic 1D arrays of length</span>
<span class="sd">              *N+1* and *M+1*, specifying the x and y boundaries of the cells.</span>

<span class="sd">              The speed is intermediate. Note: The grid is checked, and if</span>
<span class="sd">              found to be uniform the fast version is used.</span>

<span class="sd">            - Use 2D arrays *X*, *Y* if you need an *arbitrary quadrilateral</span>
<span class="sd">              grid* (i.e. if the quadrilaterals are not rectangular).</span>

<span class="sd">              In this case *X* and *Y* are 2D arrays with shape (M, N),</span>
<span class="sd">              specifying the x and y coordinates of the corners of the colored</span>
<span class="sd">              quadrilaterals. See `~.Axes.pcolormesh` for details.</span>

<span class="sd">              This is the most general, but the slowest to render.  It may</span>
<span class="sd">              produce faster and more compact output using ps, pdf, and</span>
<span class="sd">              svg backends, however.</span>

<span class="sd">            These arguments can only be passed positionally.</span>

<span class="sd">        cmap : str or `~matplotlib.colors.Colormap`, optional</span>
<span class="sd">            A Colormap instance or registered colormap name. The colormap</span>
<span class="sd">            maps the *C* values to colors. Defaults to :rc:`image.cmap`.</span>

<span class="sd">        norm : `~matplotlib.colors.Normalize`, optional</span>
<span class="sd">            The Normalize instance scales the data values to the canonical</span>
<span class="sd">            colormap range [0, 1] for mapping to colors. By default, the data</span>
<span class="sd">            range is mapped to the colorbar range using linear scaling.</span>

<span class="sd">        vmin, vmax : scalar, optional, default: None</span>
<span class="sd">            The colorbar range. If *None*, suitable min/max values are</span>
<span class="sd">            automatically chosen by the `~.Normalize` instance (defaults to</span>
<span class="sd">            the respective min/max values of *C* in case of the default linear</span>
<span class="sd">            scaling).</span>

<span class="sd">        alpha : scalar, optional, default: None</span>
<span class="sd">            The alpha blending value, between 0 (transparent) and 1 (opaque).</span>

<span class="sd">        snap : bool, optional, default: False</span>
<span class="sd">            Whether to snap the mesh to pixel boundaries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        image : `.AxesImage` or `.PcolorImage` or `.QuadMesh`</span>
<span class="sd">            The return type depends on the type of grid:</span>

<span class="sd">            - `.AxesImage` for a regular rectangular grid.</span>
<span class="sd">            - `.PcolorImage` for a non-regular rectangular grid.</span>
<span class="sd">            - `.QuadMesh` for a non-rectangular grid.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. [notes section required to get data note injection right]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;norm&#39; must be an instance of &#39;mcolors.Normalize&#39;&quot;</span><span class="p">)</span>

        <span class="n">C</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nr</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">C</span><span class="p">)[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">style</span> <span class="o">=</span> <span class="s2">&quot;image&quot;</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">nc</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">nr</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">style</span> <span class="o">=</span> <span class="s2">&quot;image&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                    <span class="n">dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dx</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span> <span class="ow">and</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">dy</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dy</span><span class="o">.</span><span class="n">mean</span><span class="p">())):</span>
                        <span class="n">style</span> <span class="o">=</span> <span class="s2">&quot;image&quot;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">style</span> <span class="o">=</span> <span class="s2">&quot;pcolorimage&quot;</span>
            <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">C</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;pcolorfast needs to use quadmesh, &#39;</span>
                        <span class="s1">&#39;which is not supported when x and y are 2D and C 3D&#39;</span><span class="p">)</span>
                <span class="n">style</span> <span class="o">=</span> <span class="s2">&quot;quadmesh&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;arguments do not match valid signatures&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;need 1 argument or 3 arguments&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">style</span> <span class="o">==</span> <span class="s2">&quot;quadmesh&quot;</span><span class="p">:</span>

            <span class="c1"># convert to one dimensional arrays</span>
            <span class="c1"># This should also be moved to the QuadMesh class</span>

            <span class="c1"># data point in each cell is value at lower left corner</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">Nx</span> <span class="o">=</span> <span class="n">nc</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">Ny</span> <span class="o">=</span> <span class="n">nr</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># The following needs to be cleaned up; the renderer</span>
            <span class="c1"># requires separate contiguous arrays for X and Y,</span>
            <span class="c1"># but the QuadMesh class requires the 2D array.</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(((</span><span class="n">Nx</span> <span class="o">*</span> <span class="n">Ny</span><span class="p">),</span> <span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span>
            <span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Y</span>

            <span class="c1"># The QuadMesh class can also be changed to</span>
            <span class="c1"># handle relevant superclass kwargs; the initializer</span>
            <span class="c1"># should do much more than it does now.</span>
            <span class="n">collection</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">QuadMesh</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">)</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">set_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">xl</span><span class="p">,</span> <span class="n">xr</span><span class="p">,</span> <span class="n">yb</span><span class="p">,</span> <span class="n">yt</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">X</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">Y</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">Y</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">collection</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># It&#39;s one of the two image styles.</span>
            <span class="n">xl</span><span class="p">,</span> <span class="n">xr</span><span class="p">,</span> <span class="n">yb</span><span class="p">,</span> <span class="n">yt</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">style</span> <span class="o">==</span> <span class="s2">&quot;image&quot;</span><span class="p">:</span>
                <span class="n">im</span> <span class="o">=</span> <span class="n">mimage</span><span class="o">.</span><span class="n">AxesImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span>
                                      <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span>
                                      <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span>
                                      <span class="n">extent</span><span class="o">=</span><span class="p">(</span><span class="n">xl</span><span class="p">,</span> <span class="n">xr</span><span class="p">,</span> <span class="n">yb</span><span class="p">,</span> <span class="n">yt</span><span class="p">),</span>
                                      <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="n">im</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
                <span class="n">im</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">style</span> <span class="o">==</span> <span class="s2">&quot;pcolorimage&quot;</span><span class="p">:</span>
                <span class="n">im</span> <span class="o">=</span> <span class="n">mimage</span><span class="o">.</span><span class="n">PcolorImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span>
                                        <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
                                        <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
                                        <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                                        <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="n">im</span><span class="o">.</span><span class="n">set_extent</span><span class="p">((</span><span class="n">xl</span><span class="p">,</span> <span class="n">xr</span><span class="p">,</span> <span class="n">yb</span><span class="p">,</span> <span class="n">yt</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_image</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">im</span>

        <span class="k">if</span> <span class="n">vmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">autoscale_None</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ret</span><span class="o">.</span><span class="n">get_clip_path</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># image does not already have clipping set, clip to axes patch</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">set_clip_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">patch</span><span class="p">)</span>

        <span class="n">ret</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">x</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">xl</span><span class="p">,</span> <span class="n">xr</span><span class="p">]</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">y</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">yb</span><span class="p">,</span> <span class="n">yt</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">xl</span><span class="p">,</span> <span class="n">yb</span><span class="p">],</span> <span class="p">[</span><span class="n">xr</span><span class="p">,</span> <span class="n">yt</span><span class="p">]]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">(</span><span class="n">tight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="nd">@_preprocess_data</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">contour</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;filled&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">contours</span> <span class="o">=</span> <span class="n">mcontour</span><span class="o">.</span><span class="n">QuadContourSet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">contours</span>
    <span class="n">contour</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">mcontour</span><span class="o">.</span><span class="n">QuadContourSet</span><span class="o">.</span><span class="n">_contour_doc</span>

    <span class="nd">@_preprocess_data</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">contourf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;filled&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">contours</span> <span class="o">=</span> <span class="n">mcontour</span><span class="o">.</span><span class="n">QuadContourSet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">contours</span>
    <span class="n">contourf</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">mcontour</span><span class="o">.</span><span class="n">QuadContourSet</span><span class="o">.</span><span class="n">_contour_doc</span>

    <span class="k">def</span> <span class="nf">clabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">CS</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CS</span><span class="o">.</span><span class="n">clabel</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">clabel</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">mcontour</span><span class="o">.</span><span class="n">ContourSet</span><span class="o">.</span><span class="n">clabel</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="c1">#### Data analysis</span>

    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s1">&#39;weights&#39;</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">hist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">cumulative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">histtype</span><span class="o">=</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="s1">&#39;mid&#39;</span><span class="p">,</span>
             <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;vertical&#39;</span><span class="p">,</span> <span class="n">rwidth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stacked</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot a histogram.</span>

<span class="sd">        Compute and draw the histogram of *x*.  The return value is a tuple</span>
<span class="sd">        (*n*, *bins*, *patches*) or ([*n0*, *n1*, ...], *bins*, [*patches0*,</span>
<span class="sd">        *patches1*,...]) if the input contains multiple data.  See the</span>
<span class="sd">        documentation of the *weights* parameter to draw a histogram of</span>
<span class="sd">        already-binned data.</span>

<span class="sd">        Multiple data can be provided via *x* as a list of datasets</span>
<span class="sd">        of potentially different length ([*x0*, *x1*, ...]), or as</span>
<span class="sd">        a 2-D ndarray in which each column is a dataset.  Note that</span>
<span class="sd">        the ndarray form is transposed relative to the list form.</span>

<span class="sd">        Masked arrays are not supported at present.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : (n,) array or sequence of (n,) arrays</span>
<span class="sd">            Input values, this takes either a single array or a sequence of</span>
<span class="sd">            arrays which are not required to be of the same length.</span>

<span class="sd">        bins : int or sequence or str, optional</span>
<span class="sd">            If an integer is given, ``bins + 1`` bin edges are calculated and</span>
<span class="sd">            returned, consistent with `numpy.histogram`.</span>

<span class="sd">            If `bins` is a sequence, gives bin edges, including left edge of</span>
<span class="sd">            first bin and right edge of last bin.  In this case, `bins` is</span>
<span class="sd">            returned unmodified.</span>

<span class="sd">            All but the last (righthand-most) bin is half-open.  In other</span>
<span class="sd">            words, if `bins` is::</span>

<span class="sd">                [1, 2, 3, 4]</span>

<span class="sd">            then the first bin is ``[1, 2)`` (including 1, but excluding 2) and</span>
<span class="sd">            the second ``[2, 3)``.  The last bin, however, is ``[3, 4]``, which</span>
<span class="sd">            *includes* 4.</span>

<span class="sd">            Unequally spaced bins are supported if *bins* is a sequence.</span>

<span class="sd">            With Numpy 1.11 or newer, you can alternatively provide a string</span>
<span class="sd">            describing a binning strategy, such as &#39;auto&#39;, &#39;sturges&#39;, &#39;fd&#39;,</span>
<span class="sd">            &#39;doane&#39;, &#39;scott&#39;, &#39;rice&#39; or &#39;sqrt&#39;, see</span>
<span class="sd">            `numpy.histogram`.</span>

<span class="sd">            The default is taken from :rc:`hist.bins`.</span>

<span class="sd">        range : tuple or None, optional</span>
<span class="sd">            The lower and upper range of the bins. Lower and upper outliers</span>
<span class="sd">            are ignored. If not provided, *range* is ``(x.min(), x.max())``.</span>
<span class="sd">            Range has no effect if *bins* is a sequence.</span>

<span class="sd">            If *bins* is a sequence or *range* is specified, autoscaling</span>
<span class="sd">            is based on the specified bin range instead of the</span>
<span class="sd">            range of x.</span>

<span class="sd">            Default is ``None``</span>

<span class="sd">        density : bool, optional</span>
<span class="sd">            If ``True``, the first element of the return tuple will</span>
<span class="sd">            be the counts normalized to form a probability density, i.e.,</span>
<span class="sd">            the area (or integral) under the histogram will sum to 1.</span>
<span class="sd">            This is achieved by dividing the count by the number of</span>
<span class="sd">            observations times the bin width and not dividing by the total</span>
<span class="sd">            number of observations. If *stacked* is also ``True``, the sum of</span>
<span class="sd">            the histograms is normalized to 1.</span>

<span class="sd">            Default is ``None`` for both *normed* and *density*. If either is</span>
<span class="sd">            set, then that value will be used. If neither are set, then the</span>
<span class="sd">            args will be treated as ``False``.</span>

<span class="sd">            If both *density* and *normed* are set an error is raised.</span>

<span class="sd">        weights : (n, ) array_like or None, optional</span>
<span class="sd">            An array of weights, of the same shape as *x*.  Each value in *x*</span>
<span class="sd">            only contributes its associated weight towards the bin count</span>
<span class="sd">            (instead of 1).  If *normed* or *density* is ``True``,</span>
<span class="sd">            the weights are normalized, so that the integral of the density</span>
<span class="sd">            over the range remains 1.</span>

<span class="sd">            Default is ``None``.</span>

<span class="sd">            This parameter can be used to draw a histogram of data that has</span>
<span class="sd">            already been binned, e.g. using `np.histogram` (by treating each</span>
<span class="sd">            bin as a single point with a weight equal to its count) ::</span>

<span class="sd">                counts, bins = np.histogram(data)</span>
<span class="sd">                plt.hist(bins[:-1], bins, weights=counts)</span>

<span class="sd">            (or you may alternatively use `~.bar()`).</span>

<span class="sd">        cumulative : bool, optional</span>
<span class="sd">            If ``True``, then a histogram is computed where each bin gives the</span>
<span class="sd">            counts in that bin plus all bins for smaller values. The last bin</span>
<span class="sd">            gives the total number of datapoints. If *normed* or *density*</span>
<span class="sd">            is also ``True`` then the histogram is normalized such that the</span>
<span class="sd">            last bin equals 1. If *cumulative* evaluates to less than 0</span>
<span class="sd">            (e.g., -1), the direction of accumulation is reversed.</span>
<span class="sd">            In this case, if *normed* and/or *density* is also ``True``, then</span>
<span class="sd">            the histogram is normalized such that the first bin equals 1.</span>

<span class="sd">            Default is ``False``</span>

<span class="sd">        bottom : array_like, scalar, or None</span>
<span class="sd">            Location of the bottom baseline of each bin.  If a scalar,</span>
<span class="sd">            the base line for each bin is shifted by the same amount.</span>
<span class="sd">            If an array, each bin is shifted independently and the length</span>
<span class="sd">            of bottom must match the number of bins.  If None, defaults to 0.</span>

<span class="sd">            Default is ``None``</span>

<span class="sd">        histtype : {&#39;bar&#39;, &#39;barstacked&#39;, &#39;step&#39;,  &#39;stepfilled&#39;}, optional</span>
<span class="sd">            The type of histogram to draw.</span>

<span class="sd">            - &#39;bar&#39; is a traditional bar-type histogram.  If multiple data</span>
<span class="sd">              are given the bars are arranged side by side.</span>

<span class="sd">            - &#39;barstacked&#39; is a bar-type histogram where multiple</span>
<span class="sd">              data are stacked on top of each other.</span>

<span class="sd">            - &#39;step&#39; generates a lineplot that is by default</span>
<span class="sd">              unfilled.</span>

<span class="sd">            - &#39;stepfilled&#39; generates a lineplot that is by default</span>
<span class="sd">              filled.</span>

<span class="sd">            Default is &#39;bar&#39;</span>

<span class="sd">        align : {&#39;left&#39;, &#39;mid&#39;, &#39;right&#39;}, optional</span>
<span class="sd">            Controls how the histogram is plotted.</span>

<span class="sd">                - &#39;left&#39;: bars are centered on the left bin edges.</span>

<span class="sd">                - &#39;mid&#39;: bars are centered between the bin edges.</span>

<span class="sd">                - &#39;right&#39;: bars are centered on the right bin edges.</span>

<span class="sd">            Default is &#39;mid&#39;</span>

<span class="sd">        orientation : {&#39;horizontal&#39;, &#39;vertical&#39;}, optional</span>
<span class="sd">            If &#39;horizontal&#39;, `~matplotlib.pyplot.barh` will be used for</span>
<span class="sd">            bar-type histograms and the *bottom* kwarg will be the left edges.</span>

<span class="sd">        rwidth : scalar or None, optional</span>
<span class="sd">            The relative width of the bars as a fraction of the bin width.  If</span>
<span class="sd">            ``None``, automatically compute the width.</span>

<span class="sd">            Ignored if *histtype* is &#39;step&#39; or &#39;stepfilled&#39;.</span>

<span class="sd">            Default is ``None``</span>

<span class="sd">        log : bool, optional</span>
<span class="sd">            If ``True``, the histogram axis will be set to a log scale. If</span>
<span class="sd">            *log* is ``True`` and *x* is a 1D array, empty bins will be</span>
<span class="sd">            filtered out and only the non-empty ``(n, bins, patches)``</span>
<span class="sd">            will be returned.</span>

<span class="sd">            Default is ``False``</span>

<span class="sd">        color : color or array_like of colors or None, optional</span>
<span class="sd">            Color spec or sequence of color specs, one per dataset.  Default</span>
<span class="sd">            (``None``) uses the standard line color sequence.</span>

<span class="sd">            Default is ``None``</span>

<span class="sd">        label : str or None, optional</span>
<span class="sd">            String, or sequence of strings to match multiple datasets.  Bar</span>
<span class="sd">            charts yield multiple patches per dataset, but only the first gets</span>
<span class="sd">            the label, so that the legend command will work as expected.</span>

<span class="sd">            default is ``None``</span>

<span class="sd">        stacked : bool, optional</span>
<span class="sd">            If ``True``, multiple data are stacked on top of each other If</span>
<span class="sd">            ``False`` multiple data are arranged side by side if histtype is</span>
<span class="sd">            &#39;bar&#39; or on top of each other if histtype is &#39;step&#39;</span>

<span class="sd">            Default is ``False``</span>

<span class="sd">        normed : bool, optional</span>
<span class="sd">            Deprecated; use the density keyword argument instead.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        n : array or list of arrays</span>
<span class="sd">            The values of the histogram bins. See *density* and *weights* for a</span>
<span class="sd">            description of the possible semantics.  If input *x* is an array,</span>
<span class="sd">            then this is an array of length *nbins*. If input is a sequence of</span>
<span class="sd">            arrays ``[data1, data2,..]``, then this is a list of arrays with</span>
<span class="sd">            the values of the histograms for each of the arrays in the same</span>
<span class="sd">            order.  The dtype of the array *n* (or of its element arrays) will</span>
<span class="sd">            always be float even if no weighting or normalization is used.</span>

<span class="sd">        bins : array</span>
<span class="sd">            The edges of the bins. Length nbins + 1 (nbins left edges and right</span>
<span class="sd">            edge of last bin).  Always a single array even when multiple data</span>
<span class="sd">            sets are passed in.</span>

<span class="sd">        patches : list or list of lists</span>
<span class="sd">            Silent list of individual patches used to create the histogram</span>
<span class="sd">            or list of such list if multiple input datasets.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs : `~matplotlib.patches.Patch` properties</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        hist2d : 2D histograms</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Avoid shadowing the builtin.</span>
        <span class="n">bin_range</span> <span class="o">=</span> <span class="nb">range</span>
        <span class="kn">from</span> <span class="nn">builtins</span> <span class="kn">import</span> <span class="nb">range</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">bins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;hist.bins&#39;</span><span class="p">]</span>

        <span class="c1"># Validate string inputs here so we don&#39;t have to clutter</span>
        <span class="c1"># subsequent code.</span>
        <span class="k">if</span> <span class="n">histtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;barstacked&#39;</span><span class="p">,</span> <span class="s1">&#39;step&#39;</span><span class="p">,</span> <span class="s1">&#39;stepfilled&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;histtype </span><span class="si">%s</span><span class="s2"> is not recognized&quot;</span> <span class="o">%</span> <span class="n">histtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">align</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;mid&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;align kwarg </span><span class="si">%s</span><span class="s2"> is not recognized&quot;</span> <span class="o">%</span> <span class="n">align</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">orientation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;horizontal&#39;</span><span class="p">,</span> <span class="s1">&#39;vertical&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;orientation kwarg </span><span class="si">%s</span><span class="s2"> is not recognized&quot;</span> <span class="o">%</span> <span class="n">orientation</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">histtype</span> <span class="o">==</span> <span class="s1">&#39;barstacked&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">stacked</span><span class="p">:</span>
            <span class="n">stacked</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">density</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">normed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;kwargs &#39;density&#39; and &#39;normed&#39; cannot be used &quot;</span>
                             <span class="s2">&quot;simultaneously. &quot;</span>
                             <span class="s2">&quot;Please only use &#39;density&#39;, since &#39;normed&#39;&quot;</span>
                             <span class="s2">&quot;is deprecated.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">normed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cbook</span><span class="o">.</span><span class="n">warn_deprecated</span><span class="p">(</span><span class="s2">&quot;2.1&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;&#39;normed&#39;&quot;</span><span class="p">,</span> <span class="n">obj_type</span><span class="o">=</span><span class="s2">&quot;kwarg&quot;</span><span class="p">,</span>
                                  <span class="n">alternative</span><span class="o">=</span><span class="s2">&quot;&#39;density&#39;&quot;</span><span class="p">,</span> <span class="n">removal</span><span class="o">=</span><span class="s2">&quot;3.1&quot;</span><span class="p">)</span>

        <span class="c1"># basic input validation</span>
        <span class="n">input_empty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="c1"># Massage &#39;x&#39; for processing.</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">_reshape_2D</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># number of datasets</span>

        <span class="c1"># Process unit information</span>
        <span class="c1"># Unit conversion is done individually on each dataset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">bin_range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bin_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">bin_range</span><span class="p">)</span>

        <span class="c1"># We need to do to &#39;weights&#39; what was done to &#39;x&#39;</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">_reshape_2D</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="s1">&#39;weights&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">nx</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nx</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;weights should have the same shape as x&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">xi</span><span class="p">,</span> <span class="n">wi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">wi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">wi</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;weights should have the same shape as x&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_lines</span><span class="o">.</span><span class="n">get_next_color</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">to_rgba_array</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nx</span><span class="p">:</span>
                <span class="n">error_message</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;color kwarg must have one color per data set. </span><span class="si">%d</span><span class="s2"> data &quot;</span>
                    <span class="s2">&quot;sets and </span><span class="si">%d</span><span class="s2"> colors were provided&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">color</span><span class="p">)))</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">error_message</span><span class="p">)</span>

        <span class="n">hist_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># if the bin_range is not given, compute without nan numpy</span>
        <span class="c1"># does not do this for us when guessing the range (but will</span>
        <span class="c1"># happily ignore nans when computing the histogram).</span>
        <span class="k">if</span> <span class="n">bin_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">xmax</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">):</span>
                    <span class="c1"># python&#39;s min/max ignore nan,</span>
                    <span class="c1"># np.minnan returns nan for all nan input</span>
                    <span class="n">xmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">xi</span><span class="p">))</span>
                    <span class="n">xmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">xi</span><span class="p">))</span>
            <span class="c1"># make sure we have seen at least one non-nan and finite</span>
            <span class="c1"># value before we reset the bin range</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">xmin</span> <span class="o">&gt;</span> <span class="n">xmax</span><span class="p">):</span>
                <span class="n">bin_range</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">)</span>

        <span class="c1"># If bins are not specified either explicitly or via range,</span>
        <span class="c1"># we need to figure out the range required for all datasets,</span>
        <span class="c1"># and supply that to np.histogram.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">input_empty</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_w</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">bins</span> <span class="o">=</span> <span class="n">histogram_bin_edges</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                                       <span class="n">bins</span><span class="p">,</span> <span class="n">bin_range</span><span class="p">,</span> <span class="n">_w</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hist_kwargs</span><span class="p">[</span><span class="s1">&#39;range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bin_range</span>

        <span class="n">density</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">density</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">bool</span><span class="p">(</span><span class="n">normed</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">density</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">stacked</span><span class="p">:</span>
            <span class="n">hist_kwargs</span><span class="p">[</span><span class="s1">&#39;density&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">density</span>

        <span class="c1"># List to store all the top coordinates of the histograms</span>
        <span class="n">tops</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mlast</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Loop through datasets</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
            <span class="c1"># this will automatically overwrite bins,</span>
            <span class="c1"># so that each histogram uses the same bins</span>
            <span class="n">m</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">bins</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">hist_kwargs</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>  <span class="c1"># causes problems later if it&#39;s an int</span>
            <span class="k">if</span> <span class="n">mlast</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mlast</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">stacked</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">+=</span> <span class="n">mlast</span>
                <span class="n">mlast</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">m</span>
            <span class="n">tops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="c1"># If a stacked density plot, normalize so the area of all the stacked</span>
        <span class="c1"># histograms together is 1</span>
        <span class="k">if</span> <span class="n">stacked</span> <span class="ow">and</span> <span class="n">density</span><span class="p">:</span>
            <span class="n">db</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">tops</span><span class="p">:</span>
                <span class="n">m</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">/</span> <span class="n">db</span><span class="p">)</span> <span class="o">/</span> <span class="n">tops</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">cumulative</span><span class="p">:</span>
            <span class="n">slc</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cumulative</span><span class="p">,</span> <span class="n">Number</span><span class="p">)</span> <span class="ow">and</span> <span class="n">cumulative</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">slc</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">density</span><span class="p">:</span>
                <span class="n">tops</span> <span class="o">=</span> <span class="p">[(</span><span class="n">m</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bins</span><span class="p">))[</span><span class="n">slc</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()[</span><span class="n">slc</span><span class="p">]</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">tops</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tops</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="p">[</span><span class="n">slc</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()[</span><span class="n">slc</span><span class="p">]</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">tops</span><span class="p">]</span>

        <span class="n">patches</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Save autoscale state for later restoration; turn autoscaling</span>
        <span class="c1"># off so we can do it all a single time at the end, instead</span>
        <span class="c1"># of having it done by bar or fill and then having to be redone.</span>
        <span class="n">_saved_autoscalex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_autoscalex_on</span><span class="p">()</span>
        <span class="n">_saved_autoscaley</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_autoscaley_on</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_autoscalex_on</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_autoscaley_on</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">histtype</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">):</span>

            <span class="n">totwidth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">rwidth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">rwidth</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tops</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span>
                  <span class="p">((</span><span class="ow">not</span> <span class="n">stacked</span><span class="p">)</span> <span class="ow">or</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;_internal.classic_mode&#39;</span><span class="p">])):</span>
                <span class="n">dr</span> <span class="o">=</span> <span class="mf">0.8</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dr</span> <span class="o">=</span> <span class="mf">1.0</span>

            <span class="k">if</span> <span class="n">histtype</span> <span class="o">==</span> <span class="s1">&#39;bar&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">stacked</span><span class="p">:</span>
                <span class="n">width</span> <span class="o">=</span> <span class="n">dr</span> <span class="o">*</span> <span class="n">totwidth</span> <span class="o">/</span> <span class="n">nx</span>
                <span class="n">dw</span> <span class="o">=</span> <span class="n">width</span>
                <span class="n">boffset</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">dr</span> <span class="o">*</span> <span class="n">totwidth</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">nx</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">histtype</span> <span class="o">==</span> <span class="s1">&#39;barstacked&#39;</span> <span class="ow">or</span> <span class="n">stacked</span><span class="p">:</span>
                <span class="n">width</span> <span class="o">=</span> <span class="n">dr</span> <span class="o">*</span> <span class="n">totwidth</span>
                <span class="n">boffset</span><span class="p">,</span> <span class="n">dw</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>

            <span class="k">if</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">&#39;mid&#39;</span><span class="p">:</span>
                <span class="n">boffset</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">totwidth</span>
            <span class="k">elif</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span>
                <span class="n">boffset</span> <span class="o">+=</span> <span class="n">totwidth</span>

            <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">:</span>
                <span class="n">_barfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">barh</span>
                <span class="n">bottom_kwarg</span> <span class="o">=</span> <span class="s1">&#39;left&#39;</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># orientation == &#39;vertical&#39;</span>
                <span class="n">_barfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bar</span>
                <span class="n">bottom_kwarg</span> <span class="o">=</span> <span class="s1">&#39;bottom&#39;</span>

            <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tops</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">bottom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">bottom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">stacked</span><span class="p">:</span>
                    <span class="n">height</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="n">bottom</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">height</span> <span class="o">=</span> <span class="n">m</span>
                <span class="n">patch</span> <span class="o">=</span> <span class="n">_barfunc</span><span class="p">(</span><span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">boffset</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span>
                                 <span class="n">align</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span>
                                 <span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="n">bottom_kwarg</span><span class="p">:</span> <span class="n">bottom</span><span class="p">})</span>
                <span class="n">patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">stacked</span><span class="p">:</span>
                    <span class="n">bottom</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">m</span>
                <span class="n">boffset</span> <span class="o">+=</span> <span class="n">dw</span>

        <span class="k">elif</span> <span class="n">histtype</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;step&#39;</span><span class="p">):</span>
            <span class="c1"># these define the perimeter of the polygon</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span>

            <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">bins</span><span class="p">,</span> <span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">bottom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">bottom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">):</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">bottom</span>
            <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">nonposx</span><span class="o">=</span><span class="s1">&#39;clip&#39;</span><span class="p">)</span>
                    <span class="n">logbase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">_scale</span><span class="o">.</span><span class="n">base</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># orientation == &#39;vertical&#39;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">nonposy</span><span class="o">=</span><span class="s1">&#39;clip&#39;</span><span class="p">)</span>
                    <span class="n">logbase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">_scale</span><span class="o">.</span><span class="n">base</span>

                <span class="c1"># Setting a minimum of 0 results in problems for log plots</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">bottom</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">minimum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">bottom</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">density</span> <span class="ow">or</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># For data that is normed to form a probability density,</span>
                    <span class="c1"># set to minimum data value / logbase</span>
                    <span class="c1"># (gives 1 full tick-label unit for the lowest filled bin)</span>
                    <span class="n">ndata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tops</span><span class="p">)</span>
                    <span class="n">minimum</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ndata</span><span class="p">[</span><span class="n">ndata</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]))</span> <span class="o">/</span> <span class="n">logbase</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># For non-normed (density = False) data,</span>
                    <span class="c1"># set the min to 1 / log base,</span>
                    <span class="c1"># again so that there is 1 full tick-label unit</span>
                    <span class="c1"># for the lowest bin</span>
                    <span class="n">minimum</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">logbase</span>

                <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">minimum</span><span class="p">,</span> <span class="n">minimum</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">minimum</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">if</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">-=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">+=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># If fill kwarg is set, it will be passed to the patch collection,</span>
            <span class="c1"># overriding this</span>
            <span class="n">fill</span> <span class="o">=</span> <span class="p">(</span><span class="n">histtype</span> <span class="o">==</span> <span class="s1">&#39;stepfilled&#39;</span><span class="p">)</span>

            <span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">tops</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">stacked</span><span class="p">:</span>
                    <span class="c1"># starting point for drawing polygon</span>
                    <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="c1"># top of the previous polygon becomes the bottom</span>
                    <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># set the top of this polygon</span>
                <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">):</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">bottom</span><span class="p">,</span>
                                                            <span class="n">m</span> <span class="o">+</span> <span class="n">bottom</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
                    <span class="n">y</span><span class="p">[</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">minimum</span><span class="p">]</span> <span class="o">=</span> <span class="n">minimum</span>
                <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">:</span>
                    <span class="n">xvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                    <span class="n">yvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">xvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                    <span class="n">yvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

            <span class="c1"># stepfill is closed, step is not</span>
            <span class="n">split</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">fill</span> <span class="k">else</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
            <span class="c1"># add patches in reverse order so that when stacking,</span>
            <span class="c1"># items lower in the stack are plotted on top of</span>
            <span class="c1"># items higher in the stack</span>
            <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span><span class="p">,</span> <span class="n">color</span><span class="p">))):</span>
                <span class="n">patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span>
                    <span class="n">x</span><span class="p">[:</span><span class="n">split</span><span class="p">],</span> <span class="n">y</span><span class="p">[:</span><span class="n">split</span><span class="p">],</span>
                    <span class="n">closed</span><span class="o">=</span><span class="kc">True</span> <span class="k">if</span> <span class="n">fill</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">facecolor</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
                    <span class="n">edgecolor</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">fill</span> <span class="k">else</span> <span class="n">c</span><span class="p">,</span>
                    <span class="n">fill</span><span class="o">=</span><span class="n">fill</span> <span class="k">if</span> <span class="n">fill</span> <span class="k">else</span> <span class="kc">None</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">patch_list</span> <span class="ow">in</span> <span class="n">patches</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">patch</span> <span class="ow">in</span> <span class="n">patch_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;vertical&#39;</span><span class="p">:</span>
                        <span class="n">patch</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">minimum</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">:</span>
                        <span class="n">patch</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">minimum</span><span class="p">)</span>

            <span class="c1"># we return patches, so put it back in the expected order</span>
            <span class="n">patches</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_autoscalex_on</span><span class="p">(</span><span class="n">_saved_autoscalex</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_autoscaley_on</span><span class="p">(</span><span class="n">_saved_autoscaley</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">label</span><span class="p">]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">label</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">lab</span><span class="p">)</span> <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">label</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">patch</span><span class="p">,</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">zip_longest</span><span class="p">(</span><span class="n">patches</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">patch</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">patch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">p</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">lbl</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="n">lbl</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">patch</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s1">&#39;_nolegend_&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nx</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tops</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bins</span><span class="p">,</span> <span class="n">cbook</span><span class="o">.</span><span class="n">silent_list</span><span class="p">(</span><span class="s1">&#39;Patch&#39;</span><span class="p">,</span> <span class="n">patches</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tops</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">cbook</span><span class="o">.</span><span class="n">silent_list</span><span class="p">(</span><span class="s1">&#39;Lists of Patches&#39;</span><span class="p">,</span> <span class="n">patches</span><span class="p">)</span>

    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;weights&quot;</span><span class="p">])</span>
    <span class="nd">@cbook</span><span class="o">.</span><span class="n">_rename_parameter</span><span class="p">(</span><span class="s2">&quot;3.1&quot;</span><span class="p">,</span> <span class="s2">&quot;normed&quot;</span><span class="p">,</span> <span class="s2">&quot;density&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">hist2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">cmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a 2D histogram plot.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : array_like, shape (n, )</span>
<span class="sd">            Input values</span>

<span class="sd">        bins : None or int or [int, int] or array_like or [array, array]</span>

<span class="sd">            The bin specification:</span>

<span class="sd">                - If int, the number of bins for the two dimensions</span>
<span class="sd">                  (nx=ny=bins).</span>

<span class="sd">                - If ``[int, int]``, the number of bins in each dimension</span>
<span class="sd">                  (nx, ny = bins).</span>

<span class="sd">                - If array_like, the bin edges for the two dimensions</span>
<span class="sd">                  (x_edges=y_edges=bins).</span>

<span class="sd">                - If ``[array, array]``, the bin edges in each dimension</span>
<span class="sd">                  (x_edges, y_edges = bins).</span>

<span class="sd">            The default value is 10.</span>

<span class="sd">        range : array_like shape(2, 2), optional, default: None</span>
<span class="sd">             The leftmost and rightmost edges of the bins along each dimension</span>
<span class="sd">             (if not specified explicitly in the bins parameters): ``[[xmin,</span>
<span class="sd">             xmax], [ymin, ymax]]``. All values outside of this range will be</span>
<span class="sd">             considered outliers and not tallied in the histogram.</span>

<span class="sd">        density : bool, optional, default: False</span>
<span class="sd">             Normalize histogram.  *normed* is a deprecated synonym for this</span>
<span class="sd">             parameter.</span>

<span class="sd">        weights : array_like, shape (n, ), optional, default: None</span>
<span class="sd">            An array of values w_i weighing each sample (x_i, y_i).</span>

<span class="sd">        cmin : scalar, optional, default: None</span>
<span class="sd">             All bins that has count less than cmin will not be displayed and</span>
<span class="sd">             these count values in the return value count histogram will also</span>
<span class="sd">             be set to nan upon return</span>

<span class="sd">        cmax : scalar, optional, default: None</span>
<span class="sd">             All bins that has count more than cmax will not be displayed (set</span>
<span class="sd">             to none before passing to imshow) and these count values in the</span>
<span class="sd">             return value count histogram will also be set to nan upon return</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        h : 2D array</span>
<span class="sd">            The bi-dimensional histogram of samples x and y. Values in x are</span>
<span class="sd">            histogrammed along the first dimension and values in y are</span>
<span class="sd">            histogrammed along the second dimension.</span>
<span class="sd">        xedges : 1D array</span>
<span class="sd">            The bin edges along the x axis.</span>
<span class="sd">        yedges : 1D array</span>
<span class="sd">            The bin edges along the y axis.</span>
<span class="sd">        image : `~.matplotlib.collections.QuadMesh`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        cmap : Colormap or str, optional</span>
<span class="sd">            A `.colors.Colormap` instance.  If not set, use rc settings.</span>

<span class="sd">        norm : Normalize, optional</span>
<span class="sd">            A `.colors.Normalize` instance is used to</span>
<span class="sd">            scale luminance data to ``[0, 1]``. If not set, defaults to</span>
<span class="sd">            `.colors.Normalize()`.</span>

<span class="sd">        vmin/vmax : None or scalar, optional</span>
<span class="sd">            Arguments passed to the `~.colors.Normalize` instance.</span>

<span class="sd">        alpha : ``0 &lt;= scalar &lt;= 1`` or ``None``, optional</span>
<span class="sd">            The alpha blending value.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        hist : 1D histogram plotting</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Currently ``hist2d`` calculates it&#39;s own axis limits, and any limits</span>
<span class="sd">          previously set are ignored.</span>
<span class="sd">        - Rendering the histogram with a logarithmic color scale is</span>
<span class="sd">          accomplished by passing a `.colors.LogNorm` instance to the *norm*</span>
<span class="sd">          keyword argument. Likewise, power-law normalization (similar</span>
<span class="sd">          in effect to gamma correction) can be accomplished with</span>
<span class="sd">          `.colors.PowerNorm`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">h</span><span class="p">,</span> <span class="n">xedges</span><span class="p">,</span> <span class="n">yedges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="nb">range</span><span class="p">,</span>
                                           <span class="n">normed</span><span class="o">=</span><span class="n">density</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">h</span><span class="p">[</span><span class="n">h</span> <span class="o">&lt;</span> <span class="n">cmin</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">cmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">h</span><span class="p">[</span><span class="n">h</span> <span class="o">&gt;</span> <span class="n">cmax</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">pc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">xedges</span><span class="p">,</span> <span class="n">yedges</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xedges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xedges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">yedges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">yedges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">h</span><span class="p">,</span> <span class="n">xedges</span><span class="p">,</span> <span class="n">yedges</span><span class="p">,</span> <span class="n">pc</span>

    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">psd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_line</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the power spectral density.</span>

<span class="sd">        The power spectral density :math:`P_{xx}` by Welch&#39;s average</span>
<span class="sd">        periodogram method.  The vector *x* is divided into *NFFT* length</span>
<span class="sd">        segments.  Each segment is detrended by function *detrend* and</span>
<span class="sd">        windowed by function *window*.  *noverlap* gives the length of</span>
<span class="sd">        the overlap between segments.  The :math:`|\mathrm{fft}(i)|^2`</span>
<span class="sd">        of each segment :math:`i` are averaged to compute :math:`P_{xx}`,</span>
<span class="sd">        with a scaling to correct for power loss due to windowing.</span>

<span class="sd">        If len(*x*) &lt; *NFFT*, it will be zero padded to *NFFT*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : 1-D array or sequence</span>
<span class="sd">            Array or sequence containing the data</span>

<span class="sd">        %(Spectral)s</span>

<span class="sd">        %(PSD)s</span>

<span class="sd">        noverlap : int</span>
<span class="sd">            The number of points of overlap between segments.</span>
<span class="sd">            The default value is 0 (no overlap).</span>

<span class="sd">        Fc : int</span>
<span class="sd">            The center frequency of *x* (defaults to 0), which offsets</span>
<span class="sd">            the x extents of the plot to reflect the frequency range used</span>
<span class="sd">            when a signal is acquired and then filtered and downsampled to</span>
<span class="sd">            baseband.</span>

<span class="sd">        return_line : bool</span>
<span class="sd">            Whether to include the line object plotted in the returned values.</span>
<span class="sd">            Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Pxx : 1-D array</span>
<span class="sd">            The values for the power spectrum `P_{xx}` before scaling</span>
<span class="sd">            (real valued).</span>

<span class="sd">        freqs : 1-D array</span>
<span class="sd">            The frequencies corresponding to the elements in *Pxx*.</span>

<span class="sd">        line : a :class:`~matplotlib.lines.Line2D` instance</span>
<span class="sd">            The line created by this function.</span>
<span class="sd">            Only returned if *return_line* is True.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments control the :class:`~matplotlib.lines.Line2D`</span>
<span class="sd">            properties:</span>

<span class="sd">        %(_Line2D_docstr)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :func:`specgram`</span>
<span class="sd">            :func:`specgram` differs in the default overlap; in not returning</span>
<span class="sd">            the mean of the segment periodograms; in returning the times of the</span>
<span class="sd">            segments; and in plotting a colormap instead of a line.</span>

<span class="sd">        :func:`magnitude_spectrum`</span>
<span class="sd">            :func:`magnitude_spectrum` plots the magnitude spectrum.</span>

<span class="sd">        :func:`csd`</span>
<span class="sd">            :func:`csd` plots the spectral density between two signals.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For plotting, the power is plotted as</span>
<span class="sd">        :math:`10\log_{10}(P_{xx})` for decibels, though *Pxx* itself</span>
<span class="sd">        is returned.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Bendat &amp; Piersol -- Random Data: Analysis and Measurement Procedures,</span>
<span class="sd">        John Wiley &amp; Sons (1986)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">Fc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Fc</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">pxx</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">psd</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span>
                              <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span>
                              <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="n">scale_by_freq</span><span class="p">)</span>
        <span class="n">freqs</span> <span class="o">+=</span> <span class="n">Fc</span>

        <span class="k">if</span> <span class="n">scale_by_freq</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="n">psd_units</span> <span class="o">=</span> <span class="s1">&#39;dB/Hz&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">psd_units</span> <span class="o">=</span> <span class="s1">&#39;dB&#39;</span>

        <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">pxx</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Power Spectral Density (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">psd_units</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">viewLim</span><span class="o">.</span><span class="n">intervaly</span>
        <span class="n">intv</span> <span class="o">=</span> <span class="n">vmax</span> <span class="o">-</span> <span class="n">vmin</span>
        <span class="n">logi</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">intv</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">logi</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logi</span> <span class="o">=</span> <span class="o">.</span><span class="mi">1</span>
        <span class="n">step</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">logi</span>
        <span class="n">ticks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">vmin</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">vmax</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">ticks</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_line</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">return_line</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pxx</span><span class="p">,</span> <span class="n">freqs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pxx</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">line</span>

    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">csd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_line</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the cross-spectral density.</span>

<span class="sd">        The cross spectral density :math:`P_{xy}` by Welch&#39;s average</span>
<span class="sd">        periodogram method.  The vectors *x* and *y* are divided into</span>
<span class="sd">        *NFFT* length segments.  Each segment is detrended by function</span>
<span class="sd">        *detrend* and windowed by function *window*.  *noverlap* gives</span>
<span class="sd">        the length of the overlap between segments.  The product of</span>
<span class="sd">        the direct FFTs of *x* and *y* are averaged over each segment</span>
<span class="sd">        to compute :math:`P_{xy}`, with a scaling to correct for power</span>
<span class="sd">        loss due to windowing.</span>

<span class="sd">        If len(*x*) &lt; *NFFT* or len(*y*) &lt; *NFFT*, they will be zero</span>
<span class="sd">        padded to *NFFT*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : 1-D arrays or sequences</span>
<span class="sd">            Arrays or sequences containing the data.</span>

<span class="sd">        %(Spectral)s</span>

<span class="sd">        %(PSD)s</span>

<span class="sd">        noverlap : int</span>
<span class="sd">            The number of points of overlap between segments.</span>
<span class="sd">            The default value is 0 (no overlap).</span>

<span class="sd">        Fc : int</span>
<span class="sd">            The center frequency of *x* (defaults to 0), which offsets</span>
<span class="sd">            the x extents of the plot to reflect the frequency range used</span>
<span class="sd">            when a signal is acquired and then filtered and downsampled to</span>
<span class="sd">            baseband.</span>

<span class="sd">        return_line : bool</span>
<span class="sd">            Whether to include the line object plotted in the returned values.</span>
<span class="sd">            Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Pxy : 1-D array</span>
<span class="sd">            The values for the cross spectrum `P_{xy}` before scaling</span>
<span class="sd">            (complex valued).</span>

<span class="sd">        freqs : 1-D array</span>
<span class="sd">            The frequencies corresponding to the elements in *Pxy*.</span>

<span class="sd">        line : a :class:`~matplotlib.lines.Line2D` instance</span>
<span class="sd">            The line created by this function.</span>
<span class="sd">            Only returned if *return_line* is True.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments control the :class:`~matplotlib.lines.Line2D`</span>
<span class="sd">            properties:</span>

<span class="sd">        %(_Line2D_docstr)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :func:`psd`</span>
<span class="sd">            :func:`psd` is the equivalent to setting y=x.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For plotting, the power is plotted as</span>
<span class="sd">        :math:`10\\log_{10}(P_{xy})` for decibels, though `P_{xy}` itself</span>
<span class="sd">        is returned.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Bendat &amp; Piersol -- Random Data: Analysis and Measurement Procedures,</span>
<span class="sd">        John Wiley &amp; Sons (1986)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">Fc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Fc</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">pxy</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">csd</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span>
                              <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span>
                              <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="n">scale_by_freq</span><span class="p">)</span>
        <span class="c1"># pxy is complex</span>
        <span class="n">freqs</span> <span class="o">+=</span> <span class="n">Fc</span>

        <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pxy</span><span class="p">)),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Cross Spectrum Magnitude (dB)&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">viewLim</span><span class="o">.</span><span class="n">intervaly</span>

        <span class="n">intv</span> <span class="o">=</span> <span class="n">vmax</span> <span class="o">-</span> <span class="n">vmin</span>
        <span class="n">step</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">intv</span><span class="p">))</span>

        <span class="n">ticks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">vmin</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">vmax</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">ticks</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_line</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">return_line</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pxy</span><span class="p">,</span> <span class="n">freqs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pxy</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">line</span>

    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">magnitude_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the magnitude spectrum.</span>

<span class="sd">        Compute the magnitude spectrum of *x*.  Data is padded to a</span>
<span class="sd">        length of *pad_to* and the windowing function *window* is applied to</span>
<span class="sd">        the signal.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : 1-D array or sequence</span>
<span class="sd">            Array or sequence containing the data.</span>

<span class="sd">        %(Spectral)s</span>

<span class="sd">        %(Single_Spectrum)s</span>

<span class="sd">        scale : {&#39;default&#39;, &#39;linear&#39;, &#39;dB&#39;}</span>
<span class="sd">            The scaling of the values in the *spec*.  &#39;linear&#39; is no scaling.</span>
<span class="sd">            &#39;dB&#39; returns the values in dB scale, i.e., the dB amplitude</span>
<span class="sd">            (20 * log10). &#39;default&#39; is &#39;linear&#39;.</span>

<span class="sd">        Fc : int</span>
<span class="sd">            The center frequency of *x* (defaults to 0), which offsets</span>
<span class="sd">            the x extents of the plot to reflect the frequency range used</span>
<span class="sd">            when a signal is acquired and then filtered and downsampled to</span>
<span class="sd">            baseband.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spectrum : 1-D array</span>
<span class="sd">            The values for the magnitude spectrum before scaling (real valued).</span>

<span class="sd">        freqs : 1-D array</span>
<span class="sd">            The frequencies corresponding to the elements in *spectrum*.</span>

<span class="sd">        line : a :class:`~matplotlib.lines.Line2D` instance</span>
<span class="sd">            The line created by this function.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments control the :class:`~matplotlib.lines.Line2D`</span>
<span class="sd">            properties:</span>

<span class="sd">        %(_Line2D_docstr)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :func:`psd`</span>
<span class="sd">            :func:`psd` plots the power spectral density.`.</span>

<span class="sd">        :func:`angle_spectrum`</span>
<span class="sd">            :func:`angle_spectrum` plots the angles of the corresponding</span>
<span class="sd">            frequencies.</span>

<span class="sd">        :func:`phase_spectrum`</span>
<span class="sd">            :func:`phase_spectrum` plots the phase (unwrapped angle) of the</span>
<span class="sd">            corresponding frequencies.</span>

<span class="sd">        :func:`specgram`</span>
<span class="sd">            :func:`specgram` can plot the magnitude spectrum of segments within</span>
<span class="sd">            the signal in a colormap.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">Fc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Fc</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">scale</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span>

        <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">magnitude_spectrum</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                              <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">)</span>
        <span class="n">freqs</span> <span class="o">+=</span> <span class="n">Fc</span>

        <span class="k">if</span> <span class="n">scale</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">spec</span>
            <span class="n">yunits</span> <span class="o">=</span> <span class="s1">&#39;energy&#39;</span>
        <span class="k">elif</span> <span class="n">scale</span> <span class="o">==</span> <span class="s1">&#39;dB&#39;</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="mf">20.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
            <span class="n">yunits</span> <span class="o">=</span> <span class="s1">&#39;dB&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown scale </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Magnitude (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">yunits</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">angle_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the angle spectrum.</span>

<span class="sd">        Compute the angle spectrum (wrapped phase spectrum) of *x*.</span>
<span class="sd">        Data is padded to a length of *pad_to* and the windowing function</span>
<span class="sd">        *window* is applied to the signal.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : 1-D array or sequence</span>
<span class="sd">            Array or sequence containing the data.</span>

<span class="sd">        %(Spectral)s</span>

<span class="sd">        %(Single_Spectrum)s</span>

<span class="sd">        Fc : int</span>
<span class="sd">            The center frequency of *x* (defaults to 0), which offsets</span>
<span class="sd">            the x extents of the plot to reflect the frequency range used</span>
<span class="sd">            when a signal is acquired and then filtered and downsampled to</span>
<span class="sd">            baseband.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spectrum : 1-D array</span>
<span class="sd">            The values for the angle spectrum in radians (real valued).</span>

<span class="sd">        freqs : 1-D array</span>
<span class="sd">            The frequencies corresponding to the elements in *spectrum*.</span>

<span class="sd">        line : a :class:`~matplotlib.lines.Line2D` instance</span>
<span class="sd">            The line created by this function.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments control the :class:`~matplotlib.lines.Line2D`</span>
<span class="sd">            properties:</span>

<span class="sd">        %(_Line2D_docstr)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :func:`magnitude_spectrum`</span>
<span class="sd">            :func:`angle_spectrum` plots the magnitudes of the corresponding</span>
<span class="sd">            frequencies.</span>

<span class="sd">        :func:`phase_spectrum`</span>
<span class="sd">            :func:`phase_spectrum` plots the unwrapped version of this</span>
<span class="sd">            function.</span>

<span class="sd">        :func:`specgram`</span>
<span class="sd">            :func:`specgram` can plot the angle spectrum of segments within the</span>
<span class="sd">            signal in a colormap.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">Fc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Fc</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">angle_spectrum</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                          <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">)</span>
        <span class="n">freqs</span> <span class="o">+=</span> <span class="n">Fc</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Angle (radians)&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">phase_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the phase spectrum.</span>

<span class="sd">        Compute the phase spectrum (unwrapped angle spectrum) of *x*.</span>
<span class="sd">        Data is padded to a length of *pad_to* and the windowing function</span>
<span class="sd">        *window* is applied to the signal.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : 1-D array or sequence</span>
<span class="sd">            Array or sequence containing the data</span>

<span class="sd">        %(Spectral)s</span>

<span class="sd">        %(Single_Spectrum)s</span>

<span class="sd">        Fc : int</span>
<span class="sd">            The center frequency of *x* (defaults to 0), which offsets</span>
<span class="sd">            the x extents of the plot to reflect the frequency range used</span>
<span class="sd">            when a signal is acquired and then filtered and downsampled to</span>
<span class="sd">            baseband.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spectrum : 1-D array</span>
<span class="sd">            The values for the phase spectrum in radians (real valued).</span>

<span class="sd">        freqs : 1-D array</span>
<span class="sd">            The frequencies corresponding to the elements in *spectrum*.</span>

<span class="sd">        line : a :class:`~matplotlib.lines.Line2D` instance</span>
<span class="sd">            The line created by this function.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments control the :class:`~matplotlib.lines.Line2D`</span>
<span class="sd">            properties:</span>

<span class="sd">        %(_Line2D_docstr)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :func:`magnitude_spectrum`</span>
<span class="sd">            :func:`magnitude_spectrum` plots the magnitudes of the</span>
<span class="sd">            corresponding frequencies.</span>

<span class="sd">        :func:`angle_spectrum`</span>
<span class="sd">            :func:`angle_spectrum` plots the wrapped version of this function.</span>

<span class="sd">        :func:`specgram`</span>
<span class="sd">            :func:`specgram` can plot the phase spectrum of segments within the</span>
<span class="sd">            signal in a colormap.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">Fc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Fc</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">phase_spectrum</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                          <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">)</span>
        <span class="n">freqs</span> <span class="o">+=</span> <span class="n">Fc</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Phase (radians)&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">])</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">cohere</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">Fc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">mlab</span><span class="o">.</span><span class="n">detrend_none</span><span class="p">,</span>
               <span class="n">window</span><span class="o">=</span><span class="n">mlab</span><span class="o">.</span><span class="n">window_hanning</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">sides</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the coherence between *x* and *y*.</span>

<span class="sd">        Plot the coherence between *x* and *y*.  Coherence is the</span>
<span class="sd">        normalized cross spectral density:</span>

<span class="sd">        .. math::</span>

<span class="sd">          C_{xy} = \\frac{|P_{xy}|^2}{P_{xx}P_{yy}}</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(Spectral)s</span>

<span class="sd">        %(PSD)s</span>

<span class="sd">        noverlap : int</span>
<span class="sd">            The number of points of overlap between blocks.  The</span>
<span class="sd">            default value is 0 (no overlap).</span>

<span class="sd">        Fc : int</span>
<span class="sd">            The center frequency of *x* (defaults to 0), which offsets</span>
<span class="sd">            the x extents of the plot to reflect the frequency range used</span>
<span class="sd">            when a signal is acquired and then filtered and downsampled to</span>
<span class="sd">            baseband.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Cxy : 1-D array</span>
<span class="sd">            The coherence vector.</span>

<span class="sd">        freqs : 1-D array</span>
<span class="sd">            The frequencies for the elements in *Cxy*.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments control the :class:`~matplotlib.lines.Line2D`</span>
<span class="sd">            properties:</span>

<span class="sd">        %(_Line2D_docstr)s</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Bendat &amp; Piersol -- Random Data: Analysis and Measurement Procedures,</span>
<span class="sd">        John Wiley &amp; Sons (1986)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cxy</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">cohere</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span>
                                 <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span>
                                 <span class="n">scale_by_freq</span><span class="o">=</span><span class="n">scale_by_freq</span><span class="p">)</span>
        <span class="n">freqs</span> <span class="o">+=</span> <span class="n">Fc</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">cxy</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Coherence&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cxy</span><span class="p">,</span> <span class="n">freqs</span>

    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span>
    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">specgram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xextent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot a spectrogram.</span>

<span class="sd">        Compute and plot a spectrogram of data in *x*.  Data are split into</span>
<span class="sd">        *NFFT* length segments and the spectrum of each section is</span>
<span class="sd">        computed.  The windowing function *window* is applied to each</span>
<span class="sd">        segment, and the amount of overlap of each segment is</span>
<span class="sd">        specified with *noverlap*. The spectrogram is plotted as a colormap</span>
<span class="sd">        (using imshow).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : 1-D array or sequence</span>
<span class="sd">            Array or sequence containing the data.</span>

<span class="sd">        %(Spectral)s</span>

<span class="sd">        %(PSD)s</span>

<span class="sd">        mode : {&#39;default&#39;, &#39;psd&#39;, &#39;magnitude&#39;, &#39;angle&#39;, &#39;phase&#39;}</span>
<span class="sd">            What sort of spectrum to use.  Default is &#39;psd&#39;, which takes the</span>
<span class="sd">            power spectral density.  &#39;magnitude&#39; returns the magnitude</span>
<span class="sd">            spectrum.  &#39;angle&#39; returns the phase spectrum without unwrapping.</span>
<span class="sd">            &#39;phase&#39; returns the phase spectrum with unwrapping.</span>

<span class="sd">        noverlap : int</span>
<span class="sd">            The number of points of overlap between blocks.  The</span>
<span class="sd">            default value is 128.</span>

<span class="sd">        scale : {&#39;default&#39;, &#39;linear&#39;, &#39;dB&#39;}</span>
<span class="sd">            The scaling of the values in the *spec*.  &#39;linear&#39; is no scaling.</span>
<span class="sd">            &#39;dB&#39; returns the values in dB scale.  When *mode* is &#39;psd&#39;,</span>
<span class="sd">            this is dB power (10 * log10).  Otherwise this is dB amplitude</span>
<span class="sd">            (20 * log10). &#39;default&#39; is &#39;dB&#39; if *mode* is &#39;psd&#39; or</span>
<span class="sd">            &#39;magnitude&#39; and &#39;linear&#39; otherwise.  This must be &#39;linear&#39;</span>
<span class="sd">            if *mode* is &#39;angle&#39; or &#39;phase&#39;.</span>

<span class="sd">        Fc : int</span>
<span class="sd">            The center frequency of *x* (defaults to 0), which offsets</span>
<span class="sd">            the x extents of the plot to reflect the frequency range used</span>
<span class="sd">            when a signal is acquired and then filtered and downsampled to</span>
<span class="sd">            baseband.</span>

<span class="sd">        cmap</span>
<span class="sd">            A :class:`matplotlib.colors.Colormap` instance; if *None*, use</span>
<span class="sd">            default determined by rc</span>

<span class="sd">        xextent : *None* or (xmin, xmax)</span>
<span class="sd">            The image extent along the x-axis. The default sets *xmin* to the</span>
<span class="sd">            left border of the first bin (*spectrum* column) and *xmax* to the</span>
<span class="sd">            right border of the last bin. Note that for *noverlap&gt;0* the width</span>
<span class="sd">            of the bins is smaller than those of the segments.</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Additional kwargs are passed on to imshow which makes the</span>
<span class="sd">            specgram image.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spectrum : 2-D array</span>
<span class="sd">            Columns are the periodograms of successive segments.</span>

<span class="sd">        freqs : 1-D array</span>
<span class="sd">            The frequencies corresponding to the rows in *spectrum*.</span>

<span class="sd">        t : 1-D array</span>
<span class="sd">            The times corresponding to midpoints of segments (i.e., the columns</span>
<span class="sd">            in *spectrum*).</span>

<span class="sd">        im : instance of class :class:`~matplotlib.image.AxesImage`</span>
<span class="sd">            The image created by imshow containing the spectrogram</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :func:`psd`</span>
<span class="sd">            :func:`psd` differs in the default overlap; in returning the mean</span>
<span class="sd">            of the segment periodograms; in not returning times; and in</span>
<span class="sd">            generating a line plot instead of colormap.</span>

<span class="sd">        :func:`magnitude_spectrum`</span>
<span class="sd">            A single spectrum, similar to having a single segment when *mode*</span>
<span class="sd">            is &#39;magnitude&#39;. Plots a line instead of a colormap.</span>

<span class="sd">        :func:`angle_spectrum`</span>
<span class="sd">            A single spectrum, similar to having a single segment when *mode*</span>
<span class="sd">            is &#39;angle&#39;. Plots a line instead of a colormap.</span>

<span class="sd">        :func:`phase_spectrum`</span>
<span class="sd">            A single spectrum, similar to having a single segment when *mode*</span>
<span class="sd">            is &#39;phase&#39;. Plots a line instead of a colormap.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The parameters *detrend* and *scale_by_freq* do only apply when *mode*</span>
<span class="sd">        is set to &#39;psd&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">NFFT</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">NFFT</span> <span class="o">=</span> <span class="mi">256</span>  <span class="c1"># same default as in mlab.specgram()</span>
        <span class="k">if</span> <span class="n">Fc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Fc</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># same default as in mlab._spectral_helper()</span>
        <span class="k">if</span> <span class="n">noverlap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">noverlap</span> <span class="o">=</span> <span class="mi">128</span>  <span class="c1"># same default as in mlab.specgram()</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;complex&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot plot a complex specgram&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">scale</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;angle&#39;</span><span class="p">,</span> <span class="s1">&#39;phase&#39;</span><span class="p">]:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="s1">&#39;dB&#39;</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;angle&#39;</span><span class="p">,</span> <span class="s1">&#39;phase&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">scale</span> <span class="o">==</span> <span class="s1">&#39;dB&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot use dB scale with angle or phase mode&#39;</span><span class="p">)</span>

        <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">specgram</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span>
                                       <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                       <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span>
                                       <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span>
                                       <span class="n">scale_by_freq</span><span class="o">=</span><span class="n">scale_by_freq</span><span class="p">,</span>
                                       <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">scale</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">spec</span>
        <span class="k">elif</span> <span class="n">scale</span> <span class="o">==</span> <span class="s1">&#39;dB&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;psd&#39;</span><span class="p">:</span>
                <span class="n">Z</span> <span class="o">=</span> <span class="mf">10.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Z</span> <span class="o">=</span> <span class="mf">20.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown scale </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>

        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">xextent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># padding is needed for first and last segment:</span>
            <span class="n">pad_xextent</span> <span class="o">=</span> <span class="p">(</span><span class="n">NFFT</span><span class="o">-</span><span class="n">noverlap</span><span class="p">)</span> <span class="o">/</span> <span class="n">Fs</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">xextent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">pad_xextent</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">pad_xextent</span>
        <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="n">xextent</span>
        <span class="n">freqs</span> <span class="o">+=</span> <span class="n">Fc</span>
        <span class="n">extent</span> <span class="o">=</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freqs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">cmap</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">im</span>

    <span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
    <span class="k">def</span> <span class="nf">spy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;equal&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;upper&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the sparsity pattern of a 2D array.</span>

<span class="sd">        This visualizes the non-zero values of the array.</span>

<span class="sd">        Two plotting styles are available: image and marker. Both</span>
<span class="sd">        are available for full arrays, but only the marker style</span>
<span class="sd">        works for `scipy.sparse.spmatrix` instances.</span>

<span class="sd">        **Image style**</span>

<span class="sd">        If *marker* and *markersize* are *None*, `~.Axes.imshow` is used. Any</span>
<span class="sd">        extra remaining kwargs are passed to this method.</span>

<span class="sd">        **Marker style**</span>

<span class="sd">        If *Z* is a `scipy.sparse.spmatrix` or *marker* or *markersize* are</span>
<span class="sd">        *None*, a `~matplotlib.lines.Line2D` object will be returned with</span>
<span class="sd">        the value of marker determining the marker type, and any</span>
<span class="sd">        remaining kwargs passed to `~.Axes.plot`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Z : array-like (M, N)</span>
<span class="sd">            The array to be plotted.</span>

<span class="sd">        precision : float or &#39;present&#39;, optional, default: 0</span>
<span class="sd">            If *precision* is 0, any non-zero value will be plotted. Otherwise,</span>
<span class="sd">            values of :math:`|Z| &gt; precision` will be plotted.</span>

<span class="sd">            For :class:`scipy.sparse.spmatrix` instances, you can also</span>
<span class="sd">            pass &#39;present&#39;. In this case any value present in the array</span>
<span class="sd">            will be plotted, even if it is identically zero.</span>

<span class="sd">        origin : {&#39;upper&#39;, &#39;lower&#39;}, optional</span>
<span class="sd">            Place the [0,0] index of the array in the upper left or lower left</span>
<span class="sd">            corner of the axes. The convention &#39;upper&#39; is typically used for</span>
<span class="sd">            matrices and images.</span>
<span class="sd">            If not given, :rc:`image.origin` is used, defaulting to &#39;upper&#39;.</span>


<span class="sd">        aspect : {&#39;equal&#39;, &#39;auto&#39;, None} or float, optional</span>
<span class="sd">            Controls the aspect ratio of the axes. The aspect is of particular</span>
<span class="sd">            relevance for images since it may distort the image, i.e. pixel</span>
<span class="sd">            will not be square.</span>

<span class="sd">            This parameter is a shortcut for explicitly calling</span>
<span class="sd">            `.Axes.set_aspect`. See there for further details.</span>

<span class="sd">            - &#39;equal&#39;: Ensures an aspect ratio of 1. Pixels will be square.</span>
<span class="sd">            - &#39;auto&#39;: The axes is kept fixed and the aspect is adjusted so</span>
<span class="sd">              that the data fit in the axes. In general, this will result in</span>
<span class="sd">              non-square pixels.</span>
<span class="sd">            - *None*: Use :rc:`image.aspect` (default: &#39;equal&#39;).</span>

<span class="sd">            Default: &#39;equal&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ret : `~matplotlib.image.AxesImage` or `.Line2D`</span>
<span class="sd">            The return type depends on the plotting style (see above).</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            The supported additional parameters depend on the plotting style.</span>

<span class="sd">            For the image style, you can pass the following additional</span>
<span class="sd">            parameters of `~.Axes.imshow`:</span>

<span class="sd">            - *cmap*</span>
<span class="sd">            - *alpha*</span>
<span class="sd">            - *url*</span>
<span class="sd">            - any `.Artist` properties (passed on to the `.AxesImage`)</span>

<span class="sd">            For the marker style, you can pass any `.Line2D` property except</span>
<span class="sd">            for *linestyle*:</span>

<span class="sd">        %(_Line2D_docstr)s</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">marker</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">markersize</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="s1">&#39;tocoo&#39;</span><span class="p">):</span>
            <span class="n">marker</span> <span class="o">=</span> <span class="s1">&#39;s&#39;</span>
        <span class="k">if</span> <span class="n">marker</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">markersize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">precision</span>

            <span class="k">if</span> <span class="s1">&#39;cmap&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;cmap&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">ListedColormap</span><span class="p">([</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">],</span>
                                                        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;binary&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;interpolation&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;spy() got an unexpected keyword argument &#39;interpolation&#39;&quot;</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="n">aspect</span><span class="p">,</span>
                              <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="s1">&#39;tocoo&#39;</span><span class="p">):</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">tocoo</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">precision</span> <span class="o">==</span> <span class="s1">&#39;present&#39;</span><span class="p">:</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">row</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">col</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nonzero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">precision</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">row</span><span class="p">[</span><span class="n">nonzero</span><span class="p">]</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">nonzero</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>
                <span class="n">nonzero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">precision</span>
                <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">nonzero</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">marker</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">marker</span> <span class="o">=</span> <span class="s1">&#39;s&#39;</span>
            <span class="k">if</span> <span class="n">markersize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">markersize</span> <span class="o">=</span> <span class="mi">10</span>
            <span class="k">if</span> <span class="s1">&#39;linestyle&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;spy() got an unexpected keyword argument &#39;linestyle&#39;&quot;</span><span class="p">)</span>
            <span class="n">marks</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span>
                         <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="n">markersize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">marks</span><span class="p">)</span>
            <span class="n">nr</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">shape</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">nc</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">nr</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="n">aspect</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">marks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">set_y</span><span class="p">(</span><span class="mf">1.05</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">tick_top</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s1">&#39;both&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">mticker</span><span class="o">.</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="n">nbins</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span>
                                                 <span class="n">steps</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
                                                 <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">mticker</span><span class="o">.</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="n">nbins</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span>
                                                 <span class="n">steps</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
                                                 <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">matshow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the values of a 2D matrix or array as color-coded image.</span>

<span class="sd">        The matrix will be shown the way it would be printed, with the first</span>
<span class="sd">        row at the top.  Row and column numbering is zero-based.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Z : array-like(M, N)</span>
<span class="sd">            The matrix to be displayed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        image : `~matplotlib.image.AxesImage`</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs : `~matplotlib.axes.Axes.imshow` arguments</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        imshow : More general function to plot data on a 2D regular raster.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is just a convenience function wrapping `.imshow` to set useful</span>
<span class="sd">        defaults for a displaying a matrix. In particular:</span>

<span class="sd">        - Set ``origin=&#39;upper&#39;``.</span>
<span class="sd">        - Set ``interpolation=&#39;nearest&#39;``.</span>
<span class="sd">        - Set ``aspect=&#39;equal&#39;``.</span>
<span class="sd">        - Ticks are placed to the left and above.</span>
<span class="sd">        - Ticks are formatted to show integer indices.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>
        <span class="n">kw</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;origin&#39;</span><span class="p">:</span> <span class="s1">&#39;upper&#39;</span><span class="p">,</span>
              <span class="s1">&#39;interpolation&#39;</span><span class="p">:</span> <span class="s1">&#39;nearest&#39;</span><span class="p">,</span>
              <span class="s1">&#39;aspect&#39;</span><span class="p">:</span> <span class="s1">&#39;equal&#39;</span><span class="p">,</span>          <span class="c1"># (already the imshow default)</span>
              <span class="o">**</span><span class="n">kwargs</span><span class="p">}</span>
        <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">set_y</span><span class="p">(</span><span class="mf">1.05</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">tick_top</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s1">&#39;both&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">mticker</span><span class="o">.</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="n">nbins</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span>
                                                 <span class="n">steps</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
                                                 <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">mticker</span><span class="o">.</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="n">nbins</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span>
                                                 <span class="n">steps</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
                                                 <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">im</span>

    <span class="nd">@_preprocess_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;dataset&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">violinplot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vert</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                   <span class="n">showmeans</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">showextrema</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">showmedians</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">points</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">bw_method</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a violin plot.</span>

<span class="sd">        Make a violin plot for each column of *dataset* or each vector in</span>
<span class="sd">        sequence *dataset*.  Each filled area extends to represent the</span>
<span class="sd">        entire data range, with optional lines at the mean, the median,</span>
<span class="sd">        the minimum, and the maximum.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dataset : Array or a sequence of vectors.</span>
<span class="sd">          The input data.</span>

<span class="sd">        positions : array-like, default = [1, 2, ..., n]</span>
<span class="sd">          Sets the positions of the violins. The ticks and limits are</span>
<span class="sd">          automatically set to match the positions.</span>

<span class="sd">        vert : bool, default = True.</span>
<span class="sd">          If true, creates a vertical violin plot.</span>
<span class="sd">          Otherwise, creates a horizontal violin plot.</span>

<span class="sd">        widths : array-like, default = 0.5</span>
<span class="sd">          Either a scalar or a vector that sets the maximal width of</span>
<span class="sd">          each violin. The default is 0.5, which uses about half of the</span>
<span class="sd">          available horizontal space.</span>

<span class="sd">        showmeans : bool, default = False</span>
<span class="sd">          If `True`, will toggle rendering of the means.</span>

<span class="sd">        showextrema : bool, default = True</span>
<span class="sd">          If `True`, will toggle rendering of the extrema.</span>

<span class="sd">        showmedians : bool, default = False</span>
<span class="sd">          If `True`, will toggle rendering of the medians.</span>

<span class="sd">        points : scalar, default = 100</span>
<span class="sd">          Defines the number of points to evaluate each of the</span>
<span class="sd">          gaussian kernel density estimations at.</span>

<span class="sd">        bw_method : str, scalar or callable, optional</span>
<span class="sd">          The method used to calculate the estimator bandwidth.  This can be</span>
<span class="sd">          &#39;scott&#39;, &#39;silverman&#39;, a scalar constant or a callable.  If a</span>
<span class="sd">          scalar, this will be used directly as `kde.factor`.  If a</span>
<span class="sd">          callable, it should take a `GaussianKDE` instance as its only</span>
<span class="sd">          parameter and return a scalar. If None (default), &#39;scott&#39; is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        result : dict</span>
<span class="sd">          A dictionary mapping each component of the violinplot to a</span>
<span class="sd">          list of the corresponding collection instances created. The</span>
<span class="sd">          dictionary has the following keys:</span>

<span class="sd">            - ``bodies``: A list of the</span>
<span class="sd">              :class:`matplotlib.collections.PolyCollection` instances</span>
<span class="sd">              containing the filled area of each violin.</span>

<span class="sd">            - ``cmeans``: A</span>
<span class="sd">              :class:`matplotlib.collections.LineCollection` instance</span>
<span class="sd">              created to identify the mean values of each of the</span>
<span class="sd">              violin&#39;s distribution.</span>

<span class="sd">            - ``cmins``: A</span>
<span class="sd">              :class:`matplotlib.collections.LineCollection` instance</span>
<span class="sd">              created to identify the bottom of each violin&#39;s</span>
<span class="sd">              distribution.</span>

<span class="sd">            - ``cmaxes``: A</span>
<span class="sd">              :class:`matplotlib.collections.LineCollection` instance</span>
<span class="sd">              created to identify the top of each violin&#39;s</span>
<span class="sd">              distribution.</span>

<span class="sd">            - ``cbars``: A</span>
<span class="sd">              :class:`matplotlib.collections.LineCollection` instance</span>
<span class="sd">              created to identify the centers of each violin&#39;s</span>
<span class="sd">              distribution.</span>

<span class="sd">            - ``cmedians``: A</span>
<span class="sd">              :class:`matplotlib.collections.LineCollection` instance</span>
<span class="sd">              created to identify the median values of each of the</span>
<span class="sd">              violin&#39;s distribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_kde_method</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
            <span class="c1"># fallback gracefully if the vector contains only one value</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">X</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">coords</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">kde</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">GaussianKDE</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">bw_method</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">kde</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>

        <span class="n">vpstats</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">violin_stats</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">_kde_method</span><span class="p">,</span> <span class="n">points</span><span class="o">=</span><span class="n">points</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">violin</span><span class="p">(</span><span class="n">vpstats</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="n">positions</span><span class="p">,</span> <span class="n">vert</span><span class="o">=</span><span class="n">vert</span><span class="p">,</span>
                           <span class="n">widths</span><span class="o">=</span><span class="n">widths</span><span class="p">,</span> <span class="n">showmeans</span><span class="o">=</span><span class="n">showmeans</span><span class="p">,</span>
                           <span class="n">showextrema</span><span class="o">=</span><span class="n">showextrema</span><span class="p">,</span> <span class="n">showmedians</span><span class="o">=</span><span class="n">showmedians</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">violin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vpstats</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vert</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
               <span class="n">showmeans</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">showextrema</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">showmedians</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Drawing function for violin plots.</span>

<span class="sd">        Draw a violin plot for each column of `vpstats`. Each filled area</span>
<span class="sd">        extends to represent the entire data range, with optional lines at the</span>
<span class="sd">        mean, the median, the minimum, and the maximum.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        vpstats : list of dicts</span>
<span class="sd">          A list of dictionaries containing stats for each violin plot.</span>
<span class="sd">          Required keys are:</span>

<span class="sd">          - ``coords``: A list of scalars containing the coordinates that</span>
<span class="sd">            the violin&#39;s kernel density estimate were evaluated at.</span>

<span class="sd">          - ``vals``: A list of scalars containing the values of the</span>
<span class="sd">            kernel density estimate at each of the coordinates given</span>
<span class="sd">            in *coords*.</span>

<span class="sd">          - ``mean``: The mean value for this violin&#39;s dataset.</span>

<span class="sd">          - ``median``: The median value for this violin&#39;s dataset.</span>

<span class="sd">          - ``min``: The minimum value for this violin&#39;s dataset.</span>

<span class="sd">          - ``max``: The maximum value for this violin&#39;s dataset.</span>

<span class="sd">        positions : array-like, default = [1, 2, ..., n]</span>
<span class="sd">          Sets the positions of the violins. The ticks and limits are</span>
<span class="sd">          automatically set to match the positions.</span>

<span class="sd">        vert : bool, default = True.</span>
<span class="sd">          If true, plots the violins vertically.</span>
<span class="sd">          Otherwise, plots the violins horizontally.</span>

<span class="sd">        widths : array-like, default = 0.5</span>
<span class="sd">          Either a scalar or a vector that sets the maximal width of</span>
<span class="sd">          each violin. The default is 0.5, which uses about half of the</span>
<span class="sd">          available horizontal space.</span>

<span class="sd">        showmeans : bool, default = False</span>
<span class="sd">          If true, will toggle rendering of the means.</span>

<span class="sd">        showextrema : bool, default = True</span>
<span class="sd">          If true, will toggle rendering of the extrema.</span>

<span class="sd">        showmedians : bool, default = False</span>
<span class="sd">          If true, will toggle rendering of the medians.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : dict</span>
<span class="sd">          A dictionary mapping each component of the violinplot to a</span>
<span class="sd">          list of the corresponding collection instances created. The</span>
<span class="sd">          dictionary has the following keys:</span>

<span class="sd">            - ``bodies``: A list of the</span>
<span class="sd">              :class:`matplotlib.collections.PolyCollection` instances</span>
<span class="sd">              containing the filled area of each violin.</span>

<span class="sd">            - ``cmeans``: A</span>
<span class="sd">              :class:`matplotlib.collections.LineCollection` instance</span>
<span class="sd">              created to identify the mean values of each of the</span>
<span class="sd">              violin&#39;s distribution.</span>

<span class="sd">            - ``cmins``: A</span>
<span class="sd">              :class:`matplotlib.collections.LineCollection` instance</span>
<span class="sd">              created to identify the bottom of each violin&#39;s</span>
<span class="sd">              distribution.</span>

<span class="sd">            - ``cmaxes``: A</span>
<span class="sd">              :class:`matplotlib.collections.LineCollection` instance</span>
<span class="sd">              created to identify the top of each violin&#39;s</span>
<span class="sd">              distribution.</span>

<span class="sd">            - ``cbars``: A</span>
<span class="sd">              :class:`matplotlib.collections.LineCollection` instance</span>
<span class="sd">              created to identify the centers of each violin&#39;s</span>
<span class="sd">              distribution.</span>

<span class="sd">            - ``cmedians``: A</span>
<span class="sd">              :class:`matplotlib.collections.LineCollection` instance</span>
<span class="sd">              created to identify the median values of each of the</span>
<span class="sd">              violin&#39;s distribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Statistical quantities to be plotted on the violins</span>
        <span class="n">means</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mins</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">maxes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">medians</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Collections to be returned</span>
        <span class="n">artists</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vpstats</span><span class="p">)</span>
        <span class="n">datashape_message</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;List of violinplot statistics and `</span><span class="si">{0}</span><span class="s2">` &quot;</span>
                             <span class="s2">&quot;values must have the same length&quot;</span><span class="p">)</span>

        <span class="c1"># Validate positions</span>
        <span class="k">if</span> <span class="n">positions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">!=</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">datashape_message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;positions&quot;</span><span class="p">))</span>

        <span class="c1"># Validate widths</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">widths</span><span class="p">):</span>
            <span class="n">widths</span> <span class="o">=</span> <span class="p">[</span><span class="n">widths</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span> <span class="o">!=</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">datashape_message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;widths&quot;</span><span class="p">))</span>

        <span class="c1"># Calculate ranges for statistics lines</span>
        <span class="n">pmins</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.25</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span> <span class="o">+</span> <span class="n">positions</span>
        <span class="n">pmaxes</span> <span class="o">=</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span> <span class="o">+</span> <span class="n">positions</span>

        <span class="c1"># Check whether we are rendering vertically or horizontally</span>
        <span class="k">if</span> <span class="n">vert</span><span class="p">:</span>
            <span class="n">fill</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_betweenx</span>
            <span class="n">perp_lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hlines</span>
            <span class="n">par_lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vlines</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fill</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_between</span>
            <span class="n">perp_lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vlines</span>
            <span class="n">par_lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hlines</span>

        <span class="k">if</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;_internal.classic_mode&#39;</span><span class="p">]:</span>
            <span class="n">fillcolor</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span>
            <span class="n">edgecolor</span> <span class="o">=</span> <span class="s1">&#39;r&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fillcolor</span> <span class="o">=</span> <span class="n">edgecolor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lines</span><span class="o">.</span><span class="n">get_next_color</span><span class="p">()</span>

        <span class="c1"># Render violins</span>
        <span class="n">bodies</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">stats</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">width</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">vpstats</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">widths</span><span class="p">):</span>
            <span class="c1"># The 0.5 factor reflects the fact that we plot from v-p to</span>
            <span class="c1"># v+p</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;vals&#39;</span><span class="p">])</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">width</span> <span class="o">*</span> <span class="n">vals</span> <span class="o">/</span> <span class="n">vals</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">bodies</span> <span class="o">+=</span> <span class="p">[</span><span class="n">fill</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">],</span>
                            <span class="o">-</span><span class="n">vals</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span>
                            <span class="n">vals</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span>
                            <span class="n">facecolor</span><span class="o">=</span><span class="n">fillcolor</span><span class="p">,</span>
                            <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)]</span>
            <span class="n">means</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">])</span>
            <span class="n">mins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">])</span>
            <span class="n">maxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">])</span>
            <span class="n">medians</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;median&#39;</span><span class="p">])</span>
        <span class="n">artists</span><span class="p">[</span><span class="s1">&#39;bodies&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bodies</span>

        <span class="c1"># Render means</span>
        <span class="k">if</span> <span class="n">showmeans</span><span class="p">:</span>
            <span class="n">artists</span><span class="p">[</span><span class="s1">&#39;cmeans&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">perp_lines</span><span class="p">(</span><span class="n">means</span><span class="p">,</span> <span class="n">pmins</span><span class="p">,</span> <span class="n">pmaxes</span><span class="p">,</span>
                                           <span class="n">colors</span><span class="o">=</span><span class="n">edgecolor</span><span class="p">)</span>

        <span class="c1"># Render extrema</span>
        <span class="k">if</span> <span class="n">showextrema</span><span class="p">:</span>
            <span class="n">artists</span><span class="p">[</span><span class="s1">&#39;cmaxes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">perp_lines</span><span class="p">(</span><span class="n">maxes</span><span class="p">,</span> <span class="n">pmins</span><span class="p">,</span> <span class="n">pmaxes</span><span class="p">,</span>
                                           <span class="n">colors</span><span class="o">=</span><span class="n">edgecolor</span><span class="p">)</span>
            <span class="n">artists</span><span class="p">[</span><span class="s1">&#39;cmins&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">perp_lines</span><span class="p">(</span><span class="n">mins</span><span class="p">,</span> <span class="n">pmins</span><span class="p">,</span> <span class="n">pmaxes</span><span class="p">,</span>
                                          <span class="n">colors</span><span class="o">=</span><span class="n">edgecolor</span><span class="p">)</span>
            <span class="n">artists</span><span class="p">[</span><span class="s1">&#39;cbars&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">par_lines</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">mins</span><span class="p">,</span> <span class="n">maxes</span><span class="p">,</span>
                                         <span class="n">colors</span><span class="o">=</span><span class="n">edgecolor</span><span class="p">)</span>

        <span class="c1"># Render medians</span>
        <span class="k">if</span> <span class="n">showmedians</span><span class="p">:</span>
            <span class="n">artists</span><span class="p">[</span><span class="s1">&#39;cmedians&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">perp_lines</span><span class="p">(</span><span class="n">medians</span><span class="p">,</span>
                                             <span class="n">pmins</span><span class="p">,</span>
                                             <span class="n">pmaxes</span><span class="p">,</span>
                                             <span class="n">colors</span><span class="o">=</span><span class="n">edgecolor</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">artists</span>

    <span class="c1"># Methods that are entirely implemented in other modules.</span>

    <span class="n">table</span> <span class="o">=</span> <span class="n">mtable</span><span class="o">.</span><span class="n">table</span>

    <span class="c1"># args can by either Y or y1,y2,... and all should be replaced</span>
    <span class="n">stackplot</span> <span class="o">=</span> <span class="n">_preprocess_data</span><span class="p">()(</span><span class="n">mstack</span><span class="o">.</span><span class="n">stackplot</span><span class="p">)</span>

    <span class="n">streamplot</span> <span class="o">=</span> <span class="n">_preprocess_data</span><span class="p">(</span>
        <span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="s2">&quot;start_points&quot;</span><span class="p">])(</span><span class="n">mstream</span><span class="o">.</span><span class="n">streamplot</span><span class="p">)</span>

    <span class="n">tricontour</span> <span class="o">=</span> <span class="n">mtri</span><span class="o">.</span><span class="n">tricontour</span>
    <span class="n">tricontourf</span> <span class="o">=</span> <span class="n">mtri</span><span class="o">.</span><span class="n">tricontourf</span>
    <span class="n">tripcolor</span> <span class="o">=</span> <span class="n">mtri</span><span class="o">.</span><span class="n">tripcolor</span>
    <span class="n">triplot</span> <span class="o">=</span> <span class="n">mtri</span><span class="o">.</span><span class="n">triplot</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Kevin A.G. Smet

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>