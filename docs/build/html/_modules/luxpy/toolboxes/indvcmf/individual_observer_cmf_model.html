<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>luxpy.toolboxes.indvcmf.individual_observer_cmf_model &mdash; LuxPy 1.11.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=b76e3c8a" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../../_static/documentation_options.js?v=6cf1fb80"></script>
        <script src="../../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            LuxPy
          </a>
              <div class="version">
                1.11.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../license.html">License: GPLv3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../required_packages.html">Imported (required) packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../luxpy_structure.html">Luxpy package structure</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">LuxPy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">luxpy.toolboxes.indvcmf.individual_observer_cmf_model</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for luxpy.toolboxes.indvcmf.individual_observer_cmf_model</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module for Individual Observer lms-CMFs (Asano, 2016 and CIE TC1-97)</span>
<span class="sd">====================================================================</span>
<span class="sd">    </span>
<span class="sd"> :_DATA_PATH: path to data files</span>
<span class="sd"> </span>
<span class="sd"> :_DATA: Dict with required data</span>
<span class="sd"> </span>
<span class="sd"> :_DSRC_STD_DEF: default data source for stdev of physiological data (&#39;matlab&#39;, &#39;germany&#39;)</span>
<span class="sd"> </span>
<span class="sd"> :_DSRC_LMS_ODENS_DEF: default data source for lms absorbances and optical densities (&#39;asano&#39;, &#39;cietc197&#39;)</span>
<span class="sd"> </span>
<span class="sd"> :_LMS_TO_XYZ_METHOD: default method to calculate lms to xyz conversion matrix (&#39;asano&#39;, &#39;cietc197&#39;)</span>
<span class="sd"> </span>
<span class="sd"> :_WL_CRIT: critical wavelength above which interpolation of S-cone data fails.</span>
<span class="sd"> </span>
<span class="sd"> :_WL: default wavelengths of spectral data in INDVCMF_DATA.</span>
<span class="sd"> </span>
<span class="sd"> :load_database(): Load a database with parameters and data required by the Asano model.</span>
<span class="sd"> </span>
<span class="sd"> :init():   Initialize: load database required for Asano Individual Observer Model </span>
<span class="sd">            into the default _DATA dict and set some options for rounding, </span>
<span class="sd">            sign. figs and chopping small value to zero; for source data to use for </span>
<span class="sd">            spectral data for LMS absorp. and optical densities, ... </span>
<span class="sd">            </span>
<span class="sd"> :query_state(): print current settings for global variables.</span>
<span class="sd"> </span>
<span class="sd"> :compute_cmfs(): Generate Individual Observer CMFs (cone fundamentals) </span>
<span class="sd">                  based on CIE2006 cone fundamentals and published literature </span>
<span class="sd">                  on observer variability in color matching and </span>
<span class="sd">                  in physiological parameters (Use of Asano optical data and model; </span>
<span class="sd">                  or of CIE TC1-91 data and &#39;variability&#39;-extended model possible).</span>
<span class="sd"> </span>
<span class="sd"> :cie2006cmfsEx(): Generate Individual Observer CMFs (cone fundamentals) </span>
<span class="sd">                   based on CIE2006 cone fundamentals and published literature </span>
<span class="sd">                   on observer variability in color matching and </span>
<span class="sd">                   in physiological parameters. (Use of Asano optical data and model; </span>
<span class="sd">                   or of CIE TC1-91 data and &#39;variability&#39;-extended model possible)</span>
<span class="sd"> </span>
<span class="sd"> :getMonteCarloParam(): Get dict with normally-distributed physiological </span>
<span class="sd">                        factors for a population of observers.</span>
<span class="sd">                            </span>
<span class="sd"> :getUSCensusAgeDist(): Get US Census Age Distribution</span>
<span class="sd"> </span>
<span class="sd"> :genMonteCarloObs(): Monte-Carlo generation of individual observer </span>
<span class="sd">                      color matching functions (cone fundamentals) for a</span>
<span class="sd">                      certain age and field size.</span>
<span class="sd"> </span>
<span class="sd"> :getCatObs(): Generate cone fundamentals for categorical observers.</span>
<span class="sd"> </span>
<span class="sd"> :get_lms_to_xyz_matrix(): Calculate lms to xyz conversion matrix for a specific field </span>
<span class="sd">                           size determined as a weighted combination of the 2° and 10° matrices.</span>
<span class="sd"> </span>
<span class="sd"> :lmsb_to_xyzb(): Convert from LMS cone fundamentals to XYZ CMFs using conversion</span>
<span class="sd">                  matrix determined as a weighted combination of the 2° and 10° matrices.</span>
<span class="sd"> </span>
<span class="sd"> :add_to_cmf_dict(): Add set of cmfs to _CMF dict.</span>
<span class="sd"> </span>
<span class="sd"> :plot_cmfs(): Plot cmf set.</span>

<span class="sd">References</span>
<span class="sd">----------</span>
<span class="sd"> 1. `Asano Y, Fairchild MD, and Blondé L (2016). </span>
<span class="sd"> Individual Colorimetric Observer Model. </span>
<span class="sd"> PLoS One 11, 1–19. </span>
<span class="sd"> &lt;https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0145671&gt;`_</span>
<span class="sd"> </span>
<span class="sd"> 2. `Asano Y, Fairchild MD, Blondé L, and Morvan P (2016). </span>
<span class="sd"> Color matching experiment for highlighting interobserver variability. </span>
<span class="sd"> Color Res. Appl. 41, 530–539. </span>
<span class="sd"> &lt;https://onlinelibrary.wiley.com/doi/abs/10.1002/col.21975&gt;`_</span>
<span class="sd"> </span>
<span class="sd"> 3. `CIE TC1-36 (2006). </span>
<span class="sd"> Fundamental Chromaticity Diagram with Physiological Axes - Part I </span>
<span class="sd"> (Vienna: CIE). </span>
<span class="sd"> &lt;https://www.cie.co.at/publications/fundamental-chromaticity-diagram-physiological-axes-part-1&gt;`_ </span>
<span class="sd"> </span>
<span class="sd"> 4. `Asano&#39;s Individual Colorimetric Observer Model </span>
<span class="sd"> &lt;https://www.rit.edu/cos/colorscience/re_AsanoObserverFunctions.php&gt;`_</span>
<span class="sd"> </span>
<span class="sd"> 5. `CIE TC1-97 cmf functions python code developed by Ivar Farup and Jan Hendrik Wold.</span>
<span class="sd"> &lt;https://github.com/ifarup/ciefunctions&gt;`_</span>
<span class="sd"> </span>
<span class="sd">Notes</span>
<span class="sd">-----</span>
<span class="sd">    1. Port of Matlab code from: </span>
<span class="sd">    https://www.rit.edu/cos/colorscience/re_AsanoObserverFunctions.php</span>
<span class="sd">    (Accessed April 20, 2018)  </span>
<span class="sd">    2. Adjusted/extended following CIE TC1-97 Python code (and data):</span>
<span class="sd">    github.com/ifarup/ciefunctions (Copyright (C) 2012-2017 Ivar Farup and Jan Henrik Wold)     </span>
<span class="sd">    (Accessed Dec 18, 2019)</span>

<span class="sd">.. codeauthor:: Kevin A.G. Smet (ksmet1977 at gmail.com)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">luxpy</span> <span class="kn">import</span> <span class="n">math</span><span class="p">,</span> <span class="n">_WL3</span><span class="p">,</span> <span class="n">_CMF</span><span class="p">,</span> <span class="n">getwlr</span><span class="p">,</span> <span class="n">getwld</span><span class="p">,</span> <span class="n">cie_interp</span><span class="p">,</span> <span class="n">spd_to_power</span><span class="p">,</span> <span class="n">xyz_to_Yxy</span><span class="p">,</span> <span class="n">spd_normalize</span>
<span class="kn">from</span> <span class="nn">luxpy.utils</span> <span class="kn">import</span> <span class="n">_PKG_PATH</span><span class="p">,</span> <span class="n">_SEP</span><span class="p">,</span> <span class="n">getdata</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;_DATA&#39;</span><span class="p">,</span><span class="s1">&#39;_DSRC_STD_DEF&#39;</span><span class="p">,</span> <span class="s1">&#39;_DSRC_LMS_ODENS_DEF&#39;</span><span class="p">,</span><span class="s1">&#39;_LMS_TO_XYZ_METHOD&#39;</span><span class="p">]</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;load_database&#39;</span><span class="p">,</span><span class="s1">&#39;init&#39;</span><span class="p">,</span><span class="s1">&#39;query_state&#39;</span><span class="p">]</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;cie2006cmfsEx&#39;</span><span class="p">,</span><span class="s1">&#39;getMonteCarloParam&#39;</span><span class="p">,</span><span class="s1">&#39;genMonteCarloObs&#39;</span><span class="p">,</span><span class="s1">&#39;getCatObs&#39;</span><span class="p">]</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;compute_cmfs&#39;</span><span class="p">,</span><span class="s1">&#39;add_to_cmf_dict&#39;</span><span class="p">,</span><span class="s1">&#39;plot_cmfs&#39;</span><span class="p">]</span>


<span class="n">_DATA_PATH</span> <span class="o">=</span> <span class="n">_PKG_PATH</span> <span class="o">+</span> <span class="n">_SEP</span> <span class="o">+</span> <span class="s1">&#39;toolboxes&#39;</span> <span class="o">+</span> <span class="n">_SEP</span> <span class="o">+</span> <span class="s1">&#39;indvcmf&#39;</span> <span class="o">+</span> <span class="n">_SEP</span> <span class="o">+</span> <span class="s1">&#39;data&#39;</span> <span class="o">+</span> <span class="n">_SEP</span>  
<span class="c1">#_DATA_PATH = &#39;./data/&#39; # for testing</span>

<span class="k">global</span> <span class="n">_WL</span><span class="p">,</span> <span class="n">_DATA</span><span class="p">,</span> <span class="n">_USE_MY_ROUND</span><span class="p">,</span> <span class="n">_USE_SIGN_FIGS</span><span class="p">,</span> <span class="n">_USE_CHOP</span><span class="p">,</span> <span class="n">_DSRC_STD_DEF</span><span class="p">,</span><span class="n">_DSRC_LMS_ODENS_DEF</span><span class="p">,</span> <span class="n">_LMS_TO_XYZ_METHOD</span><span class="p">,</span> <span class="n">_DATA</span>
<span class="n">_DATA</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">_DSRC_STD_DEF</span> <span class="o">=</span> <span class="s1">&#39;matlab&#39;</span> <span class="c1"># default data source for stdev of physiological data</span>
<span class="n">_DSRC_LMS_ODENS_DEF</span> <span class="o">=</span> <span class="s1">&#39;cietc197&#39;</span> <span class="c1"># default data source for lms absorbances and optical densities</span>
<span class="n">_LMS_TO_XYZ_METHOD</span> <span class="o">=</span> <span class="s1">&#39;cietc197&#39;</span> <span class="c1"># default method to calculate lms to xyz conversion matrix</span>


<span class="n">_WL_CRIT</span> <span class="o">=</span> <span class="mi">620</span> <span class="c1"># Asano: 620 nm: wavelenght at which interpolation fails for S-cones</span>
<span class="n">_WL_ASANO</span> <span class="o">=</span> <span class="n">getwlr</span><span class="p">([</span><span class="mi">390</span><span class="p">,</span><span class="mi">780</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span> <span class="c1"># wavelength range of spectral data in _DATA</span>
<span class="n">_WL_CIETC197</span> <span class="o">=</span> <span class="n">getwlr</span><span class="p">([</span><span class="mi">390</span><span class="p">,</span> <span class="mi">830</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">])</span> <span class="c1"># wavelength range of spectral data in _DATA</span>
<span class="k">if</span> <span class="n">_DSRC_LMS_ODENS_DEF</span> <span class="o">==</span> <span class="s1">&#39;asano&#39;</span><span class="p">:</span>
    <span class="n">_WL</span> <span class="o">=</span> <span class="n">_WL_ASANO</span>
<span class="k">elif</span> <span class="n">_DSRC_LMS_ODENS_DEF</span> <span class="o">==</span> <span class="s1">&#39;cietc197&#39;</span><span class="p">:</span>
    <span class="n">_WL</span> <span class="o">=</span> <span class="n">_WL_CIETC197</span>
    
<span class="c1">#=============================================================================  </span>
<span class="c1">#  Utility functions</span>
<span class="c1">#=============================================================================</span>
<span class="n">_USE_MY_ROUND</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">_USE_SIGN_FIGS</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">_USE_CHOP</span> <span class="o">=</span> <span class="kc">True</span>

<span class="k">def</span> <span class="nf">my_round</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Round array x to n decimal points using round half away from zero.</span>
<span class="sd">    This function is needed because the rounding specified in the CIE</span>
<span class="sd">    recommendation is different from the standard rounding scheme in python</span>
<span class="sd">    (which is following the IEEE recommendation).</span>
<span class="sd">    Args:</span>
<span class="sd">        :x: </span>
<span class="sd">            | ndarray</span>
<span class="sd">            | Array to be rounded</span>
<span class="sd">        :n:</span>
<span class="sd">            | int</span>
<span class="sd">            | Number of decimal points</span>
<span class="sd">    Returns:</span>
<span class="sd">        :y: </span>
<span class="sd">            | ndarray</span>
<span class="sd">            | Rounded array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">_USE_MY_ROUND</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="mi">10</span><span class="o">**</span><span class="n">n</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">/</span><span class="mi">10</span><span class="o">**</span><span class="n">n</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>

<span class="k">def</span> <span class="nf">sign_figs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Round x to n significant figures (not decimal points).</span>
<span class="sd">    This function is needed because the rounding specified in the CIE</span>
<span class="sd">    recommendation is different from the standard rounding scheme in python</span>
<span class="sd">    (which is following the IEEE recommendation). Uses my_round (above).</span>
<span class="sd">    Args:</span>
<span class="sd">        :x: </span>
<span class="sd">            | int, float or ndarray</span>
<span class="sd">            | Number or array to be rounded.</span>
<span class="sd">    Returns;</span>
<span class="sd">        :t:</span>
<span class="sd">            | float or ndarray</span>
<span class="sd">            | Rounded number or array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">_USE_SIGN_FIGS</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="nb">float</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">exponent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="k">return</span> <span class="mi">10</span><span class="o">**</span><span class="n">exponent</span> <span class="o">*</span> <span class="n">my_round</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="mi">10</span><span class="o">**</span><span class="n">exponent</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">exponent</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">exponent</span><span class="p">[</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">exponent</span><span class="p">[</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])))</span>
        <span class="k">return</span> <span class="mi">10</span><span class="o">**</span><span class="n">exponent</span> <span class="o">*</span> <span class="n">my_round</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="mi">10</span><span class="o">**</span><span class="n">exponent</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span> <span class="nf">chop</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-14</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Chop values smaller than epsilon in absolute value to zero.</span>
<span class="sd">    Similar to Mathematica function.</span>
<span class="sd">    Args:</span>
<span class="sd">        :arr:</span>
<span class="sd">            | float or ndarray</span>
<span class="sd">            | Array or number to be chopped.</span>
<span class="sd">        :epsilon:</span>
<span class="sd">            | float</span>
<span class="sd">            | Minimum number.</span>
<span class="sd">    Returns:</span>
<span class="sd">        :chopped:</span>
<span class="sd">            | float or ndarray</span>
<span class="sd">            | Chopped numbers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">_USE_CHOP</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">chopped</span> <span class="o">=</span> <span class="n">arr</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">chopped</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">epsilon</span><span class="p">:</span>
                <span class="n">chopped</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">chopped</span>
        <span class="n">chopped</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>                    <span class="c1"># initialise to arr values</span>
        <span class="n">chopped</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">chopped</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">epsilon</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># set too low values to zero</span>
        <span class="k">return</span> <span class="n">chopped</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>

<span class="c1">#=============================================================================  </span>
<span class="c1">#  Function/class determining/constituting the database</span>
<span class="c1">#=============================================================================</span>

<span class="k">def</span> <span class="nf">_load_asano_misc_data</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load misc. data required by Asano model.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :path:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Path where data files are stored (If None: look in ./data/ folder under toolbox path)</span>
<span class="sd">   </span>
<span class="sd">    Returns:</span>
<span class="sd">        :data:</span>
<span class="sd">            | dict with data for &#39;USCensus2010population&#39;, &#39;CatObsPfctr&#39;, &#39;M&#39; (lms to xyz conversion matrices)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">_DATA_PATH</span> 
        
    <span class="c1"># Load data from files:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;USCensus2010population&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="s1">&#39;asano_USCensus2010Population.dat&#39;</span><span class="p">,</span> <span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;infer&#39;</span><span class="p">,</span><span class="n">verbosity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> 
    <span class="c1">#data[&#39;CatObsPfctr&#39;] = getdata(path  + &#39;CatObsPfctr.dat&#39;, header = None).T </span>
    
    <span class="c1"># Define dict with Iteratively Derived Cat.Obs.:</span>
    <span class="n">t_data</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">path</span>  <span class="o">+</span> <span class="s1">&#39;asano_CatObsPfctr.dat&#39;</span><span class="p">,</span> <span class="n">header</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">dict_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">t_data</span><span class="p">[:,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">dict_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;od_lens&#39;</span><span class="p">,</span> <span class="s1">&#39;od_macula&#39;</span><span class="p">,</span> <span class="s1">&#39;od_L&#39;</span><span class="p">,</span> <span class="s1">&#39;od_M&#39;</span><span class="p">,</span> <span class="s1">&#39;od_S&#39;</span><span class="p">,</span> <span class="s1">&#39;shft_L&#39;</span><span class="p">,</span> <span class="s1">&#39;shft_M&#39;</span><span class="p">,</span> <span class="s1">&#39;shft_S&#39;</span><span class="p">]</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;CatObsPfctr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dict_keys</span><span class="p">,</span> <span class="n">dict_values</span><span class="p">))</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;CatObsPfctr&#39;</span><span class="p">][</span><span class="s1">&#39;age&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> 
    
    <span class="c1"># Matrices for conversion from LMS cone fundamentals to XYZ CMFs:</span>
    <span class="c1"># (https://www.rit.edu/cos/colorscience/re_AsanoObserverFunctions.php)</span>
    <span class="c1"># For 2-degree, the 3x3 matrix is:</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;M&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;M&#39;</span><span class="p">][</span><span class="s1">&#39;2d&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.4151</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2424</span><span class="p">,</span> <span class="mf">0.0425</span><span class="p">],</span>
                          <span class="p">[</span><span class="mf">0.1355</span><span class="p">,</span> <span class="mf">0.0833</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.0043</span><span class="p">],</span>
                          <span class="p">[</span><span class="o">-</span><span class="mf">0.0093</span><span class="p">,</span> <span class="mf">0.0125</span><span class="p">,</span> <span class="mf">0.2136</span><span class="p">]])</span>

    <span class="c1"># For 10-degree, the 3x3 matrix is:</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;M&#39;</span><span class="p">][</span><span class="s1">&#39;10d&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.4499</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2630</span><span class="p">,</span> <span class="mf">0.0460</span><span class="p">],</span>
                               <span class="p">[</span><span class="mf">0.1617</span><span class="p">,</span> <span class="mf">0.0726</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.0011</span><span class="p">],</span>
                               <span class="p">[</span><span class="o">-</span><span class="mf">0.0036</span><span class="p">,</span> <span class="mf">0.0054</span><span class="p">,</span> <span class="mf">0.2291</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">_load_asano_std_data</span><span class="p">(</span><span class="n">dsrc</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load standard deviation data for Asano Individual Observer Model.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :dsrc:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Data source (&#39;matlab&#39; code, or &#39;germany&#39;) for stdev data on physiological factors.</span>
<span class="sd">            | None defaults to string in _DSRC_DEF</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :data:</span>
<span class="sd">            | dict with data for &#39;od_lens&#39;, &#39;od_macula&#39;, &#39;od_L&#39;, &#39;od_M&#39;, &#39;od_S&#39;, &#39;shft_L&#39;, &#39;shft_M&#39;, &#39;shft_S&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dsrc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dsrc</span> <span class="o">=</span> <span class="n">_DSRC_STD_DEF</span>
    
    <span class="c1"># Store var of. physiological parameters in dict:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dsrc</span> <span class="o">==</span> <span class="s1">&#39;matlab&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">dsrc</span> <span class="o">==</span> <span class="s1">&#39;germany&#39;</span><span class="p">):</span>
        <span class="c1"># from matlab code:</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;od_lens&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">19.1</span> 
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;od_macula&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">37.2</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;od_L&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">17.9</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;od_M&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">17.9</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;od_S&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">14.7</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;shft_L&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">4.0</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;shft_M&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.0</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;shft_S&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.5</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Unknown data source (options: </span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;matlab&#39;</span><span class="p">,</span> <span class="s1">&#39;germany&#39;</span><span class="p">))</span>
        
    <span class="k">if</span> <span class="p">(</span><span class="n">dsrc</span> <span class="o">==</span> <span class="s1">&#39;germany&#39;</span><span class="p">):</span>
        <span class="c1"># Scale down StdDev by scalars optimized using Asano&#39;s 75 observers </span>
        <span class="c1"># collected in Germany:</span>
        <span class="n">scale_factors</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.98</span><span class="p">,</span> <span class="mf">0.98</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]</span>
        <span class="n">scale_factors</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="n">scale_factors</span><span class="p">))</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span> <span class="p">:</span> <span class="n">v</span><span class="o">*</span><span class="n">scale_factors</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
   
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;dsrc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dsrc</span>
    
    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">_load_asano_lms_and_odensities</span><span class="p">(</span><span class="n">wl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load LMS absorbance data and optical density data from Asano.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :wl:</span>
<span class="sd">            | [390, 780,5], optional</span>
<span class="sd">            | Wavelength range to interpolate data to.</span>
<span class="sd">        :path:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Path where data files are stored (If None: look in ./data/ folder under toolbox path)</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :data:</span>
<span class="sd">            | dict with:</span>
<span class="sd">            | - LMS absorbances (&#39;LMSa&#39;) </span>
<span class="sd">            | - relative macular pigment density (&#39;rmd&#39;) </span>
<span class="sd">            | - ocular media optical density (&#39;docul&#39;)</span>
<span class="sd">            | - LMSa absorbance interpolators (&#39;LMSa_interps&#39;) for use in _get_LMSa_absorbance (&#39;pre-calculation increases speed&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">_DATA_PATH</span> 
    <span class="k">if</span> <span class="n">wl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">wl</span> <span class="o">=</span> <span class="n">_WL_ASANO</span>
    <span class="c1"># Load data from files:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">wls</span> <span class="o">=</span> <span class="n">getwlr</span><span class="p">([</span><span class="mi">390</span><span class="p">,</span><span class="mi">780</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;wls&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">wl</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;rmd&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="s1">&#39;asano_cie2006_RelativeMacularDensity.dat&#39;</span><span class="p">,</span> <span class="n">header</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> 
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;docul&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">path</span>  <span class="o">+</span> <span class="s1">&#39;asano_cie2006_docul.dat&#39;</span><span class="p">,</span> <span class="n">header</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> 
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;LMSa&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="s1">&#39;asano_cie2006_Alms.dat&#39;</span><span class="p">,</span> <span class="n">header</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="s1">&#39;wls&#39;</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">cie_interp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">wls</span><span class="p">,</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">])),</span> <span class="n">wl</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span><span class="n">negative_values_allowed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;LMSa_interps&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_create_LMSa_interpolators</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;LMSa&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">kind</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span>
    
<span class="k">def</span> <span class="nf">_docul_fine</span><span class="p">(</span><span class="n">ocular_sum_32</span><span class="p">,</span> <span class="n">docul2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the two parts of the expression for the optical density of the </span>
<span class="sd">    ocular media as function of age.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :ocular_sum_32:</span>
<span class="sd">            | ndarray</span>
<span class="sd">            | Sum of two ocular functions</span>
<span class="sd">        :docul2:</span>
<span class="sd">            | ndarray</span>
<span class="sd">    Returns:</span>
<span class="sd">        :docul1_fine:</span>
<span class="sd">            | ndarray</span>
<span class="sd">            | The calculatedd values for part 1, docul1, tabulated  </span>
<span class="sd">            | with high resolution</span>
<span class="sd">        :docul2_fine:</span>
<span class="sd">            | ndarray</span>
<span class="sd">            | The calculatedd values for part 2, docul2, tabulated  </span>
<span class="sd">            | with high resolution</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">docul2_pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">75</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>             <span class="c1"># initialize</span>
    <span class="n">docul2_pad</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">460</span><span class="p">,</span> <span class="mi">835</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1"># fill</span>
    <span class="n">docul2_pad</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>                       <span class="c1"># fill</span>
    <span class="n">docul2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">docul2</span><span class="p">,</span> <span class="n">docul2_pad</span><span class="p">))</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">interpolate</span> <span class="c1"># lazy import</span>
    <span class="n">spl</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">InterpolatedUnivariateSpline</span><span class="p">(</span><span class="n">docul2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">docul2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">docul2_fine</span> <span class="o">=</span> <span class="n">ocular_sum_32</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">docul2_fine</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">spl</span><span class="p">(</span><span class="n">ocular_sum_32</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">docul1_fine</span> <span class="o">=</span> <span class="n">ocular_sum_32</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">docul1_fine</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ocular_sum_32</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">docul2_fine</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">docul1_fine</span><span class="p">,</span> <span class="n">docul2_fine</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]))</span>

<span class="k">def</span> <span class="nf">_load_cietc197_lms_and_odensities</span><span class="p">(</span><span class="n">wl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load LMS absorbance data and optical density data from CIE TC1-97.</span>
<span class="sd">        </span>
<span class="sd">    Args:</span>
<span class="sd">        :wl:</span>
<span class="sd">            | [390, 830, 0.1], optional</span>
<span class="sd">            | Wavelength range to interpolate data to.</span>
<span class="sd">        :path:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Path where data files are stored (If None: look in ./data/ folder under toolbox path)</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :data:</span>
<span class="sd">            | dict with:</span>
<span class="sd">            | - LMS absorbances (&#39;LMSa&#39;) </span>
<span class="sd">            | - relative macular pigment density (&#39;rmd&#39;) </span>
<span class="sd">            | - ocular media optical density (&#39;docul&#39;)</span>
<span class="sd">            | - LMSa absorbance interpolators (&#39;LMSa_interps&#39;) for use in _get_LMSa_absorbance (&#39;pre-calculation increases speed&#39;)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">_DATA_PATH</span> 
    <span class="k">if</span> <span class="n">wl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">wl</span> <span class="o">=</span> <span class="n">_WL_CIETC197</span>
    <span class="c1"># data from tc197:</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">path</span>  <span class="o">+</span> <span class="s1">&#39;cietc197_absorbances0_1nm.dat&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)[:,[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]]</span><span class="o">.</span><span class="n">T</span>
    <span class="n">isnan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">3</span><span class="p">,:])</span> <span class="c1"># find isnan for Sbar (missing values -&gt; need to be set at -inf)</span>
    <span class="n">first_isnan_wl</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">isnan</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="c1"># find wavelength at which first isnan occurs for Sbar</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">cie_interp</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span><span class="n">wl</span><span class="p">,</span> <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span><span class="n">negative_values_allowed</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span><span class="c1">#, extrap_values = &#39;ext&#39;)</span>
    
    <span class="n">absorbance</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],:]</span> <span class="c1">#LMS absorbance</span>
    <span class="n">absorbance</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="n">first_isnan_wl</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="c1"># set to -inf.</span>

    <span class="n">macula_rel</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],:]</span> 
    <span class="n">macula_rel</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">/=</span> <span class="mf">0.35</span>  <span class="c1"># div by 0.35 since macula at 2° has a maximum of 0.35 at 460 (at 5nm step)</span>
    <span class="n">docul2</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">path</span>  <span class="o">+</span> <span class="s1">&#39;cietc197_docul2.dat&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">ocular_sum_32</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],:]</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># 32 years only!</span>
    <span class="n">docul2</span> <span class="o">=</span> <span class="n">_docul_fine</span><span class="p">(</span><span class="n">ocular_sum_32</span><span class="p">,</span> <span class="n">docul2</span><span class="p">)</span>
    <span class="n">docul2</span> <span class="o">=</span> <span class="n">cie_interp</span><span class="p">(</span><span class="n">docul2</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">wl</span><span class="p">,</span> <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span><span class="n">negative_values_allowed</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">extrap_values</span> <span class="o">=</span> <span class="s1">&#39;ext&#39;</span><span class="p">)</span>
    <span class="n">absorbance_interps</span> <span class="o">=</span> <span class="n">_create_LMSa_interpolators</span><span class="p">(</span><span class="n">absorbance</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">kind</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;wls&#39;</span><span class="p">:</span> <span class="n">wl</span><span class="p">,</span> <span class="s1">&#39;rmd&#39;</span><span class="p">:</span> <span class="n">macula_rel</span><span class="p">,</span> <span class="s1">&#39;docul&#39;</span><span class="p">:</span><span class="n">docul2</span><span class="p">,</span> <span class="s1">&#39;LMSa&#39;</span><span class="p">:</span> <span class="n">absorbance</span><span class="p">,</span><span class="s1">&#39;LMSa_interps&#39;</span><span class="p">:</span><span class="n">absorbance_interps</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">_create_LMSa_interpolators</span><span class="p">(</span><span class="n">LMSa</span><span class="p">,</span> <span class="n">kind</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">interpolate</span> <span class="c1"># lazy import</span>
    <span class="n">_peak_shft</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span> 
            <span class="c1"># L, M:</span>
            <span class="n">_peak_shft</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interpolate</span><span class="o">.</span><span class="n">InterpolatedUnivariateSpline</span><span class="p">(</span><span class="n">LMSa</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">LMSa</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">k</span> <span class="o">=</span> <span class="n">kind</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># S:</span>
            <span class="n">non_nan_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">LMSa</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="n">LMSa</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
            <span class="n">_peak_shft</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interpolate</span><span class="o">.</span><span class="n">InterpolatedUnivariateSpline</span><span class="p">(</span><span class="n">LMSa</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">non_nan_indices</span><span class="p">],</span><span class="n">LMSa</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">non_nan_indices</span><span class="p">],</span> <span class="n">k</span> <span class="o">=</span> <span class="n">kind</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="mi">0</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">_peak_shft</span>

<span class="c1"># Create the interpolators in advance for speed:</span>
<span class="c1"># _LMS_ABSORBANCE_INTERPOLATORS = get_LMSa_interpolators(odata = _DATA[&#39;odata&#39;], kind = 3)</span>


<div class="viewcode-block" id="load_database">
<a class="viewcode-back" href="../../../../toolboxes.html#luxpy.toolboxes.indvcmf.load_database">[docs]</a>
<span class="k">def</span> <span class="nf">load_database</span><span class="p">(</span><span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dsrc_std</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dsrc_lms_odens</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load database required for Asano Individual Observer Model.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :wl:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Wavelength range to interpolate data to.</span>
<span class="sd">            | None defaults to the wavelength range associated with data in :dsrc_lms_odens:</span>
<span class="sd">        :path:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Path where data files are stored (If None: look in ./data/ folder under toolbox path)</span>
<span class="sd">        :dsrc_std:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Data source (&#39;matlab&#39; code, or &#39;germany&#39;) for stdev data on physiological factors.</span>
<span class="sd">            | None defaults to string in _DSRC_STD_DEF</span>
<span class="sd">        :dsrc_lms_odens:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Data source (&#39;asano&#39;, &#39;cietc197&#39;) for LMS absorbance and optical density data.</span>
<span class="sd">            | None defaults to string in _DSRC_LMS_ODENS_DEF</span>
<span class="sd">    Returns:</span>
<span class="sd">        :data:</span>
<span class="sd">            | dict with data for:</span>
<span class="sd">            | - &#39;LMSa&#39;: LMS absorbances </span>
<span class="sd">            | - &#39;rmd&#39;: relative macular pigment density </span>
<span class="sd">            | - &#39;docul&#39;: ocular media optical density </span>
<span class="sd">            | - &#39;USCensus2010population&#39;: data (age and numbers) on a 2010 US Census </span>
<span class="sd">            | - &#39;CatObsPfctr&#39;: dict with iteratively derived Categorical Observer physiological stdevs.</span>
<span class="sd">            | - &#39;M2d&#39;: Asano 2° lms to xyz conversion matrix </span>
<span class="sd">            | - &#39;M10d&#39;: Asano 10° lms to xyz conversion matrix </span>
<span class="sd">            | - standard deviations on physiological parameters: &#39;od_lens&#39;, &#39;od_macula&#39;, &#39;od_L&#39;, &#39;od_M&#39;, &#39;od_S&#39;, &#39;shft_L&#39;, &#39;shft_M&#39;, &#39;shft_S&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">_load_asano_misc_data</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">)</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;stdev&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_load_asano_std_data</span><span class="p">(</span><span class="n">dsrc</span><span class="o">=</span><span class="n">dsrc_std</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dsrc_lms_odens</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dsrc_lms_odens</span> <span class="o">=</span> <span class="n">_DSRC_LMS_ODENS_DEF</span>
    <span class="k">if</span> <span class="n">dsrc_lms_odens</span> <span class="o">==</span> <span class="s1">&#39;asano&#39;</span><span class="p">:</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;odata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_load_asano_lms_and_odensities</span><span class="p">(</span><span class="n">wl</span><span class="o">=</span><span class="n">wl</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">dsrc_lms_odens</span> <span class="o">==</span> <span class="s1">&#39;cietc197&#39;</span><span class="p">:</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;odata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_load_cietc197_lms_and_odensities</span><span class="p">(</span><span class="n">wl</span><span class="o">=</span><span class="n">wl</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;odata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown source string for optical data (options: </span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;asano&#39;</span><span class="p">,</span> <span class="s1">&#39;cietc197&#39;</span><span class="p">))</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;odata&#39;</span><span class="p">][</span><span class="s1">&#39;dsrc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dsrc_lms_odens</span>
    <span class="k">return</span> <span class="n">data</span></div>


<span class="c1">#Actually load default database</span>
<span class="n">_DATA</span> <span class="o">=</span> <span class="n">load_database</span><span class="p">()</span>

<div class="viewcode-block" id="init">
<a class="viewcode-back" href="../../../../toolboxes.html#luxpy.toolboxes.indvcmf.init">[docs]</a>
<span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dsrc_std</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dsrc_lms_odens</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">lms_to_xyz_method</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
         <span class="n">use_sign_figs</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">use_my_round</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span><span class="n">use_chop</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
         <span class="n">path</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbosity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialize: load database required for Asano Individual Observer Model </span>
<span class="sd">    into the default _DATA dict and set some options for rounding, </span>
<span class="sd">    sign. figs and chopping small value to zero; for source data to use for </span>
<span class="sd">    spectral data for LMS absorp. and optical desnities, ... </span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :wl:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Wavelength range to interpolate data to.</span>
<span class="sd">            | None defaults to the wavelength range associated with data in :dsrc_lms_odens:</span>
<span class="sd">        :dsrc_std:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Data source (&#39;matlab&#39; code, or &#39;germany&#39;) for stdev data on physiological factors.</span>
<span class="sd">            | None defaults to string in _DSRC_STD_DEF</span>
<span class="sd">        :dsrc_lms_odens:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Data source (&#39;asano&#39;, &#39;cietc197&#39;) for LMS absorbance and optical density data.</span>
<span class="sd">            | None defaults to string in _DSRC_LMS_ODENS_DEF</span>
<span class="sd">        :lms_to_xyz_method:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Method to use to determine lms-to-xyz conversion matrix (options: &#39;asano&#39;, &#39;cietc197&#39;)</span>
<span class="sd">        :use_my_round:</span>
<span class="sd">            | True, optional</span>
<span class="sd">            | If True: use my_rounding() conform CIE TC1-91 Python code &#39;ciefunctions&#39;. (slows down code)</span>
<span class="sd">            | by setting _USE_MY_ROUND.</span>
<span class="sd">        :use_sign_figs:</span>
<span class="sd">            | True, optional</span>
<span class="sd">            | If True: use sign_figs() conform CIE TC1-91 Python code &#39;ciefunctions&#39;. (slows down code)</span>
<span class="sd">            | by setting _USE_SIGN_FIGS.</span>
<span class="sd">        :use_chop:</span>
<span class="sd">            | True, optional</span>
<span class="sd">            | If True: use chop() conform CIE TC1-91 Python code &#39;ciefunctions&#39;. (slows down code)</span>
<span class="sd">            | by setting _USE_CHOP.</span>
<span class="sd">        :path:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Path where data files are stored (If None: look in ./data/ folder under toolbox path)</span>
<span class="sd">        :out:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | If None: only set global variables, do not output _DATA.copy()</span>
<span class="sd">        :verbosity:</span>
<span class="sd">            | 1, optional</span>
<span class="sd">            | Print new state of global settings.</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :data:</span>
<span class="sd">            | if out is not None: return a dict with dict with data for:</span>
<span class="sd">            | - &#39;LMSa&#39;: LMS absorbances </span>
<span class="sd">            | - &#39;rmd&#39;: relative macular pigment density </span>
<span class="sd">            | - &#39;docul&#39;: ocular media optical density </span>
<span class="sd">            | - &#39;USCensus2010population&#39;: data (age and numbers) on a 2010 US Census </span>
<span class="sd">            | - &#39;CatObsPfctr&#39;: dict with iteratively derived Categorical Observer physiological stdevs.</span>
<span class="sd">            | - &#39;M2d&#39;: Asano 2° lms to xyz conversion matrix </span>
<span class="sd">            | - &#39;M10d&#39;: Asano 10° lms to xyz conversion matrix </span>
<span class="sd">            | - standard deviations on physiological parameters: &#39;od_lens&#39;, &#39;od_macula&#39;, &#39;od_L&#39;, &#39;od_M&#39;, &#39;od_S&#39;, &#39;shft_L&#39;, &#39;shft_M&#39;, &#39;shft_S&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_WL</span><span class="p">,</span> <span class="n">_DATA</span><span class="p">,</span> <span class="n">_USE_MY_ROUND</span><span class="p">,</span> <span class="n">_USE_SIGN_FIGS</span><span class="p">,</span> <span class="n">_USE_CHOP</span><span class="p">,</span> <span class="n">_DSRC_STD_DEF</span><span class="p">,</span><span class="n">_DSRC_LMS_ODENS_DEF</span><span class="p">,</span> <span class="n">_LMS_TO_XYZ_METHOD</span>
    
    <span class="n">_USE_MY_ROUND</span> <span class="o">=</span> <span class="n">use_my_round</span>
    <span class="n">_USE_SIGN_FIGS</span> <span class="o">=</span> <span class="n">use_sign_figs</span>
    <span class="n">_USE_CHOP</span> <span class="o">=</span> <span class="n">use_chop</span>
    
    <span class="k">if</span> <span class="n">dsrc_std</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_DSRC_STD_DEF</span> <span class="o">=</span> <span class="n">dsrc_std</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_DSRC_STD_DEF</span> <span class="o">=</span> <span class="s1">&#39;matlab&#39;</span>
        
    <span class="k">if</span> <span class="n">dsrc_lms_odens</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_DSRC_LMS_ODENS_DEF</span> <span class="o">=</span> <span class="n">dsrc_lms_odens</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_DSRC_LMS_ODENS_DEF</span> <span class="o">=</span> <span class="s1">&#39;cietc197&#39;</span>
    
    <span class="k">if</span> <span class="n">lms_to_xyz_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_LMS_TO_XYZ_METHOD</span> <span class="o">=</span> <span class="n">lms_to_xyz_method</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_LMS_TO_XYZ_METHOD</span> <span class="o">=</span> <span class="s1">&#39;cietc197&#39;</span>
    
    <span class="k">if</span> <span class="n">_DSRC_LMS_ODENS_DEF</span> <span class="o">==</span> <span class="s1">&#39;asano&#39;</span><span class="p">:</span>
        <span class="n">_WL</span> <span class="o">=</span> <span class="n">_WL_ASANO</span>
    <span class="k">elif</span> <span class="n">_DSRC_LMS_ODENS_DEF</span> <span class="o">==</span> <span class="s1">&#39;cietc197&#39;</span><span class="p">:</span>
        <span class="n">_WL</span> <span class="o">=</span> <span class="n">_WL_CIETC197</span>
    
    <span class="n">_DATA</span> <span class="o">=</span> <span class="n">load_database</span><span class="p">(</span><span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> <span class="n">dsrc_std</span> <span class="o">=</span> <span class="n">dsrc_std</span><span class="p">,</span> <span class="n">dsrc_lms_odens</span> <span class="o">=</span> <span class="n">dsrc_lms_odens</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">query_state</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_DATA</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out</span></div>

    
<div class="viewcode-block" id="query_state">
<a class="viewcode-back" href="../../../../toolboxes.html#luxpy.toolboxes.indvcmf.query_state">[docs]</a>
<span class="k">def</span> <span class="nf">query_state</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Print current settings for &#39;global variables&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Current state of &#39;global variables/settings&#39;: </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">_USE_MY_ROUND = &quot;</span><span class="p">,</span> <span class="n">_USE_MY_ROUND</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">_USE_SIGN_FIGS = &quot;</span><span class="p">,</span> <span class="n">_USE_SIGN_FIGS</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">_USE_CHOP = &quot;</span><span class="p">,</span> <span class="n">_USE_CHOP</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">_WL = [</span><span class="si">{:1.2f}</span><span class="s2">, </span><span class="si">{:1.2f}</span><span class="s2">, </span><span class="si">{:1.2f}</span><span class="s2">, ..., </span><span class="si">{:1.2f}</span><span class="s2">, </span><span class="si">{:1.2f}</span><span class="s2">, </span><span class="si">{:1.2f}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_WL</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">_WL</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">_WL</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">_WL</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span><span class="n">_WL</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">_WL</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">_DSRC_STD_DEF = &quot;</span><span class="p">,</span> <span class="n">_DSRC_STD_DEF</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">_DSRC_LMS_ODENS_DEF = &quot;</span><span class="p">,</span> <span class="n">_DSRC_LMS_ODENS_DEF</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">_LMS_TO_XYZ_METHOD = &quot;</span><span class="p">,</span> <span class="n">_LMS_TO_XYZ_METHOD</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">Database dsrc_std = &quot;</span><span class="p">,</span> <span class="n">_DATA</span><span class="p">[</span><span class="s1">&#39;stdev&#39;</span><span class="p">][</span><span class="s1">&#39;dsrc&#39;</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Database dsrc_lms_odens = &quot;</span><span class="p">,</span> <span class="n">_DATA</span><span class="p">[</span><span class="s1">&#39;odata&#39;</span><span class="p">][</span><span class="s1">&#39;dsrc&#39;</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">_WL</span><span class="p">,</span> <span class="n">_DATA</span><span class="p">[</span><span class="s1">&#39;odata&#39;</span><span class="p">][</span><span class="s1">&#39;wls&#39;</span><span class="p">]):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Note that [&#39;odata&#39;][&#39;wls&#39;]) does not match database setting.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_DATA</span><span class="p">[</span><span class="s1">&#39;stdev&#39;</span><span class="p">][</span><span class="s1">&#39;dsrc&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">_DSRC_STD_DEF</span><span class="p">:</span> 
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Note that _STD_DEF does not match database setting.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_DATA</span><span class="p">[</span><span class="s1">&#39;odata&#39;</span><span class="p">][</span><span class="s1">&#39;dsrc&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">_DSRC_LMS_ODENS_DEF</span><span class="p">:</span> 
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Note that _LMS_ODENS_DEF does not match database setting&#39;</span><span class="p">)</span></div>

    

<span class="c1">#==============================================================================</span>
<span class="c1">#  Functions of age and/or field size</span>
<span class="c1">#==============================================================================</span>

<span class="k">def</span> <span class="nf">_d_ocular</span><span class="p">(</span><span class="n">age</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="n">var_od_lens</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">docul0</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the optical density of the ocular media for a given age.</span>

<span class="sd">    Args:</span>
<span class="sd">        :age:</span>
<span class="sd">            | 32, float, optional</span>
<span class="sd">            | Age in years.</span>
<span class="sd">        :var_od_lens:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | Variation of optical density of lens.</span>
<span class="sd">        :docul0: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Uncorrected ocular media density function </span>
<span class="sd">            | None defaults to the one stored in _DATA</span>

<span class="sd">    Returns:</span>
<span class="sd">        :docul:</span>
<span class="sd">            | ndarray with the calculated optical density of the ocular media; row 0 are wavelenghts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">docul0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">docul</span> <span class="o">=</span> <span class="n">_DATA</span><span class="p">[</span><span class="s1">&#39;odata&#39;</span><span class="p">][</span><span class="s1">&#39;docul&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="n">docul</span> <span class="o">=</span> <span class="n">docul0</span>
    
    <span class="k">if</span> <span class="n">var_od_lens</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">100</span><span class="p">:</span>
        <span class="n">var_od_lens</span> <span class="o">=</span> <span class="o">-</span><span class="mi">100</span>
        
    <span class="c1"># age corrected lens/ocular media density: </span>
    <span class="k">if</span> <span class="p">(</span><span class="n">age</span> <span class="o">&lt;=</span> <span class="mi">60</span><span class="p">):</span>
        <span class="n">corrected_lomd</span> <span class="o">=</span> <span class="n">docul</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">0.02</span><span class="o">*</span><span class="p">(</span><span class="n">age</span><span class="o">-</span><span class="mi">32</span><span class="p">))</span> <span class="o">+</span> <span class="n">docul</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">,:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">corrected_lomd</span> <span class="o">=</span> <span class="n">docul</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.56</span> <span class="o">+</span> <span class="mf">0.0667</span><span class="o">*</span><span class="p">(</span><span class="n">age</span><span class="o">-</span><span class="mi">60</span><span class="p">))</span> <span class="o">+</span> <span class="n">docul</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">,:]</span>
    <span class="n">corrected_lomd</span> <span class="o">=</span> <span class="n">corrected_lomd</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">var_od_lens</span><span class="o">/</span><span class="mi">100</span><span class="p">)</span> <span class="c1"># varied overall optical density of lens</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">docul</span><span class="p">[:</span><span class="mi">1</span><span class="p">,:],</span><span class="n">corrected_lomd</span><span class="p">))</span> 

<span class="k">def</span> <span class="nf">_d_mac_max</span><span class="p">(</span><span class="n">fieldsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">var_od</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the maximum optical density of the macular pigment for a given field size.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :fieldsize:</span>
<span class="sd">            | 10, float, optional</span>
<span class="sd">            | Field size in degrees.</span>
<span class="sd">        :var_od:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | Variation of optical density of macula.</span>

<span class="sd">    Returns:</span>
<span class="sd">        :d_mac_max:</span>
<span class="sd">            | float</span>
<span class="sd">            | The calculated maximum optical density of the macular pigment.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">var_od</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">100</span><span class="p">:</span>
        <span class="n">var_od</span> <span class="o">=</span> <span class="o">-</span><span class="mi">100</span>
    <span class="k">return</span> <span class="n">my_round</span><span class="p">((</span><span class="mf">0.485</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">fieldsize</span><span class="o">/</span><span class="mf">6.132</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">var_od</span><span class="o">/</span><span class="mi">100</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_d_mac</span><span class="p">(</span><span class="n">fieldsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">var_od</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rmd0</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the optical density of the macular pigment for a given field size.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :fieldsize:</span>
<span class="sd">            | 10, float, optional</span>
<span class="sd">            | Field size in degrees.</span>
<span class="sd">        :var_od:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | Variation of optical density of macula.</span>
<span class="sd">        :rmd0: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Uncorrected relative density of macula function</span>
<span class="sd">            | None defaults to the one stored in _DATA</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :rmd:</span>
<span class="sd">            | ndarray with the calculated relative optical density of the macular pigment; row 0 are wavelenghts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rmd0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rmd</span> <span class="o">=</span> <span class="n">_DATA</span><span class="p">[</span><span class="s1">&#39;odata&#39;</span><span class="p">][</span><span class="s1">&#39;rmd&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rmd</span> <span class="o">=</span> <span class="n">rmd0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">rmd</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span> <span class="o">=</span> <span class="n">rmd</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span> <span class="o">*</span> <span class="n">_d_mac_max</span><span class="p">(</span><span class="n">fieldsize</span> <span class="o">=</span> <span class="n">fieldsize</span><span class="p">,</span> <span class="n">var_od</span> <span class="o">=</span> <span class="n">var_od</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rmd</span>

<span class="k">def</span> <span class="nf">_d_LM_max</span><span class="p">(</span><span class="n">fieldsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">var_od</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the maximum optical density of the L- and M-cone photopigments for a given field size.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :field_size:</span>
<span class="sd">            | 10, float, optional</span>
<span class="sd">            | Field size in degrees.</span>
<span class="sd">        :var_od:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | Variation of optical density.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :d_LM_max:</span>
<span class="sd">            | float</span>
<span class="sd">            | The calculated maximum optical density of the L- and M-cone photopigments</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">var_od</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">100</span><span class="p">:</span>
        <span class="n">var_od</span> <span class="o">=</span> <span class="o">-</span><span class="mi">100</span>
    <span class="k">return</span> <span class="n">my_round</span><span class="p">((</span><span class="mf">0.38</span> <span class="o">+</span> <span class="mf">0.54</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">fieldsize</span><span class="o">/</span><span class="mf">1.333</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">var_od</span><span class="o">/</span><span class="mi">100</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_d_S_max</span><span class="p">(</span><span class="n">fieldsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">var_od</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the maximum optical density of the S-cone photopigment for a given field size.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :fieldsize:</span>
<span class="sd">            | 10, float, optional</span>
<span class="sd">            | Field size in degrees.</span>
<span class="sd">        :var_od:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | Variation of optical density.</span>

<span class="sd">    Returns:</span>
<span class="sd">        :d_S_max:</span>
<span class="sd">            | float</span>
<span class="sd">            | The calculated maximum optical density of the S-cone visual pigment</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">var_od</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">100</span><span class="p">:</span>
        <span class="n">var_od</span> <span class="o">=</span> <span class="o">-</span><span class="mi">100</span>
    <span class="k">return</span> <span class="n">my_round</span><span class="p">((</span><span class="mf">0.30</span> <span class="o">+</span> <span class="mf">0.45</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">fieldsize</span><span class="o">/</span><span class="mf">1.333</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">var_od</span><span class="o">/</span><span class="mi">100</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>

<span class="c1"># def _LMS_absorptance_old(fieldsize = 10, var_shft_LMS = [0,0,0], var_od_LMS = [0, 0, 0], LMSa0 = None,**kwargs):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Calculate the quantal absorptance of the L, M and S cones for a given field size.</span>
    
<span class="c1">#     Args:</span>
<span class="c1">#         :fieldsize: </span>
<span class="c1">#             | 10, float, optional</span>
<span class="c1">#             | Field size in degrees.</span>
<span class="c1">#         :var_shft_LMS:</span>
<span class="c1">#             | [0, 0, 0] optional</span>
<span class="c1">#             | Variation (shift) of LMS peak absorptance.</span>
<span class="c1">#         :var_od_LMS:</span>
<span class="c1">#             | [0, 0, 0] optional</span>
<span class="c1">#             | Variation of LMS optical densities.</span>
<span class="c1">#         :LMSa0: </span>
<span class="c1">#             | None, optional</span>
<span class="c1">#             | Uncorrected LMS absorptance functions</span>
<span class="c1">#             | None defaults to the ones stored in _DATA</span>

<span class="c1">#     Returns:</span>
<span class="c1">#         alpha_lms: </span>
<span class="c1">#             | ndarray with the calculated quantal absorptances of the L, M and S cones; row 0 are wavelenghts.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     from scipy import interpolate # lazy import</span>
<span class="c1">#     if LMSa0 is None:</span>
<span class="c1">#         LMSa = _DATA[&#39;odata&#39;][&#39;LMSa&#39;].copy()</span>
<span class="c1">#     else:</span>
<span class="c1">#         LMSa = LMSa0.copy()</span>
  
<span class="c1">#     wls = LMSa[:1,:].copy() # wavelengths</span>
<span class="c1">#     LMSa = LMSa[1:,:] # get rid of wavelengths</span>

<span class="c1">#     # Peak Wavelength Shift:</span>
<span class="c1">#     wl_shifted = np.empty(LMSa.shape)</span>
<span class="c1">#     wl_shifted[0] = wls + var_shft_LMS[0] </span>
<span class="c1">#     wl_shifted[1] = wls + var_shft_LMS[1] </span>
<span class="c1">#     wl_shifted[2] = wls + var_shft_LMS[2] </span>
    
<span class="c1">#     LMSa_shft = np.empty(LMSa.shape)</span>
<span class="c1">#     kind = 3 # -&gt;&#39;cubic&#39;</span>
<span class="c1">#     if var_shft_LMS[0] == 0:</span>
<span class="c1">#         LMSa_shft[0] = LMSa[0]</span>
<span class="c1">#     else:</span>
<span class="c1">#         LMSa_shft[0] = interpolate.InterpolatedUnivariateSpline(wl_shifted[0],LMSa[0], k = kind, ext = &quot;extrapolate&quot;)(wls)</span>
<span class="c1">#     if var_shft_LMS[1] == 0:</span>
<span class="c1">#         LMSa_shft[1] = LMSa[1]</span>
<span class="c1">#     else:</span>
<span class="c1">#         LMSa_shft[1] = interpolate.InterpolatedUnivariateSpline(wl_shifted[1],LMSa[1], k = kind, ext = &quot;extrapolate&quot;)(wls)</span>
    
<span class="c1">#     if var_shft_LMS[2] == 0:</span>
<span class="c1">#         LMSa_shft[2] = LMSa[2]</span>
<span class="c1">#     else:</span>
<span class="c1">#         LMSa[2,np.isinf(LMSa[2,:])] = np.nan</span>
<span class="c1">#         non_nan_indices = np.logical_not(np.isnan(LMSa[2]))</span>
<span class="c1">#         LMSa_shft[2] = interpolate.InterpolatedUnivariateSpline(wl_shifted[2][non_nan_indices],LMSa[2][non_nan_indices], k = kind, ext = &quot;extrapolate&quot;)(wls)</span>

<span class="c1">#         # Detect poor interpolation (sign switch due to instability):</span>
<span class="c1">#         ssw = np.hstack((0,np.sign(np.diff(LMSa_shft[2,:])))) </span>
<span class="c1">#         cond = ((ssw &gt;= 0) &amp; (wls &gt; 560))</span>
<span class="c1">#         if cond.any():</span>
<span class="c1">#             wl_min = wls[np.where(cond)].min()</span>
<span class="c1">#             LMSa_shft[2,np.where((wls &gt;= wl_min))] = np.nan</span>

<span class="c1">#     # corrected LMS (no age correction):</span>
<span class="c1">#     pkOd_L = _d_LM_max(fieldsize, var_od_LMS[0])  # varied peak optical density of L-cone</span>
<span class="c1">#     pkOd_M = _d_LM_max(fieldsize, var_od_LMS[1])  # varied peak optical density of M-cone</span>
<span class="c1">#     pkOd_S = _d_S_max(fieldsize, var_od_LMS[2])   # varied peak optical density of S-cone</span>
    
<span class="c1">#     alpha_lms = 1. * LMSa_shft</span>
<span class="c1">#     alpha_lms[0] = 1 - 10**(-pkOd_L*(10**LMSa_shft[0]))</span>
<span class="c1">#     alpha_lms[1] = 1 - 10**(-pkOd_M*(10**LMSa_shft[1]))</span>
<span class="c1">#     alpha_lms[2] = 1 - 10**(-pkOd_S*(10**LMSa_shft[2]))</span>
<span class="c1"># #    alpha_lms[np.isnan(alpha_lms)] = 0</span>
<span class="c1">#     # this fix is required because the above math fails for alpha_lms[2,:]==0</span>
<span class="c1">#     #alpha_lms[2,np.where(wls &gt;= _WL_CRIT)] = 0 </span>

<span class="c1">#     return np.vstack((wls,alpha_lms))</span>

<span class="k">def</span> <span class="nf">_LMS_absorptance</span><span class="p">(</span><span class="n">fieldsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">var_shft_LMS</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">var_od_LMS</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">LMSa0</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">LMSa0_interps</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the quantal absorptance of the L, M and S cones for a given field size.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :fieldsize: </span>
<span class="sd">            | 10, float, optional</span>
<span class="sd">            | Field size in degrees.</span>
<span class="sd">        :var_shft_LMS:</span>
<span class="sd">            | [0, 0, 0] optional</span>
<span class="sd">            | Variation (shift) of LMS peak absorptance.</span>
<span class="sd">        :var_od_LMS:</span>
<span class="sd">            | [0, 0, 0] optional</span>
<span class="sd">            | Variation of LMS optical densities.</span>
<span class="sd">        :LMSa0: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Uncorrected LMS absorptance functions</span>
<span class="sd">            | None defaults to the ones stored in _DATA</span>
<span class="sd">        :LMSa0_interps:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Pre-calculated interpolators for uncorrected LMS absorbance functions</span>
<span class="sd">            | None defaults to the ones stored in _DATA</span>

<span class="sd">    Returns:</span>
<span class="sd">        alpha_lms: </span>
<span class="sd">            | ndarray with the calculated quantal absorptances of the L, M and S cones; row 0 are wavelenghts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">LMSa0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">LMSa</span> <span class="o">=</span> <span class="n">_DATA</span><span class="p">[</span><span class="s1">&#39;odata&#39;</span><span class="p">][</span><span class="s1">&#39;LMSa&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">LMSa</span> <span class="o">=</span> <span class="n">LMSa0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">LMSa0_interps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">LMSa_interps</span> <span class="o">=</span> <span class="n">_DATA</span><span class="p">[</span><span class="s1">&#39;odata&#39;</span><span class="p">][</span><span class="s1">&#39;LMSa_interps&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">LMSa_interps</span> <span class="o">=</span> <span class="n">LMSa0_interps</span>
  
    <span class="n">wls</span> <span class="o">=</span> <span class="n">LMSa</span><span class="p">[:</span><span class="mi">1</span><span class="p">,:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># wavelengths</span>
    <span class="n">LMSa</span> <span class="o">=</span> <span class="n">LMSa</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span> <span class="c1"># get rid of wavelengths</span>
    
    <span class="c1"># Peak Wavelength Shift:</span>
    <span class="n">wl_shifted</span> <span class="o">=</span> <span class="p">(</span><span class="n">wls</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">var_shft_LMS</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">])</span>

    <span class="n">alpha_lms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">LMSa</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="c1"># kind = 3 # -&gt;&#39;cubic&#39;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span> 
        <span class="k">if</span> <span class="n">var_shft_LMS</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_peak_shft</span> <span class="o">=</span> <span class="n">LMSa</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_peak_shft</span> <span class="o">=</span> <span class="n">LMSa_interps</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">wl_shifted</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> 
                <span class="c1"># S: Detect poor interpolation (sign switch due to instability):</span>
                <span class="n">ssw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">_peak_shft</span><span class="p">))))</span> 
                <span class="n">cond</span> <span class="o">=</span> <span class="p">((</span><span class="n">ssw</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">wls</span> <span class="o">&gt;</span> <span class="mi">560</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">cond</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">wl_min</span> <span class="o">=</span> <span class="n">wls</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cond</span><span class="p">)]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                    <span class="n">_peak_shft</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">wls</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">wl_min</span><span class="p">))]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># L,M:</span>
            <span class="n">_pkOd</span> <span class="o">=</span> <span class="n">_d_LM_max</span><span class="p">(</span><span class="n">fieldsize</span><span class="p">,</span> <span class="n">var_od_LMS</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>  <span class="c1"># varied peak optical density of L,M-cone</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># S:</span>
            <span class="n">_pkOd</span> <span class="o">=</span> <span class="n">_d_S_max</span><span class="p">(</span><span class="n">fieldsize</span><span class="p">,</span> <span class="n">var_od_LMS</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>  <span class="c1"># varied peak optical density of S-cone</span>
            
        <span class="n">alpha_lms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">_pkOd</span><span class="o">*</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="n">_peak_shft</span><span class="p">))</span> 


    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">wls</span><span class="p">,</span><span class="n">alpha_lms</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_LMS_quantal</span><span class="p">(</span><span class="n">fieldsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="n">var_od_lens</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">var_od_mac</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
                 <span class="n">var_shft_LMS</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">var_od_LMS</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> 
                 <span class="n">norm_type</span> <span class="o">=</span> <span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;LMSq&#39;</span><span class="p">,</span> <span class="n">odata0</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the quantal based LMS cone fundamentals for a given field size and age.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :fieldsize:</span>
<span class="sd">            | 10, float, optional</span>
<span class="sd">            | Field size in degrees.</span>
<span class="sd">        :age:</span>
<span class="sd">            | 32, float, optional</span>
<span class="sd">            | Age in years.</span>
<span class="sd">        :var_od_lens:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | Variation of optical density of lens.</span>
<span class="sd">        :var_od_mac:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | Variation of optical density of macula.</span>
<span class="sd">        :var_shft_LMS:</span>
<span class="sd">            | [0, 0, 0] optional</span>
<span class="sd">            | Variation (shift) of LMS peak absorptance.</span>
<span class="sd">        :var_od_LMS:</span>
<span class="sd">            | [0, 0, 0] optional</span>
<span class="sd">            | Variation of LMS optical densities.</span>
<span class="sd">        :norm_type:</span>
<span class="sd">            | &#39;max&#39;, optional</span>
<span class="sd">            | - &#39;max&#39;: normalize LMSq functions to max = 1</span>
<span class="sd">            | - &#39;area&#39;: normalize to area</span>
<span class="sd">            | - &#39;power&#39;: normalize to power</span>
<span class="sd">        :odata0: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Dict with uncorrected ocular media and macula density functions and LMS absorptance functions</span>
<span class="sd">            | None defaults to the ones stored in _DATA</span>

<span class="sd">    Returns:</span>
<span class="sd">        :LMSq: </span>
<span class="sd">            | ndarray with the calculated quantum_based LMS cone fundamentals; first row are wavelengths.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">odata0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">odata</span> <span class="o">=</span> <span class="n">_DATA</span><span class="p">[</span><span class="s1">&#39;odata&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">odata</span> <span class="o">=</span> <span class="n">odata0</span>
        
    <span class="c1"># field size corrected macular density:</span>
    <span class="n">rmd</span> <span class="o">=</span> <span class="n">_d_mac</span><span class="p">(</span><span class="n">fieldsize</span> <span class="o">=</span> <span class="n">fieldsize</span><span class="p">,</span> <span class="n">var_od</span> <span class="o">=</span> <span class="n">var_od_mac</span><span class="p">,</span> <span class="n">rmd0</span> <span class="o">=</span> <span class="n">odata</span><span class="p">[</span><span class="s1">&#39;rmd&#39;</span><span class="p">])</span> 
    
    <span class="c1"># age corrected lens/ocular media density: </span>
    <span class="n">docul</span> <span class="o">=</span> <span class="n">_d_ocular</span><span class="p">(</span><span class="n">age</span> <span class="o">=</span> <span class="n">age</span><span class="p">,</span> <span class="n">var_od_lens</span> <span class="o">=</span> <span class="n">var_od_lens</span><span class="p">,</span> <span class="n">docul0</span> <span class="o">=</span> <span class="n">odata</span><span class="p">[</span><span class="s1">&#39;docul&#39;</span><span class="p">])</span>
    
    <span class="c1"># corrected LMS (no age correction):</span>
    <span class="n">alpha_lms</span> <span class="o">=</span> <span class="n">_LMS_absorptance</span><span class="p">(</span><span class="n">fieldsize</span> <span class="o">=</span> <span class="n">fieldsize</span><span class="p">,</span> <span class="n">var_shft_LMS</span> <span class="o">=</span> <span class="n">var_shft_LMS</span><span class="p">,</span> <span class="n">var_od_LMS</span> <span class="o">=</span> <span class="n">var_od_LMS</span><span class="p">,</span> <span class="n">LMSa0</span> <span class="o">=</span> <span class="n">odata</span><span class="p">[</span><span class="s1">&#39;LMSa&#39;</span><span class="p">],</span> <span class="n">LMSa0_interps</span> <span class="o">=</span> <span class="n">odata</span><span class="p">[</span><span class="s1">&#39;LMSa_interps&#39;</span><span class="p">])</span>
    
    <span class="c1"># Corrected to Corneal Incidence:</span>
    <span class="n">LMSq</span> <span class="o">=</span> <span class="n">alpha_lms</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">LMSq</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span> <span class="o">=</span> <span class="n">alpha_lms</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">rmd</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span> <span class="o">-</span> <span class="n">docul</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">alpha_lms</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    
    
    <span class="k">if</span> <span class="n">norm_type</span> <span class="o">==</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span>
        <span class="n">LMSq</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span> <span class="o">=</span> <span class="n">LMSq</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">LMSq</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:],</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;LMSq&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">LMSq</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;LMSq,rmd,docul,alpha_lms&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">LMSq</span><span class="p">,</span><span class="n">rmd</span><span class="p">,</span><span class="n">docul</span><span class="p">,</span><span class="n">alpha_lms</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">eval</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_LMS_energy</span><span class="p">(</span><span class="n">fieldsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="n">var_od_lens</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">var_od_mac</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
                <span class="n">var_shft_LMS</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">var_od_LMS</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> 
                <span class="n">norm_type</span> <span class="o">=</span> <span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;LMSe&#39;</span><span class="p">,</span> <span class="n">base</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">odata0</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the energy based LMS cone fundamentals for a given field size and age.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :fieldsize:</span>
<span class="sd">            | 10, float, optional</span>
<span class="sd">            | Field size in degrees.</span>
<span class="sd">        :age:</span>
<span class="sd">            | 32, float, optional</span>
<span class="sd">            | Age in years.</span>
<span class="sd">        :var_od_lens:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | Variation of optical density of lens.</span>
<span class="sd">        :var_od_mac:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | Variation of optical density of macula.</span>
<span class="sd">        :var_shft_LMS:</span>
<span class="sd">            | [0, 0, 0] optional</span>
<span class="sd">            | Variation (shift) of LMS peak absorptance.</span>
<span class="sd">        :var_od_LMS:</span>
<span class="sd">            | [0, 0, 0] optional</span>
<span class="sd">            | Variation of LMS optical densities.</span>
<span class="sd">        :norm_type:</span>
<span class="sd">            | &#39;max&#39;, optional</span>
<span class="sd">            | - &#39;max&#39;: normalize LMSq functions to max = 1</span>
<span class="sd">            | - &#39;area&#39;: normalize to area</span>
<span class="sd">            | - &#39;power&#39;: normalize to power</span>
<span class="sd">        :base:</span>
<span class="sd">            | False, boolean, optional</span>
<span class="sd">            | The returned energy-based LMS cone fundamentals given to the</span>
<span class="sd">            | precision of 9 sign. figs. if &#39;True&#39;, and to the precision of</span>
<span class="sd">            | 6 sign. figs. if &#39;False&#39;.</span>
<span class="sd">        :odata0: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Dict with uncorrected ocular media and macula density functions and LMS absorptance functions</span>
<span class="sd">            | None defaults to the ones stored in _DATA</span>

<span class="sd">    Returns:</span>
<span class="sd">        :LMSe: </span>
<span class="sd">            | ndarray with the calculated quantum_based LMS cone fundamentals; first row are wavelengths.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">LMSq</span><span class="p">,</span> <span class="n">rmd</span><span class="p">,</span> <span class="n">docul</span><span class="p">,</span> <span class="n">alpha_lms</span>  <span class="o">=</span> <span class="n">_LMS_quantal</span><span class="p">(</span><span class="n">fieldsize</span> <span class="o">=</span> <span class="n">fieldsize</span><span class="p">,</span> <span class="n">age</span> <span class="o">=</span> <span class="n">age</span><span class="p">,</span>
                                                <span class="n">var_od_lens</span> <span class="o">=</span> <span class="n">var_od_lens</span><span class="p">,</span> <span class="n">var_od_mac</span> <span class="o">=</span> <span class="n">var_od_mac</span><span class="p">,</span>
                                                <span class="n">var_shft_LMS</span> <span class="o">=</span> <span class="n">var_shft_LMS</span><span class="p">,</span> <span class="n">var_od_LMS</span> <span class="o">=</span> <span class="n">var_od_LMS</span><span class="p">,</span> 
                                                <span class="n">norm_type</span> <span class="o">=</span> <span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;LMSq,rmd,docul,alpha_lms&#39;</span><span class="p">,</span>
                                                <span class="n">odata0</span> <span class="o">=</span> <span class="n">odata0</span><span class="p">)</span>
    <span class="n">wls</span> <span class="o">=</span> <span class="n">LMSq</span><span class="p">[:</span><span class="mi">1</span><span class="p">,:]</span>
    <span class="n">LMSe</span> <span class="o">=</span> <span class="n">LMSq</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">LMSe</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span> <span class="o">=</span> <span class="n">LMSe</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span><span class="o">*</span><span class="n">wls</span>
    
    <span class="c1"># Set NaN values to zero:</span>
    <span class="n">LMSe</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">LMSe</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1"># Get max values before normalization:</span>
    <span class="n">LMSe_o_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">LMSe</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:],</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">norm_type</span> <span class="o">==</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span>
        <span class="n">LMSe</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span> <span class="o">=</span> <span class="n">LMSe</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span> <span class="o">/</span> <span class="n">LMSe_o_max</span>
    <span class="k">elif</span> <span class="n">norm_type</span> <span class="o">==</span> <span class="s1">&#39;area&#39;</span><span class="p">:</span>
        <span class="n">LMSe</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span> <span class="o">=</span> <span class="n">LMSe</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">LMSe</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:],</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">norm_type</span> <span class="o">==</span> <span class="s1">&#39;power&#39;</span><span class="p">:</span>
        <span class="n">LMSe</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span> <span class="o">=</span> <span class="n">LMSe</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span> <span class="o">/</span> <span class="n">spd_to_power</span><span class="p">(</span><span class="n">LMSe</span><span class="p">,</span> <span class="n">ptype</span><span class="o">=</span><span class="s1">&#39;ru&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">base</span><span class="p">:</span>
        <span class="n">LMSe</span> <span class="o">=</span> <span class="n">sign_figs</span><span class="p">(</span><span class="n">LMSe</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">LMSe</span> <span class="o">=</span> <span class="n">sign_figs</span><span class="p">(</span><span class="n">LMSe</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;LMSe&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">LMSe</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;LMSe,LMSq,alpha_lms,LMSe_o_max,rmd,docul&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">LMSe</span><span class="p">,</span><span class="n">LMSq</span><span class="p">,</span><span class="n">alpha_lms</span><span class="p">,</span><span class="n">LMSe_o_max</span><span class="p">,</span><span class="n">rmd</span><span class="p">,</span><span class="n">docul</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;LMSe,LMSq,alpha_lms,LMSe_o_max&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">LMSe</span><span class="p">,</span> <span class="n">LMSq</span><span class="p">,</span> <span class="n">alpha_lms</span><span class="p">,</span> <span class="n">LMSe_o_max</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;LMSe,LMSe_o_max&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">LMSe</span><span class="p">,</span> <span class="n">LMSe_o_max</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;LMSe,LMSq&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">LMSe</span><span class="p">,</span> <span class="n">LMSq</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;LMSe,LMSq,alpha_lms&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">LMSe</span><span class="p">,</span> <span class="n">LMSq</span><span class="p">,</span> <span class="n">alpha_lms</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;LMSe,rmd,docul,alpha_lms&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">LMSe</span><span class="p">,</span><span class="n">rmd</span><span class="p">,</span><span class="n">docul</span><span class="p">,</span><span class="n">alpha_lms</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;LMSe,LMSq,rmd,docul,alpha_lms&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">LMSe</span><span class="p">,</span><span class="n">LMSq</span><span class="p">,</span><span class="n">rmd</span><span class="p">,</span><span class="n">docul</span><span class="p">,</span><span class="n">alpha_lms</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">eval</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_relative_L_cone_weight_Vl_quantal</span><span class="p">(</span><span class="n">fieldsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="n">strategy_2</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                      <span class="n">LMSa</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">LMSq</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                                      <span class="n">var_od_lens</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">var_od_mac</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
                                      <span class="n">var_shft_LMS</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">var_od_LMS</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                      <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;kLq&#39;</span><span class="p">,</span> <span class="n">odata0</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the weighting factor of the quantal L-cone fundamental in the</span>
<span class="sd">    synthesis of the cone-fundamental-based quantal V(λ) function (normalized to max=1).</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :fieldsize: </span>
<span class="sd">            | 10, float, optional</span>
<span class="sd">            | Field size in degrees.</span>
<span class="sd">        :age:</span>
<span class="sd">            | 32, float, optional</span>
<span class="sd">            | Age in years.</span>
<span class="sd">        :strategy_2: </span>
<span class="sd">            | True, bool, optional</span>
<span class="sd">            | Use strategy 2 in github.com/ifarup/ciefunctions issue #121 for </span>
<span class="sd">            | computing the weighting factor. If false, strategy 3 is applied.</span>
<span class="sd">        :LMSa:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Pre-calculated LMSa (if None: will be calculated)</span>
<span class="sd">        :LMSq:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Pre-calculated LMSq (if None: will be calculated)</span>
<span class="sd">        :var_od_lens:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | Variation of optical density of lens.</span>
<span class="sd">        :var_od_mac:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | Variation of optical density of macula.</span>
<span class="sd">        :var_shft_LMS:</span>
<span class="sd">            | [0, 0, 0] optional</span>
<span class="sd">            | Variation (shift) of LMS peak absorptance.</span>
<span class="sd">        :var_od_LMS:</span>
<span class="sd">            | [0, 0, 0] optional</span>
<span class="sd">            | Variation of LMS optical densities.</span>
<span class="sd">        :odata0: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Dict with uncorrected ocular media and macula density functions and LMS absorptance functions</span>
<span class="sd">            | None defaults to the ones stored in _DATA</span>

<span class="sd">    Returns:</span>
<span class="sd">        kLq: </span>
<span class="sd">            | float</span>
<span class="sd">            | The computed weighting factor of the quantal L cone fundamental </span>
<span class="sd">            | in the synthesis of the quantal V(λ) function , i.e.</span>
<span class="sd">            | Vq(λ) = kLq lq_bar((λ) + mq_bar(λ)).</span>
<span class="sd">            </span>
<span class="sd">    Strategies:</span>
<span class="sd">        1. Continue using constant 1.89 for all situations</span>
<span class="sd">        2. Assume 1.89 for all field sizes, 32 years, and scale for other ages (most probably)</span>
<span class="sd">        3. Assume 1.89 for 32 years, 2 degrees, and scale from there</span>
<span class="sd">        4. Find general solution for l_bar_max / m_bar_max as function of age and field size</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">strategy_2</span><span class="p">:</span>
        <span class="n">field_size</span> <span class="o">=</span> <span class="mf">2.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">field_size</span> <span class="o">=</span> <span class="n">fieldsize</span>

    <span class="k">if</span> <span class="n">odata0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">odata</span> <span class="o">=</span> <span class="n">_DATA</span><span class="p">[</span><span class="s1">&#39;odata&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">odata</span> <span class="o">=</span> <span class="n">odata0</span>
  
    <span class="c1"># avoid recalculation if unnecessary:  </span>
    <span class="k">if</span> <span class="p">(</span><span class="n">field_size</span> <span class="o">!=</span> <span class="n">fieldsize</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">LMSa</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">LMSq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">LMSq_fs_age</span><span class="p">,</span> <span class="n">LMSa_fs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_LMS_energy</span><span class="p">(</span><span class="n">fieldsize</span> <span class="o">=</span> <span class="n">field_size</span><span class="p">,</span> <span class="n">age</span> <span class="o">=</span> <span class="n">age</span><span class="p">,</span>
                                                      <span class="n">var_od_lens</span> <span class="o">=</span> <span class="n">var_od_lens</span><span class="p">,</span> <span class="n">var_od_mac</span> <span class="o">=</span> <span class="n">var_od_mac</span><span class="p">,</span>
                                                      <span class="n">var_shft_LMS</span> <span class="o">=</span> <span class="n">var_shft_LMS</span><span class="p">,</span> <span class="n">var_od_LMS</span> <span class="o">=</span> <span class="n">var_od_LMS</span><span class="p">,</span> 
                                                      <span class="n">norm_type</span> <span class="o">=</span> <span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;LMSe,LMSq,alpha_lms,LMSe_o_max&#39;</span><span class="p">,</span>
                                                      <span class="n">base</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">odata0</span> <span class="o">=</span> <span class="n">odata</span><span class="p">)</span> <span class="c1"># note: base only applies to LMSe !</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">LMSa_fs</span> <span class="o">=</span> <span class="n">LMSa</span>
        <span class="n">LMSq_fs_age</span> <span class="o">=</span> <span class="n">LMSq</span>

    <span class="n">LMSa_2</span> <span class="o">=</span> <span class="n">_LMS_absorptance</span><span class="p">(</span><span class="n">fieldsize</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">LMSa0</span> <span class="o">=</span> <span class="n">odata</span><span class="p">[</span><span class="s1">&#39;LMSa&#39;</span><span class="p">],</span> <span class="n">LMSa0_interps</span> <span class="o">=</span> <span class="n">odata</span><span class="p">[</span><span class="s1">&#39;LMSa_interps&#39;</span><span class="p">])</span>
    <span class="n">LMSq_2_32</span> <span class="o">=</span> <span class="n">_LMS_quantal</span><span class="p">(</span><span class="n">fieldsize</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="n">odata0</span> <span class="o">=</span> <span class="n">odata</span><span class="p">)</span>
    
    <span class="n">const_fs_age</span> <span class="o">=</span> <span class="p">(</span><span class="n">LMSa_fs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">LMSq_fs_age</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">LMSa_fs</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">LMSq_fs_age</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
    <span class="n">const_2_32</span> <span class="o">=</span> <span class="p">(</span><span class="n">LMSa_2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">LMSq_2_32</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">LMSa_2</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">LMSq_2_32</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
    <span class="n">kLq_rel</span> <span class="o">=</span> <span class="mf">1.89</span> <span class="o">*</span> <span class="n">const_fs_age</span> <span class="o">/</span> <span class="n">const_2_32</span>
    
    <span class="k">if</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;kLq&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">kLq_rel</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">eval</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_Vl_energy_and_LM_weights</span><span class="p">(</span><span class="n">fieldsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="n">strategy_2</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                             <span class="n">LMSa</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">LMSq</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">LMSe</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">LMSe_o_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                             <span class="n">var_od_lens</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">var_od_mac</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
                             <span class="n">var_shft_LMS</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">var_od_LMS</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                             <span class="n">odata0</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the energy-based V(λ) function (starting from energy-based LMS).</span>
<span class="sd">    Return both V(λ) and the the corresponding L and M cone weights used</span>
<span class="sd">    in the synthesis.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :fieldsize: </span>
<span class="sd">            | 10, float, optional</span>
<span class="sd">            | Field size in degrees.</span>
<span class="sd">        :age:</span>
<span class="sd">            | 32, float, optional</span>
<span class="sd">            | Age in years.</span>
<span class="sd">        :strategy_2: </span>
<span class="sd">            | True, bool, optional</span>
<span class="sd">            | Use strategy 2 in github.com/ifarup/ciefunctions issue #121 for </span>
<span class="sd">            | computing the weighting factor. If false, strategy 3 is applied.</span>
<span class="sd">        :LMSa:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Pre-calculated LMSa (if None: will be calculated)</span>
<span class="sd">        :LMSq:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Pre-calculated LMSq (if None: will be calculated)</span>
<span class="sd">        :LMSe:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Pre-calculated LMSe (if None: will be calculated)</span>
<span class="sd">        :LMSe_o_max:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Max of original (prior to normalization) LMSe.</span>
<span class="sd">            | Pre-calculated value (if None: will be calculated).</span>
<span class="sd">        :var_od_lens:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | Variation of optical density of lens.</span>
<span class="sd">        :var_od_mac:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | Variation of optical density of macula.</span>
<span class="sd">        :var_shft_LMS:</span>
<span class="sd">            | [0, 0, 0] optional</span>
<span class="sd">            | Variation (shift) of LMS peak absorptance.</span>
<span class="sd">        :var_od_LMS:</span>
<span class="sd">            | [0, 0, 0] optional</span>
<span class="sd">            | Variation of LMS optical densities.</span>
<span class="sd">        :odata0: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Dict with uncorrected ocular media and macula density functions and LMS absorptance functions</span>
<span class="sd">            | None defaults to the ones stored in _DATA</span>

<span class="sd">    Returns:</span>
<span class="sd">        :Vl:</span>
<span class="sd">            | ndarray</span>
<span class="sd">            | The energy-based V(λ) function; wavelengths in first row.</span>
<span class="sd">        :a21,a22:</span>
<span class="sd">            | float</span>
<span class="sd">            | The computed weighting factors of, respectively, the L and the</span>
<span class="sd">            | M cone fundamental in the synthesis of energy-based V(λ) function,</span>
<span class="sd">            | i.e. V(λ) = a21*l_bar(λ) + a22*m_bar(λ)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">kLq_rel</span> <span class="o">=</span> <span class="n">_relative_L_cone_weight_Vl_quantal</span><span class="p">(</span><span class="n">fieldsize</span> <span class="o">=</span> <span class="n">fieldsize</span><span class="p">,</span> <span class="n">age</span> <span class="o">=</span> <span class="n">age</span><span class="p">,</span> <span class="n">strategy_2</span> <span class="o">=</span> <span class="n">strategy_2</span><span class="p">,</span>
                                                 <span class="n">LMSa</span> <span class="o">=</span> <span class="n">LMSa</span><span class="p">,</span> <span class="n">LMSq</span> <span class="o">=</span> <span class="n">LMSq</span><span class="p">,</span>
                                                 <span class="n">var_od_lens</span> <span class="o">=</span> <span class="n">var_od_lens</span><span class="p">,</span> <span class="n">var_od_mac</span> <span class="o">=</span> <span class="n">var_od_mac</span><span class="p">,</span> 
                                                 <span class="n">var_shft_LMS</span> <span class="o">=</span> <span class="n">var_shft_LMS</span><span class="p">,</span> <span class="n">var_od_LMS</span> <span class="o">=</span> <span class="n">var_od_LMS</span><span class="p">,</span>
                                                 <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;kLq&#39;</span><span class="p">,</span> <span class="n">odata0</span> <span class="o">=</span> <span class="n">odata0</span><span class="p">)</span>
    <span class="p">(</span><span class="n">Lo_max</span><span class="p">,</span> <span class="n">Mo_max</span><span class="p">)</span> <span class="o">=</span> <span class="n">LMSe_o_max</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">Vo_max</span> <span class="o">=</span> <span class="p">(</span><span class="n">kLq_rel</span> <span class="o">*</span> <span class="n">Lo_max</span> <span class="o">*</span> <span class="n">LMSe</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">+</span> <span class="n">Mo_max</span> <span class="o">*</span> <span class="n">LMSe</span><span class="p">[</span><span class="mi">2</span><span class="p">,:])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">a21</span> <span class="o">=</span> <span class="n">my_round</span><span class="p">(</span><span class="n">kLq_rel</span> <span class="o">*</span> <span class="n">Lo_max</span> <span class="o">/</span> <span class="n">Vo_max</span><span class="p">,</span> <span class="mi">8</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">a22</span> <span class="o">=</span> <span class="n">my_round</span><span class="p">(</span><span class="n">Mo_max</span> <span class="o">/</span> <span class="n">Vo_max</span><span class="p">,</span> <span class="mi">8</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">sign_figs</span><span class="p">(</span><span class="n">a21</span> <span class="o">*</span> <span class="n">LMSe</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">+</span> <span class="n">a22</span> <span class="o">*</span> <span class="n">LMSe</span><span class="p">[</span><span class="mi">2</span><span class="p">,:],</span> <span class="mi">7</span><span class="p">)</span>
    <span class="n">Vl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(([</span><span class="n">LMSe</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="n">V</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">Vl</span><span class="p">,</span> <span class="p">(</span><span class="n">a21</span><span class="p">,</span> <span class="n">a22</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_xyz_interpolated_reference_system</span><span class="p">(</span><span class="n">fieldsize</span><span class="p">,</span> <span class="n">XYZ31_std</span><span class="p">,</span> <span class="n">XYZ64_std</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the spectral chromaticity coordinates of the reference system</span>
<span class="sd">    by interpolation between correspoding spectral chromaticity coordinates</span>
<span class="sd">    of the CIE 1931 XYZ systems and the CIE 1964 XYZ systems.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :fieldsize:</span>
<span class="sd">            | float</span>
<span class="sd">            | The field size in degrees.</span>
<span class="sd">        :XYZ31_std:</span>
<span class="sd">            | ndarray</span>
<span class="sd">            | The CIE 1931 XYZ colour-matching functions (2°), given at 1 nm</span>
<span class="sd">            | steps from 360 nm to 830 nm; wavelengths in first row.</span>
<span class="sd">        :XYZ64_std:</span>
<span class="sd">            | ndarray</span>
<span class="sd">            | The CIE 1964 XYZ colour-matching functions (10°), given at 1 nm</span>
<span class="sd">            | steps from 360 nm to 830 nm; wavelengths in first row.</span>

<span class="sd">    Returns:</span>
<span class="sd">        :chromaticity:</span>
<span class="sd">            | ndarray</span>
<span class="sd">            | The computed interpolated spectral chromaticity coordinates of the</span>
<span class="sd">            | CIE standard XYZ systems; wavelenghts in first row.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">interpolate</span> <span class="c1"># lazy import</span>
    
    <span class="c1"># Compute the xyz spectral chromaticity coordinates of the CIE standards </span>
    <span class="n">xyz31</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">XYZ31_std</span><span class="p">[:</span><span class="mi">1</span><span class="p">,:],(</span><span class="n">xyz_to_Yxy</span><span class="p">((</span><span class="n">XYZ31_std</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:])</span><span class="o">.</span><span class="n">T</span><span class="p">)[:,</span><span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
    <span class="n">xyz64</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">XYZ64_std</span><span class="p">[:</span><span class="mi">1</span><span class="p">,:],(</span><span class="n">xyz_to_Yxy</span><span class="p">(</span><span class="n">XYZ64_std</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span><span class="o">.</span><span class="n">T</span><span class="p">)[:,</span><span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
    
    <span class="c1"># Determine the wavelength parameters of the knots in the CIE 1931 and </span>
    <span class="c1"># CIE 1964 xy diagrams that serve as guide-points for the interpolation </span>
    <span class="c1"># (morphing) between the spectral CIE 1931 chromaticities and the spectral</span>
    <span class="c1"># CIE 1964 chromaticities. </span>
    <span class="p">[</span><span class="n">wl31</span><span class="p">,</span> <span class="n">x31</span><span class="p">,</span> <span class="n">y31</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">xyz31</span><span class="p">)[:</span><span class="mi">3</span><span class="p">]</span>  
    <span class="p">[</span><span class="n">wl64</span><span class="p">,</span> <span class="n">x64</span><span class="p">,</span> <span class="n">y64</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">xyz64</span><span class="p">)[:</span><span class="mi">3</span><span class="p">]</span> 
    <span class="n">wl31_knots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">360</span><span class="p">,</span> <span class="n">wl31</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">x31</span><span class="p">)],</span> <span class="n">wl31</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">y31</span><span class="p">)],</span> <span class="mi">700</span><span class="p">,</span> <span class="mi">830</span><span class="p">])</span>
    <span class="n">wl64_knots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">360</span><span class="p">,</span> <span class="n">wl64</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">x64</span><span class="p">)],</span> <span class="n">wl64</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">y64</span><span class="p">)],</span> <span class="mi">700</span><span class="p">,</span> <span class="mi">830</span><span class="p">])</span>
    
    <span class="c1"># Determine the wavelength parameters of the knots (guide-points) in the</span>
    <span class="c1"># reference diagram (for the field size specified)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">fieldsize</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mf">8.</span>
    <span class="n">wl_knots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">360.</span><span class="p">,</span>
                       <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">wl31</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">x31</span><span class="p">)]</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">wl64</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">x64</span><span class="p">)],</span>
                       <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">wl31</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">y31</span><span class="p">)]</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">wl64</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">y64</span><span class="p">)],</span>
                       <span class="mf">700.</span><span class="p">,</span>
                       <span class="mf">830.</span><span class="p">])</span>
    <span class="c1"># wl values</span>
    <span class="n">wl31_interp</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">InterpolatedUnivariateSpline</span><span class="p">(</span><span class="n">wl_knots</span><span class="p">,</span> <span class="n">wl31_knots</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)(</span><span class="n">wl31</span><span class="p">)</span>
    <span class="n">wl64_interp</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">InterpolatedUnivariateSpline</span><span class="p">(</span><span class="n">wl_knots</span><span class="p">,</span> <span class="n">wl64_knots</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)(</span><span class="n">wl64</span><span class="p">)</span>

    <span class="c1"># x values</span>
    <span class="n">x31_interp</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">InterpolatedUnivariateSpline</span><span class="p">(</span><span class="n">wl31</span><span class="p">,</span> <span class="n">x31</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)(</span><span class="n">wl31_interp</span><span class="p">)</span>
    <span class="n">x64_interp</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">InterpolatedUnivariateSpline</span><span class="p">(</span><span class="n">wl64</span><span class="p">,</span> <span class="n">x64</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)(</span><span class="n">wl64_interp</span><span class="p">)</span>
    <span class="n">x_values</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">x31_interp</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x64_interp</span>
    
    <span class="c1"># y values</span>
    <span class="n">y31_interp</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">InterpolatedUnivariateSpline</span><span class="p">(</span><span class="n">wl31</span><span class="p">,</span> <span class="n">y31</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)(</span><span class="n">wl31_interp</span><span class="p">)</span>
    <span class="n">y64_interp</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">InterpolatedUnivariateSpline</span><span class="p">(</span><span class="n">wl64</span><span class="p">,</span> <span class="n">y64</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)(</span><span class="n">wl64_interp</span><span class="p">)</span>
    <span class="n">y_values</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">y31_interp</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">y64_interp</span>
    
    <span class="c1"># z values</span>
    <span class="n">z_values</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">x_values</span> <span class="o">-</span> <span class="n">y_values</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">wl31</span><span class="p">,</span> <span class="n">x_values</span><span class="p">,</span> <span class="n">y_values</span><span class="p">,</span> <span class="n">z_values</span><span class="p">])</span>

<span class="c1"># =============================================================================</span>
<span class="c1"># Minimisation function</span>
<span class="c1"># =============================================================================</span>

    
<span class="k">def</span> <span class="nf">_square_sum</span><span class="p">(</span><span class="n">a13</span><span class="p">,</span> <span class="n">a21</span><span class="p">,</span> <span class="n">a22</span><span class="p">,</span> <span class="n">a33</span><span class="p">,</span> 
                <span class="n">xyz_ref_trunk</span><span class="p">,</span> <span class="n">x_ref_min</span><span class="p">,</span>
                <span class="n">L_wl_sum</span><span class="p">,</span> <span class="n">M_wl_sum</span><span class="p">,</span> <span class="n">S_wl_sum</span><span class="p">,</span> <span class="n">V_wl_sum</span><span class="p">,</span>
                <span class="n">L_wl_ref_min</span><span class="p">,</span> <span class="n">M_wl_ref_min</span><span class="p">,</span> <span class="n">S_wl_ref_min</span><span class="p">,</span> <span class="n">V_wl_ref_min</span><span class="p">,</span>
                <span class="n">LMS_390_830</span><span class="p">,</span> <span class="n">wl_390_830</span><span class="p">,</span> <span class="n">wl_ref_min</span><span class="p">,</span> <span class="n">full_results</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to be optimised for determination of element a13 in the (non-renormalized) </span>
<span class="sd">    transformation matrix of the linear transformation LMS --&gt; XYZ.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :a13: </span>
<span class="sd">            | ndarray</span>
<span class="sd">            | 1x1 array with parameter to optimise.</span>
<span class="sd">        :a21, a22, a33: </span>
<span class="sd">            | float</span>
<span class="sd">            | Parameters in matrix for LMS to XYZ conversion.</span>
<span class="sd">        :L_wl_sum, M_wl_sum, S_wl_sum, V_wl_sum: </span>
<span class="sd">            | Sum of L, M, S, V (i.e. L_spline(wl_main).sum())</span>
<span class="sd">        :L_wl_ref_min, M_wl_ref_min, S_wl_ref_min, V_wl_ref_min: </span>
<span class="sd">            | value of L, M, S, V at wl_ref_min (i.e. L_spline(wl_ref_min))</span>
<span class="sd">        :wl_390_830:</span>
<span class="sd">            | wavelengths from 390 - 830 nm.</span>
<span class="sd">        :LMS_390_830:</span>
<span class="sd">            | LMS evaluated for wl_390_830 nm.</span>
<span class="sd">        :xyz_ref_trunk: </span>
<span class="sd">            | ndarray</span>
<span class="sd">            | Truncated reference xyz chromaticity coordinates at 1 nm steps (wavelengths in first row).</span>
<span class="sd">        :x_ref_min:</span>
<span class="sd">            | min of x coordinate in xyz_ref_trunk</span>
<span class="sd">        :wl_ref_min: </span>
<span class="sd">            | float</span>
<span class="sd">            | λ value that gives a minimum for the x-coordinate in the</span>
<span class="sd">            | corresponding reference diagram, i.e. x(wl_ref_min) = x_ref_min.</span>
<span class="sd">        :full_results: </span>
<span class="sd">            | bool</span>
<span class="sd">            | Return all results or just the computed error.</span>

<span class="sd">    Returns:</span>
<span class="sd">        :err: </span>
<span class="sd">            | float</span>
<span class="sd">            | Computed error.</span>
<span class="sd">        :trans_mat:</span>
<span class="sd">            | ndarray</span>
<span class="sd">            | Transformation matrix.</span>
<span class="sd">        :wl_test_min:</span>
<span class="sd">            | float</span>
<span class="sd">            | argmin(x(wl)).</span>
<span class="sd">        :ok:</span>
<span class="sd">            | bool</span>
<span class="sd">            | Hit the correct minimum wavelength.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Transformation coefficients (a11 and a12 computed by Mathematica)</span>
    <span class="n">a11</span> <span class="o">=</span> <span class="p">(((</span><span class="n">a13</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x_ref_min</span><span class="p">)</span> <span class="o">*</span>
             <span class="p">(</span><span class="n">M_wl_ref_min</span> <span class="o">*</span> <span class="n">S_wl_sum</span> <span class="o">-</span>
              <span class="n">S_wl_ref_min</span> <span class="o">*</span> <span class="n">M_wl_sum</span><span class="p">))</span> <span class="o">+</span>
            <span class="p">(</span><span class="n">x_ref_min</span> <span class="o">*</span>
             <span class="p">(</span><span class="n">a21</span> <span class="o">*</span> <span class="n">L_wl_ref_min</span> <span class="o">+</span> <span class="n">a22</span> <span class="o">*</span> <span class="n">M_wl_ref_min</span> <span class="o">+</span>
              <span class="n">a33</span> <span class="o">*</span> <span class="n">S_wl_ref_min</span><span class="p">)</span> <span class="o">*</span> <span class="n">M_wl_sum</span><span class="p">)</span> <span class="o">-</span>
            <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x_ref_min</span><span class="p">)</span> <span class="o">*</span> <span class="n">M_wl_ref_min</span> <span class="o">*</span> <span class="n">V_wl_sum</span><span class="p">))</span> <span class="o">/</span>
           <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x_ref_min</span><span class="p">)</span> <span class="o">*</span>
            <span class="p">(</span><span class="n">L_wl_ref_min</span> <span class="o">*</span> <span class="n">M_wl_sum</span> <span class="o">-</span>
             <span class="n">M_wl_ref_min</span> <span class="o">*</span> <span class="n">L_wl_sum</span><span class="p">)))</span>
    <span class="n">a12</span> <span class="o">=</span> <span class="p">(((</span><span class="n">a13</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x_ref_min</span><span class="p">)</span> <span class="o">*</span>
             <span class="p">(</span><span class="n">L_wl_ref_min</span> <span class="o">*</span> <span class="n">S_wl_sum</span> <span class="o">-</span>
              <span class="n">S_wl_ref_min</span> <span class="o">*</span> <span class="n">L_wl_sum</span><span class="p">))</span> <span class="o">+</span>
            <span class="p">(</span><span class="n">x_ref_min</span> <span class="o">*</span>
             <span class="p">(</span><span class="n">a21</span> <span class="o">*</span> <span class="n">L_wl_ref_min</span> <span class="o">+</span> <span class="n">a22</span> <span class="o">*</span> <span class="n">M_wl_ref_min</span> <span class="o">+</span>
              <span class="n">a33</span> <span class="o">*</span> <span class="n">S_wl_ref_min</span><span class="p">)</span> <span class="o">*</span> <span class="n">L_wl_sum</span><span class="p">)</span> <span class="o">-</span>
            <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x_ref_min</span><span class="p">)</span> <span class="o">*</span> <span class="n">L_wl_ref_min</span> <span class="o">*</span> <span class="n">V_wl_sum</span><span class="p">))</span> <span class="o">/</span>
           <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x_ref_min</span><span class="p">)</span> <span class="o">*</span>
            <span class="p">(</span><span class="n">M_wl_ref_min</span> <span class="o">*</span> <span class="n">L_wl_sum</span> <span class="o">-</span>
             <span class="n">L_wl_ref_min</span> <span class="o">*</span> <span class="n">M_wl_sum</span><span class="p">)))</span>
    <span class="n">a11</span> <span class="o">=</span> <span class="n">my_round</span><span class="p">(</span><span class="n">a11</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">8</span><span class="p">)</span>
    <span class="n">a12</span> <span class="o">=</span> <span class="n">my_round</span><span class="p">(</span><span class="n">a12</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">8</span><span class="p">)</span>
    <span class="n">a13</span> <span class="o">=</span> <span class="n">my_round</span><span class="p">(</span><span class="n">a13</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">8</span><span class="p">)</span>
    <span class="n">trans_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">a11</span><span class="p">,</span> <span class="n">a12</span><span class="p">,</span> <span class="n">a13</span><span class="p">],</span> <span class="p">[</span><span class="n">a21</span><span class="p">,</span> <span class="n">a22</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">a33</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">XYZ</span> <span class="o">=</span> <span class="n">sign_figs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">trans_mat</span><span class="p">,</span> <span class="n">LMS_390_830</span><span class="p">),</span> <span class="mi">7</span><span class="p">)</span>
<span class="c1">#    sumXYZ = X + Y + Z</span>
<span class="c1">#    xyz = np.array([X / sumXYZ, Y / sumXYZ, Z / sumXYZ])</span>

    <span class="n">xyz</span> <span class="o">=</span> <span class="n">XYZ</span><span class="o">/</span><span class="n">XYZ</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">err</span> <span class="o">=</span> <span class="p">((</span><span class="n">xyz</span> <span class="o">-</span> <span class="n">xyz_ref_trunk</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">wl_test_min</span> <span class="o">=</span> <span class="n">wl_390_830</span><span class="p">[</span><span class="n">xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">argmin</span><span class="p">()]</span>
    <span class="n">ok</span> <span class="o">=</span> <span class="p">(</span><span class="n">wl_test_min</span> <span class="o">==</span> <span class="n">wl_ref_min</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ok</span><span class="p">:</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">err</span> <span class="o">+</span> <span class="mf">1e300</span>
    
    <span class="k">if</span> <span class="n">full_results</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">trans_mat</span><span class="p">,</span> <span class="n">wl_test_min</span><span class="p">,</span> <span class="n">ok</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">err</span>
    
<span class="k">def</span> <span class="nf">_compute_LMS</span><span class="p">(</span><span class="n">wls</span><span class="p">,</span> <span class="n">L_spline</span><span class="p">,</span> <span class="n">M_spline</span><span class="p">,</span> <span class="n">S_spline</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the LMS cone fundamentals for given wavelengths, as linear values </span>
<span class="sd">    to respective specified precisions.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :wls:</span>
<span class="sd">            | ndarray</span>
<span class="sd">            | The wavelengths for which the LMS cone fundamentals are to be calculated.</span>
<span class="sd">        :L_spline, M_spline, S_spline:</span>
<span class="sd">            | Spline-interpolation functions for the LMS cone fundamentals (on a linear scale).</span>
<span class="sd">        :base:</span>
<span class="sd">            | boolean</span>
<span class="sd">            | The returned energy-based LMS values are given to the precision of</span>
<span class="sd">            | 9 sign. figs. / 8 decimal points if &#39;True&#39;, and to the precision of</span>
<span class="sd">            | 6 sign. figs. / 5 decimal points if &#39;False&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        :LMS:</span>
<span class="sd">            | ndarray</span>
<span class="sd">            | The computed LMS cone fundamentals; wavelengths in first row.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">base</span><span class="p">:</span>
        <span class="n">LMS_sf</span> <span class="o">=</span> <span class="mi">9</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">LMS_sf</span> <span class="o">=</span> <span class="mi">6</span>
        
    <span class="c1"># Compute linear values</span>
    <span class="n">LMS</span> <span class="o">=</span> <span class="n">chop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">wls</span><span class="p">,</span>
                         <span class="n">sign_figs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">L_spline</span><span class="p">(</span><span class="n">wls</span><span class="p">),</span> 
                                             <span class="n">M_spline</span><span class="p">(</span><span class="n">wls</span><span class="p">),</span> 
                                             <span class="n">S_spline</span><span class="p">(</span><span class="n">wls</span><span class="p">)]),</span> <span class="n">LMS_sf</span><span class="p">))))</span>
    <span class="k">return</span> <span class="n">LMS</span>
    
<span class="k">def</span> <span class="nf">_compute_XYZ</span><span class="p">(</span><span class="n">L_spline</span><span class="p">,</span> <span class="n">M_spline</span><span class="p">,</span> <span class="n">S_spline</span><span class="p">,</span> <span class="n">V_spline</span><span class="p">,</span>
                <span class="n">LMS_spec</span><span class="p">,</span> <span class="n">LMS_all</span><span class="p">,</span> <span class="n">LM_weights</span><span class="p">,</span> <span class="n">xyz_reference</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the CIE cone-fundamental-based XYZ tristimulus functions.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :L_spline, M_spline, S_spline:</span>
<span class="sd">            | Spline-interpolation functions for the LMS cone fundamentals (on a linear scale).</span>
<span class="sd">        :V_spline:</span>
<span class="sd">            | Spline-interpolation functions for the cone-fundamental-based V(λ)-function (on a linear scale).</span>
<span class="sd">        :LMS_spec: </span>
<span class="sd">            | ndarray</span>
<span class="sd">            | Table of LMS values at specified wavelengths, given to base-value</span>
<span class="sd">            | precision (i.e. 9 sign. figs); wavelengths in first column.</span>
<span class="sd">        :LMS_all: </span>
<span class="sd">            | ndarray</span>
<span class="sd">            | Table of LMS values at 0.1 nm steps from 390 nm to 830 nm,</span>
<span class="sd">            | given to base-value precision (i.e. 9 sign. figs.); wavelengths in first row.</span>
<span class="sd">        :LM_weights:</span>
<span class="sd">            | ndarray</span>
<span class="sd">            | The weighting factors kL and kM in the synthesis of the</span>
<span class="sd">            | cone-fundamental-based V(λ)-function, i.e.</span>
<span class="sd">            | V(λ) = kL * l_bar(λ) + kM * m_bar(λ).</span>
<span class="sd">        :xyz_reference:</span>
<span class="sd">            | ndarray</span>
<span class="sd">            | The spectral chromaticity coordinates of the reference system</span>
<span class="sd">            | (obtained by shape-morphing (interpolation) between the CIE 1931</span>
<span class="sd">            | standard and the CIE 1964 standard).</span>

<span class="sd">    Returns:</span>
<span class="sd">        :trans_mat:</span>
<span class="sd">            | ndarray</span>
<span class="sd">            | The non-renormalized transformation matrix of the linear transformation LMS --&gt; XYZ.</span>
<span class="sd">        :XYZ_spec:</span>
<span class="sd">            | ndarray</span>
<span class="sd">            | The non-renormalized CIE cone-fundamental-based XYZ spectral</span>
<span class="sd">            | tristimulus values for the tabulated wavelengths, given to</span>
<span class="sd">            | standard/specified precision; wavelengths in first row.</span>
<span class="sd">        :trans_mat_N:</span>
<span class="sd">            | ndarray</span>
<span class="sd">            | The renormalized transformation matrix of the linear transformation LMS --&gt; XYZ.</span>
<span class="sd">        :XYZ_spec_N:</span>
<span class="sd">            | ndarray</span>
<span class="sd">            | The renormalized CIE cone-fundamental-based XYZ spectral</span>
<span class="sd">            | tristimulus values for the tabulated wavelengths, given to</span>
<span class="sd">            | standard/specified precision; wavelengths in first row.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">optimize</span> <span class="c1"># lazy import</span>
    
    <span class="c1"># &#39;_all&#39;  : values given at 0.1 nm steps from 390 nm to 830 nm</span>
    <span class="c1"># &#39;_main&#39; : values given at 1 nm steps from 390 nm to 830 nm</span>
    <span class="c1"># &#39;_spec&#39; : values given at specified wavelengths</span>

    <span class="n">xyz_ref</span> <span class="o">=</span> <span class="n">xyz_reference</span>
    <span class="p">(</span><span class="n">a21</span><span class="p">,</span> <span class="n">a22</span><span class="p">)</span> <span class="o">=</span> <span class="n">LM_weights</span>
    
    <span class="n">d</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">getwld</span><span class="p">(</span><span class="n">LMS_all</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">d</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="nb">float</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">LMS_main</span> <span class="o">=</span> <span class="n">LMS_all</span><span class="p">[:,::</span><span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Obtaining LMS_main by interpolation&#39;</span><span class="p">)</span>
        <span class="n">LMS_main</span> <span class="o">=</span> <span class="n">cie_interp</span><span class="p">(</span><span class="n">LMS_all</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">390</span><span class="p">,</span> <span class="mi">831</span><span class="p">),</span> <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;cubic&#39;</span><span class="p">)</span>
    <span class="p">(</span><span class="n">wl_main</span><span class="p">,</span> <span class="n">L_main</span><span class="p">,</span> <span class="n">M_main</span><span class="p">,</span> <span class="n">S_main</span><span class="p">)</span> <span class="o">=</span> <span class="n">LMS_main</span>
    <span class="n">V_main</span> <span class="o">=</span> <span class="n">sign_figs</span><span class="p">(</span><span class="n">a21</span> <span class="o">*</span> <span class="n">L_main</span> <span class="o">+</span> <span class="n">a22</span> <span class="o">*</span> <span class="n">M_main</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
    <span class="n">a33</span> <span class="o">=</span> <span class="n">my_round</span><span class="p">(</span><span class="n">V_main</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">S_main</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="mi">8</span><span class="p">)</span>
    
    <span class="c1"># Compute optimised non-renormalised transformation matrix</span>
    <span class="n">wl_x_min_ref</span> <span class="o">=</span> <span class="mi">502</span>
    <span class="n">wl_390_830</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">390</span><span class="p">,</span> <span class="mi">831</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1">## Pre-compute some stuff that doesn&#39;t change over each iteration (for speed):</span>
    <span class="n">LMS_390_830</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">L_spline</span><span class="p">(</span><span class="n">wl_390_830</span><span class="p">),</span>
                            <span class="n">M_spline</span><span class="p">(</span><span class="n">wl_390_830</span><span class="p">),</span>
                            <span class="n">S_spline</span><span class="p">(</span><span class="n">wl_390_830</span><span class="p">)])</span>
    <span class="n">L_wl_sum</span> <span class="o">=</span> <span class="n">L_spline</span><span class="p">(</span><span class="n">wl_main</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">M_wl_sum</span> <span class="o">=</span> <span class="n">M_spline</span><span class="p">(</span><span class="n">wl_main</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">S_wl_sum</span> <span class="o">=</span> <span class="n">S_spline</span><span class="p">(</span><span class="n">wl_main</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">V_wl_sum</span> <span class="o">=</span> <span class="n">V_spline</span><span class="p">(</span><span class="n">wl_main</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        
    <span class="n">xyz_ref_trunk</span> <span class="o">=</span> <span class="n">xyz_ref</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span><span class="mi">30</span><span class="p">:]</span> <span class="c1"># Stripping reference values in accordance with CIE2006 tables</span>
    <span class="n">x_ref_min</span> <span class="o">=</span> <span class="n">xyz_ref_trunk</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

    <span class="n">ok</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">ok</span><span class="p">:</span>
        <span class="n">L_wl_ref_min</span> <span class="o">=</span> <span class="n">L_spline</span><span class="p">(</span><span class="n">wl_x_min_ref</span><span class="p">)</span>
        <span class="n">M_wl_ref_min</span> <span class="o">=</span> <span class="n">M_spline</span><span class="p">(</span><span class="n">wl_x_min_ref</span><span class="p">)</span>
        <span class="n">S_wl_ref_min</span> <span class="o">=</span> <span class="n">S_spline</span><span class="p">(</span><span class="n">wl_x_min_ref</span><span class="p">)</span>
        <span class="n">V_wl_ref_min</span> <span class="o">=</span> <span class="n">V_spline</span><span class="p">(</span><span class="n">wl_x_min_ref</span><span class="p">)</span>
        
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
            <span class="n">a13</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">fmin</span><span class="p">(</span><span class="n">_square_sum</span><span class="p">,</span> <span class="mf">0.39</span><span class="p">,</span> 
                                   <span class="p">(</span><span class="n">a21</span><span class="p">,</span> <span class="n">a22</span><span class="p">,</span> <span class="n">a33</span><span class="p">,</span>
                                   <span class="n">xyz_ref_trunk</span><span class="p">,</span> <span class="n">x_ref_min</span><span class="p">,</span>
                                   <span class="n">L_wl_sum</span><span class="p">,</span> <span class="n">M_wl_sum</span><span class="p">,</span> <span class="n">S_wl_sum</span><span class="p">,</span> <span class="n">V_wl_sum</span><span class="p">,</span>
                                   <span class="n">L_wl_ref_min</span><span class="p">,</span> <span class="n">M_wl_ref_min</span><span class="p">,</span> <span class="n">S_wl_ref_min</span><span class="p">,</span> <span class="n">V_wl_ref_min</span><span class="p">,</span>
                                   <span class="n">LMS_390_830</span><span class="p">,</span> <span class="n">wl_390_830</span><span class="p">,</span> <span class="n">wl_x_min_ref</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
                                <span class="n">xtol</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">,</span> <span class="n">disp</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> 
        <span class="n">trans_mat</span><span class="p">,</span> <span class="n">wl_x_min_ref</span><span class="p">,</span> <span class="n">ok</span> <span class="o">=</span> <span class="p">(</span><span class="n">_square_sum</span><span class="p">(</span><span class="n">a13</span><span class="p">,</span> <span class="n">a21</span><span class="p">,</span> <span class="n">a22</span><span class="p">,</span> <span class="n">a33</span><span class="p">,</span>  
                                       <span class="n">xyz_ref_trunk</span><span class="p">,</span> <span class="n">x_ref_min</span><span class="p">,</span>
                                       <span class="n">L_wl_sum</span><span class="p">,</span> <span class="n">M_wl_sum</span><span class="p">,</span> <span class="n">S_wl_sum</span><span class="p">,</span> <span class="n">V_wl_sum</span><span class="p">,</span>
                                       <span class="n">L_wl_ref_min</span><span class="p">,</span> <span class="n">M_wl_ref_min</span><span class="p">,</span> <span class="n">S_wl_ref_min</span><span class="p">,</span> <span class="n">V_wl_ref_min</span><span class="p">,</span>
                                       <span class="n">LMS_390_830</span><span class="p">,</span> <span class="n">wl_390_830</span><span class="p">,</span> <span class="n">wl_x_min_ref</span><span class="p">,</span> <span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">:])</span>        

    <span class="c1"># Compute renormalized transformation matrix</span>
    <span class="n">wl_spec</span> <span class="o">=</span> <span class="n">LMS_spec</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
    <span class="p">(</span><span class="n">X_exact_spec</span><span class="p">,</span> <span class="n">Y_exact_spec</span><span class="p">,</span> <span class="n">Z_exact_spec</span><span class="p">)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">trans_mat</span><span class="p">,</span> <span class="n">LMS_spec</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:])</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">wl_spec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mf">390.</span> <span class="ow">and</span> <span class="n">wl_spec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mf">830.</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">my_round</span><span class="p">(</span><span class="n">wl_spec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">wl_spec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">)):</span>
        <span class="n">trans_mat_N</span> <span class="o">=</span> <span class="n">trans_mat</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="p">(</span><span class="n">X_exact_sum</span><span class="p">,</span> <span class="n">Y_exact_sum</span><span class="p">,</span> <span class="n">Z_exact_sum</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">X_exact_spec</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Y_exact_spec</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Z_exact_spec</span><span class="p">))</span>
        <span class="n">trans_mat_N</span> <span class="o">=</span> <span class="n">my_round</span><span class="p">(</span><span class="n">trans_mat</span> <span class="o">*</span> <span class="p">([</span><span class="n">Y_exact_sum</span> <span class="o">/</span> <span class="n">X_exact_sum</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">Y_exact_sum</span> <span class="o">/</span> <span class="n">Z_exact_sum</span><span class="p">]),</span> <span class="mi">8</span><span class="p">)</span> 
    
    <span class="c1"># Compute spectral tristimulus values (for table)</span>
    <span class="c1">### non-renormalized:</span>
    <span class="n">XYZ_spec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">wl_spec</span><span class="p">,</span><span class="n">sign_figs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">trans_mat</span><span class="p">,</span> <span class="n">LMS_spec</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]),</span><span class="mi">7</span><span class="p">)))</span>

    <span class="c1">### renormalized:</span>
    <span class="n">XYZ_spec_N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">wl_spec</span><span class="p">,</span><span class="n">sign_figs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">trans_mat_N</span><span class="p">,</span> <span class="n">LMS_spec</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]),</span><span class="mi">7</span><span class="p">)))</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">trans_mat</span><span class="p">,</span> <span class="n">XYZ_spec</span><span class="p">,</span> <span class="n">trans_mat_N</span><span class="p">,</span> <span class="n">XYZ_spec_N</span><span class="p">)</span>


<div class="viewcode-block" id="compute_cmfs">
<a class="viewcode-back" href="../../../../toolboxes.html#luxpy.toolboxes.indvcmf.compute_cmfs">[docs]</a>
<span class="k">def</span> <span class="nf">compute_cmfs</span><span class="p">(</span><span class="n">fieldsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">var_od_lens</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">var_od_macula</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
                 <span class="n">var_shft_LMS</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">var_od_LMS</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> 
                 <span class="n">norm_type</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;lms&#39;</span><span class="p">,</span> <span class="n">base</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                 <span class="n">strategy_2</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">odata0</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">lms_to_xyz_method</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">allow_negative_values</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">normalize_lms_to_xyz_matrix</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate Individual Observer CMFs (cone fundamentals) </span>
<span class="sd">    based on CIE2006 cone fundamentals and published literature </span>
<span class="sd">    on observer variability in color matching and in physiological parameters.</span>
<span class="sd">        </span>
<span class="sd">    Args:</span>
<span class="sd">        :age: </span>
<span class="sd">            | 32 or float or int, optional</span>
<span class="sd">            | Observer age</span>
<span class="sd">        :fieldsize:</span>
<span class="sd">            | 10, optional</span>
<span class="sd">            | Field size of stimulus in degrees (between 2° and 10°).</span>
<span class="sd">        :wl: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Interpolation/extraplation of :LMS: output to specified wavelengths.</span>
<span class="sd">            | None: output original _WL</span>
<span class="sd">        :var_od_lens:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | Variation of optical density of lens.</span>
<span class="sd">        :var_od_macula:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | Variation of optical density of macula.</span>
<span class="sd">        :var_shft_LMS:</span>
<span class="sd">            | [0, 0, 0] optional</span>
<span class="sd">            | Variation (shift) of LMS peak absorptance.</span>
<span class="sd">        :var_od_LMS:</span>
<span class="sd">            | [0, 0, 0] optional</span>
<span class="sd">            | Variation of LMS optical densities.</span>
<span class="sd">        :norm_type:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | - &#39;max&#39;: normalize LMSq functions to max = 1</span>
<span class="sd">            | - &#39;area&#39;: normalize to area</span>
<span class="sd">            | - &#39;power&#39;: normalize to power</span>
<span class="sd">        :out: </span>
<span class="sd">            | &#39;lms&#39; or &#39;xyz&#39;, optional</span>
<span class="sd">            | Determines output.</span>
<span class="sd">        :base:</span>
<span class="sd">            | False, boolean, optional</span>
<span class="sd">            | The returned energy-based LMS cone fundamentals given to the</span>
<span class="sd">            | precision of 9 sign. figs. if &#39;True&#39;, and to the precision of</span>
<span class="sd">            | 6 sign. figs. if &#39;False&#39;.</span>
<span class="sd">        :strategy_2: </span>
<span class="sd">            | True, bool, optional</span>
<span class="sd">            | Use strategy 2 in github.com/ifarup/ciefunctions issue #121 for </span>
<span class="sd">            | computing the weighting factor. If false, strategy 3 is applied.</span>
<span class="sd">        :odata0: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Dict with uncorrected ocular media and macula density functions and LMS absorptance functions</span>
<span class="sd">            | None defaults to the ones stored in _DATA</span>
<span class="sd">        :lms_to_xyz_method:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Method to use to determine lms-to-xyz conversion matrix (options: &#39;asano&#39;, &#39;cietc197&#39;)</span>
<span class="sd">        :allow_negative_values:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | Cone fundamentals or color matching functions should not have negative values.</span>
<span class="sd">            |     If False: X[X&lt;0] = 0.</span>
<span class="sd">        :normalize_lms_to_xyz_matrix:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | Normalize that EEW is always at [100,100,100] in XYZ and LMS system.</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | - &#39;LMS&#39; [or &#39;XYZ&#39;]: ndarray with individual observer equal area-normalized </span>
<span class="sd">            |           cone fundamentals. Wavelength have been added.</span>
<span class="sd">            |    </span>
<span class="sd">            | [- &#39;M&#39;: lms to xyz conversion matrix</span>
<span class="sd">            |  -  &#39;trans_lens&#39;: ndarray with lens transmission </span>
<span class="sd">            |      (no interpolation)</span>
<span class="sd">            |  - &#39;trans_macula&#39;: ndarray with macula transmission </span>
<span class="sd">            |      (no interpolation)</span>
<span class="sd">            |  - &#39;sens_photopig&#39; : ndarray with photopigment sens. </span>
<span class="sd">            |      (no interpolation)]</span>
<span class="sd">            </span>
<span class="sd">    References:</span>
<span class="sd">         1. `Asano Y, Fairchild MD, and Blondé L, (2016), </span>
<span class="sd">         Individual Colorimetric Observer Model. </span>
<span class="sd">         PLoS One 11, 1–19. </span>
<span class="sd">         &lt;http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0145671&gt;`_</span>
<span class="sd">        </span>
<span class="sd">         2. `Asano Y, Fairchild MD, Blondé L, and Morvan P (2016). </span>
<span class="sd">         Color matching experiment for highlighting interobserver variability. </span>
<span class="sd">         Color Res. Appl. 41, 530–539. </span>
<span class="sd">         &lt;https://onlinelibrary.wiley.com/doi/abs/10.1002/col.21975&gt;`_</span>
<span class="sd">         </span>
<span class="sd">         3. `CIE, TC1-36, (2006). </span>
<span class="sd">         Fundamental Chromaticity Diagram with Physiological Axes - Part I </span>
<span class="sd">         (Vienna: CIE). </span>
<span class="sd">         &lt;http://www.cie.co.at/publications/fundamental-chromaticity-diagram-physiological-axes-part-1&gt;`_ </span>
<span class="sd">         </span>
<span class="sd">         4. `Asano&#39;s Individual Colorimetric Observer Model </span>
<span class="sd">         &lt;https://www.rit.edu/cos/colorscience/re_AsanoObserverFunctions.php&gt;`_</span>
<span class="sd">         </span>
<span class="sd">         5. `CIE TC1-97 Python code for cone fundamentals and XYZ cmf calculations </span>
<span class="sd">         (by Ivar Farup and Jan Henrik Wold, (c) 2012-2017) </span>
<span class="sd">         &lt;http://github.com/ifarup/ciefunctions&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">interpolate</span> <span class="c1"># lazy import</span>
    
    <span class="c1"># TC1-97 ciefunctions rounds fieldsize:</span>
    <span class="n">fieldsize_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">fieldsize</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fieldsize_tmp</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">fieldsize_tmp</span> <span class="o">==</span> <span class="mi">10</span><span class="p">):</span>
        <span class="n">fieldsize</span> <span class="o">=</span> <span class="n">fieldsize_tmp</span>
    
    <span class="k">if</span> <span class="n">odata0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">odata</span> <span class="o">=</span> <span class="n">_DATA</span><span class="p">[</span><span class="s1">&#39;odata&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">odata</span> <span class="o">=</span> <span class="n">odata0</span>
    
    <span class="k">if</span> <span class="n">wl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">wl</span> <span class="o">=</span> <span class="n">odata</span><span class="p">[</span><span class="s1">&#39;wls&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">wl</span> <span class="o">=</span> <span class="n">getwlr</span><span class="p">(</span><span class="n">wl3</span> <span class="o">=</span> <span class="n">wl</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">lms_to_xyz_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lms_to_xyz_method</span> <span class="o">=</span> <span class="n">_LMS_TO_XYZ_METHOD</span>
    
    <span class="n">out_list</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
    
    <span class="c1"># =======================================================================</span>
    <span class="c1"># Create initial data arrays</span>
    <span class="c1"># =======================================================================</span>
    <span class="c1"># &#39;_base&#39; : 9 sign. figs.</span>
    <span class="c1"># &#39;_std&#39;  : standard number of sign. figs./decimal places</span>
    <span class="c1"># &#39;_all&#39;  : values given at 0.1 nm steps from 390 nm to 830 nm</span>
    <span class="c1"># &#39;_main&#39; : values given at 1 nm steps from 390 nm to 830 nm</span>
    <span class="c1"># &#39;_spec&#39; : values given at specified wavelengths</span>

    <span class="c1"># wavelength arrays:</span>
    <span class="n">wl_all</span> <span class="o">=</span> <span class="n">odata</span><span class="p">[</span><span class="s1">&#39;wls&#39;</span><span class="p">]</span><span class="c1">#my_round(np.arange(390., 830. + .01, .1), 1)</span>
    <span class="n">wl_spec</span> <span class="o">=</span> <span class="n">wl</span>

    <span class="c1"># LMS-base values (9 sign.figs.) at 0.1 nm steps from 390 nm to 830 nm;</span>
    <span class="c1"># wavelengths in first row.</span>
    <span class="n">LMS_base_all</span><span class="p">,</span> <span class="n">LMSq_</span><span class="p">,</span> <span class="n">LMSa_</span><span class="p">,</span> <span class="n">LMSe_o_max</span><span class="p">,</span> <span class="n">rmd</span><span class="p">,</span> <span class="n">docul</span> <span class="o">=</span> <span class="n">_LMS_energy</span><span class="p">(</span><span class="n">fieldsize</span> <span class="o">=</span> <span class="n">fieldsize</span><span class="p">,</span> <span class="n">age</span> <span class="o">=</span> <span class="n">age</span><span class="p">,</span>
                                                                      <span class="n">var_od_lens</span> <span class="o">=</span> <span class="n">var_od_lens</span><span class="p">,</span> <span class="n">var_od_mac</span> <span class="o">=</span> <span class="n">var_od_macula</span><span class="p">,</span>
                                                                      <span class="n">var_shft_LMS</span> <span class="o">=</span> <span class="n">var_shft_LMS</span><span class="p">,</span> <span class="n">var_od_LMS</span> <span class="o">=</span> <span class="n">var_od_LMS</span><span class="p">,</span> 
                                                                      <span class="n">norm_type</span> <span class="o">=</span> <span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;LMSe,LMSq,alpha_lms,LMSe_o_max,rmd,docul&#39;</span><span class="p">,</span>
                                                                      <span class="n">base</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">odata0</span> <span class="o">=</span> <span class="n">odata</span><span class="p">)</span> <span class="c1"># note: base only applies to LMSe !</span>

    <span class="c1"># Do sompe checks to save on calculation time (don&#39;t calculate anything not needed.):</span>
    <span class="n">wl_equal_to_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">my_round</span><span class="p">(</span><span class="n">wl_spec</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">my_round</span><span class="p">(</span><span class="n">LMS_base_all</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">wl_equal_to_all</span><span class="p">)</span> <span class="o">|</span> <span class="p">(((</span><span class="s1">&#39;xyz&#39;</span> <span class="ow">in</span> <span class="n">out_list</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="s1">&#39;XYZ&#39;</span> <span class="ow">in</span> <span class="n">out_list</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="s1">&#39;M&#39;</span> <span class="ow">in</span> <span class="n">out_list</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">lms_to_xyz_method</span> <span class="o">==</span> <span class="s1">&#39;cietc197&#39;</span><span class="p">)):</span>

        <span class="c1"># =======================================================================</span>
        <span class="c1"># Create LMS spline functions</span>
        <span class="c1"># =======================================================================</span>
        <span class="c1"># base:</span>
        <span class="p">(</span><span class="n">wl_all</span><span class="p">,</span> <span class="n">L_base_all</span><span class="p">,</span> <span class="n">M_base_all</span><span class="p">,</span> <span class="n">S_base_all</span><span class="p">)</span> <span class="o">=</span> <span class="n">LMS_base_all</span>
        <span class="n">L_base_spline</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">InterpolatedUnivariateSpline</span><span class="p">(</span><span class="n">wl_all</span><span class="p">,</span> <span class="n">L_base_all</span><span class="p">)</span>
        <span class="n">M_base_spline</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">InterpolatedUnivariateSpline</span><span class="p">(</span><span class="n">wl_all</span><span class="p">,</span> <span class="n">M_base_all</span><span class="p">)</span>
        <span class="n">S_base_spline</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">InterpolatedUnivariateSpline</span><span class="p">(</span><span class="n">wl_all</span><span class="p">,</span> <span class="n">S_base_all</span><span class="p">)</span>
            
        <span class="c1"># =======================================================================</span>
        <span class="c1"># Compute the LMS-base cone fundamentals </span>
        <span class="c1"># =======================================================================</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">wl_equal_to_all</span><span class="p">):</span>
            <span class="c1"># - LMS-base values (9 sign. figs) for specified wavelengths;</span>
            <span class="c1">#   wavelengths in first row.</span>
            <span class="n">LMS_base_spec</span> <span class="o">=</span> <span class="n">chop</span><span class="p">(</span><span class="n">_compute_LMS</span><span class="p">(</span><span class="n">wl_spec</span><span class="p">,</span> <span class="n">L_base_spline</span><span class="p">,</span> <span class="n">M_base_spline</span><span class="p">,</span> <span class="n">S_base_spline</span><span class="p">,</span> <span class="n">base</span> <span class="o">=</span> <span class="kc">True</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">LMS_base_spec</span> <span class="o">=</span> <span class="n">chop</span><span class="p">(</span><span class="n">LMS_base_all</span><span class="p">)</span>
        <span class="n">LMS</span> <span class="o">=</span> <span class="n">LMS_base_spec</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">LMS</span> <span class="o">=</span> <span class="n">chop</span><span class="p">(</span><span class="n">LMS_base_all</span><span class="p">)</span>
  
    <span class="c1"># =========================================================================</span>
    <span class="c1"># Compute the cone-fundamental-based XYZ tristimulus functions</span>
    <span class="c1"># =========================================================================</span>
    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;xyz&#39;</span> <span class="ow">in</span> <span class="n">out_list</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="s1">&#39;XYZ&#39;</span> <span class="ow">in</span> <span class="n">out_list</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="s1">&#39;M&#39;</span> <span class="ow">in</span> <span class="n">out_list</span><span class="p">):</span> 
        
        <span class="k">if</span> <span class="n">lms_to_xyz_method</span> <span class="o">==</span> <span class="s1">&#39;asano&#39;</span><span class="p">:</span>
            <span class="n">XYZ</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">lmsb_to_xyzb</span><span class="p">(</span><span class="n">LMS</span><span class="p">,</span> <span class="n">fieldsize</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;xyz,M&#39;</span><span class="p">,</span> <span class="n">allow_negative_values</span> <span class="o">=</span> <span class="n">allow_negative_values</span><span class="p">)</span>
                    
        <span class="k">elif</span> <span class="n">lms_to_xyz_method</span> <span class="o">==</span> <span class="s1">&#39;cietc197&#39;</span><span class="p">:</span>
        
            <span class="c1"># Vλ and weighting factors of the L and M cone fundamentals:</span>
        
            <span class="c1"># - Cone-fundamental-based V(λ) values (7 sign. figs.) at 0.1 nm steps</span>
            <span class="c1">#   from 390 nm to 830 nm; wavelengths in first column</span>
            <span class="c1"># - Weights of L and M cone fundamentals in V(λ) synthesis</span>
            <span class="c1"># Re-use already calculated LMSe, LMSq, ...</span>
            <span class="p">(</span><span class="n">V_std_all</span><span class="p">,</span> <span class="n">LM_weights</span><span class="p">)</span> <span class="o">=</span> <span class="n">_Vl_energy_and_LM_weights</span><span class="p">(</span><span class="n">fieldsize</span> <span class="o">=</span> <span class="n">fieldsize</span><span class="p">,</span> <span class="n">age</span> <span class="o">=</span> <span class="n">age</span><span class="p">,</span>
                                                                  <span class="n">strategy_2</span> <span class="o">=</span> <span class="n">strategy_2</span><span class="p">,</span>
                                                                  <span class="n">LMSa</span> <span class="o">=</span> <span class="n">LMSa_</span><span class="p">,</span> <span class="n">LMSq</span> <span class="o">=</span> <span class="n">LMSq_</span><span class="p">,</span> 
                                                                  <span class="n">LMSe</span> <span class="o">=</span> <span class="n">LMS_base_all</span><span class="p">,</span> <span class="n">LMSe_o_max</span> <span class="o">=</span> <span class="n">LMSe_o_max</span><span class="p">,</span>
                                                                  <span class="n">odata0</span> <span class="o">=</span> <span class="n">odata0</span><span class="p">)</span>

            <span class="c1"># Create spline function for Vlambda:</span>
            <span class="n">wl_all</span><span class="p">,</span> <span class="n">V_std_all</span> <span class="o">=</span> <span class="n">V_std_all</span>
            <span class="n">V_std_spline</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">InterpolatedUnivariateSpline</span><span class="p">(</span><span class="n">wl_all</span><span class="p">,</span> <span class="n">V_std_all</span><span class="p">)</span>
            
            <span class="c1">#  Determine reference diagram</span>
            <span class="n">xyz_reference</span> <span class="o">=</span> <span class="n">_xyz_interpolated_reference_system</span><span class="p">(</span><span class="n">fieldsize</span><span class="p">,</span> <span class="n">_CMF</span><span class="p">[</span><span class="s1">&#39;1931_2&#39;</span><span class="p">][</span><span class="s1">&#39;bar&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">_CMF</span><span class="p">[</span><span class="s1">&#39;1964_10&#39;</span><span class="p">][</span><span class="s1">&#39;bar&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

            <span class="c1"># - Non-renormalised tranformation matrix (8 decimal placed)</span>
            <span class="c1"># - Non-renormalised CIE cone-fundamental-based XYZ tristimulus</span>
            <span class="c1">#   values (7 sign. figs) for specified wavelengths; wavelengths in first row.</span>
            <span class="c1"># - Ditto renormalized</span>
            <span class="p">(</span><span class="n">trans_mat_std</span><span class="p">,</span> <span class="n">XYZ_std_spec</span><span class="p">,</span> <span class="n">trans_mat_std_N</span><span class="p">,</span> <span class="n">XYZ_std_spec_N</span><span class="p">)</span> <span class="o">=</span> <span class="n">_compute_XYZ</span><span class="p">(</span><span class="n">L_base_spline</span><span class="p">,</span> 
                                                                                         <span class="n">M_base_spline</span><span class="p">,</span>
                                                                                         <span class="n">S_base_spline</span><span class="p">,</span> 
                                                                                         <span class="n">V_std_spline</span><span class="p">,</span>
                                                                                         <span class="n">LMS_base_spec</span><span class="p">,</span> 
                                                                                         <span class="n">LMS_base_all</span><span class="p">,</span>
                                                                                         <span class="n">LM_weights</span><span class="p">,</span> 
                                                                                         <span class="n">xyz_reference</span><span class="p">)</span>
            
<span class="c1">#            M = trans_mat_std, # unnormalized xyzbar! (when specified wavelenght range = [390,830,1] then XYZ_spec == XYZ_spec_N!!)</span>
<span class="c1">#            XYZ = XYZ_std_spec</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">trans_mat_std_N</span> <span class="c1"># re-normalized xyzbar! (for specified wavelenght range)</span>
            <span class="n">XYZ</span> <span class="o">=</span> <span class="n">XYZ_std_spec_N</span>

    <span class="c1"># Output extra:</span>
    <span class="k">if</span> <span class="s1">&#39;trans_lens&#39;</span> <span class="ow">in</span> <span class="n">out_list</span><span class="p">:</span>
        <span class="n">trans_lens</span> <span class="o">=</span> <span class="n">docul</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">trans_lens</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">docul</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:])</span> 
    <span class="k">if</span> <span class="s1">&#39;trans_macula&#39;</span> <span class="ow">in</span> <span class="n">out_list</span><span class="p">:</span>
        <span class="n">trans_macula</span> <span class="o">=</span> <span class="n">rmd</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">trans_macula</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">rmd</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:])</span> 
    <span class="k">if</span> <span class="s1">&#39;sens_photopig&#39;</span> <span class="ow">in</span> <span class="n">out_list</span><span class="p">:</span>
        <span class="n">sens_photopig</span> <span class="o">=</span> <span class="n">LMSa_</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">sens_photopig</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span> <span class="o">=</span> <span class="n">LMSa_</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span> <span class="o">*</span> <span class="n">LMSa_</span><span class="p">[:</span><span class="mi">1</span><span class="p">,:]</span> 
    
    <span class="c1"># Change normalization of M to </span>
    <span class="c1"># ensure that EEW is always at [100,100,100] in XYZ system:</span>
    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;M&#39;</span> <span class="ow">in</span> <span class="n">out_list</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">normalize_lms_to_xyz_matrix</span> <span class="o">==</span> <span class="kc">True</span><span class="p">):</span>
        <span class="n">Mi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">M</span><span class="p">)</span> <span class="c1"># M: lms-&gt;xyz; Mi: xyz-&gt;lms</span>
        <span class="n">Min</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">normalize_3x3_matrix</span><span class="p">(</span><span class="n">Mi</span><span class="p">,</span> <span class="n">xyz0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]))</span> <span class="c1"># normalize Mi matrix</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">Min</span><span class="p">)</span> <span class="c1"># calculate new lms-&gt;xyz normalized matrix</span>
        <span class="n">LMS</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Min</span><span class="p">,</span><span class="n">XYZ</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:])</span> <span class="c1"># calculate lmsbar such that they match M!</span>
        
        
    <span class="k">if</span> <span class="p">((</span><span class="s1">&#39;xyz&#39;</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;lms&#39;</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">))):</span>
        <span class="c1"># Change normalization of LMS, XYZ:</span>
        <span class="k">if</span> <span class="n">norm_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">LMS</span> <span class="o">=</span> <span class="n">spd_normalize</span><span class="p">(</span><span class="n">LMS</span><span class="p">,</span> <span class="n">norm_type</span> <span class="o">=</span> <span class="n">norm_type</span><span class="p">)</span>
            <span class="n">XYZ</span> <span class="o">=</span> <span class="n">spd_normalize</span><span class="p">(</span><span class="n">XYZ</span><span class="p">,</span> <span class="n">norm_type</span> <span class="o">=</span> <span class="n">norm_type</span><span class="p">)</span>
 
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;xyz&#39;</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)):</span>
            <span class="n">LMS</span> <span class="o">=</span> <span class="n">XYZ</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;xyz&#39;</span><span class="p">,</span><span class="s1">&#39;LMS&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;XYZ&#39;</span><span class="p">,</span><span class="s1">&#39;LMS&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;lms&#39;</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;lms&#39;</span><span class="p">,</span><span class="s1">&#39;LMS&#39;</span><span class="p">)</span>

        <span class="c1"># Change normalization of LMS:</span>
        <span class="k">if</span> <span class="n">norm_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">LMS</span> <span class="o">=</span> <span class="n">spd_normalize</span><span class="p">(</span><span class="n">LMS</span><span class="p">,</span> <span class="n">norm_type</span> <span class="o">=</span> <span class="n">norm_type</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">base</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;lms&#39;</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)):</span>
            <span class="n">LMS</span> <span class="o">=</span> <span class="n">sign_figs</span><span class="p">(</span><span class="n">LMS</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="c1"># only LMS. XYZ is output at 7 sign. digit level in tc197 Python code</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;LMS&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;lms&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">LMS</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;XYZ&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;xyz&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">XYZ</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;LMS,M&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;lms,M&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">LMS</span><span class="p">,</span> <span class="n">M</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;XYZ,M&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;xyz,M&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">XYZ</span><span class="p">,</span> <span class="n">M</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;LMS,XYZ,M&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;lms,xyz,M&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">LMS</span><span class="p">,</span> <span class="n">XYZ</span><span class="p">,</span> <span class="n">M</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;M&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">M</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;LMS,trans_lens,trans_macula,sens_photopig&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">LMS</span><span class="p">,</span><span class="n">trans_lens</span><span class="p">,</span> <span class="n">trans_macula</span><span class="p">,</span> <span class="n">sens_photopig</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;LMS,trans_lens,trans_macula,sens_photopig,LMSa&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">LMS</span><span class="p">,</span> <span class="n">trans_lens</span><span class="p">,</span> <span class="n">trans_macula</span><span class="p">,</span> <span class="n">sens_photopig</span><span class="p">,</span> <span class="n">odata</span><span class="p">[</span><span class="s1">&#39;LMSa&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">eval</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="cie2006cmfsEx">
<a class="viewcode-back" href="../../../../toolboxes.html#luxpy.toolboxes.indvcmf.cie2006cmfsEx">[docs]</a>
<span class="k">def</span> <span class="nf">cie2006cmfsEx</span><span class="p">(</span><span class="n">age</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span><span class="n">fieldsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>\
                  <span class="n">var_od_lens</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">var_od_macula</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> \
                  <span class="n">var_od_L</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">var_od_M</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">var_od_S</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>\
                  <span class="n">var_shft_L</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">var_shft_M</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">var_shft_S</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>\
                  <span class="n">norm_type</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;lms&#39;</span><span class="p">,</span> <span class="n">base</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                  <span class="n">strategy_2</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">odata0</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">lms_to_xyz_method</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">allow_negative_values</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                  <span class="n">normalize_lms_to_xyz_matrix</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate Individual Observer CMFs (cone fundamentals) </span>
<span class="sd">    based on CIE2006 cone fundamentals and published literature </span>
<span class="sd">    on observer variability in color matching and in physiological parameters.</span>
<span class="sd">        </span>
<span class="sd">    Args:</span>
<span class="sd">        :age: </span>
<span class="sd">            | 32 or float or int, optional</span>
<span class="sd">            | Observer age</span>
<span class="sd">        :fieldsize:</span>
<span class="sd">            | 10, optional</span>
<span class="sd">            | Field size of stimulus in degrees (between 2° and 10°).</span>
<span class="sd">        :wl: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Interpolation/extraplation of :LMS: output to specified wavelengths.</span>
<span class="sd">            | None: output original _WL </span>
<span class="sd">        :var_od_lens:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | Std Dev. in peak optical density [%] of lens.</span>
<span class="sd">        :var_od_macula:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | Std Dev. in peak optical density [%] of macula.</span>
<span class="sd">        :var_od_L:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | Std Dev. in peak optical density [%] of L-cone.</span>
<span class="sd">        :var_od_M:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | Std Dev. in peak optical density [%] of M-cone.</span>
<span class="sd">        :var_od_S:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | Std Dev. in peak optical density [%] of S-cone.</span>
<span class="sd">        :var_shft_L:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | Std Dev. in peak wavelength shift [nm] of L-cone. </span>
<span class="sd">        :var_shft_L:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | Std Dev. in peak wavelength shift [nm] of M-cone.  </span>
<span class="sd">        :var_shft_S:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | Std Dev. in peak wavelength shift [nm] of S-cone. </span>
<span class="sd">        :norm_type:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | - &#39;max&#39;: normalize LMSq functions to max = 1</span>
<span class="sd">            | - &#39;area&#39;: normalize to area</span>
<span class="sd">            | - &#39;power&#39;: normalize to power</span>
<span class="sd">        :out: </span>
<span class="sd">            | &#39;lms&#39; or &#39;xyz&#39;, optional</span>
<span class="sd">            | Determines output.</span>
<span class="sd">        :base:</span>
<span class="sd">            | False, boolean, optional</span>
<span class="sd">            | The returned energy-based LMS cone fundamentals given to the</span>
<span class="sd">            | precision of 9 sign. figs. if &#39;True&#39;, and to the precision of</span>
<span class="sd">            | 6 sign. figs. if &#39;False&#39;.</span>
<span class="sd">        :strategy_2: </span>
<span class="sd">            | True, bool, optional</span>
<span class="sd">            | Use strategy 2 in github.com/ifarup/ciefunctions issue #121 for </span>
<span class="sd">            | computing the weighting factor. If false, strategy 3 is applied.</span>
<span class="sd">        :odata0: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Dict with uncorrected ocular media and macula density functions and LMS absorptance functions</span>
<span class="sd">            | None defaults to the ones stored in _DATA</span>
<span class="sd">        :lms_to_xyz_method:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Method to use to determine lms-to-xyz conversion matrix (options: &#39;asano&#39;, &#39;cietc197&#39;)</span>
<span class="sd">        :allow_negative_values:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | Cone fundamentals or color matching functions should not have negative values.</span>
<span class="sd">            |     If False: X[X&lt;0] = 0.</span>
<span class="sd">        :normalize_lms_to_xyz_matrix:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | Normalize that EEW is always at [100,100,100] in XYZ and LMS system.</span>

<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | - &#39;LMS&#39; [or &#39;XYZ&#39;]: ndarray with individual observer equal area-normalized </span>
<span class="sd">            |           cone fundamentals. Wavelength have been added.</span>
<span class="sd">            |   </span>
<span class="sd">            | [- &#39;M&#39;: lms to xyz conversion matrix</span>
<span class="sd">            |  -  &#39;trans_lens&#39;: ndarray with lens transmission </span>
<span class="sd">            |      (no interpolation)</span>
<span class="sd">            |  - &#39;trans_macula&#39;: ndarray with macula transmission </span>
<span class="sd">            |      (no interpolation)</span>
<span class="sd">            |  - &#39;sens_photopig&#39; : ndarray with photopigment sens. </span>
<span class="sd">            |      (no interpolation)]</span>
<span class="sd">            </span>
<span class="sd">    References:</span>
<span class="sd">         1. `Asano Y, Fairchild MD, and Blondé L, (2016), </span>
<span class="sd">         Individual Colorimetric Observer Model. </span>
<span class="sd">         PLoS One 11, 1–19. </span>
<span class="sd">         &lt;http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0145671&gt;`_</span>
<span class="sd">        </span>
<span class="sd">         2. `Asano Y, Fairchild MD, Blondé L, and Morvan P (2016). </span>
<span class="sd">         Color matching experiment for highlighting interobserver variability. </span>
<span class="sd">         Color Res. Appl. 41, 530–539. </span>
<span class="sd">         &lt;https://onlinelibrary.wiley.com/doi/abs/10.1002/col.21975&gt;`_</span>
<span class="sd">         </span>
<span class="sd">         3. `CIE TC1-36, (2006), </span>
<span class="sd">         Fundamental Chromaticity Diagram with Physiological Axes - Part I </span>
<span class="sd">         (Vienna: CIE). </span>
<span class="sd">         &lt;http://www.cie.co.at/publications/fundamental-chromaticity-diagram-physiological-axes-part-1&gt;`_ </span>
<span class="sd">         </span>
<span class="sd">         4. `Asano&#39;s Individual Colorimetric Observer Model </span>
<span class="sd">         &lt;https://www.rit.edu/cos/colorscience/re_AsanoObserverFunctions.php&gt;`_</span>
<span class="sd">         </span>
<span class="sd">         5. `CIE TC1-97 Python code for cone fundamentals and XYZ cmf calculations </span>
<span class="sd">         (by Ivar Farup and Jan Henrik Wold, (c) 2012-2017) </span>
<span class="sd">         &lt;http://github.com/ifarup/ciefunctions&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">compute_cmfs</span><span class="p">(</span><span class="n">fieldsize</span> <span class="o">=</span> <span class="n">fieldsize</span><span class="p">,</span> <span class="n">age</span> <span class="o">=</span> <span class="n">age</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span>
                        <span class="n">var_od_lens</span> <span class="o">=</span> <span class="n">var_od_lens</span><span class="p">,</span> <span class="n">var_od_macula</span> <span class="o">=</span> <span class="n">var_od_macula</span><span class="p">,</span>
                        <span class="n">var_shft_LMS</span> <span class="o">=</span> <span class="p">[</span><span class="n">var_shft_L</span><span class="p">,</span> <span class="n">var_shft_M</span><span class="p">,</span> <span class="n">var_shft_S</span><span class="p">],</span>
                        <span class="n">var_od_LMS</span> <span class="o">=</span> <span class="p">[</span><span class="n">var_od_L</span><span class="p">,</span> <span class="n">var_od_M</span><span class="p">,</span> <span class="n">var_od_S</span><span class="p">],</span> 
                        <span class="n">norm_type</span> <span class="o">=</span> <span class="n">norm_type</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">,</span>
                        <span class="n">base</span> <span class="o">=</span> <span class="n">base</span><span class="p">,</span> <span class="n">strategy_2</span> <span class="o">=</span> <span class="n">strategy_2</span><span class="p">,</span> <span class="n">odata0</span> <span class="o">=</span> <span class="n">odata0</span><span class="p">,</span>
                        <span class="n">lms_to_xyz_method</span> <span class="o">=</span> <span class="n">lms_to_xyz_method</span><span class="p">,</span> 
                        <span class="n">allow_negative_values</span> <span class="o">=</span> <span class="n">allow_negative_values</span><span class="p">,</span>
                        <span class="n">normalize_lms_to_xyz_matrix</span> <span class="o">=</span> <span class="n">normalize_lms_to_xyz_matrix</span><span class="p">)</span></div>



<div class="viewcode-block" id="getMonteCarloParam">
<a class="viewcode-back" href="../../../../toolboxes.html#luxpy.toolboxes.indvcmf.getMonteCarloParam">[docs]</a>
<span class="k">def</span> <span class="nf">getMonteCarloParam</span><span class="p">(</span><span class="n">n_obs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">stdDevAllParam</span> <span class="o">=</span> <span class="n">_DATA</span><span class="p">[</span><span class="s1">&#39;stdev&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get dict with normally-distributed physiological factors </span>
<span class="sd">    for a population of observers.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :n_obs: </span>
<span class="sd">            | 1, optional</span>
<span class="sd">            | Number of individual observers in population.</span>
<span class="sd">        :stdDevAllParam:</span>
<span class="sd">            | _DATA[&#39;stdev&#39;], optional</span>
<span class="sd">            | Dict with parameters for:</span>
<span class="sd">            |     [&#39;od_lens&#39;, &#39;od_macula&#39;, </span>
<span class="sd">            |      &#39;od_L&#39;, &#39;od_M&#39;, &#39;od_S&#39;, </span>
<span class="sd">            |      &#39;shft_L&#39;, &#39;shft_M&#39;, &#39;shft_S&#39;]</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | dict with n_obs randomly drawn parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">varParam</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">stdDevAllParam</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="s1">&#39;dsrc&#39;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
        <span class="n">varParam</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">stdDevAllParam</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n_obs</span><span class="p">)</span>
  
        <span class="c1"># limit varAllParam so that it doesn&#39;t create negative val for </span>
        <span class="c1"># lens, macula, pkod_LMS:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;od_lens&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;od_macula&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;od_L&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;od_M&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;od_S&#39;</span><span class="p">):</span>
            <span class="n">varParam</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">varParam</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">100</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">100</span>
        
    <span class="k">return</span> <span class="n">varParam</span>  </div>

  
<span class="k">def</span> <span class="nf">getUSCensusAgeDist</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get US Census Age Distribution</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t_num</span> <span class="o">=</span> <span class="n">_DATA</span><span class="p">[</span><span class="s1">&#39;USCensus2010population&#39;</span><span class="p">]</span> 
    
    <span class="n">list_AgeCensus</span> <span class="o">=</span> <span class="n">t_num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
    <span class="n">freq_AgeCensus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">t_num</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span> <span class="c1"># Reduce # of populations to manageable number, this doesn&#39;t change probability</span>
    
    <span class="c1"># Remove age &lt; 10 and 70 &lt; age:</span>
    <span class="n">freq_AgeCensus</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">freq_AgeCensus</span><span class="p">[</span><span class="mi">71</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
      
    <span class="n">list_Age</span> <span class="o">=</span> <span class="p">[]</span> 
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">list_AgeCensus</span><span class="p">)):</span>
        <span class="n">list_Age</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">list_Age</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">list_AgeCensus</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">freq_AgeCensus</span><span class="p">[</span><span class="n">k</span><span class="p">])))</span> 

    <span class="k">return</span> <span class="n">list_Age</span>    

<div class="viewcode-block" id="genMonteCarloObs">
<a class="viewcode-back" href="../../../../toolboxes.html#luxpy.toolboxes.indvcmf.genMonteCarloObs">[docs]</a>
<span class="k">def</span> <span class="nf">genMonteCarloObs</span><span class="p">(</span><span class="n">n_obs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fieldsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">list_Age</span> <span class="o">=</span> <span class="p">[</span><span class="mi">32</span><span class="p">],</span> <span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                     <span class="n">norm_type</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;lms&#39;</span><span class="p">,</span> <span class="n">base</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                     <span class="n">strategy_2</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">odata0</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">lms_to_xyz_method</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">allow_negative_values</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Monte-Carlo generation of individual observer cone fundamentals.</span>
<span class="sd">    </span>
<span class="sd">    Args: </span>
<span class="sd">        :n_obs: </span>
<span class="sd">            | 1, optional</span>
<span class="sd">            | Number of observer CMFs to generate.</span>
<span class="sd">        :list_Age:</span>
<span class="sd">            | list of observer ages or str, optional</span>
<span class="sd">            | Defaults to 32 (cfr. CIE2006 CMFs)</span>
<span class="sd">            | If &#39;us_census&#39;: use US population census of 2010 </span>
<span class="sd">            | to generate list_Age.</span>
<span class="sd">        :fieldsize: </span>
<span class="sd">            | fieldsize in degrees (between 2° and 10°), optional</span>
<span class="sd">            | Defaults to 10°.</span>
<span class="sd">        :wl: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Interpolation/extraplation of :LMS: output to specified wavelengths.</span>
<span class="sd">            | None: output original _WL </span>
<span class="sd">        :norm_type:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | - &#39;max&#39;: normalize LMSq functions to max = 1</span>
<span class="sd">            | - &#39;area&#39;: normalize to area</span>
<span class="sd">            | - &#39;power&#39;: normalize to power</span>
<span class="sd">        :out: </span>
<span class="sd">            | &#39;lms&#39; or &#39;xyz&#39;, optional</span>
<span class="sd">            | Determines output.</span>
<span class="sd">        :base:</span>
<span class="sd">            | False, boolean, optional</span>
<span class="sd">            | The returned energy-based LMS cone fundamentals given to the</span>
<span class="sd">            | precision of 9 sign. figs. if &#39;True&#39;, and to the precision of</span>
<span class="sd">            | 6 sign. figs. if &#39;False&#39;.</span>
<span class="sd">        :strategy_2: </span>
<span class="sd">            | True, bool, optional</span>
<span class="sd">            | Use strategy 2 in github.com/ifarup/ciefunctions issue #121 for </span>
<span class="sd">            | computing the weighting factor. If false, strategy 3 is applied.</span>
<span class="sd">        :odata0: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Dict with uncorrected ocular media and macula density functions and LMS absorptance functions</span>
<span class="sd">            | None defaults to the ones stored in _DATA</span>
<span class="sd">        :lms_to_xyz_method:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Method to use to determine lms-to-xyz conversion matrix (options: &#39;asano&#39;, &#39;cietc197&#39;)</span>
<span class="sd">        :allow_negative_values:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | Cone fundamentals or color matching functions should not have negative values.</span>
<span class="sd">            |     If False: X[X&lt;0] = 0.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | LMS [,var_age, vAll] </span>
<span class="sd">            |   - LMS: ndarray with population LMS functions.</span>
<span class="sd">            |   - var_age: ndarray with population observer ages.</span>
<span class="sd">            |   - vAll: dict with population physiological factors (see .keys()) </span>
<span class="sd">            </span>
<span class="sd">    References:</span>
<span class="sd">         1. `Asano Y., Fairchild M.D., and Blondé L., (2016), </span>
<span class="sd">         Individual Colorimetric Observer Model. </span>
<span class="sd">         PLoS One 11, 1–19. </span>
<span class="sd">         &lt;http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0145671&gt;`_</span>
<span class="sd">         </span>
<span class="sd">         2. `Asano Y, Fairchild MD, Blondé L, and Morvan P (2016). </span>
<span class="sd">         Color matching experiment for highlighting interobserver variability. </span>
<span class="sd">         Color Res. Appl. 41, 530–539. </span>
<span class="sd">         &lt;https://onlinelibrary.wiley.com/doi/abs/10.1002/col.21975&gt;`_</span>
<span class="sd">         </span>
<span class="sd">         3. `CIE TC1-36, (2006), </span>
<span class="sd">         Fundamental Chromaticity Diagram with Physiological Axes - Part I. </span>
<span class="sd">         (Vienna: CIE). </span>
<span class="sd">         &lt;http://www.cie.co.at/publications/fundamental-chromaticity-diagram-physiological-axes-part-1&gt;`_ </span>
<span class="sd">         </span>
<span class="sd">         4. `Asano&#39;s Individual Colorimetric Observer Model </span>
<span class="sd">         &lt;https://www.rit.edu/cos/colorscience/re_AsanoObserverFunctions.php&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get Normally-distributed Physiological Factors:</span>
    <span class="n">vAll</span> <span class="o">=</span> <span class="n">getMonteCarloParam</span><span class="p">(</span><span class="n">n_obs</span> <span class="o">=</span> <span class="n">n_obs</span><span class="p">)</span> 
     
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">list_Age</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span> 
        <span class="k">if</span> <span class="n">list_Age</span> <span class="o">==</span> <span class="s1">&#39;us_census&#39;</span><span class="p">:</span>
            <span class="n">list_Age</span> <span class="o">=</span> <span class="n">getUSCensusAgeDist</span><span class="p">()</span>
    
    <span class="c1"># Generate Random Ages with the same probability density distribution </span>
    <span class="c1"># as color matching experiment:</span>
    <span class="n">sz_interval</span> <span class="o">=</span> <span class="mi">1</span> 
    <span class="n">list_AgeRound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">list_Age</span><span class="p">)</span><span class="o">/</span><span class="n">sz_interval</span> <span class="p">)</span> <span class="o">*</span> <span class="n">sz_interval</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">list_AgeRound</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">list_AgeRound</span><span class="p">),</span> <span class="n">bin_center</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">h</span><span class="o">/</span><span class="n">h</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="c1"># probability density distribution</span>

    <span class="n">var_age</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">list_AgeRound</span><span class="p">),</span> \
                               <span class="n">size</span> <span class="o">=</span> <span class="n">n_obs</span><span class="p">,</span> <span class="n">replace</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>\
                               <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">odata0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">odata</span> <span class="o">=</span> <span class="n">_DATA</span><span class="p">[</span><span class="s1">&#39;odata&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">odata</span> <span class="o">=</span> <span class="n">odata0</span>
    
    <span class="c1"># Set requested wavelength range:</span>
    <span class="k">if</span> <span class="n">wl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">wl</span> <span class="o">=</span> <span class="n">odata</span><span class="p">[</span><span class="s1">&#39;wls&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">wl</span> <span class="o">=</span> <span class="n">getwlr</span><span class="p">(</span><span class="n">wl3</span> <span class="o">=</span> <span class="n">wl</span><span class="p">)</span>
     
    <span class="k">if</span> <span class="s1">&#39;lms&#39;</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">):</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="s1">&#39;lms&#39;</span>
    <span class="k">elif</span> <span class="s1">&#39;xyz&#39;</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">):</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="s1">&#39;xyz&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Must request either &#39;lms&#39; or &#39;xyz&#39; in :out:.&quot;</span><span class="p">)</span>
        
    <span class="n">LMS_All</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">wl</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">n_obs</span><span class="p">));</span> <span class="n">LMS_All</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;M&#39;</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">):</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">out_</span><span class="o">+</span><span class="s1">&#39;,M&#39;</span>
        <span class="n">M_All</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span><span class="n">n_obs</span><span class="p">));</span> <span class="n">M_All</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_obs</span><span class="p">):</span>
        <span class="n">returned</span> <span class="o">=</span> <span class="n">cie2006cmfsEx</span><span class="p">(</span><span class="n">age</span> <span class="o">=</span> <span class="n">var_age</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">fieldsize</span> <span class="o">=</span> <span class="n">fieldsize</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span>\
                                <span class="n">var_od_lens</span> <span class="o">=</span> <span class="n">vAll</span><span class="p">[</span><span class="s1">&#39;od_lens&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">],</span> <span class="n">var_od_macula</span> <span class="o">=</span> <span class="n">vAll</span><span class="p">[</span><span class="s1">&#39;od_macula&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">],</span> \
                                <span class="n">var_od_L</span> <span class="o">=</span> <span class="n">vAll</span><span class="p">[</span><span class="s1">&#39;od_L&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">],</span> <span class="n">var_od_M</span> <span class="o">=</span> <span class="n">vAll</span><span class="p">[</span><span class="s1">&#39;od_M&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">],</span> <span class="n">var_od_S</span> <span class="o">=</span> <span class="n">vAll</span><span class="p">[</span><span class="s1">&#39;od_S&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">],</span>\
                                <span class="n">var_shft_L</span> <span class="o">=</span> <span class="n">vAll</span><span class="p">[</span><span class="s1">&#39;shft_L&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">],</span> <span class="n">var_shft_M</span> <span class="o">=</span> <span class="n">vAll</span><span class="p">[</span><span class="s1">&#39;shft_M&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">],</span> <span class="n">var_shft_S</span> <span class="o">=</span> <span class="n">vAll</span><span class="p">[</span><span class="s1">&#39;shft_S&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">],</span>\
                                <span class="n">out</span> <span class="o">=</span> <span class="n">out_</span><span class="o">+</span><span class="s1">&#39;,trans_lens,trans_macula,sens_photopig&#39;</span><span class="p">,</span>
                                <span class="n">norm_type</span> <span class="o">=</span> <span class="n">norm_type</span><span class="p">,</span>  <span class="n">base</span> <span class="o">=</span> <span class="n">base</span><span class="p">,</span> \
                                <span class="n">strategy_2</span> <span class="o">=</span> <span class="n">strategy_2</span><span class="p">,</span> <span class="n">odata0</span> <span class="o">=</span> <span class="n">odata</span><span class="p">,</span>\
                                <span class="n">lms_to_xyz_method</span> <span class="o">=</span> <span class="n">lms_to_xyz_method</span><span class="p">,</span> <span class="n">allow_negative_values</span> <span class="o">=</span> <span class="n">allow_negative_values</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;M&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">):</span>
            <span class="n">t_LMS</span><span class="p">,</span> <span class="n">t_trans_lens</span><span class="p">,</span> <span class="n">t_trans_macula</span><span class="p">,</span> <span class="n">t_sens_photopig</span> <span class="o">=</span> <span class="n">returned</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t_LMS</span><span class="p">,</span> <span class="n">t_M</span><span class="p">,</span> <span class="n">t_trans_lens</span><span class="p">,</span> <span class="n">t_trans_macula</span><span class="p">,</span> <span class="n">t_sens_photopig</span> <span class="o">=</span> <span class="n">returned</span>
            <span class="n">M_All</span><span class="p">[:,:,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_M</span>
        <span class="n">LMS_All</span><span class="p">[:,:,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_LMS</span>
        
    <span class="k">if</span> <span class="n">n_obs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">LMS_All</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">LMS_All</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;M&#39;</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">):</span> 
            <span class="n">M_All</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">M_All</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;xyz&#39;</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;xyz&#39;</span><span class="p">,</span><span class="s1">&#39;LMS&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;XYZ&#39;</span><span class="p">,</span><span class="s1">&#39;LMS&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;lms&#39;</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;lms&#39;</span><span class="p">,</span><span class="s1">&#39;LMS&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;LMS&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">LMS_All</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;LMS,M&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">LMS_All</span><span class="p">,</span><span class="n">M_All</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;LMS,var_age,vAll&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">LMS_All</span><span class="p">,</span> <span class="n">var_age</span><span class="p">,</span> <span class="n">vAll</span> 
    <span class="k">elif</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;LMS,M,var_age,vAll&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">LMS_All</span><span class="p">,</span> <span class="n">M_All</span><span class="p">,</span> <span class="n">var_age</span><span class="p">,</span> <span class="n">vAll</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">eval</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>


        
<div class="viewcode-block" id="getCatObs">
<a class="viewcode-back" href="../../../../toolboxes.html#luxpy.toolboxes.indvcmf.getCatObs">[docs]</a>
<span class="k">def</span> <span class="nf">getCatObs</span><span class="p">(</span><span class="n">n_cat</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">fieldsize</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>  <span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
             <span class="n">norm_type</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;lms&#39;</span><span class="p">,</span> <span class="n">base</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
             <span class="n">strategy_2</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">odata0</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="n">lms_to_xyz_method</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">allow_negative_values</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate cone fundamentals for categorical observers.</span>
<span class="sd">    </span>
<span class="sd">    Args: </span>
<span class="sd">        :n_cat: </span>
<span class="sd">            | 10, optional</span>
<span class="sd">            | Number of observer CMFs to generate.</span>
<span class="sd">        :fieldsize:</span>
<span class="sd">            | fieldsize in degrees (between 2° and 10°), optional</span>
<span class="sd">            | Defaults to 10°.</span>
<span class="sd">        :out: </span>
<span class="sd">            | &#39;LMS&#39; or str, optional</span>
<span class="sd">            | Determines output.</span>
<span class="sd">        :wl: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Interpolation/extraplation of :LMS: output to specified wavelengths.</span>
<span class="sd">            |  None: output original _WL </span>
<span class="sd">        :norm_type:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | - &#39;max&#39;: normalize LMSq functions to max = 1</span>
<span class="sd">            | - &#39;area&#39;: normalize to area</span>
<span class="sd">            | - &#39;power&#39;: normalize to power</span>
<span class="sd">        :out: </span>
<span class="sd">            | &#39;lms&#39; or &#39;xyz&#39;, optional</span>
<span class="sd">            | Determines output.</span>
<span class="sd">        :base:</span>
<span class="sd">            | False, boolean, optional</span>
<span class="sd">            | The returned energy-based LMS cone fundamentals given to the</span>
<span class="sd">            | precision of 9 sign. figs. if &#39;True&#39;, and to the precision of</span>
<span class="sd">            | 6 sign. figs. if &#39;False&#39;.</span>
<span class="sd">        :strategy_2: </span>
<span class="sd">            | True, bool, optional</span>
<span class="sd">            | Use strategy 2 in github.com/ifarup/ciefunctions issue #121 for </span>
<span class="sd">            | computing the weighting factor. If false, strategy 3 is applied.</span>
<span class="sd">        :odata0: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Dict with uncorrected ocular media and macula density functions and LMS absorptance functions</span>
<span class="sd">            | None defaults to the ones stored in _DATA</span>
<span class="sd">        :lms_to_xyz_method:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Method to use to determine lms-to-xyz conversion matrix (options: &#39;asano&#39;, &#39;cietc197&#39;)</span>
<span class="sd">        :allow_negative_values:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | Cone fundamentals or color matching functions should not have negative values.</span>
<span class="sd">            |     If False: X[X&lt;0] = 0.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | LMS [,var_age, vAll] </span>
<span class="sd">            |   - LMS: ndarray with population LMS functions.</span>
<span class="sd">            |   - var_age: ndarray with population observer ages.</span>
<span class="sd">            |   - vAll: dict with population physiological factors (see .keys()) </span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        1. Categorical observers are observer functions that would represent </span>
<span class="sd">        color-normal populations. They are finite and discrete as opposed to </span>
<span class="sd">        observer functions generated from the individual colorimetric observer </span>
<span class="sd">        model. Thus, they would offer more convenient and practical approaches</span>
<span class="sd">        for the personalized color imaging workflow and color matching analyses.</span>
<span class="sd">        Categorical observers were derived in two steps. </span>
<span class="sd">        At the first step, 10000 observer functions were generated from the </span>
<span class="sd">        individual colorimetric observer model using Monte Carlo simulation. </span>
<span class="sd">        At the second step, the cluster analysis, a modified k-medoids </span>
<span class="sd">        algorithm, was applied to the 10000 observers minimizing the squared </span>
<span class="sd">        Euclidean distance in cone fundamentals space, and categorical </span>
<span class="sd">        observers were derived iteratively. Since the proposed categorical </span>
<span class="sd">        observers are defined by their physiological parameters and ages, their</span>
<span class="sd">        CMFs can be derived for any target field size.</span>
<span class="sd">        2. Categorical observers were ordered by the importance; </span>
<span class="sd">        the first categorical observer vas the average observer equivalent to </span>
<span class="sd">        CIEPO06 with 38 year-old for a given field size, followed by the second</span>
<span class="sd">        most important categorical observer, the third, and so on.</span>
<span class="sd">        </span>
<span class="sd">        3. see: https://www.rit.edu/cos/colorscience/re_AsanoObserverFunctions.php</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Use Iteratively Derived Cat.Obs.:</span>
    <span class="n">var_age</span> <span class="o">=</span> <span class="n">_DATA</span><span class="p">[</span><span class="s1">&#39;CatObsPfctr&#39;</span><span class="p">][</span><span class="s1">&#39;age&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">vAll</span> <span class="o">=</span> <span class="n">_DATA</span><span class="p">[</span><span class="s1">&#39;CatObsPfctr&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">vAll</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;age&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">odata0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">odata</span> <span class="o">=</span> <span class="n">_DATA</span><span class="p">[</span><span class="s1">&#39;odata&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">odata</span> <span class="o">=</span> <span class="n">odata0</span>
    
    <span class="c1"># Set requested wavelength range:</span>
    <span class="k">if</span> <span class="n">wl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">wl</span> <span class="o">=</span> <span class="n">odata</span><span class="p">[</span><span class="s1">&#39;wls&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">wl</span> <span class="o">=</span> <span class="n">getwlr</span><span class="p">(</span><span class="n">wl3</span> <span class="o">=</span> <span class="n">wl</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;lms&#39;</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">):</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="s1">&#39;lms&#39;</span>
    <span class="k">elif</span> <span class="s1">&#39;xyz&#39;</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">):</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="s1">&#39;xyz&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Must request either &#39;lms&#39; or &#39;xyz&#39; in :out:.&quot;</span><span class="p">)</span>

    <span class="n">LMS_All</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">wl</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">n_cat</span><span class="p">));</span> <span class="n">LMS_All</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;M&#39;</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">):</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">out_</span><span class="o">+</span><span class="s1">&#39;,M&#39;</span>
        <span class="n">M_All</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span><span class="n">n_cat</span><span class="p">));</span> <span class="n">M_All</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_cat</span><span class="p">):</span>
        <span class="n">returned</span> <span class="o">=</span> <span class="n">cie2006cmfsEx</span><span class="p">(</span><span class="n">age</span> <span class="o">=</span> <span class="n">var_age</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">fieldsize</span> <span class="o">=</span> <span class="n">fieldsize</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span>\
                              <span class="n">var_od_lens</span> <span class="o">=</span> <span class="n">vAll</span><span class="p">[</span><span class="s1">&#39;od_lens&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">],</span>\
                              <span class="n">var_od_macula</span> <span class="o">=</span> <span class="n">vAll</span><span class="p">[</span><span class="s1">&#39;od_macula&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">],</span>\
                              <span class="n">var_od_L</span> <span class="o">=</span> <span class="n">vAll</span><span class="p">[</span><span class="s1">&#39;od_L&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">],</span>\
                              <span class="n">var_od_M</span> <span class="o">=</span> <span class="n">vAll</span><span class="p">[</span><span class="s1">&#39;od_M&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">],</span>\
                              <span class="n">var_od_S</span> <span class="o">=</span> <span class="n">vAll</span><span class="p">[</span><span class="s1">&#39;od_S&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">],</span>\
                              <span class="n">var_shft_L</span> <span class="o">=</span> <span class="n">vAll</span><span class="p">[</span><span class="s1">&#39;shft_L&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">],</span>\
                              <span class="n">var_shft_M</span> <span class="o">=</span> <span class="n">vAll</span><span class="p">[</span><span class="s1">&#39;shft_M&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">],</span>\
                              <span class="n">var_shft_S</span> <span class="o">=</span> <span class="n">vAll</span><span class="p">[</span><span class="s1">&#39;shft_S&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">],</span>\
                              <span class="n">out</span> <span class="o">=</span> <span class="n">out_</span><span class="p">,</span>\
                              <span class="n">norm_type</span> <span class="o">=</span> <span class="n">norm_type</span><span class="p">,</span>  <span class="n">base</span> <span class="o">=</span> <span class="n">base</span><span class="p">,</span> \
                              <span class="n">strategy_2</span> <span class="o">=</span> <span class="n">strategy_2</span><span class="p">,</span> <span class="n">odata0</span> <span class="o">=</span> <span class="n">odata</span><span class="p">,</span>\
                              <span class="n">lms_to_xyz_method</span> <span class="o">=</span> <span class="n">lms_to_xyz_method</span><span class="p">,</span> \
                              <span class="n">allow_negative_values</span> <span class="o">=</span> <span class="n">allow_negative_values</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;M&#39;</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">):</span>
            <span class="n">t_LMS</span><span class="p">,</span> <span class="n">t_M</span> <span class="o">=</span> <span class="n">returned</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t_LMS</span> <span class="o">=</span> <span class="n">returned</span>
        <span class="n">LMS_All</span><span class="p">[:,:,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_LMS</span> 
    
    <span class="n">LMS_All</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">LMS_All</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">if</span> <span class="n">n_cat</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">LMS_All</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">LMS_All</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;xyz&#39;</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;xyz&#39;</span><span class="p">,</span><span class="s1">&#39;LMS&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;XYZ&#39;</span><span class="p">,</span><span class="s1">&#39;LMS&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;lms&#39;</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;lms&#39;</span><span class="p">,</span><span class="s1">&#39;LMS&#39;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;LMS&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">LMS_All</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;LMS,M&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">LMS_All</span><span class="p">,</span><span class="n">M_All</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;LMS,var_age,vAll&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">LMS_All</span><span class="p">,</span><span class="n">var_age</span><span class="p">,</span><span class="n">vAll</span> 
    <span class="k">elif</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;LMS,M,var_age,vAll&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">LMS_All</span><span class="p">,</span><span class="n">M_All</span><span class="p">,</span><span class="n">var_age</span><span class="p">,</span><span class="n">vAll</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">eval</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">get_lms_to_xyz_matrix</span><span class="p">(</span><span class="n">fieldsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the lms to xyz conversion matrix for specific fieldsize using Asano&#39;s method </span>
<span class="sd">    (i.e. use as a weighted combination of the 2° and 10° matrices).</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :fieldsize: </span>
<span class="sd">            | fieldsize in degrees (between 2° and 10°), optional</span>
<span class="sd">            | Defaults to 10°.</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :M: </span>
<span class="sd">            | ndarray with conversion matrix.</span>
<span class="sd">    </span>
<span class="sd">    Note: </span>
<span class="sd">        For intermediate field sizes (2°&lt;fieldsize&lt;10°) the conversion matrix </span>
<span class="sd">        is calculated by linear interpolation between </span>
<span class="sd">        the _DATA[&#39;M&#39;][&#39;2d&#39;] and _DATA[&#39;M&#39;][&#39;10d&#39;]matrices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fieldsize</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">fieldsize</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="n">fieldsize</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
        <span class="n">fieldsize</span> <span class="o">=</span> <span class="mi">10</span> 
    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="o">-</span><span class="n">fieldsize</span><span class="p">)</span><span class="o">/</span><span class="mi">8</span>     
    <span class="n">M</span> <span class="o">=</span> <span class="n">_DATA</span><span class="p">[</span><span class="s1">&#39;M&#39;</span><span class="p">][</span><span class="s1">&#39;2d&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="n">_DATA</span><span class="p">[</span><span class="s1">&#39;M&#39;</span><span class="p">][</span><span class="s1">&#39;10d&#39;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">M</span>

<span class="k">def</span> <span class="nf">lmsb_to_xyzb</span><span class="p">(</span><span class="n">lms</span><span class="p">,</span> <span class="n">fieldsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;xyz&#39;</span><span class="p">,</span> <span class="n">allow_negative_values</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert from LMS cone fundamentals to XYZ color matching functions using Asano&#39;s method</span>
<span class="sd">    (use conversion matrix determined as a determined a weighted combination of the 2° and 10° matrices).</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :lms: </span>
<span class="sd">            | ndarray with lms cone fundamentals, optional</span>
<span class="sd">        :fieldsize: </span>
<span class="sd">            | fieldsize in degrees, optional</span>
<span class="sd">            | Defaults to 10°.</span>
<span class="sd">        :out: </span>
<span class="sd">            | &#39;xyz&#39; or str, optional</span>
<span class="sd">            | Determines output.</span>
<span class="sd">        :allow_negative_values:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | XYZ color matching functions should not have negative values.</span>
<span class="sd">            |     If False: xyz[xyz&lt;0] = 0.</span>
<span class="sd">        :method:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | None defaults to _LMS_TO_XYZ_METHOD</span>
<span class="sd">            | Options: &#39;asano&#39; (see note below), &#39;cietc197&#39;</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | LMS </span>
<span class="sd">            |   - LMS: ndarray with population XYZ color matching functions.    </span>
<span class="sd">    </span>
<span class="sd">    Note: </span>
<span class="sd">        If method == &#39;asano&#39;: For intermediate field sizes (2°&lt;fieldsize&lt;10°) </span>
<span class="sd">        the conversion matrix is calculated by linear interpolation between </span>
<span class="sd">        the _DATA[&#39;M&#39;][&#39;2d&#39;] and _DATA[&#39;M&#39;][&#39;10d&#39;]matrices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wl</span> <span class="o">=</span> <span class="n">lms</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#store wavelengths</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">get_lms_to_xyz_matrix</span><span class="p">(</span><span class="n">fieldsize</span> <span class="o">=</span> <span class="n">fieldsize</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">lms</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">wl</span><span class="p">,</span><span class="n">math</span><span class="o">.</span><span class="n">dot23</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">lms</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span><span class="o">...</span><span class="p">],</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">wl</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">lms</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span><span class="o">...</span><span class="p">])))</span>
    <span class="k">if</span> <span class="n">allow_negative_values</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">xyz</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">xyz</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;xyz&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xyz</span>
    <span class="k">elif</span> <span class="n">out</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;xyz,m&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">M</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">eval</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

<div class="viewcode-block" id="add_to_cmf_dict">
<a class="viewcode-back" href="../../../../toolboxes.html#luxpy.toolboxes.indvcmf.add_to_cmf_dict">[docs]</a>
<span class="k">def</span> <span class="nf">add_to_cmf_dict</span><span class="p">(</span><span class="n">bar</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="s1">&#39;indv&#39;</span><span class="p">,</span> <span class="n">K</span> <span class="o">=</span> <span class="mi">683</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add set of cmfs to _CMF dict.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :bar: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Set of CMFs. None: initializes to empty ndarray.</span>
<span class="sd">        :cieobs:</span>
<span class="sd">            | &#39;indv&#39; or str, optional</span>
<span class="sd">            | Name of CMF set.</span>
<span class="sd">        :K: </span>
<span class="sd">            | 683 (lm/W), optional</span>
<span class="sd">            | Conversion factor from radiometric to photometric quantity.</span>
<span class="sd">        :M: </span>
<span class="sd">            | np.eye, optional</span>
<span class="sd">            | Matrix for lms to xyz conversion.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">bar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">wl3</span> <span class="o">=</span> <span class="n">getwlr</span><span class="p">(</span><span class="n">_WL3</span><span class="p">)</span>
        <span class="n">bar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">wl3</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">wl3</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))))</span>
    <span class="n">_CMF</span><span class="p">[</span><span class="s1">&#39;types&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cieobs</span><span class="p">)</span>
    <span class="n">_CMF</span><span class="p">[</span><span class="n">cieobs</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;bar&#39;</span> <span class="p">:</span> <span class="n">bar</span><span class="p">}</span>
    <span class="n">_CMF</span><span class="p">[</span><span class="n">cieobs</span><span class="p">][</span><span class="s1">&#39;K&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">K</span>
    <span class="n">_CMF</span><span class="p">[</span><span class="n">cieobs</span><span class="p">][</span><span class="s1">&#39;M&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span></div>

    <span class="c1">#return _CMF</span>
   
<div class="viewcode-block" id="plot_cmfs">
<a class="viewcode-back" href="../../../../toolboxes.html#luxpy.toolboxes.indvcmf.plot_cmfs">[docs]</a>
<span class="k">def</span> <span class="nf">plot_cmfs</span><span class="p">(</span><span class="n">cmf</span><span class="p">,</span><span class="n">axh</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot cmf set.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span> <span class="c1"># lazy import</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">axh</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
    <span class="n">axh</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cmf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">cmf</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span> <span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">axh</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cmf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">cmf</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">color</span> <span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">axh</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cmf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">cmf</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">color</span> <span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">axh</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Wavelenghts (nm)&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">axh</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">luxpy</span> <span class="k">as</span> <span class="nn">lx</span>
    <span class="n">init</span><span class="p">(</span><span class="n">use_my_round</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">use_sign_figs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">use_chop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">dsrc_lms_odens</span><span class="o">=</span><span class="s1">&#39;cietc197&#39;</span><span class="p">,</span><span class="n">lms_to_xyz_method</span><span class="o">=</span><span class="s1">&#39;cietc197&#39;</span><span class="p">)</span>
    <span class="n">xyz2b</span><span class="p">,</span><span class="n">M2</span> <span class="o">=</span> <span class="n">compute_cmfs</span><span class="p">(</span><span class="n">fieldsize</span><span class="o">=</span><span class="mf">2.1</span><span class="p">,</span><span class="n">age</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="s1">&#39;xyz,M&#39;</span><span class="p">,</span><span class="n">lms_to_xyz_method</span><span class="o">=</span><span class="s1">&#39;cietc197&#39;</span><span class="p">,</span><span class="n">norm_type</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">lx</span><span class="o">.</span><span class="n">spd_to_xyz</span><span class="p">(</span><span class="n">lx</span><span class="o">.</span><span class="n">_CIE_E</span><span class="p">,</span><span class="n">relative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">cieobs</span><span class="o">=</span><span class="n">xyz2b</span><span class="p">,</span><span class="n">K</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M2</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">200</span><span class="p">,</span><span class="mi">200</span><span class="p">,</span><span class="mi">200</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">plot_cmfs</span><span class="p">(</span><span class="n">xyz2b</span><span class="p">)</span>
    
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span> <span class="c1"># lazy import</span>
    
    <span class="n">data</span> <span class="o">=</span> <span class="n">load_database</span><span class="p">(</span><span class="n">wl</span><span class="o">=</span><span class="n">_WL</span><span class="p">)</span>
    <span class="n">_DATA</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="n">lms</span><span class="p">,</span><span class="n">M</span><span class="o">=</span><span class="n">compute_cmfs</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="s1">&#39;xyz,M&#39;</span><span class="p">,</span><span class="n">odata0</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;odata&#39;</span><span class="p">],</span> <span class="n">var_shft_LMS</span><span class="o">=</span><span class="p">[</span><span class="mi">15</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">norm_type</span> <span class="o">=</span> <span class="s1">&#39;area&#39;</span><span class="p">,</span><span class="n">lms_to_xyz_method</span><span class="o">=</span><span class="s1">&#39;cietc197&#39;</span><span class="p">)</span>
    
    
    <span class="n">outcmf</span> <span class="o">=</span> <span class="s1">&#39;xyz&#39;</span>
    
    <span class="n">out</span> <span class="o">=</span> <span class="n">outcmf</span> <span class="o">+</span> <span class="s1">&#39;,trans_lens,trans_macula,sens_photopig,LMSa&#39;</span>
    <span class="n">LMS</span><span class="p">,</span> <span class="n">trans_lens</span><span class="p">,</span> <span class="n">trans_macula</span><span class="p">,</span> <span class="n">sens_photopig</span><span class="p">,</span> <span class="n">LMSa</span> <span class="o">=</span> <span class="n">cie2006cmfsEx</span><span class="p">(</span><span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">,</span> <span class="n">norm_type</span> <span class="o">=</span> <span class="s1">&#39;area&#39;</span><span class="p">,</span><span class="n">var_shft_L</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span><span class="n">lms_to_xyz_method</span><span class="o">=</span><span class="s1">&#39;asano&#39;</span><span class="p">)</span>
    
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">LMS</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">LMS</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span> <span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">LMS</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">LMS</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">color</span> <span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">LMS</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">LMS</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">color</span> <span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;cie2006cmfsEx(...)&#39;</span><span class="p">)</span>
    
<span class="c1">#    plt.figure()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">lms</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span> <span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">lms</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">color</span> <span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">lms</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">color</span> <span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;x__main__&#39;</span><span class="p">:</span>  
    <span class="kn">import</span> <span class="nn">luxpy</span> <span class="k">as</span> <span class="nn">lx</span> 
    
    <span class="n">out</span> <span class="o">=</span> <span class="n">outcmf</span> <span class="o">+</span> <span class="s1">&#39;,var_age,vAll&#39;</span>

    <span class="n">LMS_All</span><span class="p">,</span> <span class="n">var_age</span><span class="p">,</span> <span class="n">vAll</span> <span class="o">=</span> <span class="n">genMonteCarloObs</span><span class="p">(</span><span class="n">n_obs</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">fieldsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">list_Age</span> <span class="o">=</span> <span class="p">[</span><span class="mi">32</span><span class="p">],</span> <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">LMS_All</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">LMS_All</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span> <span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">LMS_All</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">LMS_All</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">color</span> <span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">LMS_All</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">LMS_All</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">color</span> <span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;genMonteCarloObs(...)&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    
    <span class="n">LMS_All_US</span><span class="p">,</span> <span class="n">var_age_US</span><span class="p">,</span> <span class="n">vAll_US</span> <span class="o">=</span> <span class="n">genMonteCarloObs</span><span class="p">(</span><span class="n">n_obs</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">fieldsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">,</span> <span class="n">list_Age</span> <span class="o">=</span> <span class="s1">&#39;us_census&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">LMS_All_US</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">LMS_All_US</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span> <span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">LMS_All_US</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">LMS_All_US</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">color</span> <span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">LMS_All_US</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">LMS_All_US</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">color</span> <span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;genMonteCarloObs(..., list_Age = &#39;use_census&#39;)&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    
    <span class="n">LMS_All_CatObs</span><span class="p">,</span> <span class="n">var_age_CatObs</span><span class="p">,</span> <span class="n">vAll_CatObs</span>  <span class="o">=</span> <span class="n">getCatObs</span><span class="p">(</span><span class="n">n_cat</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">fieldsize</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">LMS_All_CatObs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">LMS_All_CatObs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span> <span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">LMS_All_CatObs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">LMS_All_CatObs</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">color</span> <span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">LMS_All_CatObs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">LMS_All_CatObs</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">color</span> <span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;getCatObs(...)&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    
<span class="c1">#    XYZ_All_CatObs = lmsb_to_xyzb(LMS_All_CatObs, fieldsize = 3)</span>
<span class="c1">#    plt.figure()</span>
<span class="c1">#    plt.plot(wl[:,None],XYZ_All_CatObs[0,:,:], color =&#39;r&#39;, linestyle=&#39;-&#39;)</span>
<span class="c1">#    plt.plot(wl[:,None],XYZ_All_CatObs[1,:,:], color =&#39;g&#39;, linestyle=&#39;-&#39;)</span>
<span class="c1">#    plt.plot(wl[:,None],XYZ_All_CatObs[2,:,:], color =&#39;b&#39;, linestyle=&#39;-&#39;)</span>
<span class="c1">#    plt.title(&#39;getCatObs XYZ&#39;)</span>
<span class="c1">#    plt.show()</span>
    
    <span class="c1"># Calculate new set of CMFs and calculate xyzw and cct, duv:</span>
    <span class="kn">from</span> <span class="nn">luxpy</span> <span class="kn">import</span> <span class="n">spd_to_xyz</span><span class="p">,</span> <span class="n">_CIE_ILLUMINANTS</span><span class="p">,</span> <span class="n">xyz_to_cct_ohno</span>
    <span class="n">XYZb_All_CatObs</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span>  <span class="o">=</span> <span class="n">getCatObs</span><span class="p">(</span><span class="n">n_cat</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fieldsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">)</span>
    <span class="n">add_to_cmf_dict</span><span class="p">(</span><span class="n">bar</span> <span class="o">=</span> <span class="n">XYZb_All_CatObs</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="s1">&#39;CatObs1&#39;</span><span class="p">,</span> <span class="n">K</span> <span class="o">=</span> <span class="mi">683</span><span class="p">)</span> 
    <span class="n">xyz2</span> <span class="o">=</span> <span class="n">spd_to_xyz</span><span class="p">(</span><span class="n">_CIE_ILLUMINANTS</span><span class="p">[</span><span class="s1">&#39;F4&#39;</span><span class="p">],</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="s1">&#39;1931_2&#39;</span><span class="p">)</span>
    <span class="n">xyz1</span> <span class="o">=</span> <span class="n">spd_to_xyz</span><span class="p">(</span><span class="n">_CIE_ILLUMINANTS</span><span class="p">[</span><span class="s1">&#39;F4&#39;</span><span class="p">],</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="s1">&#39;CatObs1&#39;</span><span class="p">)</span>
    <span class="n">cct2</span><span class="p">,</span><span class="n">duv2</span> <span class="o">=</span> <span class="n">lx</span><span class="o">.</span><span class="n">xyz_to_cct_ohno2014</span><span class="p">(</span><span class="n">xyz2</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="s1">&#39;1931_2&#39;</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;cct,duv&#39;</span><span class="p">)</span>
    <span class="n">cct1</span><span class="p">,</span><span class="n">duv1</span> <span class="o">=</span> <span class="n">lx</span><span class="o">.</span><span class="n">xyz_to_cct_ohno2014</span><span class="p">(</span><span class="n">xyz1</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="s1">&#39;CatObs1&#39;</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;cct,duv&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cct,duv using 1931_2: </span><span class="si">{:1.0f}</span><span class="s1"> K, </span><span class="si">{:1.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cct2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">duv2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cct,duv using CatObs1: </span><span class="si">{:1.0f}</span><span class="s1"> K, </span><span class="si">{:1.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cct1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">duv1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Kevin A.G. Smet.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>