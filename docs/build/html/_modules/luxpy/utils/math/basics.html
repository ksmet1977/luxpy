

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>luxpy.utils.math.basics &mdash; LuxPy 1.4.10 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 

  
  <script src="../../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../../index.html" class="icon icon-home"> LuxPy
          

          
          </a>

          
            
            
              <div class="version">
                1.4.10
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../license.html">License: GPLv3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../required_packages.html">Imported (required) packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../luxpy_structure.html">Luxpy package structure</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">LuxPy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>luxpy.utils.math.basics</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for luxpy.utils.math.basics</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">########################################################################</span>
<span class="c1"># &lt;LUXPY: a Python package for lighting and color science.&gt;</span>
<span class="c1"># Copyright (C) &lt;2017&gt;  &lt;Kevin A.G. Smet&gt; (ksmet1977 at gmail.com)</span>
<span class="c1">#</span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#########################################################################</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module with useful basic math functions</span>
<span class="sd">=======================================</span>

<span class="sd"> :normalize_3x3_matrix(): Normalize 3x3 matrix M to xyz0 -- &gt; [1,1,1]</span>

<span class="sd"> :line_intersect(): | Line intersections of series of two line segments a and b. </span>
<span class="sd">                    | https://stackoverflow.com/questions/3252194/numpy-and-line-intersections</span>

<span class="sd"> :positive_arctan(): Calculates the positive angle (0°-360° or 0 - 2*pi rad.) </span>
<span class="sd">                     from x and y.</span>

<span class="sd"> :dot23(): Dot product of a 2-d ndarray </span>
<span class="sd">           with a (N x K x L) 3-d ndarray using einsum().</span>

<span class="sd"> :check_symmetric(): Checks if A is symmetric.</span>

<span class="sd"> :check_posdef(): Checks positive definiteness of a matrix via Cholesky.</span>

<span class="sd"> :symmM_to_posdefM(): | Converts a symmetric matrix to a positive definite one. </span>
<span class="sd">                      | Two methods are supported:</span>
<span class="sd">                      |    * &#39;make&#39;: A Python/Numpy port of Muhammad Asim Mubeen&#39;s</span>
<span class="sd">                      |              matlab function Spd_Mat.m </span>
<span class="sd">                      |       (https://nl.mathworks.com/matlabcentral/fileexchange/45873-positive-definite-matrix)</span>
<span class="sd">                      |    * &#39;nearest&#39;: A Python/Numpy port of John D&#39;Errico&#39;s </span>
<span class="sd">                      |                &#39;nearestSPD&#39; MATLAB code. </span>
<span class="sd">                      |        (https://stackoverflow.com/questions/43238173/python-convert-matrix-to-positive-semi-definite)</span>

<span class="sd"> :bvgpdf(): Evaluate bivariate Gaussian probability density function (BVGPDF) </span>
<span class="sd">            at (x,y) with center mu and inverse covariance matric, sigmainv.</span>

<span class="sd"> :mahalanobis2(): Evaluate the squared mahalanobis distance with center mu and </span>
<span class="sd">                  shape and orientation determined by sigmainv. </span>

<span class="sd"> :rms(): Calculates root-mean-square along axis.</span>

<span class="sd"> :geomean(): Calculates geometric mean along axis.</span>

<span class="sd"> :polyarea(): | Calculates area of polygon. </span>
<span class="sd">              | (First coordinate should also be last)</span>

<span class="sd"> :erf(): erf-function, direct import from scipy.special</span>

<span class="sd"> :cart2pol(): Converts Cartesian to polar coordinates.</span>

<span class="sd"> :pol2cart(): Converts polar to Cartesian coordinates.</span>
<span class="sd"> </span>
<span class="sd"> :cart2spher(): Converts Cartesian to spherical coordinates.</span>
<span class="sd"> </span>
<span class="sd"> :spher2cart(): Converts spherical to Cartesian coordinates.</span>

<span class="sd"> :magnitude_v():  Calculates magnitude of vector.</span>

<span class="sd"> :angle_v1v2():  Calculates angle between two vectors.</span>

<span class="sd"> :histogram(): | Histogram function that can take as bins either the center</span>
<span class="sd">               | (cfr. matlab hist) or bin-edges.</span>

<span class="sd"> :v_to_cik(): Calculate 2x2 &#39;(covariance matrix)^-1&#39; elements cik from v-format ellipse descriptor.</span>

<span class="sd"> :cik_to_v(): Calculate v-format ellipse descriptor from 2x2 &#39;covariance matrix&#39;^-1 cik.</span>
<span class="sd"> </span>
<span class="sd"> :fmod(): Floating point modulus, e.g.: fmod(theta, np.pi * 2) would keep an angle in [0, 2pi]b</span>

<span class="sd"> :fit_ellipse(): Fit an ellipse to supplied data points.</span>
<span class="sd"> </span>
<span class="sd"> :ndinterp1(): Perform n-dimensional interpolation using Delaunay triangulation.</span>
<span class="sd"> </span>
<span class="sd">.. codeauthor:: Kevin A.G. Smet (ksmet1977 at gmail.com)</span>
<span class="sd">===============================================================================</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">luxpy</span> <span class="k">import</span> <span class="n">np</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">np2d</span><span class="p">,</span> <span class="n">_EPS</span><span class="p">,</span> <span class="n">asplit</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="k">import</span> <span class="n">erf</span><span class="p">,</span> <span class="n">erfinv</span>
<span class="n">__all__</span>  <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;normalize_3x3_matrix&#39;</span><span class="p">,</span><span class="s1">&#39;symmM_to_posdefM&#39;</span><span class="p">,</span><span class="s1">&#39;check_symmetric&#39;</span><span class="p">,</span>
            <span class="s1">&#39;check_posdef&#39;</span><span class="p">,</span><span class="s1">&#39;positive_arctan&#39;</span><span class="p">,</span><span class="s1">&#39;line_intersect&#39;</span><span class="p">,</span><span class="s1">&#39;erf&#39;</span><span class="p">,</span> <span class="s1">&#39;erfinv&#39;</span><span class="p">,</span> 
            <span class="s1">&#39;histogram&#39;</span><span class="p">,</span> <span class="s1">&#39;pol2cart&#39;</span><span class="p">,</span> <span class="s1">&#39;cart2pol&#39;</span><span class="p">,</span> <span class="s1">&#39;spher2cart&#39;</span><span class="p">,</span> <span class="s1">&#39;cart2spher&#39;</span><span class="p">]</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;bvgpdf&#39;</span><span class="p">,</span><span class="s1">&#39;mahalanobis2&#39;</span><span class="p">,</span><span class="s1">&#39;dot23&#39;</span><span class="p">,</span> <span class="s1">&#39;rms&#39;</span><span class="p">,</span><span class="s1">&#39;geomean&#39;</span><span class="p">,</span><span class="s1">&#39;polyarea&#39;</span><span class="p">]</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;magnitude_v&#39;</span><span class="p">,</span><span class="s1">&#39;angle_v1v2&#39;</span><span class="p">]</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;v_to_cik&#39;</span><span class="p">,</span> <span class="s1">&#39;cik_to_v&#39;</span><span class="p">,</span> <span class="s1">&#39;fmod&#39;</span><span class="p">,</span> <span class="s1">&#39;fit_ellipse&#39;</span><span class="p">,</span><span class="s1">&#39;ndinterp1&#39;</span><span class="p">]</span>


<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="normalize_3x3_matrix"><a class="viewcode-back" href="../../../../utils.html#luxpy.utils.math.normalize_3x3_matrix">[docs]</a><span class="k">def</span> <span class="nf">normalize_3x3_matrix</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">xyz0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">]])):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize 3x3 matrix M to xyz0 -- &gt; [1,1,1]</span>
<span class="sd">    If M.shape == (1,9): M is reshaped to (3,3)</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :M: </span>
<span class="sd">            | ndarray((3,3) or ndarray((1,9))</span>
<span class="sd">        :xyz0: </span>
<span class="sd">            | 2darray, optional </span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | normalized matrix such that M*xyz0 = [1,1,1]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">9</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">xyz0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagflat</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">xyz0</span><span class="o">.</span><span class="n">T</span><span class="p">))),</span><span class="n">M</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagflat</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">xyz0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">))),</span><span class="n">M</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xyz0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">xyz0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span></div>

<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="line_intersect"><a class="viewcode-back" href="../../../../utils.html#luxpy.utils.math.line_intersect">[docs]</a><span class="k">def</span> <span class="nf">line_intersect</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Line intersections of series of two line segments a and b. </span>
<span class="sd">        </span>
<span class="sd">    Args:</span>
<span class="sd">        :a1: </span>
<span class="sd">            | ndarray (.shape  = (N,2)) specifying end-point 1 of line a</span>
<span class="sd">        :a2: </span>
<span class="sd">            | ndarray (.shape  = (N,2)) specifying end-point 2 of line a</span>
<span class="sd">        :b1: </span>
<span class="sd">            | ndarray (.shape  = (N,2)) specifying end-point 1 of line b</span>
<span class="sd">        :b2: </span>
<span class="sd">            | ndarray (.shape  = (N,2)) specifying end-point 2 of line b</span>
<span class="sd">    </span>
<span class="sd">    Note: </span>
<span class="sd">        N is the number of line segments a and b.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | ndarray with line-intersections (.shape = (N,2))</span>
<span class="sd">    </span>
<span class="sd">    References:</span>
<span class="sd">        1. https://stackoverflow.com/questions/3252194/numpy-and-line-intersections</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]])</span>
    <span class="n">da</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">a2</span> <span class="o">-</span> <span class="n">a1</span><span class="p">)</span>
    <span class="n">db</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">b2</span> <span class="o">-</span> <span class="n">b1</span><span class="p">)</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">a1</span> <span class="o">-</span> <span class="n">b1</span><span class="p">)</span>
    <span class="n">dap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dap</span> <span class="o">*</span> <span class="n">db</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dap</span> <span class="o">*</span> <span class="n">dp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">num</span> <span class="o">/</span> <span class="n">denom</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">db</span> <span class="o">+</span> <span class="n">b1</span></div>

<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="positive_arctan"><a class="viewcode-back" href="../../../../utils.html#luxpy.utils.math.positive_arctan">[docs]</a><span class="k">def</span> <span class="nf">positive_arctan</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="n">htype</span> <span class="o">=</span> <span class="s1">&#39;deg&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate positive angle (0°-360° or 0 - 2*pi rad.) from x and y.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :x: </span>
<span class="sd">            | ndarray of x-coordinates</span>
<span class="sd">        :y: </span>
<span class="sd">            | ndarray of y-coordinates</span>
<span class="sd">        :htype:</span>
<span class="sd">            | &#39;deg&#39; or &#39;rad&#39;, optional</span>
<span class="sd">            |   - &#39;deg&#39;: hue angle between 0° and 360°</span>
<span class="sd">            |   - &#39;rad&#39;: hue angle between 0 and 2pi radians</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | ndarray of positive angles.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">htype</span> <span class="o">==</span> <span class="s1">&#39;deg&#39;</span><span class="p">:</span>
        <span class="n">r2d</span> <span class="o">=</span> <span class="mf">180.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">h360</span> <span class="o">=</span> <span class="mf">360.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">r2d</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">h360</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">r2d</span><span class="p">))</span>
    <span class="n">h</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">h</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">h</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)]</span> <span class="o">+</span> <span class="n">h360</span>
    <span class="k">return</span> <span class="n">h</span></div>


<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="dot23"><a class="viewcode-back" href="../../../../utils.html#luxpy.utils.math.dot23">[docs]</a><span class="k">def</span> <span class="nf">dot23</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dot product of a 2-d ndarray with a (N x K x L) 3-d ndarray </span>
<span class="sd">    using einsum().</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :A: </span>
<span class="sd">            | ndarray (.shape = (M,N))</span>
<span class="sd">        :B: </span>
<span class="sd">            | ndarray (.shape = (N,K,L))</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | ndarray (.shape = (M,K,L))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">dotAB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,jkl-&gt;ikl&#39;</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">keepdims</span> <span class="o">==</span> <span class="kc">True</span><span class="p">):</span>
            <span class="n">dotAB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">dotAB</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">dotAB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,jk-&gt;ik&#39;</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">keepdims</span> <span class="o">==</span> <span class="kc">True</span><span class="p">):</span>
            <span class="n">dotAB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">dotAB</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            
    <span class="k">return</span> <span class="n">dotAB</span></div>

<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="check_symmetric"><a class="viewcode-back" href="../../../../utils.html#luxpy.utils.math.check_symmetric">[docs]</a><span class="k">def</span> <span class="nf">check_symmetric</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1.0e-9</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1.0e-9</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if A is symmetric.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :A: </span>
<span class="sd">            | ndarray</span>
<span class="sd">        :atol:</span>
<span class="sd">            | float, optional</span>
<span class="sd">            | The absolute tolerance parameter (see Notes of numpy.allclose())</span>
<span class="sd">        :rtol:</span>
<span class="sd">            | float, optional</span>
<span class="sd">            | The relative tolerance parameter (see Notes of numpy.allclose())</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | Bool</span>
<span class="sd">            | True: the array is symmetric within the given tolerance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="n">rtol</span><span class="p">)</span></div>


<div class="viewcode-block" id="check_posdef"><a class="viewcode-back" href="../../../../utils.html#luxpy.utils.math.check_posdef">[docs]</a><span class="k">def</span> <span class="nf">check_posdef</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1.0e-9</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1.0e-9</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks positive definiteness of a matrix via Cholesky.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :A: </span>
<span class="sd">            | ndarray</span>
<span class="sd">        :atol:</span>
<span class="sd">            | float, optional</span>
<span class="sd">            | The absolute tolerance parameter (see Notes of numpy.allclose())</span>
<span class="sd">        :rtol:</span>
<span class="sd">            | float, optional</span>
<span class="sd">            | The relative tolerance parameter (see Notes of numpy.allclose())</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | Bool</span>
<span class="sd">            | True: the array is positive-definite within the given tolerance</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">atol</span> <span class="o">=</span> <span class="n">atol</span><span class="p">,</span><span class="n">rtol</span> <span class="o">=</span> <span class="n">rtol</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="symmM_to_posdefM"><a class="viewcode-back" href="../../../../utils.html#luxpy.utils.math.symmM_to_posdefM">[docs]</a><span class="k">def</span> <span class="nf">symmM_to_posdefM</span><span class="p">(</span><span class="n">A</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1.0e-9</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1.0e-9</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;make&#39;</span><span class="p">,</span> <span class="n">forcesymm</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a symmetric matrix to a positive definite one. </span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :A: </span>
<span class="sd">            | ndarray</span>
<span class="sd">        :atol:</span>
<span class="sd">            | float, optional</span>
<span class="sd">            | The absolute tolerance parameter (see Notes of numpy.allclose())</span>
<span class="sd">        :rtol:</span>
<span class="sd">            | float, optional</span>
<span class="sd">            | The relative tolerance parameter (see Notes of numpy.allclose())</span>
<span class="sd">        :method: </span>
<span class="sd">            | &#39;make&#39; or &#39;nearest&#39;, optional (see notes for more info)</span>
<span class="sd">        :forcesymm: </span>
<span class="sd">            | True or False, optional</span>
<span class="sd">            | If A is not symmetric, force symmetry using: </span>
<span class="sd">            |    A = numpy.triu(A) + numpy.triu(A).T - numpy.diag(numpy.diag(A))</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | ndarray with positive-definite matrix.</span>
<span class="sd">        </span>
<span class="sd">    Notes on supported methods:</span>
<span class="sd">        1. `&#39;make&#39;: A Python/Numpy port of Muhammad Asim Mubeen&#39;s matlab function </span>
<span class="sd">        Spd_Mat.m </span>
<span class="sd">        &lt;https://nl.mathworks.com/matlabcentral/fileexchange/45873-positive-definite-matrix&gt;`_</span>
<span class="sd">        2. `&#39;nearest&#39;: A Python/Numpy port of John D&#39;Errico&#39;s `nearestSPD` </span>
<span class="sd">        MATLAB code. </span>
<span class="sd">        &lt;https://stackoverflow.com/questions/43238173/python-convert-matrix-to-positive-semi-definite&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">A</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        
        
        <span class="c1"># Make sure matrix A is symmetric up to a certain tolerance:</span>
        <span class="n">sn</span> <span class="o">=</span> <span class="n">check_symmetric</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="n">rtol</span><span class="p">)</span> 
        <span class="k">if</span> <span class="p">((</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">sn</span> <span class="o">!=</span> <span class="kc">True</span><span class="p">)):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">forcesymm</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)</span>  <span class="o">&amp;</span>  <span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;symmM_to_posdefM(): matrix A not symmetric.&#39;</span><span class="p">)</span>
        
        
        <span class="k">if</span> <span class="n">check_posdef</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="n">rtol</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">A</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;make&#39;</span><span class="p">:</span>

                <span class="c1"># A Python/Numpy port of Muhammad Asim Mubeen&#39;s matlab function Spd_Mat.m</span>
                <span class="c1">#</span>
                <span class="c1"># See: https://nl.mathworks.com/matlabcentral/fileexchange/45873-positive-definite-matrix</span>
                <span class="n">Val</span><span class="p">,</span> <span class="n">Vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> 
                <span class="n">Val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">Val</span><span class="p">)</span>
                <span class="n">Vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">Vec</span><span class="p">)</span>
                <span class="n">Val</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Val</span><span class="o">==</span><span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_EPS</span> <span class="c1">#making zero eigenvalues non-zero</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Val</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">Val</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">Val</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="c1">#making negative eigenvalues positive</span>
                <span class="k">return</span>   <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Vec</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Val</span><span class="p">)</span> <span class="p">,</span> <span class="n">Vec</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
 
            
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;nearest&#39;</span><span class="p">:</span>
                
                 <span class="c1"># A Python/Numpy port of John D&#39;Errico&#39;s `nearestSPD` MATLAB code [1], which</span>
                 <span class="c1"># credits [2].</span>
                 <span class="c1">#</span>
                 <span class="c1"># [1] https://www.mathworks.com/matlabcentral/fileexchange/42885-nearestspd</span>
                 <span class="c1">#</span>
                 <span class="c1"># [2] N.J. Higham, &quot;Computing a nearest symmetric positive semidefinite</span>
                 <span class="c1"># matrix&quot; (1988): https://doi.org/10.1016/0024-3795(88)90223-6</span>
                 <span class="c1">#</span>
                 <span class="c1"># See: https://stackoverflow.com/questions/43238173/python-convert-matrix-to-positive-semi-definite</span>
                
                <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span> <span class="o">+</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>

                <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">V</span><span class="p">))</span>

                <span class="n">A2</span> <span class="o">=</span> <span class="p">(</span><span class="n">B</span> <span class="o">+</span> <span class="n">H</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>

                <span class="n">A3</span> <span class="o">=</span> <span class="p">(</span><span class="n">A2</span> <span class="o">+</span> <span class="n">A2</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>

                <span class="k">if</span> <span class="n">check_posdef</span><span class="p">(</span><span class="n">A3</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="n">rtol</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">A3</span>

                <span class="n">spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">spacing</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
                <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">while</span> <span class="ow">not</span> <span class="n">check_posdef</span><span class="p">(</span><span class="n">A3</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="n">rtol</span><span class="p">):</span>
                    <span class="n">mineig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">A3</span><span class="p">)))</span>
                    <span class="n">A3</span> <span class="o">+=</span> <span class="n">I</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">mineig</span> <span class="o">*</span> <span class="n">k</span><span class="o">**</span><span class="mf">2.0</span><span class="o">+</span> <span class="n">spacing</span><span class="p">)</span>
                    <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">return</span> <span class="n">A3</span></div>


<span class="c1">#-----------------------------------------------------------------------------</span>
<div class="viewcode-block" id="bvgpdf"><a class="viewcode-back" href="../../../../utils.html#luxpy.utils.math.bvgpdf">[docs]</a><span class="k">def</span> <span class="nf">bvgpdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mu</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">sigmainv</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate bivariate Gaussian probability density function (BVGPDF) at (x,y) </span>
<span class="sd">    with center mu and inverse covariance matric, sigmainv.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :x: </span>
<span class="sd">            | scalar or list or ndarray (.ndim = 1 or 2) with </span>
<span class="sd">            | x(y)-coordinates at which to evaluate bivariate Gaussian PD.</span>
<span class="sd">        :y: </span>
<span class="sd">            | None or scalar or list or ndarray (.ndim = 1) with </span>
<span class="sd">            | y-coordinates at which to evaluate bivariate Gaussian PD, optional.</span>
<span class="sd">            | If :y: is None, :x: should be a 2d array.</span>
<span class="sd">        :mu: </span>
<span class="sd">            | None or ndarray (.ndim = 2) with center coordinates of </span>
<span class="sd">            | bivariate Gaussian PD, optional. </span>
<span class="sd">            | None defaults to ndarray([0,0]).</span>
<span class="sd">        :sigmainv:</span>
<span class="sd">            | None or ndarray with &#39;inverse covariance matrix&#39;, optional </span>
<span class="sd">            | Determines the shape and orientation of the PD.</span>
<span class="sd">            | None default to numpy.eye(2).</span>
<span class="sd">     </span>
<span class="sd">    Returns:</span>
<span class="sd">         :returns:</span>
<span class="sd">             | ndarray with magnitude of BVGPDF(x,y)   </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">mahalanobis2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span> <span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigmainv</span><span class="o">=</span> <span class="n">sigmainv</span><span class="p">))</span></div>

<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="mahalanobis2"><a class="viewcode-back" href="../../../../utils.html#luxpy.utils.math.mahalanobis2">[docs]</a><span class="k">def</span> <span class="nf">mahalanobis2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mu</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="n">sigmainv</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the squared mahalanobis distance with center mu and shape </span>
<span class="sd">    and orientation determined by sigmainv. </span>
<span class="sd">    </span>
<span class="sd">    Args: </span>
<span class="sd">        :x: </span>
<span class="sd">            | scalar or list or ndarray (.ndim = 1 or 2) with x(y)-coordinates </span>
<span class="sd">              at which to evaluate the mahalanobis distance squared.</span>
<span class="sd">        :y: </span>
<span class="sd">            | None or scalar or list or ndarray (.ndim = 1) with y-coordinates </span>
<span class="sd">              at which to evaluate the mahalanobis distance squared, optional.</span>
<span class="sd">            | If :y: is None, :x: should be a 2d array.</span>
<span class="sd">        :mu: </span>
<span class="sd">            | None or ndarray (.ndim = 2) with center coordinates of the </span>
<span class="sd">              mahalanobis ellipse, optional. </span>
<span class="sd">            | None defaults to ndarray([0,0]).</span>
<span class="sd">        :sigmainv:</span>
<span class="sd">            | None or ndarray with &#39;inverse covariance matrix&#39;, optional </span>
<span class="sd">            | Determines the shape and orientation of the PD.</span>
<span class="sd">            | None default to np.eye(2).</span>
<span class="sd">    Returns:</span>
<span class="sd">         :returns: </span>
<span class="sd">             | ndarray with magnitude of mahalanobis2(x,y)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sigmainv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sigmainv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="n">x</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">mu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># center data on mu </span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">mu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># center data on mu </span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">mu</span> <span class="c1"># center data on mu    </span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">asplit</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">sigmainv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">sigmainv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">sigmainv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span></div>



<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="rms"><a class="viewcode-back" href="../../../../utils.html#luxpy.utils.math.rms">[docs]</a><span class="k">def</span> <span class="nf">rms</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate root-mean-square along axis.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :data: </span>
<span class="sd">            | list of values or ndarray</span>
<span class="sd">        :axis:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | Axis along which to calculate rms.</span>
<span class="sd">        :keepdims:</span>
<span class="sd">            | False or True, optional</span>
<span class="sd">            | Keep original dimensions of array.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | ndarray with rms values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="n">keepdims</span><span class="p">))</span></div>

<span class="c1">#-----------------------------------------------------------------------------</span>
<div class="viewcode-block" id="geomean"><a class="viewcode-back" href="../../../../utils.html#luxpy.utils.math.geomean">[docs]</a><span class="k">def</span> <span class="nf">geomean</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate geometric mean along axis.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :data:</span>
<span class="sd">            | list of values or ndarray</span>
<span class="sd">        :axis:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | Axis along which to calculate geomean.</span>
<span class="sd">        :keepdims:</span>
<span class="sd">            | False or True, optional</span>
<span class="sd">            | Keep original dimensions of array.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | ndarray with geomean values. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="n">keepdims</span><span class="p">),</span><span class="mi">1</span><span class="o">/</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span></div>
 
<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="polyarea"><a class="viewcode-back" href="../../../../utils.html#luxpy.utils.math.polyarea">[docs]</a><span class="k">def</span> <span class="nf">polyarea</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates area of polygon. </span>
<span class="sd">    </span>
<span class="sd">    | First coordinate should also be last.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :x: </span>
<span class="sd">            | ndarray of x-coordinates of polygon vertices.</span>
<span class="sd">        :y: </span>
<span class="sd">            | ndarray of x-coordinates of polygon vertices.     </span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | float (area or polygon)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">))</span></div>

<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="cart2pol"><a class="viewcode-back" href="../../../../utils.html#luxpy.utils.math.cart2pol">[docs]</a><span class="k">def</span> <span class="nf">cart2pol</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">htype</span> <span class="o">=</span> <span class="s1">&#39;deg&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert Cartesion to polar coordinates.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :x: </span>
<span class="sd">            | float or ndarray with x-coordinates</span>
<span class="sd">        :y: </span>
<span class="sd">            | None or float or ndarray with x-coordinates, optional</span>
<span class="sd">            | If None, y-coordinates are assumed to be in :x:.</span>
<span class="sd">        :htype:</span>
<span class="sd">            | &#39;deg&#39; or &#39;rad, optional</span>
<span class="sd">            | Output type of theta.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | (float or ndarray of theta, float or ndarray of r) values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">positive_arctan</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="n">htype</span> <span class="o">=</span> <span class="n">htype</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="pol2cart"><a class="viewcode-back" href="../../../../utils.html#luxpy.utils.math.pol2cart">[docs]</a><span class="k">def</span> <span class="nf">pol2cart</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">htype</span> <span class="o">=</span> <span class="s1">&#39;deg&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert Cartesion to polar coordinates.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :theta: </span>
<span class="sd">            | float or ndarray with theta-coordinates</span>
<span class="sd">        :r: </span>
<span class="sd">            | None or float or ndarray with r-coordinates, optional</span>
<span class="sd">            | If None, r-coordinates are assumed to be in :theta:.</span>
<span class="sd">        :htype:</span>
<span class="sd">            | &#39;deg&#39; or &#39;rad, optional</span>
<span class="sd">            | Intput type of :theta:.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | (float or ndarray of x, float or ndarray of y) coordinates </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">htype</span> <span class="o">==</span> <span class="s1">&#39;deg&#39;</span><span class="p">:</span>
        <span class="n">d2r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">d2r</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="o">*</span><span class="n">d2r</span>
    <span class="k">return</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span></div>

<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="spher2cart"><a class="viewcode-back" href="../../../../utils.html#luxpy.utils.math.spher2cart">[docs]</a><span class="k">def</span> <span class="nf">spher2cart</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">deg</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert spherical to cartesian coordinates.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :theta:</span>
<span class="sd">            | Float, int or ndarray</span>
<span class="sd">            | Angle with positive z-axis.</span>
<span class="sd">        :phi:</span>
<span class="sd">            | Float, int or ndarray</span>
<span class="sd">            | Angle around positive z-axis starting from x-axis.</span>
<span class="sd">        :r:</span>
<span class="sd">            | 1, optional</span>
<span class="sd">            | Float, int or ndarray</span>
<span class="sd">            | radius</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :x, y, z:</span>
<span class="sd">            | tuple of floats, ints or ndarrays</span>
<span class="sd">            | Cartesian coordinates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">deg</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    <span class="n">x</span><span class="o">=</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    <span class="n">y</span><span class="o">=</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    <span class="n">z</span><span class="o">=</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span></div>

<div class="viewcode-block" id="cart2spher"><a class="viewcode-back" href="../../../../utils.html#luxpy.utils.math.cart2spher">[docs]</a><span class="k">def</span> <span class="nf">cart2spher</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span> <span class="n">deg</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert cartesian to spherical coordinates.</span>
<span class="sd">    </span>
<span class="sd">    Args:        </span>
<span class="sd">        :x, y, z:</span>
<span class="sd">            | tuple of floats, ints or ndarrays</span>
<span class="sd">            | Cartesian coordinates</span>
<span class="sd">    Returns:</span>
<span class="sd">        :theta:</span>
<span class="sd">            | Float, int or ndarray</span>
<span class="sd">            | Angle with positive z-axis.</span>
<span class="sd">        :phi:</span>
<span class="sd">            | Float, int or ndarray</span>
<span class="sd">            | Angle around positive z-axis starting from x-axis.</span>
<span class="sd">        :r:</span>
<span class="sd">            | 1, optional</span>
<span class="sd">            | Float, int or ndarray</span>
<span class="sd">            | radius</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="o">*</span><span class="n">z</span><span class="p">)</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
    <span class="n">phi</span><span class="p">[</span><span class="n">phi</span><span class="o">&lt;</span><span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="n">phi</span><span class="p">[</span><span class="n">phi</span><span class="o">&lt;</span><span class="mf">0.</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">zdr</span> <span class="o">=</span> <span class="n">z</span><span class="o">/</span><span class="n">r</span>
    <span class="n">zdr</span><span class="p">[</span><span class="n">zdr</span> <span class="o">&gt;</span> <span class="mf">1.</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="n">zdr</span><span class="p">[</span><span class="n">zdr</span><span class="o">&lt;-</span><span class="mf">1.</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">zdr</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">deg</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">phi</span> <span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">return</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">r</span>   </div>


<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># magnitude of a vector</span>
<div class="viewcode-block" id="magnitude_v"><a class="viewcode-back" href="../../../../utils.html#luxpy.utils.math.magnitude_v">[docs]</a><span class="k">def</span> <span class="nf">magnitude_v</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates magnitude of vector.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :v: </span>
<span class="sd">            | ndarray with vector</span>
<span class="sd"> </span>
<span class="sd">    Returns:</span>
<span class="sd">        :magnitude:</span>
<span class="sd">            | ndarray </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">v</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">magnitude</span></div>


<span class="c1"># angle between vectors</span>
<div class="viewcode-block" id="angle_v1v2"><a class="viewcode-back" href="../../../../utils.html#luxpy.utils.math.angle_v1v2">[docs]</a><span class="k">def</span> <span class="nf">angle_v1v2</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="n">htype</span> <span class="o">=</span> <span class="s1">&#39;deg&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates angle between two vectors.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :v1: </span>
<span class="sd">            | ndarray with vector 1</span>
<span class="sd">        :v2: </span>
<span class="sd">            | ndarray with vector 2</span>
<span class="sd">        :htype:</span>
<span class="sd">            | &#39;deg&#39; or &#39;rad&#39;, optional</span>
<span class="sd">            | Requested angle type.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :ang: </span>
<span class="sd">            | ndarray </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="n">magnitude_v</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span><span class="o">*</span><span class="n">magnitude_v</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>
    <span class="n">denom</span><span class="p">[</span><span class="n">denom</span><span class="o">==</span><span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">ang</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v1</span><span class="o">*</span><span class="n">v2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">denom</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">htype</span> <span class="o">==</span> <span class="s1">&#39;deg&#39;</span><span class="p">:</span>
        <span class="n">ang</span> <span class="o">=</span> <span class="n">ang</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">return</span> <span class="n">ang</span></div>
	
<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="histogram"><a class="viewcode-back" href="../../../../utils.html#luxpy.utils.math.histogram">[docs]</a><span class="k">def</span> <span class="nf">histogram</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">bin_center</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Histogram function that can take as bins either </span>
<span class="sd">    the center (cfr. matlab hist) or bin-edges.</span>
<span class="sd">    </span>
<span class="sd">    Args: </span>
<span class="sd">        :bin_center:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | False: if :bins: int, str or sequence of scalars:</span>
<span class="sd">            |       default to numpy.histogram (uses bin edges).</span>
<span class="sd">            | True: if :bins: is a sequence of scalars:</span>
<span class="sd">            |         bins (containing centers) are transformed to edges</span>
<span class="sd">            |         and nump.histogram is run. </span>
<span class="sd">            |         Mimicks matlab hist (uses bin centers).</span>
<span class="sd">        </span>
<span class="sd">    Note:</span>
<span class="sd">        For other armuments and output, see ?numpy.histogram</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | ndarray with histogram</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="o">|</span>  <span class="nb">isinstance</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">bin_center</span> <span class="o">==</span> <span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">centers</span> <span class="o">=</span> <span class="n">bins</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">centers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">centers</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span><span class="p">,</span> <span class="n">centers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">edges</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="nb">range</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="n">normed</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="n">density</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="nb">range</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="n">normed</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="n">density</span><span class="p">)</span></div>

<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="v_to_cik"><a class="viewcode-back" href="../../../../utils.html#luxpy.utils.math.v_to_cik">[docs]</a><span class="k">def</span> <span class="nf">v_to_cik</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">inverse</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate 2x2 &#39;(covariance matrix)^-1&#39; elements cik </span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :v: </span>
<span class="sd">            | (Nx5) np.ndarray</span>
<span class="sd">            | ellipse parameters [Rmax,Rmin,xc,yc,theta]</span>
<span class="sd">        :inverse:</span>
<span class="sd">            | If True: return inverse of cik.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :cik: </span>
<span class="sd">            &#39;Nx2x2&#39; (covariance matrix)^-1</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        | cik is not actually a covariance matrix,</span>
<span class="sd">        | only for a Gaussian or normal distribution!</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">g11</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">v</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">v</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">g22</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">v</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">v</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">g12</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">v</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="n">v</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span><span class="mi">4</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span><span class="mi">4</span><span class="p">])</span>
    <span class="n">cik</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">g11</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">g11</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">cik</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">g11</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">g12</span><span class="p">[</span><span class="n">i</span><span class="p">])),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">g12</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">g22</span><span class="p">[</span><span class="n">i</span><span class="p">]))))</span>
        <span class="k">if</span> <span class="n">inverse</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">cik</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">cik</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:])</span>
    <span class="k">return</span> <span class="n">cik</span></div>
<span class="c1">#------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="cik_to_v"><a class="viewcode-back" href="../../../../utils.html#luxpy.utils.math.cik_to_v">[docs]</a><span class="k">def</span> <span class="nf">cik_to_v</span><span class="p">(</span><span class="n">cik</span><span class="p">,</span> <span class="n">xyc</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">inverse</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate v-format ellipse descriptor from 2x2 &#39;covariance matrix&#39;^-1 cik </span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :cik: </span>
<span class="sd">            | &#39;Nx2x2&#39; (covariance matrix)^-1</span>
<span class="sd">        :inverse:</span>
<span class="sd">            | If True: input is inverse of cik.</span>
<span class="sd">              </span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :v: </span>
<span class="sd">            | (Nx5) np.ndarray</span>
<span class="sd">            | ellipse parameters [Rmax,Rmin,xc,yc,theta]</span>

<span class="sd">    Notes:</span>
<span class="sd">        | cik is not actually the inverse covariance matrix,</span>
<span class="sd">        | only for a Gaussian or normal distribution!</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">inverse</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cik</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">cik</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">cik</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:])</span>
            
    <span class="n">g11</span> <span class="o">=</span> <span class="n">cik</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">g22</span> <span class="o">=</span> <span class="n">cik</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> 
    <span class="n">g12</span> <span class="o">=</span> <span class="n">cik</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">theta</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">g12</span><span class="p">,(</span><span class="n">g11</span><span class="o">-</span><span class="n">g22</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">g12</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1">#theta = theta2 + (np.pi/2)*(g12&lt;0)</span>
    <span class="c1">#theta2 = theta</span>
    <span class="n">cottheta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="c1">#np.cot(theta)</span>
    <span class="n">cottheta</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">cottheta</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">g22</span> <span class="o">+</span> <span class="n">g12</span><span class="o">*</span><span class="n">cottheta</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">g11</span> <span class="o">-</span> <span class="n">g12</span><span class="o">*</span><span class="n">cottheta</span><span class="p">))</span>

    <span class="c1"># ensure largest ellipse axis is first (correct angle):</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="o">&gt;</span><span class="n">a</span><span class="p">;</span> <span class="n">a</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">theta</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">c</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="n">c</span><span class="p">],</span><span class="n">theta</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">theta</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    
    <span class="c1"># add center coordinates:</span>
    <span class="k">if</span> <span class="n">xyc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">v</span><span class="p">[:,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">xyc</span>
    
    <span class="k">return</span> <span class="n">v</span></div>

<div class="viewcode-block" id="fmod"><a class="viewcode-back" href="../../../../utils.html#luxpy.utils.math.fmod">[docs]</a><span class="k">def</span> <span class="nf">fmod</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Floating point modulus</span>
<span class="sd">        e.g., fmod(theta, np.pi * 2) would keep an angle in [0, 2pi]</span>

<span class="sd">    Args:</span>
<span class="sd">        :x:</span>
<span class="sd">            | angle to restrict</span>
<span class="sd">        :y: </span>
<span class="sd">            | end of  interval [0, y] to restrict to</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :r: floating point modulus</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">while</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="n">y</span>
    <span class="k">while</span><span class="p">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="n">y</span>
    <span class="k">return</span> <span class="n">r</span></div>


<div class="viewcode-block" id="fit_ellipse"><a class="viewcode-back" href="../../../../utils.html#luxpy.utils.math.fit_ellipse">[docs]</a><span class="k">def</span> <span class="nf">fit_ellipse</span><span class="p">(</span><span class="n">xy</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fit an ellipse to supplied data points.</span>

<span class="sd">    Args:</span>
<span class="sd">        :xy: </span>
<span class="sd">            | coordinates of points to fit (Nx2 array)</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :v:</span>
<span class="sd">            | vector with ellipse parameters [Rmax,Rmin, xc,yc, theta]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># remove centroid:</span>
    <span class="n">center</span> <span class="o">=</span> <span class="n">xy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">xy</span> <span class="o">=</span> <span class="n">xy</span> <span class="o">-</span> <span class="n">center</span>
    
    <span class="c1"># Fit ellipse:</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span> <span class="n">xy</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
    <span class="n">S</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
    <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">C</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">U</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="n">C</span><span class="p">))</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">U</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        
    <span class="c1"># get ellipse axis lengths, center and orientation:</span>
    <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># get ellipse center:</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span>
    <span class="n">xc</span> <span class="o">=</span> <span class="p">((</span><span class="n">c</span> <span class="o">*</span> <span class="n">d</span> <span class="o">-</span> <span class="n">b</span> <span class="o">*</span> <span class="n">f</span><span class="p">)</span> <span class="o">/</span> <span class="n">num</span><span class="p">)</span> <span class="o">+</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">yc</span> <span class="o">=</span> <span class="p">((</span><span class="n">a</span> <span class="o">*</span> <span class="n">f</span> <span class="o">-</span> <span class="n">b</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span> <span class="o">/</span> <span class="n">num</span><span class="p">)</span> <span class="o">+</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="c1"># get ellipse orientation:</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">b</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">a</span> <span class="o">-</span> <span class="n">c</span><span class="p">)))</span> <span class="o">/</span> <span class="mi">2</span>
    
    <span class="c1"># axis lengths:</span>
    <span class="n">up</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">f</span> <span class="o">*</span> <span class="n">f</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">d</span> <span class="o">+</span> <span class="n">g</span> <span class="o">*</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">f</span> <span class="o">-</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span> <span class="o">*</span> <span class="n">g</span><span class="p">)</span>
    <span class="n">down1</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">c</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">/</span> <span class="p">((</span><span class="n">a</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">c</span><span class="p">)))</span> <span class="o">-</span> <span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="n">a</span><span class="p">))</span>
    <span class="n">down2</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">a</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">/</span> <span class="p">((</span><span class="n">a</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">c</span><span class="p">)))</span> <span class="o">-</span> <span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="n">a</span><span class="p">))</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">up</span> <span class="o">/</span> <span class="n">down1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">up</span> <span class="o">/</span> <span class="n">down2</span><span class="p">)</span>

    <span class="c1"># assert that a is the major axis (otherwise swap and correct angle)</span>
    <span class="k">if</span><span class="p">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">):</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>

        <span class="c1"># ensure the angle is betwen 0 and 2*pi</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">fmod</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">xc</span><span class="p">,</span> <span class="n">yc</span><span class="p">,</span> <span class="n">theta</span><span class="p">))</span></div>

<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ndinterp1"><a class="viewcode-back" href="../../../../utils.html#luxpy.utils.math.ndinterp1">[docs]</a><span class="k">def</span> <span class="nf">ndinterp1</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform n-dimensional linear interpolation using Delaunay triangulation.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :X: </span>
<span class="sd">            | ndarray with n-dimensional coordinates (last axis represents dimension).</span>
<span class="sd">        :Y: </span>
<span class="sd">            | ndarray with values at coordinates in X.</span>
<span class="sd">        :Xnew: </span>
<span class="sd">            | ndarray of new coordinates (last axis represents dimension).</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        :Ynew:</span>
<span class="sd">            | ndarray with new values at coordinates in Xnew.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#get dimensions:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">Xnew</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># create an object with triangulation</span>
    <span class="n">tri</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">Delaunay</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> 
    <span class="c1"># find simplexes that contain interpolated points</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">tri</span><span class="o">.</span><span class="n">find_simplex</span><span class="p">(</span><span class="n">Xnew</span><span class="p">)</span>
    <span class="c1"># get the vertices for each simplex</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">tri</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
    <span class="c1"># get transform matrices for each simplex (see explanation bellow)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">tri</span><span class="o">.</span><span class="n">transform</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
    <span class="c1"># for each interpolated point p, mutliply the transform matrix by </span>
    <span class="c1"># vector p-r, where r=m[:,n,:] is one of the simplex vertices to which </span>
    <span class="c1"># the matrix m is related to (again, see bellow)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,ik-&gt;ij&#39;</span><span class="p">,</span> <span class="n">m</span><span class="p">[:,:</span><span class="n">n</span><span class="p">,:</span><span class="n">n</span><span class="p">],</span> <span class="n">Xnew</span><span class="o">-</span><span class="n">m</span><span class="p">[:,</span><span class="n">n</span><span class="p">,:])</span>
    
    <span class="c1"># get the weights for the vertices; `b` contains an n-dimensional vector</span>
    <span class="c1"># with weights for all but the last vertices of the simplex</span>
    <span class="c1"># (note that for n-D grid, each simplex consists of n+1 vertices);</span>
    <span class="c1"># the remaining weight for the last vertex can be copmuted from</span>
    <span class="c1"># the condition that sum of weights must be equal to 1</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">b</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
    
    <span class="c1"># interpolate:</span>
    <span class="k">if</span> <span class="n">Y</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">Ynew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,ij-&gt;ik&#39;</span><span class="p">,</span> <span class="n">Y</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">w</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Ynew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,ij-&gt;i&#39;</span><span class="p">,</span> <span class="n">Y</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">w</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">Ynew</span></div>
    
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Kevin A.G. Smet

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>