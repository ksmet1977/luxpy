

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>luxpy.math.basics &mdash; LuxPy 1.12.5 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=a687bbd5"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            LuxPy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License: GPLv3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../required_packages.html">Imported (required) packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../luxpy_structure.html">Luxpy package structure</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">LuxPy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">luxpy.math.basics</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for luxpy.math.basics</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">########################################################################</span>
<span class="c1"># &lt;LUXPY: a Python package for lighting and color science.&gt;</span>
<span class="c1"># Copyright (C) &lt;2017&gt;  &lt;Kevin A.G. Smet&gt; (ksmet1977 at gmail.com)</span>
<span class="c1">#</span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#########################################################################</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module with useful basic math functions</span>
<span class="sd">=======================================</span>

<span class="sd"> :normalize_3x3_matrix(): Normalize 3x3 matrix M to xyz0 -- &gt; [1,1,1]</span>

<span class="sd"> :line_intersect(): | Line intersections of series of two line segments a and b. </span>
<span class="sd">                    | https://stackoverflow.com/questions/3252194/numpy-and-line-intersections</span>

<span class="sd"> :positive_arctan(): Calculates the positive angle (0°-360° or 0 - 2*pi rad.) </span>
<span class="sd">                     from x and y.</span>

<span class="sd"> :dot23(): Dot product of a 2-d ndarray </span>
<span class="sd">           with a (N x K x L) 3-d ndarray using einsum().</span>

<span class="sd"> :check_symmetric(): Checks if A is symmetric.</span>

<span class="sd"> :check_posdef(): Checks positive definiteness of a matrix via Cholesky.</span>

<span class="sd"> :symmM_to_posdefM(): | Converts a symmetric matrix to a positive definite one. </span>
<span class="sd">                      | Two methods are supported:</span>
<span class="sd">                      |    * &#39;make&#39;: A Python/Numpy port of Muhammad Asim Mubeen&#39;s</span>
<span class="sd">                      |              matlab function Spd_Mat.m </span>
<span class="sd">                      |       (https://nl.mathworks.com/matlabcentral/fileexchange/45873-positive-definite-matrix)</span>
<span class="sd">                      |    * &#39;nearest&#39;: A Python/Numpy port of John D&#39;Errico&#39;s </span>
<span class="sd">                      |                &#39;nearestSPD&#39; MATLAB code. </span>
<span class="sd">                      |        (https://stackoverflow.com/questions/43238173/python-convert-matrix-to-positive-semi-definite)</span>

<span class="sd"> :bvgpdf(): Evaluate bivariate Gaussian probability density function (BVGPDF) </span>
<span class="sd">            at (x,y) with center mu and inverse covariance matric, sigmainv.</span>

<span class="sd"> :mahalanobis2(): Evaluate the squared mahalanobis distance with center mu and </span>
<span class="sd">                  shape and orientation determined by sigmainv. </span>

<span class="sd"> :rms(): Calculates root-mean-square along axis.</span>

<span class="sd"> :geomean(): Calculates geometric mean along axis.</span>

<span class="sd"> :polyarea(): | Calculates area of polygon. </span>
<span class="sd">              | (First coordinate should also be last)</span>

<span class="sd"> :erf(), erfinv(): erf-function and its inverse, imported from scipy.special</span>

<span class="sd"> :cart2pol(): Converts Cartesian to polar coordinates.</span>

<span class="sd"> :pol2cart(): Converts polar to Cartesian coordinates.</span>
<span class="sd"> </span>
<span class="sd"> :cart2spher(): Converts Cartesian to spherical coordinates.</span>
<span class="sd"> </span>
<span class="sd"> :spher2cart(): Converts spherical to Cartesian coordinates.</span>

<span class="sd"> :magnitude_v():  Calculates magnitude of vector.</span>

<span class="sd"> :angle_v1v2():  Calculates angle between two vectors.</span>

<span class="sd"> :histogram(): | Histogram function that can take as bins either the center</span>
<span class="sd">               | (cfr. matlab hist) or bin-edges.</span>

<span class="sd"> :v_to_cik(): Calculate 2x2 &#39;(covariance matrix)^-1&#39; elements cik from v-format ellipse descriptor.</span>

<span class="sd"> :cik_to_v(): Calculate v-format ellipse descriptor from 2x2 &#39;covariance matrix&#39;^-1 cik.</span>
<span class="sd"> </span>
<span class="sd"> :fmod(): Floating point modulus, e.g.: fmod(theta, np.pi * 2) would keep an angle in [0, 2pi]b</span>
<span class="sd"> </span>
<span class="sd"> :remove_outliers(): Remove multivariate outliers from data when outside of alpha-level confidence ellipsoid.</span>

<span class="sd"> :fit_ellipse(): Fit an ellipse to supplied data points.</span>
<span class="sd"> </span>
<span class="sd"> :fit_cov_ellipse(): Fit an covariance ellipse to supplied data points.</span>
<span class="sd"> </span>
<span class="sd"> :interp1_sprague5(): Perform a 1-dimensional 5th order Sprague interpolation.</span>
<span class="sd"> </span>
<span class="sd"> :interp1_sprague_cie224_2017(): Perform a 1-dimensional Sprague interpolation according to CIE-224-2017 (Rf calculation).</span>

<span class="sd"> :interp1_lagrange(): Perform a 1-dimensional k-th order Lagrange interpolation.</span>
<span class="sd"> </span>
<span class="sd"> :linterp():  Perform a 1-dimensional linear interpolation (wrapper around numpy.interp1 with added linear extrapolation).</span>
<span class="sd"> </span>
<span class="sd"> :interp1(): Perform a 1-dimensional linear interpolation (wrapper around scipy.interpolate.InterpolatedUnivariateSpline, scipy.interpolate.interp1d and numpy based linterp).</span>
<span class="sd"> </span>
<span class="sd"> :ndinterp1(): Perform n-dimensional interpolation using Delaunay triangulation.</span>
<span class="sd"> </span>
<span class="sd"> :ndinterp1_scipy(): Perform n-dimensional interpolation using Delaunay triangulation (wrapper around scipy.interpolate.LinearNDInterpolator)</span>
<span class="sd"> </span>
<span class="sd"> :box_m(): Performs a Box M test on covariance matrices.</span>
<span class="sd"> </span>
<span class="sd"> :pitman_morgan(): Pitman-Morgan Test for the difference between correlated variances with paired samples.</span>
<span class="sd">     </span>
<span class="sd"> :stress(): Calculate STandardize-Residual-Sum-of-Squares (STRESS)</span>
<span class="sd"> </span>
<span class="sd"> :stress_F_test(): Perform F-test on significance of difference between STRESS A and STRESS B.</span>
<span class="sd"> </span>
<span class="sd"> :mean_distance_weighted(): Recursively calculates distance weighted mean.</span>
<span class="sd"> </span>
<span class="sd"> :round(): Round x (int, float, ndarray or tuple) to n significant digits, or n decimals (&#39;to nearest even&#39; or &#39;halfway from zero&#39;).</span>
<span class="sd"> </span>
<span class="sd">.. codeauthor:: Kevin A.G. Smet (ksmet1977 at gmail.com)</span>
<span class="sd">===============================================================================</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">luxpy.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">np2d</span><span class="p">,</span> <span class="n">_EPS</span><span class="p">,</span> <span class="n">asplit</span>
<span class="c1"># from scipy import stats # has become a lazy import</span>

<span class="n">__all__</span>  <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;normalize_3x3_matrix&#39;</span><span class="p">,</span><span class="s1">&#39;symmM_to_posdefM&#39;</span><span class="p">,</span><span class="s1">&#39;check_symmetric&#39;</span><span class="p">,</span> <span class="s1">&#39;in_hull&#39;</span><span class="p">,</span>
            <span class="s1">&#39;check_posdef&#39;</span><span class="p">,</span><span class="s1">&#39;positive_arctan&#39;</span><span class="p">,</span><span class="s1">&#39;line_intersect&#39;</span><span class="p">,</span><span class="s1">&#39;erf&#39;</span><span class="p">,</span> <span class="s1">&#39;erfinv&#39;</span><span class="p">,</span> 
            <span class="s1">&#39;histogram&#39;</span><span class="p">,</span> <span class="s1">&#39;pol2cart&#39;</span><span class="p">,</span> <span class="s1">&#39;cart2pol&#39;</span><span class="p">,</span> <span class="s1">&#39;spher2cart&#39;</span><span class="p">,</span> <span class="s1">&#39;cart2spher&#39;</span><span class="p">]</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;bvgpdf&#39;</span><span class="p">,</span><span class="s1">&#39;mahalanobis2&#39;</span><span class="p">,</span><span class="s1">&#39;dot23&#39;</span><span class="p">,</span> <span class="s1">&#39;rms&#39;</span><span class="p">,</span><span class="s1">&#39;geomean&#39;</span><span class="p">,</span><span class="s1">&#39;polyarea&#39;</span><span class="p">]</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;magnitude_v&#39;</span><span class="p">,</span><span class="s1">&#39;angle_v1v2&#39;</span><span class="p">]</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;v_to_cik&#39;</span><span class="p">,</span> <span class="s1">&#39;cik_to_v&#39;</span><span class="p">,</span> <span class="s1">&#39;fmod&#39;</span><span class="p">,</span> <span class="s1">&#39;remove_outliers&#39;</span><span class="p">,</span><span class="s1">&#39;fit_ellipse&#39;</span><span class="p">,</span><span class="s1">&#39;fit_cov_ellipse&#39;</span><span class="p">]</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;linterp&#39;</span><span class="p">,</span><span class="s1">&#39;interpolatedunivariatespline&#39;</span><span class="p">,</span> <span class="s1">&#39;interp1_sprague5&#39;</span><span class="p">,</span><span class="s1">&#39;interp1_sprague_cie224_2017&#39;</span><span class="p">,</span><span class="s1">&#39;interp1_lagrange&#39;</span><span class="p">,</span> <span class="s1">&#39;interp1&#39;</span><span class="p">,</span> <span class="s1">&#39;ndinterp1&#39;</span><span class="p">,</span><span class="s1">&#39;ndinterp1_scipy&#39;</span><span class="p">]</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;box_m&#39;</span><span class="p">,</span><span class="s1">&#39;pitman_morgan&#39;</span><span class="p">,</span> <span class="s1">&#39;stress&#39;</span><span class="p">,</span><span class="s1">&#39;stress_F_test&#39;</span><span class="p">,</span><span class="s1">&#39;mean_distance_weighted&#39;</span><span class="p">,</span><span class="s1">&#39;round&#39;</span><span class="p">]</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;_interpolate_with_nans&#39;</span><span class="p">,</span> <span class="s1">&#39;_extrap_y&#39;</span><span class="p">]</span>


<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="erf">
<a class="viewcode-back" href="../../../math.html#luxpy.math.erf">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">erf</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    erf(x, /, out=None, *, where=True, casting=&#39;same_kind&#39;, order=&#39;K&#39;, dtype=None, subok=True[, signature, extobj])</span>
<span class="sd">    erf(z) Returns the error function of complex argument.</span>
<span class="sd">    </span>
<span class="sd">    It is defined as ``2/sqrt(pi)*integral(exp(-t**2), t=0..z)``.</span>
<span class="sd">    Args: </span>
<span class="sd">        :x: </span>
<span class="sd">            | ndarray</span>
<span class="sd">            | Input array.</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :res:</span>
<span class="sd">            | ndarray</span>
<span class="sd">            | The values of the error function at the given points `x`.</span>
<span class="sd">    See Also:</span>
<span class="sd">        | nerfc, erfinv, erfcinv, wofz, erfcx, erfi</span>
<span class="sd">        </span>
<span class="sd">    Notes:</span>
<span class="sd">        1. The cumulative of the unit normal distribution is given by</span>
<span class="sd">        ``Phi(z) = 1/2[1 + erf(z/sqrt(2))]``.</span>
<span class="sd">        </span>
<span class="sd">    References:</span>
<span class="sd">        1. https://en.wikipedia.org/wiki/Error_function</span>
<span class="sd">        2. Milton Abramowitz and Irene A. Stegun, eds.</span>
<span class="sd">        Handbook of Mathematical Functions with Formulas, Graphs, and Mathematical Tables. µ</span>
<span class="sd">        New York: Dover, 1972. http://www.math.sfu.ca/~cbm/aands/page_297.htm </span>
<span class="sd">        3. Steven G. Johnson, Faddeeva W function implementation.</span>
<span class="sd">        http://ab-initio.mit.edu/Faddeeva </span>
<span class="sd">        </span>
<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from scipy import special</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; x = np.linspace(-3, 3)</span>
<span class="sd">        &gt;&gt;&gt; plt.plot(x, special.erf(x))</span>
<span class="sd">        &gt;&gt;&gt; plt.xlabel(&#39;$x$&#39;)</span>
<span class="sd">        &gt;&gt;&gt; plt.ylabel(&#39;$erf(x)$&#39;)</span>
<span class="sd">        &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.special</span><span class="w"> </span><span class="kn">import</span> <span class="n">erf</span> <span class="c1"># lazy import</span>
    <span class="k">return</span> <span class="n">erf</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="erfinv">
<a class="viewcode-back" href="../../../math.html#luxpy.math.erfinv">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">erfinv</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    erfinv(x, /, out=None, *, where=True, casting=&#39;same_kind&#39;, order=&#39;K&#39;, dtype=None, subok=True[, signature, extobj])</span>
<span class="sd">    Inverse of the error function.</span>
<span class="sd">    Computes the inverse of the error function.</span>
<span class="sd">    </span>
<span class="sd">    In the complex domain, there is no unique complex number w satisfying erf(w)=z. </span>
<span class="sd">    This indicates a true inverse function would have multi-value.</span>
<span class="sd">    When the domain restricts to the real, -1 &lt; x &lt; 1, there is a unique real number</span>
<span class="sd">    satisfying erf(erfinv(x)) = x.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :y:</span>
<span class="sd">            | ndarray</span>
<span class="sd">            | Argument at which to evaluate. Domain: [-1, 1]</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :erfinv: </span>
<span class="sd">            | ndarray</span>
<span class="sd">            | The inverse of erf of y, element-wise)</span>
<span class="sd">    </span>
<span class="sd">    See Also:</span>
<span class="sd">        - erf : Error function of a complex argument</span>
<span class="sd">        - erfc : Complementary error function, ``1 - erf(x)``</span>
<span class="sd">        - erfcinv : Inverse of the complementary error function</span>
<span class="sd">        </span>
<span class="sd">    Examples:</span>
<span class="sd">        1) evaluating a float number</span>
<span class="sd">            &gt;&gt;&gt; from scipy import special</span>
<span class="sd">            &gt;&gt;&gt; special.erfinv(0.5)</span>
<span class="sd">            0.4769362762044698</span>
<span class="sd">        2) evaluating an ndarray</span>
<span class="sd">            &gt;&gt;&gt; from scipy import special</span>
<span class="sd">            &gt;&gt;&gt; y = np.linspace(-1.0, 1.0, num=10)</span>
<span class="sd">            &gt;&gt;&gt; special.erfinv(y)</span>
<span class="sd">            array([       -inf, -0.86312307, -0.5407314 , -0.30457019, -0.0987901 ,</span>
<span class="sd">                   0.0987901 ,  0.30457019,  0.5407314 ,  0.86312307,         inf])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.special</span><span class="w"> </span><span class="kn">import</span> <span class="n">erfinv</span> <span class="c1"># lazy import</span>
    <span class="k">return</span> <span class="n">erfinv</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="normalize_3x3_matrix">
<a class="viewcode-back" href="../../../math.html#luxpy.math.normalize_3x3_matrix">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">normalize_3x3_matrix</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">xyz0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">]])):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize 3x3 matrix M to xyz0 -- &gt; [1,1,1]</span>
<span class="sd">    </span>
<span class="sd">    | If M.shape == (1,9): M is reshaped to (3,3)</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :M: </span>
<span class="sd">            | ndarray((3,3) or ndarray((1,9))</span>
<span class="sd">        :xyz0: </span>
<span class="sd">            | 2darray, optional </span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | normalized matrix such that M*xyz0 = [1,1,1]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">9</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">xyz0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagflat</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">xyz0</span><span class="o">.</span><span class="n">T</span><span class="p">))),</span><span class="n">M</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagflat</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">xyz0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">))),</span><span class="n">M</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xyz0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">xyz0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span></div>


<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="line_intersect">
<a class="viewcode-back" href="../../../math.html#luxpy.math.line_intersect">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">line_intersect</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Line intersections of series of two line segments a and b. </span>
<span class="sd">        </span>
<span class="sd">    Args:</span>
<span class="sd">        :a1: </span>
<span class="sd">            | ndarray (.shape  = (N,2)) specifying end-point 1 of line a</span>
<span class="sd">        :a2: </span>
<span class="sd">            | ndarray (.shape  = (N,2)) specifying end-point 2 of line a</span>
<span class="sd">        :b1: </span>
<span class="sd">            | ndarray (.shape  = (N,2)) specifying end-point 1 of line b</span>
<span class="sd">        :b2: </span>
<span class="sd">            | ndarray (.shape  = (N,2)) specifying end-point 2 of line b</span>
<span class="sd">    </span>
<span class="sd">    Note: </span>
<span class="sd">        N is the number of line segments a and b.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | ndarray with line-intersections (.shape = (N,2))</span>
<span class="sd">    </span>
<span class="sd">    References:</span>
<span class="sd">        1. https://stackoverflow.com/questions/3252194/numpy-and-line-intersections</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]])</span>
    <span class="n">da</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">a2</span> <span class="o">-</span> <span class="n">a1</span><span class="p">)</span>
    <span class="n">db</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">b2</span> <span class="o">-</span> <span class="n">b1</span><span class="p">)</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">a1</span> <span class="o">-</span> <span class="n">b1</span><span class="p">)</span>
    <span class="n">dap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dap</span> <span class="o">*</span> <span class="n">db</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dap</span> <span class="o">*</span> <span class="n">dp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">num</span> <span class="o">/</span> <span class="n">denom</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">db</span> <span class="o">+</span> <span class="n">b1</span></div>


<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="positive_arctan">
<a class="viewcode-back" href="../../../math.html#luxpy.math.positive_arctan">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">positive_arctan</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="n">htype</span> <span class="o">=</span> <span class="s1">&#39;deg&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate positive angle (0°-360° or 0 - 2*pi rad.) from x and y.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :x: </span>
<span class="sd">            | ndarray of x-coordinates</span>
<span class="sd">        :y: </span>
<span class="sd">            | ndarray of y-coordinates</span>
<span class="sd">        :htype:</span>
<span class="sd">            | &#39;deg&#39; or &#39;rad&#39;, optional</span>
<span class="sd">            |   - &#39;deg&#39;: hue angle between 0° and 360°</span>
<span class="sd">            |   - &#39;rad&#39;: hue angle between 0 and 2pi radians</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | ndarray of positive angles.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">htype</span> <span class="o">==</span> <span class="s1">&#39;deg&#39;</span><span class="p">:</span>
        <span class="n">r2d</span> <span class="o">=</span> <span class="mf">180.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">h360</span> <span class="o">=</span> <span class="mf">360.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">r2d</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">h360</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">r2d</span><span class="p">))</span>
    <span class="n">h</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">h</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">h</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)]</span> <span class="o">+</span> <span class="n">h360</span>
    <span class="k">return</span> <span class="n">h</span></div>



<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="dot23">
<a class="viewcode-back" href="../../../math.html#luxpy.math.dot23">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dot23</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dot product of a 2-d ndarray with a (N x K x L) 3-d ndarray </span>
<span class="sd">    using einsum().</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :A: </span>
<span class="sd">            | ndarray (.shape = (M,N))</span>
<span class="sd">        :B: </span>
<span class="sd">            | ndarray (.shape = (N,K,L))</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | ndarray (.shape = (M,K,L))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">dotAB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,jkl-&gt;ikl&#39;</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">keepdims</span> <span class="o">==</span> <span class="kc">True</span><span class="p">):</span>
            <span class="n">dotAB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">dotAB</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">dotAB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,jk-&gt;ik&#39;</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">keepdims</span> <span class="o">==</span> <span class="kc">True</span><span class="p">):</span>
            <span class="n">dotAB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">dotAB</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            
    <span class="k">return</span> <span class="n">dotAB</span></div>


<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="check_symmetric">
<a class="viewcode-back" href="../../../math.html#luxpy.math.check_symmetric">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">check_symmetric</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1.0e-9</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1.0e-9</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if A is symmetric.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :A: </span>
<span class="sd">            | ndarray</span>
<span class="sd">        :atol:</span>
<span class="sd">            | float, optional</span>
<span class="sd">            | The absolute tolerance parameter (see Notes of numpy.allclose())</span>
<span class="sd">        :rtol:</span>
<span class="sd">            | float, optional</span>
<span class="sd">            | The relative tolerance parameter (see Notes of numpy.allclose())</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | Bool</span>
<span class="sd">            | True: the array is symmetric within the given tolerance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="n">rtol</span><span class="p">)</span></div>



<div class="viewcode-block" id="check_posdef">
<a class="viewcode-back" href="../../../math.html#luxpy.math.check_posdef">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">check_posdef</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1.0e-9</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1.0e-9</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks positive definiteness of a matrix via Cholesky.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :A: </span>
<span class="sd">            | ndarray</span>
<span class="sd">        :atol:</span>
<span class="sd">            | float, optional</span>
<span class="sd">            | The absolute tolerance parameter (see Notes of numpy.allclose())</span>
<span class="sd">        :rtol:</span>
<span class="sd">            | float, optional</span>
<span class="sd">            | The relative tolerance parameter (see Notes of numpy.allclose())</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | Bool</span>
<span class="sd">            | True: the array is positive-definite within the given tolerance</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">atol</span> <span class="o">=</span> <span class="n">atol</span><span class="p">,</span><span class="n">rtol</span> <span class="o">=</span> <span class="n">rtol</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>



<div class="viewcode-block" id="symmM_to_posdefM">
<a class="viewcode-back" href="../../../math.html#luxpy.math.symmM_to_posdefM">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">symmM_to_posdefM</span><span class="p">(</span><span class="n">A</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1.0e-9</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1.0e-9</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;make&#39;</span><span class="p">,</span> <span class="n">forcesymm</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a symmetric matrix to a positive definite one. </span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :A: </span>
<span class="sd">            | ndarray</span>
<span class="sd">        :atol:</span>
<span class="sd">            | float, optional</span>
<span class="sd">            | The absolute tolerance parameter (see Notes of numpy.allclose())</span>
<span class="sd">        :rtol:</span>
<span class="sd">            | float, optional</span>
<span class="sd">            | The relative tolerance parameter (see Notes of numpy.allclose())</span>
<span class="sd">        :method: </span>
<span class="sd">            | &#39;make&#39; or &#39;nearest&#39;, optional (see notes for more info)</span>
<span class="sd">        :forcesymm: </span>
<span class="sd">            | True or False, optional</span>
<span class="sd">            | If A is not symmetric, force symmetry using: </span>
<span class="sd">            |    A = numpy.triu(A) + numpy.triu(A).T - numpy.diag(numpy.diag(A))</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | ndarray with positive-definite matrix.</span>
<span class="sd">        </span>
<span class="sd">    Notes on supported methods:</span>
<span class="sd">        1. `&#39;make&#39;: A Python/Numpy port of Muhammad Asim Mubeen&#39;s matlab function </span>
<span class="sd">        Spd_Mat.m </span>
<span class="sd">        &lt;https://nl.mathworks.com/matlabcentral/fileexchange/45873-positive-definite-matrix&gt;`_</span>
<span class="sd">        2. `&#39;nearest&#39;: A Python/Numpy port of John D&#39;Errico&#39;s `nearestSPD` </span>
<span class="sd">        MATLAB code. </span>
<span class="sd">        &lt;https://stackoverflow.com/questions/43238173/python-convert-matrix-to-positive-semi-definite&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">A</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        
        
        <span class="c1"># Make sure matrix A is symmetric up to a certain tolerance:</span>
        <span class="n">sn</span> <span class="o">=</span> <span class="n">check_symmetric</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="n">rtol</span><span class="p">)</span> 
        <span class="k">if</span> <span class="p">((</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">sn</span> <span class="o">!=</span> <span class="kc">True</span><span class="p">)):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">forcesymm</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)</span>  <span class="o">&amp;</span>  <span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;symmM_to_posdefM(): matrix A not symmetric.&#39;</span><span class="p">)</span>
        
        
        <span class="k">if</span> <span class="n">check_posdef</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="n">rtol</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">A</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;make&#39;</span><span class="p">:</span>

                <span class="c1"># A Python/Numpy port of Muhammad Asim Mubeen&#39;s matlab function Spd_Mat.m</span>
                <span class="c1">#</span>
                <span class="c1"># See: https://nl.mathworks.com/matlabcentral/fileexchange/45873-positive-definite-matrix</span>
                <span class="n">Val</span><span class="p">,</span> <span class="n">Vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> 
                <span class="n">Val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">Val</span><span class="p">)</span>
                <span class="n">Vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">Vec</span><span class="p">)</span>
                <span class="n">Val</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Val</span><span class="o">==</span><span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_EPS</span> <span class="c1">#making zero eigenvalues non-zero</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Val</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">Val</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">Val</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="c1">#making negative eigenvalues positive</span>
                <span class="k">return</span>   <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Vec</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Val</span><span class="p">)</span> <span class="p">,</span> <span class="n">Vec</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
 
            
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;nearest&#39;</span><span class="p">:</span>
                
                 <span class="c1"># A Python/Numpy port of John D&#39;Errico&#39;s `nearestSPD` MATLAB code [1], which</span>
                 <span class="c1"># credits [2].</span>
                 <span class="c1">#</span>
                 <span class="c1"># [1] https://www.mathworks.com/matlabcentral/fileexchange/42885-nearestspd</span>
                 <span class="c1">#</span>
                 <span class="c1"># [2] N.J. Higham, &quot;Computing a nearest symmetric positive semidefinite</span>
                 <span class="c1"># matrix&quot; (1988): https://doi.org/10.1016/0024-3795(88)90223-6</span>
                 <span class="c1">#</span>
                 <span class="c1"># See: https://stackoverflow.com/questions/43238173/python-convert-matrix-to-positive-semi-definite</span>
                
                <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span> <span class="o">+</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>

                <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">V</span><span class="p">))</span>

                <span class="n">A2</span> <span class="o">=</span> <span class="p">(</span><span class="n">B</span> <span class="o">+</span> <span class="n">H</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>

                <span class="n">A3</span> <span class="o">=</span> <span class="p">(</span><span class="n">A2</span> <span class="o">+</span> <span class="n">A2</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>

                <span class="k">if</span> <span class="n">check_posdef</span><span class="p">(</span><span class="n">A3</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="n">rtol</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">A3</span>

                <span class="n">spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">spacing</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
                <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">while</span> <span class="ow">not</span> <span class="n">check_posdef</span><span class="p">(</span><span class="n">A3</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="n">rtol</span><span class="p">):</span>
                    <span class="n">mineig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">A3</span><span class="p">)))</span>
                    <span class="n">A3</span> <span class="o">+=</span> <span class="n">I</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">mineig</span> <span class="o">*</span> <span class="n">k</span><span class="o">**</span><span class="mf">2.0</span><span class="o">+</span> <span class="n">spacing</span><span class="p">)</span>
                    <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">return</span> <span class="n">A3</span></div>



<span class="c1">#-----------------------------------------------------------------------------</span>
<div class="viewcode-block" id="bvgpdf">
<a class="viewcode-back" href="../../../math.html#luxpy.math.bvgpdf">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">bvgpdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mu</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">sigmainv</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate bivariate Gaussian probability density function (BVGPDF)</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :x: </span>
<span class="sd">            | scalar or list or ndarray (.ndim = 1 or 2) with </span>
<span class="sd">            | x(y)-coordinates at which to evaluate bivariate Gaussian PD.</span>
<span class="sd">        :y: </span>
<span class="sd">            | None or scalar or list or ndarray (.ndim = 1) with </span>
<span class="sd">            | y-coordinates at which to evaluate bivariate Gaussian PD, optional.</span>
<span class="sd">            | If :y: is None, :x: should be a 2d array.</span>
<span class="sd">        :mu: </span>
<span class="sd">            | None or ndarray (.ndim = 2) with center coordinates of </span>
<span class="sd">            | bivariate Gaussian PD, optional. </span>
<span class="sd">            | None defaults to ndarray([0,0]).</span>
<span class="sd">        :sigmainv:</span>
<span class="sd">            | None or ndarray with &#39;inverse covariance matrix&#39;, optional </span>
<span class="sd">            | Determines the shape and orientation of the PD.</span>
<span class="sd">            | None default to numpy.eye(2).</span>
<span class="sd">     </span>
<span class="sd">    Returns:</span>
<span class="sd">         :returns:</span>
<span class="sd">             | ndarray with magnitude of BVGPDF(x,y)   </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">mahalanobis2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span> <span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigmainv</span> <span class="o">=</span> <span class="n">sigmainv</span><span class="p">))</span></div>


<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="mahalanobis2">
<a class="viewcode-back" href="../../../math.html#luxpy.math.mahalanobis2">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">mahalanobis2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mu</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">sigmainv</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the squared mahalanobis distance</span>
<span class="sd">    </span>
<span class="sd">    Args: </span>
<span class="sd">        :x: </span>
<span class="sd">            | scalar or list or ndarray (.ndim = 1 or 2) with x(y)-coordinates </span>
<span class="sd">              at which to evaluate the mahalanobis distance squared.</span>
<span class="sd">        :y: </span>
<span class="sd">            | None or scalar or list or ndarray (.ndim = 1) with y-coordinates </span>
<span class="sd">              at which to evaluate the mahalanobis distance squared, optional.</span>
<span class="sd">            | If :y: is None, :x: should be a 2d array.</span>
<span class="sd">        :z: </span>
<span class="sd">            | None or scalar or list or ndarray (.ndim = 1) with z-coordinates </span>
<span class="sd">              at which to evaluate the mahalanobis distance squared, optional.</span>
<span class="sd">            | If :z: is None &amp; :y: is None, then :x: should be a 2d array.</span>
<span class="sd">        :mu: </span>
<span class="sd">            | None or ndarray (.ndim = 1) with center coordinates of the </span>
<span class="sd">              mahalanobis ellipse, optional. </span>
<span class="sd">            | None defaults to zeros(2) or zeros(3).</span>
<span class="sd">        :sigmainv:</span>
<span class="sd">            | None or ndarray with &#39;inverse covariance matrix&#39;, optional </span>
<span class="sd">            | Determines the shape and orientation of the PD.</span>
<span class="sd">            | None default to np.eye(2) or eye(3).</span>
<span class="sd">    Returns:</span>
<span class="sd">         :returns: </span>
<span class="sd">             | ndarray with magnitude of mahalanobis2(x,y[,z])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="mi">2</span>
    
    <span class="k">if</span> <span class="n">mu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sigmainv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sigmainv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    
    <span class="n">x</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">mu</span>
        <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">asplit</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">p</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">asplit</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">mu</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">asplit</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">mu</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># center data on mu </span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">mu</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># center data on mu </span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">mu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># center data on mu </span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">mu</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># center data on mu </span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">-</span> <span class="n">mu</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># center data on mu </span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">mu</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># center data on mu </span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">-</span> <span class="n">mu</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># center data on mu </span>
            
    <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">sigmainv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">sigmainv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">sigmainv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">sigmainv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">sigmainv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">sigmainv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> 
                <span class="n">sigmainv</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">z</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">sigmainv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span>  <span class="mf">2.0</span><span class="o">*</span><span class="n">sigmainv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="n">z</span><span class="p">))</span></div>





<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="rms">
<a class="viewcode-back" href="../../../math.html#luxpy.math.rms">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">rms</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate root-mean-square along axis.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :data: </span>
<span class="sd">            | list of values or ndarray</span>
<span class="sd">        :axis:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | Axis along which to calculate rms.</span>
<span class="sd">        :keepdims:</span>
<span class="sd">            | False or True, optional</span>
<span class="sd">            | Keep original dimensions of array.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | ndarray with rms values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="n">keepdims</span><span class="p">))</span></div>


<span class="c1">#-----------------------------------------------------------------------------</span>
<div class="viewcode-block" id="geomean">
<a class="viewcode-back" href="../../../math.html#luxpy.math.geomean">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">geomean</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate geometric mean along axis.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :data:</span>
<span class="sd">            | list of values or ndarray</span>
<span class="sd">        :axis:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | Axis along which to calculate geomean.</span>
<span class="sd">        :keepdims:</span>
<span class="sd">            | False or True, optional</span>
<span class="sd">            | Keep original dimensions of array.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | ndarray with geomean values. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="n">keepdims</span><span class="p">),</span><span class="mi">1</span><span class="o">/</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span></div>

 
<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="polyarea">
<a class="viewcode-back" href="../../../math.html#luxpy.math.polyarea">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">polyarea</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates area of polygon. </span>
<span class="sd">    </span>
<span class="sd">    | First coordinate should also be last.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :x: </span>
<span class="sd">            | ndarray of x-coordinates of polygon vertices.</span>
<span class="sd">        :y: </span>
<span class="sd">            | ndarray of x-coordinates of polygon vertices.     </span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | float (area or polygon)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">))</span></div>


<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="cart2pol">
<a class="viewcode-back" href="../../../math.html#luxpy.math.cart2pol">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cart2pol</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">htype</span> <span class="o">=</span> <span class="s1">&#39;deg&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert Cartesion to polar coordinates.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :x: </span>
<span class="sd">            | float or ndarray with x-coordinates</span>
<span class="sd">        :y: </span>
<span class="sd">            | None or float or ndarray with x-coordinates, optional</span>
<span class="sd">            | If None, y-coordinates are assumed to be in :x:.</span>
<span class="sd">        :htype:</span>
<span class="sd">            | &#39;deg&#39; or &#39;rad, optional</span>
<span class="sd">            | Output type of theta.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | (float or ndarray of theta, float or ndarray of r) values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">positive_arctan</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="n">htype</span> <span class="o">=</span> <span class="n">htype</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="pol2cart">
<a class="viewcode-back" href="../../../math.html#luxpy.math.pol2cart">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">pol2cart</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">htype</span> <span class="o">=</span> <span class="s1">&#39;deg&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert Cartesion to polar coordinates.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :theta: </span>
<span class="sd">            | float or ndarray with theta-coordinates</span>
<span class="sd">        :r: </span>
<span class="sd">            | None or float or ndarray with r-coordinates, optional</span>
<span class="sd">            | If None, r-coordinates are assumed to be in :theta:.</span>
<span class="sd">        :htype:</span>
<span class="sd">            | &#39;deg&#39; or &#39;rad, optional</span>
<span class="sd">            | Intput type of :theta:.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | (float or ndarray of x, float or ndarray of y) coordinates </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">htype</span> <span class="o">==</span> <span class="s1">&#39;deg&#39;</span><span class="p">:</span>
        <span class="n">d2r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">d2r</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="o">*</span><span class="n">d2r</span>
    <span class="k">return</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span></div>


<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="spher2cart">
<a class="viewcode-back" href="../../../math.html#luxpy.math.spher2cart">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">spher2cart</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">deg</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert spherical to cartesian coordinates.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :theta:</span>
<span class="sd">            | Float, int or ndarray</span>
<span class="sd">            | Angle with positive z-axis.</span>
<span class="sd">        :phi:</span>
<span class="sd">            | Float, int or ndarray</span>
<span class="sd">            | Angle around positive z-axis starting from x-axis.</span>
<span class="sd">        :r:</span>
<span class="sd">            | 1, optional</span>
<span class="sd">            | Float, int or ndarray</span>
<span class="sd">            | radius</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :x, y, z:</span>
<span class="sd">            | tuple of floats, ints or ndarrays</span>
<span class="sd">            | Cartesian coordinates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">deg</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    <span class="n">x</span><span class="o">=</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    <span class="n">y</span><span class="o">=</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    <span class="n">z</span><span class="o">=</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span></div>


<div class="viewcode-block" id="cart2spher">
<a class="viewcode-back" href="../../../math.html#luxpy.math.cart2spher">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cart2spher</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span> <span class="n">deg</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert cartesian to spherical coordinates.</span>
<span class="sd">    </span>
<span class="sd">    Args:        </span>
<span class="sd">        :x, y, z:</span>
<span class="sd">            | tuple of floats, ints or ndarrays</span>
<span class="sd">            | Cartesian coordinates</span>
<span class="sd">    Returns:</span>
<span class="sd">        :theta:</span>
<span class="sd">            | Float, int or ndarray</span>
<span class="sd">            | Angle with positive z-axis.</span>
<span class="sd">        :phi:</span>
<span class="sd">            | Float, int or ndarray</span>
<span class="sd">            | Angle around positive z-axis starting from x-axis.</span>
<span class="sd">        :r:</span>
<span class="sd">            | 1, optional</span>
<span class="sd">            | Float, int or ndarray</span>
<span class="sd">            | radius</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="o">*</span><span class="n">z</span><span class="p">)</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
    <span class="n">phi</span><span class="p">[</span><span class="n">phi</span><span class="o">&lt;</span><span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="n">phi</span><span class="p">[</span><span class="n">phi</span><span class="o">&lt;</span><span class="mf">0.</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">zdr</span> <span class="o">=</span> <span class="n">z</span><span class="o">/</span><span class="n">r</span>
    <span class="n">zdr</span><span class="p">[</span><span class="n">zdr</span> <span class="o">&gt;</span> <span class="mf">1.</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="n">zdr</span><span class="p">[</span><span class="n">zdr</span><span class="o">&lt;-</span><span class="mf">1.</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">zdr</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">deg</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">phi</span> <span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">return</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">r</span>   </div>



<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># magnitude of a vector</span>
<div class="viewcode-block" id="magnitude_v">
<a class="viewcode-back" href="../../../math.html#luxpy.math.magnitude_v">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">magnitude_v</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates magnitude of vector.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :v: </span>
<span class="sd">            | ndarray with vector</span>
<span class="sd"> </span>
<span class="sd">    Returns:</span>
<span class="sd">        :magnitude:</span>
<span class="sd">            | ndarray </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">v</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">magnitude</span></div>



<span class="c1"># angle between vectors</span>
<div class="viewcode-block" id="angle_v1v2">
<a class="viewcode-back" href="../../../math.html#luxpy.math.angle_v1v2">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">angle_v1v2</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="n">htype</span> <span class="o">=</span> <span class="s1">&#39;deg&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates angle between two vectors.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :v1: </span>
<span class="sd">            | ndarray with vector 1</span>
<span class="sd">        :v2: </span>
<span class="sd">            | ndarray with vector 2</span>
<span class="sd">        :htype:</span>
<span class="sd">            | &#39;deg&#39; or &#39;rad&#39;, optional</span>
<span class="sd">            | Requested angle type.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :ang: </span>
<span class="sd">            | ndarray </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="n">magnitude_v</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span><span class="o">*</span><span class="n">magnitude_v</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>
    <span class="n">denom</span><span class="p">[</span><span class="n">denom</span><span class="o">==</span><span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">ang</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v1</span><span class="o">*</span><span class="n">v2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">denom</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">htype</span> <span class="o">==</span> <span class="s1">&#39;deg&#39;</span><span class="p">:</span>
        <span class="n">ang</span> <span class="o">=</span> <span class="n">ang</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">return</span> <span class="n">ang</span></div>

    
<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="histogram">
<a class="viewcode-back" href="../../../math.html#luxpy.math.histogram">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">histogram</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">bin_center</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Histogram function that can take as bins either the center (cfr. matlab hist) or bin-edges.</span>
<span class="sd">    </span>
<span class="sd">    Args: </span>
<span class="sd">        :bin_center:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | False: if :bins: int, str or sequence of scalars:</span>
<span class="sd">            |       default to numpy.histogram (uses bin edges).</span>
<span class="sd">            | True: if :bins: is a sequence of scalars:</span>
<span class="sd">            |         bins (containing centers) are transformed to edges</span>
<span class="sd">            |         and nump.histogram is run. </span>
<span class="sd">            |         Mimicks matlab hist (uses bin centers).</span>
<span class="sd">        </span>
<span class="sd">    Note:</span>
<span class="sd">        For other armuments and output, see ?numpy.histogram</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | ndarray with histogram</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="o">|</span>  <span class="nb">isinstance</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">bin_center</span> <span class="o">==</span> <span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">centers</span> <span class="o">=</span> <span class="n">bins</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">centers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">centers</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span><span class="p">,</span> <span class="n">centers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">edges</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="nb">range</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="n">density</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="nb">range</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="n">density</span><span class="p">)</span></div>

    
<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="v_to_cik">
<a class="viewcode-back" href="../../../math.html#luxpy.math.v_to_cik">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">v_to_cik</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">inverse</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate 2x2 &#39;(covariance matrix)^-1&#39; elements cik </span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :v: </span>
<span class="sd">            | (Nx5) np.ndarray</span>
<span class="sd">            | ellipse parameters [Rmax,Rmin,xc,yc,theta]</span>
<span class="sd">        :inverse:</span>
<span class="sd">            | If True: return inverse of cik.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :cik: </span>
<span class="sd">            | &#39;Nx2x2&#39; (covariance matrix)^-1</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        | cik is not actually a covariance matrix,</span>
<span class="sd">        | only for a Gaussian or normal distribution!</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">g11</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">v</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">v</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">g22</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">v</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">v</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">g12</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">v</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="n">v</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span><span class="mi">4</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span><span class="mi">4</span><span class="p">])</span>
    <span class="n">cik</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">g11</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">g11</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">cik</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">g11</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">g12</span><span class="p">[</span><span class="n">i</span><span class="p">])),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">g12</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">g22</span><span class="p">[</span><span class="n">i</span><span class="p">]))))</span>
        <span class="k">if</span> <span class="n">inverse</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">cik</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">cik</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:])</span>
    <span class="k">return</span> <span class="n">cik</span></div>

<span class="c1">#------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="cik_to_v">
<a class="viewcode-back" href="../../../math.html#luxpy.math.cik_to_v">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cik_to_v</span><span class="p">(</span><span class="n">cik</span><span class="p">,</span> <span class="n">xyc</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">inverse</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate v-format ellipse descriptor from 2x2 &#39;covariance matrix&#39;^-1 cik </span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :cik: </span>
<span class="sd">            | &#39;Nx2x2&#39; (covariance matrix)^-1</span>
<span class="sd">        :inverse:</span>
<span class="sd">            | If True: input is inverse of cik.</span>
<span class="sd">              </span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :v: </span>
<span class="sd">            | (Nx5) np.ndarray</span>
<span class="sd">            | ellipse parameters [Rmax,Rmin,xc,yc,theta]</span>

<span class="sd">    Notes:</span>
<span class="sd">        | cik is not actually the inverse covariance matrix,</span>
<span class="sd">        | only for a Gaussian or normal distribution!</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">cik</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">cik</span> <span class="o">=</span> <span class="n">cik</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">inverse</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cik</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">cik</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">cik</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:])</span>
            
    <span class="n">g11</span> <span class="o">=</span> <span class="n">cik</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">g22</span> <span class="o">=</span> <span class="n">cik</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> 
    <span class="n">g12</span> <span class="o">=</span> <span class="n">cik</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">theta</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">g12</span><span class="p">,(</span><span class="n">g11</span><span class="o">-</span><span class="n">g22</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">g12</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1">#theta = theta2 + (np.pi/2)*(g12&lt;0)</span>
    <span class="c1">#theta2 = theta</span>
    <span class="n">cottheta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="c1">#np.cot(theta)</span>
    <span class="n">cottheta</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">cottheta</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">g22</span> <span class="o">+</span> <span class="n">g12</span><span class="o">*</span><span class="n">cottheta</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">g11</span> <span class="o">-</span> <span class="n">g12</span><span class="o">*</span><span class="n">cottheta</span><span class="p">))</span>

    <span class="c1"># ensure largest ellipse axis is first (correct angle):</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="o">&gt;</span><span class="n">a</span><span class="p">;</span> <span class="n">a</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">theta</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">c</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="n">c</span><span class="p">],</span><span class="n">theta</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">theta</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    
    <span class="c1"># add center coordinates:</span>
    <span class="k">if</span> <span class="n">xyc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">v</span><span class="p">[:,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">xyc</span>
    
    <span class="k">return</span> <span class="n">v</span></div>


<div class="viewcode-block" id="fmod">
<a class="viewcode-back" href="../../../math.html#luxpy.math.fmod">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fmod</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Floating point modulus </span>
<span class="sd">    </span>
<span class="sd">    | e.g., fmod(theta, np.pi * 2) would keep an angle in [0, 2pi]</span>

<span class="sd">    Args:</span>
<span class="sd">        :x:</span>
<span class="sd">            | angle to restrict</span>
<span class="sd">        :y: </span>
<span class="sd">            | end of  interval [0, y] to restrict to</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :r: floating point modulus</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">while</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="n">y</span>
    <span class="k">while</span><span class="p">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="n">y</span>
    <span class="k">return</span> <span class="n">r</span></div>


<div class="viewcode-block" id="remove_outliers">
<a class="viewcode-back" href="../../../math.html#luxpy.math.remove_outliers">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">remove_outliers</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove multivariate outliers from data when outside of alpha-level confidence ellipsoid.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :data:</span>
<span class="sd">            | Nxp ndarray with multivariate data (N samples, p variables)</span>
<span class="sd">        :alpha:</span>
<span class="sd">            | 0.01, optional</span>
<span class="sd">            | Significance level of confidence ellipsoid marking the boundary for outliers.</span>
<span class="sd">            </span>
<span class="sd">    Return:</span>
<span class="sd">        :data:</span>
<span class="sd">            | (N-... x p) ndarray with multivariate data; outliers removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">stats</span> <span class="c1"># lazy import</span>
    
    <span class="c1"># delete outliers:    </span>
    <span class="n">datac</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">cov_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">mahalanobis2</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mu</span> <span class="o">=</span> <span class="n">datac</span><span class="p">,</span> <span class="n">sigmainv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">cov_</span><span class="p">)</span><span class="o">/</span><span class="n">f</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
    <span class="n">datan</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">datan</span> <span class="o">=</span> <span class="n">datan</span><span class="p">[</span><span class="n">D</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">datan</span></div>


<div class="viewcode-block" id="fit_ellipse">
<a class="viewcode-back" href="../../../math.html#luxpy.math.fit_ellipse">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fit_ellipse</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">center_on_mean_xy</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fit an ellipse to supplied data points.</span>

<span class="sd">    Args:</span>
<span class="sd">        :xy: </span>
<span class="sd">            | coordinates of points to fit (Nx2 array)</span>
<span class="sd">        :center_on_mean_xy:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | Center ellipse on mean of xy </span>
<span class="sd">            | (otherwise it might be offset due to solving </span>
<span class="sd">            | the contrained minization problem: aT*S*a, see ref below.)</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :v:</span>
<span class="sd">            | vector with ellipse parameters [Rmax,Rmin, xc,yc, theta (rad.)]</span>
<span class="sd">            </span>
<span class="sd">    Reference:</span>
<span class="sd">        1. Fitzgibbon, A.W., Pilu, M., and Fischer R.B., </span>
<span class="sd">        Direct least squares fitting of ellipsees, </span>
<span class="sd">        Proc. of the 13th Internation Conference on Pattern Recognition, </span>
<span class="sd">        pp 253–257, Vienna, 1996.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># remove centroid:</span>
<span class="c1">#    center = xy.mean(axis=0)</span>
<span class="c1">#    xy = xy - center</span>
    
    <span class="c1"># Fit ellipse:</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span> <span class="n">xy</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
    <span class="n">S</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
    <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">C</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">U</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="n">C</span><span class="p">))</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">U</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
<span class="c1">#    E, V =  np.linalg.eig(np.dot(np.linalg.inv(S), C))</span>
<span class="c1">#    n = np.argmax(np.abs(E))</span>
<span class="c1">#    e = V[:,n]</span>
        
    <span class="c1"># get ellipse axis lengths, center and orientation:</span>
    <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># get ellipse center:</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">xc</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">yc</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xc</span> <span class="o">=</span> <span class="p">((</span><span class="n">c</span> <span class="o">*</span> <span class="n">d</span> <span class="o">-</span> <span class="n">b</span> <span class="o">*</span> <span class="n">f</span><span class="p">)</span> <span class="o">/</span> <span class="n">num</span><span class="p">)</span> 
        <span class="n">yc</span> <span class="o">=</span> <span class="p">((</span><span class="n">a</span> <span class="o">*</span> <span class="n">f</span> <span class="o">-</span> <span class="n">b</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span> <span class="o">/</span> <span class="n">num</span><span class="p">)</span> 
    
    <span class="c1"># get ellipse orientation:</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">b</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">a</span> <span class="o">-</span> <span class="n">c</span><span class="p">)))</span> <span class="o">/</span> <span class="mi">2</span>
<span class="c1">#    if b == 0:</span>
<span class="c1">#        if a &gt; c:</span>
<span class="c1">#            theta = 0</span>
<span class="c1">#        else:</span>
<span class="c1">#            theta = np.pi/2</span>
<span class="c1">#    else:</span>
<span class="c1">#        if a &gt; c:</span>
<span class="c1">#            theta = np.arctan2(2*b,(a-c))/2</span>
<span class="c1">#        else:</span>
<span class="c1">#            theta =  np.arctan2(2*b,(a-c))/2 + np.pi/2</span>
        
    <span class="c1"># axis lengths:</span>
    <span class="n">up</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">f</span> <span class="o">*</span> <span class="n">f</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">d</span> <span class="o">+</span> <span class="n">g</span> <span class="o">*</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">f</span> <span class="o">-</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span> <span class="o">*</span> <span class="n">g</span><span class="p">)</span>
    <span class="n">down1</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">c</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">/</span> <span class="p">((</span><span class="n">a</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">c</span><span class="p">)))</span> <span class="o">-</span> <span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="n">a</span><span class="p">))</span>
    <span class="n">down2</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">a</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">/</span> <span class="p">((</span><span class="n">a</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">c</span><span class="p">)))</span> <span class="o">-</span> <span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="n">a</span><span class="p">))</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">up</span> <span class="o">/</span> <span class="n">down1</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">up</span> <span class="o">/</span> <span class="n">down2</span><span class="p">))</span>


    <span class="c1"># assert that a is the major axis (otherwise swap and correct angle)</span>
    <span class="k">if</span><span class="p">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">):</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
        <span class="c1"># ensure the angle is betwen 0 and 2*pi</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">fmod</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">center_on_mean_xy</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">xc</span><span class="p">,</span><span class="n">yc</span> <span class="o">=</span> <span class="n">xy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">xc</span><span class="p">,</span> <span class="n">yc</span><span class="p">,</span> <span class="n">theta</span><span class="p">))</span></div>



<div class="viewcode-block" id="fit_cov_ellipse">
<a class="viewcode-back" href="../../../math.html#luxpy.math.fit_cov_ellipse">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fit_cov_ellipse</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span> <span class="n">pdf</span> <span class="o">=</span> <span class="s1">&#39;chi2&#39;</span><span class="p">,</span> <span class="n">SE</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                    <span class="n">robust</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">robust_alpha</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fit covariance ellipse to xy data.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :xy: </span>
<span class="sd">            | coordinates of points to fit (Nx2 array)</span>
<span class="sd">        :alpha:</span>
<span class="sd">            | 0.05, optional</span>
<span class="sd">            | alpha significance level </span>
<span class="sd">            | (e.g alpha = 0.05 for 95% confidence ellipse)</span>
<span class="sd">        :pdf:</span>
<span class="sd">            | chi2, optional</span>
<span class="sd">            | - &#39;chi2&#39;: Rescale using Chi2-distribution</span>
<span class="sd">            | - &#39;t&#39;: Rescale using Student t-distribution</span>
<span class="sd">            | - &#39;norm&#39;: Rescale using normal-distribution</span>
<span class="sd">            | - None: don&#39;t rescale using pdf, use alpha as scalefactor (cfr. alpha* 1SD or alpha * 1SE)</span>
<span class="sd">        :SE:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | If false, fit standard error ellipse at alpha significance level</span>
<span class="sd">            | If true, fit standard deviation ellipse at alpha significance level</span>
<span class="sd">        :robust:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | If True: remove outliers beyond the confidence ellipsoid before calculating</span>
<span class="sd">            |          the covariances.</span>
<span class="sd">        :robust_alpha:</span>
<span class="sd">            | 0.01, optional</span>
<span class="sd">            | Significance level of confidence ellipsoid marking the boundary for outliers.</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :v:</span>
<span class="sd">            | vector with ellipse parameters [Rmax,Rmin, xc,yc, theta (rad.)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">stats</span> <span class="c1"># lazy import </span>
    
    <span class="c1"># delete outliers:    </span>
    <span class="k">if</span> <span class="n">robust</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="n">remove_outliers</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">robust_alpha</span><span class="p">)</span>
    
    <span class="n">xyc</span> <span class="o">=</span> <span class="n">xy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">cov_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">xy</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    
    
    <span class="n">cik</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">cov_</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">pdf</span> <span class="o">==</span> <span class="s1">&#39;chi2&#39;</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">,</span> <span class="n">xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">pdf</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">,</span> <span class="n">xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">pdf</span> <span class="o">==</span><span class="s1">&#39;norm&#39;</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">pdf</span> <span class="o">==</span> <span class="s1">&#39;sample&#39;</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">p</span><span class="p">)</span><span class="o">*</span><span class="n">stats</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="n">p</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">alpha</span> <span class="c1">#  -&gt; fraction of Mahalanobis distance</span>
        
    <span class="k">if</span> <span class="n">SE</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">/</span><span class="n">xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
    <span class="n">v</span> <span class="o">=</span> <span class="n">cik_to_v</span><span class="p">(</span><span class="n">cik</span><span class="o">/</span><span class="n">f</span><span class="p">,</span> <span class="n">xyc</span><span class="o">=</span><span class="n">xyc</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">v</span></div>


<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="in_hull">
<a class="viewcode-back" href="../../../math.html#luxpy.math.in_hull">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">in_hull</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">hull</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test if points in `p` are in `hull`</span>

<span class="sd">    Args:</span>
<span class="sd">        :p: </span>
<span class="sd">            | NxK coordinates of N points in K dimensions</span>
<span class="sd">        :hull:</span>
<span class="sd">            | Either a scipy.spatial.Delaunay object or the MxK array of the </span>
<span class="sd">            | coordinates of M points in K dimensions for which Delaunay </span>
<span class="sd">            | triangulation will be computed</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :bool:</span>
<span class="sd">            | boolean ndarray with True for in-gamut and False for out-of-gamut points</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">Delaunay</span> <span class="c1"># lazy import</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hull</span><span class="p">,</span><span class="n">Delaunay</span><span class="p">):</span>
        <span class="n">hull</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="n">hull</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hull</span><span class="o">.</span><span class="n">find_simplex</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">0</span></div>


<span class="c1"># #------------------------------------------------------------------------------</span>
<span class="c1"># _SPRAGUE_COEFFICIENTS = np.array([</span>
                                 <span class="c1"># [884, -1960, 3033, -2648, 1080, -180],</span>
                                 <span class="c1"># [508, -540, 488, -367, 144, -24],</span>
                                 <span class="c1"># [-24, 144, -367, 488, -540, 508],</span>
                                 <span class="c1"># [-180, 1080, -2648, 3033, -1960, 884],</span>
                                 <span class="c1"># ]).T / 209.0</span>
<span class="c1"># def interp1_sprague5(x, y, xn, extrap = (np.nan, np.nan), scipy_interpolator = &#39;interp1d&#39;):</span>
    <span class="c1"># &quot;&quot;&quot; </span>
    <span class="c1"># Perform a 1-dimensional 5th order Sprague interpolation.</span>
    
    <span class="c1"># Args:</span>
        <span class="c1"># :x:</span>
            <span class="c1"># | ndarray with n-dimensional coordinates.</span>
        <span class="c1"># :y: </span>
            <span class="c1"># | ndarray with values at coordinates in x.</span>
        <span class="c1"># :xn:</span>
            <span class="c1"># | ndarray of new coordinates.</span>
        <span class="c1"># :extrap:</span>
            <span class="c1"># | (np.nan, np.nan) or string, optional</span>
            <span class="c1"># | If tuple: fill with values in tuple (&lt;x[0],&gt;x[-1])</span>
            <span class="c1"># | If string:  (&#39;zeros&#39;,&#39;linear&#39;, &#39;nearest&#39;, &#39;nearest-up&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;, &#39;previous&#39;,&#39;next&#39;)</span>
            <span class="c1"># |           for more info on the other options see: scipy.interpolate.interp1d?</span>
    <span class="c1"># Returns:</span>
        <span class="c1"># :yn:</span>
            <span class="c1"># | ndarray with values at new coordinates in xn.</span>
    <span class="c1"># &quot;&quot;&quot;</span>
    <span class="c1"># # Do extrapolation:</span>
    <span class="c1"># if ((xn&lt;x[0]) | (xn&gt;x[-1])).any(): # extrapolation needed !</span>
        <span class="c1"># if isinstance(extrap,tuple):</span>
            <span class="c1"># if extrap[0] == extrap[1]: </span>
                <span class="c1"># yne = np.ones((y.shape[0],len(xn)))*extrap[0]</span>
            <span class="c1"># else:</span>
                <span class="c1"># yne = np.zeros((y.shape[0],len(xn)))</span>
                <span class="c1"># yne[:,(xn&lt;x[0])] = extrap[0]</span>
                <span class="c1"># yne[:,(xn&gt;x[-1])] = extrap[1]</span>
        <span class="c1"># elif isinstance(extrap,str):</span>
            <span class="c1"># #from scipy.interpolate import interp1d # lazy import</span>
            <span class="c1"># #yne = interp1d(x, y, kind = extrap, bounds_error = False, fill_value = &#39;extrapolate&#39;)(xn)</span>
            <span class="c1"># yne = interp1(x, y, xn, kind = extrap, ext = &#39;extrapolate&#39;, scipy_interpolator = scipy_interpolator)</span>
        <span class="c1"># else:</span>
            <span class="c1"># raise Exception(&#39;Invalid option for extrap argument. Only tuple and string allowed.&#39;)</span>
        <span class="c1"># xn_x = xn[(xn&gt;=x[0]) &amp; (xn&lt;=x[-1])]</span>
    <span class="c1"># else:</span>
        <span class="c1"># xn_x = xn</span>
        <span class="c1"># yne = None</span>
     
    <span class="c1"># # Check equal x-spacing:</span>
    <span class="c1"># dx = np.diff(x)</span>
    <span class="c1"># if np.all(dx == dx[0]):</span>
        <span class="c1"># dx = dx[0] </span>
    <span class="c1"># else:</span>
        <span class="c1"># raise Exception(&#39;Elements in x are not equally spaced!&#39;)</span>
        
    <span class="c1"># # Extrapolate x, y with required additional elements for Sprague to work:</span>
    <span class="c1"># xe = np.hstack((x[0] - 2*dx, x[0] - dx, x, x[-1] + dx, x[-1] + 2*dx))</span>
    
    <span class="c1"># y = np.atleast_2d(y)</span>
    <span class="c1"># ye1 = (y[:, :6] @ _SPRAGUE_COEFFICIENTS[:,0])[:,None]</span>
    <span class="c1"># ye2 = (y[:, :6] @ _SPRAGUE_COEFFICIENTS[:,1])[:,None]</span>
    <span class="c1"># ye3 = (y[:,-6:] @ _SPRAGUE_COEFFICIENTS[:,2])[:,None]</span>
    <span class="c1"># ye4 = (y[:,-6:] @ _SPRAGUE_COEFFICIENTS[:,3])[:,None]</span>
    <span class="c1"># ye = np.hstack((ye1,ye2,y,ye3,ye4)).T</span>
    
    
    <span class="c1"># # Evaluate at xn_x (no extrapolation!!):</span>
    <span class="c1"># i = np.searchsorted(xe, xn_x) - 1</span>
    <span class="c1"># X = np.atleast_2d((xn_x - xe[i]) / (xe[i + 1] - xe[i])).T</span>

    <span class="c1"># a0 = ye[i]</span>
    <span class="c1"># a1 = ((2 * ye[i - 2] - 16 * ye[i - 1] + 16 * ye[i + 1] - 2 * ye[i + 2]) / 24)  </span>
    <span class="c1"># a2 = ((-ye[i - 2] + 16 * ye[i - 1] - 30 * ye[i] + 16 * ye[i + 1] - ye[i + 2]) / 24) </span>
    <span class="c1"># a3 = ((-9 * ye[i - 2] + 39 * ye[i - 1] - 70 * ye[i] + 66 * ye[i + 1] - 33 * ye[i + 2] + 7 * ye[i + 3]) / 24)</span>
    <span class="c1"># a4 = ((13 * ye[i - 2] - 64 * ye[i - 1] + 126 * ye[i] - 124 * ye[i + 1] + 61 * ye[i + 2] - 12 * ye[i + 3]) / 24)</span>
    <span class="c1"># a5 = ((-5 * ye[i - 2] + 25 * ye[i - 1] - 50 * ye[i] + 50 * ye[i + 1] - 25 * ye[i + 2] + 5 * ye[i + 3]) / 24)</span>

    <span class="c1"># yn = (a0 + a1*X + a2*X**2 + a3*X**3 + a4*X**4 + a5*X**5).T</span>
    
    <span class="c1"># if yne is None:</span>
        <span class="c1"># return yn</span>
    <span class="c1"># else:</span>
        <span class="c1"># yne[:,(xn&gt;=x[0]) &amp; (xn&lt;=x[-1])] = yn</span>
        <span class="c1"># return yne</span>

<span class="c1"># #------------------------------------------------------------------------------</span>
<span class="c1"># def interp1(X,Y,Xnew, kind = &#39;linear&#39;, ext = &#39;extrapolate&#39;, fill_value = &#39;extrapolate&#39;, </span>
            <span class="c1"># force_scipy_interpolator = False, scipy_interpolator = &#39;interp1d&#39;,</span>
            <span class="c1"># w = None, bbox=[None, None], check_finite = False):</span>
    <span class="c1"># &quot;&quot;&quot;</span>
    <span class="c1"># Perform a 1-dimensional interpolation </span>
    <span class="c1"># (wrapper around scipy.interpolate.InterpolatedUnivariateSpline, scipy.interpolate.interp1d and numpy.interp).</span>
    
    <span class="c1"># Args:</span>
        <span class="c1"># :X: </span>
            <span class="c1"># | ndarray with n-dimensional coordinates (last axis represents dimension)</span>
        <span class="c1"># :Y: </span>
            <span class="c1"># | ndarray with values at coordinates in X</span>
        <span class="c1"># :Xnew: </span>
            <span class="c1"># | ndarray of new coordinates (last axis represents dimension)</span>
        <span class="c1"># :kind:</span>
            <span class="c1"># | str or int,  optional</span>
            <span class="c1"># | supported options for str: &#39;linear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
        <span class="c1"># :ext:</span>
            <span class="c1"># | &#39;extrapolate&#39;, optional</span>
            <span class="c1"># | options: </span>
            <span class="c1"># |   - &#39;extrapolate&#39;</span>
            <span class="c1"># |   - &#39;zeros&#39;: out-of-bounds values are filled with zeros</span>
            <span class="c1"># |   - &#39;const&#39;: out-of-bounds values are filled with nearest value</span>
            <span class="c1"># |   - &#39;fill_value&#39;: value of tuple (2,) of values is used to fill out-of-bounds values</span>
        <span class="c1"># :fill_value:</span>
            <span class="c1"># | &#39;extrpolate&#39; or float or int or tupple, optional</span>
            <span class="c1"># | If ext == &#39;fill_value&#39;: use fill_value to set lower- and upper-out-of-bounds values when extrapolating</span>
        <span class="c1"># :force_scipy_interpolator:</span>
            <span class="c1"># | False, optional</span>
            <span class="c1"># | If False: numpy.interp function is used for linear interpolation when no extrapolation is used/required (fast!). </span>
        <span class="c1"># :scipy_interpolator:</span>
            <span class="c1"># | &#39;interp1d&#39;, optional</span>
            <span class="c1"># | options: [&#39;InterpolatedUnivariateSpline&#39;, &#39;interp1d&#39;] (or 0 or 1)</span>
        <span class="c1"># :other args:</span>
            <span class="c1"># | see scipy.interpolate.InterpolatedUnivariateSpline()</span>
        
    <span class="c1"># Returns:</span>
        <span class="c1"># :Ynew:</span>
            <span class="c1"># | ndarray with new values at coordinates in Xnew</span>
    
    <span class="c1"># Note:</span>
        <span class="c1"># 1. &#39;numpy.interp&#39; is fastest (but only works for linear interpolation without extrapolation)</span>
        <span class="c1"># 2. For linear interpolation: &#39;interp1d&#39; is faster for Y (N,...) with N &gt; 1, else &#39;InterpolatedUnivariateSpline&#39; is faster</span>
        <span class="c1"># 3. For &#39;cubic&#39; interpolation: &#39;InterpolatedUnivariateSpline&#39; is faster for Y (N,...) with N &gt; 1, else &#39;interp1d&#39; is faster</span>
    <span class="c1"># &quot;&quot;&quot;</span>
    
    <span class="c1"># if X.ndim == 2: X = X[0]</span>
    <span class="c1"># if Xnew.ndim == 2: Xnew = Xnew[0]</span>
    
    <span class="c1"># # avoid interpolation/extrapolation if none is needed:</span>
    <span class="c1"># if np.array_equal(X,Xnew): return Y</span>
    
    <span class="c1"># if isinstance(scipy_interpolator,int): scipy_interpolator = [&#39;InterpolatedUnivariateSpline&#39;, &#39;interp1d&#39;][scipy_interpolator]</span>
    <span class="c1"># if isinstance(kind,str):</span>
        <span class="c1"># if kind == &#39;nearest&#39;: kind, ext = &#39;linear&#39;, &#39;const&#39;</span>
        <span class="c1"># if scipy_interpolator == &#39;InterpolatedUnivariateSpline&#39;: </span>
            <span class="c1"># k = [&#39;linear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;, &#39;quartic&#39;, &#39;quintic&#39;].index(kind) + 1</span>
        <span class="c1"># else:</span>
            <span class="c1"># k = [&#39;zero&#39;, &#39;linear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;].index(kind) </span>
    <span class="c1"># else:</span>
        <span class="c1"># k = kind</span>
    <span class="c1"># if ext == &#39;nearest&#39;: ext = &#39;const&#39;</span>
    
    <span class="c1"># if (k == 1) &amp; (force_scipy_interpolator == False):</span>
        <span class="c1"># if (((((ext == &#39;const&#39;) | (ext == 3) | (ext == &#39;zeros&#39;) | (ext == 1))) | </span>
            <span class="c1"># ((ext == &#39;fill_value&#39;) &amp; (not (fill_value == &#39;extrapolate&#39;)))) |</span>
            <span class="c1"># ((Xnew[0] &gt;= X[0]) &amp; (Xnew[-1] &lt;= (X[-1])))):</span>
            <span class="c1"># if ((ext == &#39;zeros&#39;) | (ext == 1)):</span>
                <span class="c1"># (left, right) = (0.0,0.0) </span>
            <span class="c1"># elif ((ext == &#39;const&#39;) | (ext == 3)): </span>
                <span class="c1"># (left, right) = (None, None)</span>
            <span class="c1"># elif ((ext == &#39;fill_value&#39;)):</span>
                <span class="c1"># if isinstance(fill_value, (float,int)): </span>
                    <span class="c1"># fill_value = (fill_value, fill_value) </span>
                <span class="c1"># (left,right) = fill_value</span>
            <span class="c1"># else:</span>
                <span class="c1"># (left, right) = (None, None)</span>

            <span class="c1"># if Y.ndim == 1:</span>
                <span class="c1"># return np.interp(Xnew, X, Y, left = left, right = right)</span>
            <span class="c1"># else:</span>
                <span class="c1"># return np.array([np.interp(Xnew, X, Y[i], left = left, right = right) for i in range(Y.shape[0])])</span>
    
    <span class="c1"># from scipy import interpolate # lazy import</span>
    <span class="c1"># if scipy_interpolator == &#39;InterpolatedUnivariateSpline&#39;:</span>
        <span class="c1"># ext_original = ext</span>
        <span class="c1"># if ext == &#39;fill_value&#39;:</span>
            <span class="c1"># ext = &#39;extrapolate&#39;</span>
        <span class="c1"># if Y.ndim == 1:</span>
            <span class="c1"># Yn = interpolate.InterpolatedUnivariateSpline(X,Y, ext = ext, k = k, w = w, bbox = bbox, check_finite = check_finite)(Xnew)</span>
        <span class="c1"># else:</span>
           <span class="c1"># Yn = np.array([interpolate.InterpolatedUnivariateSpline(X,Y[i], ext = ext, k = k, w = w, bbox = bbox, check_finite = check_finite)(Xnew) for i in range(Y.shape[0])])</span>
        <span class="c1"># if (ext_original == &#39;fill_value&#39;) &amp; (not (fill_value == &#39;extrapolate&#39;)):</span>
            <span class="c1"># if isinstance(fill_value, (float,int)): fill_value = (fill_value, fill_value)</span>
            <span class="c1"># Yn[:,Xnew &lt; X[0]] = fill_value[0]</span>
            <span class="c1"># Yn[:,Xnew &gt; X[-1]] = fill_value[1]</span>
        <span class="c1"># return Yn</span>
            
    <span class="c1"># else:</span>
        <span class="c1"># if ((ext == &#39;extrapolate&#39;) | (ext == 0)): </span>
            <span class="c1"># fill_value = &#39;extrapolate&#39;</span>
        <span class="c1"># elif ((ext == &#39;zeros&#39;) | (ext == 1)):</span>
            <span class="c1"># fill_value = (0.0,0.0) </span>
        <span class="c1"># elif ((ext == &#39;const&#39;) | (ext == 3)):</span>
            <span class="c1"># fill_value = (Y[...,0], Y[...,-1])</span>
        <span class="c1"># elif ((ext == &#39;fill_value&#39;)):</span>
            <span class="c1"># if isinstance(fill_value, (float,int)): fill_value = (fill_value, fill_value) </span>
        <span class="c1"># return interpolate.interp1d(X, Y, kind = k, bounds_error = False, fill_value = fill_value)(Xnew)</span>

<span class="c1">#------------------------------------------------------------------------------</span>

<span class="c1">#------------------------------------------------------------------------------</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_use_log</span><span class="p">(</span><span class="n">use_log</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">use_log</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span> 
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">Y</span><span class="p">,</span><span class="n">Yi</span><span class="p">:</span> <span class="n">Yi</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">,</span><span class="n">f</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span>  <span class="k">lambda</span> <span class="n">Y</span><span class="p">,</span><span class="n">Yi</span><span class="p">:</span> <span class="n">Yi</span> <span class="k">if</span> <span class="p">(</span><span class="n">Y</span><span class="o">&lt;=</span><span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">Yi</span><span class="p">)</span>
        <span class="n">fi</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">Y</span><span class="p">,</span><span class="n">Yi</span><span class="p">:</span> <span class="n">Yi</span> <span class="k">if</span> <span class="p">(</span><span class="n">Y</span><span class="o">&lt;=</span><span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">Yi</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">,</span> <span class="n">fi</span>

<div class="viewcode-block" id="linterp">
<a class="viewcode-back" href="../../../math.html#luxpy.math.linterp">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">linterp</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="s1">&#39;ext&#39;</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="s1">&#39;ext&#39;</span><span class="p">,</span> 
             <span class="n">interp_log</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">extrap_log</span> <span class="o">=</span> <span class="kc">False</span>
             <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform linear 1-D interpolation (with linear or constant extrapolation).</span>
<span class="sd">    (wrapper around np.interp)</span>

<span class="sd">    Args:</span>
<span class="sd">        :X: </span>
<span class="sd">            | ndarray with n-dimensional coordinates (last axis represents dimension)</span>
<span class="sd">        :Y: </span>
<span class="sd">            | ndarray with values at coordinates in X</span>
<span class="sd">        :Xnew: </span>
<span class="sd">            | ndarray of new coordinates (last axis represents dimension)</span>
<span class="sd">        :left: </span>
<span class="sd">            | &#39;ext&#39;, optional float corresponding to Y.</span>
<span class="sd">            | Value to return for `Xnew &lt; X[0]`, None is `Y[0]`.</span>
<span class="sd">            | If &#39;ext&#39;: perform linear extrapolation</span>
<span class="sd">        :right:</span>
<span class="sd">            | &#39;ext&#39;, optional float corresponding to Y.</span>
<span class="sd">            | Value to return for `Xnew &gt; X[-1]`, None is `Y[-1]`.</span>
<span class="sd">            | If &#39;ext&#39;: perform linear extrapolation</span>
<span class="sd">        :interp_log:</span>
<span class="sd">            | Perform interpolation method (&#39;linear&#39;, &#39;quadratic&#39;, or &#39;cubic&#39;) in log space.</span>
<span class="sd">        :extrap_log:</span>
<span class="sd">            | Perform extrapolation method (&#39;linear&#39;, &#39;quadratic&#39;, or &#39;cubic&#39;) in log space.</span>

<span class="sd">    Returns:</span>
<span class="sd">        :Ynew:</span>
<span class="sd">            | ndarray with new values at coordinates in Xnew</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_left</span><span class="p">,</span> <span class="n">_right</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span> 
        <span class="n">_left</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="p">,</span> <span class="kc">None</span> 
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span> 
        <span class="n">_right</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="p">,</span> <span class="kc">None</span>
    <span class="n">fi</span><span class="p">,</span><span class="n">fii</span> <span class="o">=</span> <span class="n">_use_log</span><span class="p">(</span><span class="n">interp_log</span><span class="p">)</span> 
    <span class="k">if</span> <span class="n">Y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> 
        <span class="n">Ynew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fii</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">Xnew</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">fi</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Ynew</span> <span class="o">=</span> <span class="n">fii</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">Xnew</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">fi</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span><span class="n">Y</span><span class="p">),</span> <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_left</span> <span class="o">==</span> <span class="s1">&#39;ext&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">_right</span> <span class="o">==</span> <span class="s1">&#39;ext&#39;</span><span class="p">):</span>
        <span class="n">fe</span><span class="p">,</span><span class="n">fei</span> <span class="o">=</span> <span class="n">_use_log</span><span class="p">(</span><span class="n">extrap_log</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_left</span> <span class="o">==</span> <span class="s1">&#39;ext&#39;</span><span class="p">):</span> <span class="n">Ynew</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">Xnew</span> <span class="o">&lt;</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">fei</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="mi">2</span><span class="p">],(</span><span class="n">fe</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="mi">2</span><span class="p">],</span><span class="n">Y</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="p">((</span><span class="n">fe</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="mi">2</span><span class="p">],</span><span class="n">Y</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="n">fe</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="mi">2</span><span class="p">],</span><span class="n">Y</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]))</span><span class="o">*</span><span class="p">(</span><span class="n">Xnew</span><span class="p">[</span><span class="n">Xnew</span><span class="o">&lt;</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">-</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">/</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_right</span> <span class="o">==</span> <span class="s1">&#39;ext&#39;</span><span class="p">):</span> <span class="n">Ynew</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">Xnew</span> <span class="o">&gt;</span> <span class="n">X</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">=</span> <span class="n">fei</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">:],(</span><span class="n">fe</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">:],</span><span class="n">Y</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">:])</span> <span class="o">+</span> <span class="p">((</span><span class="n">fe</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">:],</span><span class="n">Y</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">:])</span><span class="o">-</span><span class="n">fe</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">:],</span><span class="n">Y</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span><span class="o">*</span><span class="p">(</span><span class="n">Xnew</span><span class="p">[</span><span class="n">Xnew</span><span class="o">&gt;</span><span class="n">X</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">-</span><span class="n">X</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span><span class="o">/</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">X</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])))</span>
    <span class="k">return</span> <span class="n">Ynew</span></div>


<div class="viewcode-block" id="interpolatedunivariatespline">
<a class="viewcode-back" href="../../../math.html#luxpy.math.interpolatedunivariatespline">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">interpolatedunivariatespline</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">,</span> <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> 
                                 <span class="n">ext</span> <span class="o">=</span> <span class="s1">&#39;extrapolate&#39;</span><span class="p">,</span> 
                                 <span class="n">fill_value</span> <span class="o">=</span> <span class="s1">&#39;extrapolate&#39;</span><span class="p">,</span>
                                 <span class="n">w</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">bbox</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> 
                                 <span class="n">check_finite</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                 <span class="n">interp_log</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">extrap_log</span> <span class="o">=</span> <span class="kc">False</span>
                                 <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Perform a 1-dimensional interpolation (with extrapolation)</span>
<span class="sd">    (wrapper around scipy.interpolate.InterpolatedUnivariateSpline).</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :X: </span>
<span class="sd">            | ndarray with n-dimensional coordinates (last axis represents dimension)</span>
<span class="sd">        :Y: </span>
<span class="sd">            | ndarray with values at coordinates in X</span>
<span class="sd">        :Xnew: </span>
<span class="sd">            | ndarray of new coordinates (last axis represents dimension)</span>
<span class="sd">        :kind:</span>
<span class="sd">            | str,  optional</span>
<span class="sd">            | supported options for str: &#39;linear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">        :ext:</span>
<span class="sd">            | &#39;extrapolate&#39;, optional</span>
<span class="sd">            | options: </span>
<span class="sd">            |   - &#39;extrapolate&#39;</span>
<span class="sd">            |   - &#39;zeros&#39;: out-of-bounds values are filled with zeros</span>
<span class="sd">            |   - &#39;const&#39;: out-of-bounds values are filled with nearest value</span>
<span class="sd">            |   - &#39;fill_value&#39;: value of tuple (2,) of values is used to fill out-of-bounds values</span>
<span class="sd">        :fill_value:</span>
<span class="sd">            | &#39;extrapolate&#39; or float or int or tupple, optional</span>
<span class="sd">            | If ext == &#39;fill_value&#39;: use fill_value to set lower- and upper-out-of-bounds values when extrapolating</span>
<span class="sd">        :w,bbox,check_finite:</span>
<span class="sd">            | see scipy.interpolate.InterpolatedUnivariateSpline()</span>
<span class="sd">        :interp_log:</span>
<span class="sd">            | Perform interpolation method (&#39;linear&#39;, &#39;quadratic&#39;, or &#39;cubic&#39;) in log space.</span>
<span class="sd">        :extrap_log:</span>
<span class="sd">            | Perform extrapolation method (&#39;linear&#39;, &#39;quadratic&#39;, or &#39;cubic&#39;) in log space.</span>

<span class="sd">    Returns:</span>
<span class="sd">        :Ynew:</span>
<span class="sd">            | ndarray with new values at coordinates in Xnew</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">interpolate</span> <span class="c1"># lazy import </span>

    <span class="c1"># get interpolator type index:</span>
    <span class="n">k</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">,</span> <span class="s1">&#39;cubic&#39;</span><span class="p">,</span> <span class="s1">&#39;quartic&#39;</span><span class="p">,</span> <span class="s1">&#39;quintic&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">ext_original</span> <span class="o">=</span> <span class="n">ext</span>
    <span class="k">if</span> <span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;fill_value&#39;</span><span class="p">:</span> <span class="n">ext</span> <span class="o">=</span> <span class="s1">&#39;extrapolate&#39;</span>
    <span class="n">fi</span><span class="p">,</span><span class="n">fii</span> <span class="o">=</span> <span class="n">_use_log</span><span class="p">(</span><span class="n">use_log</span> <span class="o">=</span> <span class="n">interp_log</span><span class="p">)</span> 
    <span class="k">if</span> <span class="n">Y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">Yn</span> <span class="o">=</span> <span class="n">fi</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span><span class="n">interpolate</span><span class="o">.</span><span class="n">InterpolatedUnivariateSpline</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">fi</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span><span class="n">Y</span><span class="p">),</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">ext</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="p">,</span> <span class="n">bbox</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">,</span> <span class="n">check_finite</span> <span class="o">=</span> <span class="n">check_finite</span><span class="p">)(</span><span class="n">Xnew</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Yn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fi</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">interpolate</span><span class="o">.</span><span class="n">InterpolatedUnivariateSpline</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">fi</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">ext</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="p">,</span> <span class="n">bbox</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">,</span> <span class="n">check_finite</span> <span class="o">=</span> <span class="n">check_finite</span><span class="p">)(</span><span class="n">Xnew</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ext_original</span> <span class="o">==</span> <span class="s1">&#39;fill_value&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="ow">not</span> <span class="p">(</span><span class="n">fill_value</span> <span class="o">==</span> <span class="s1">&#39;extrapolate&#39;</span><span class="p">)):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fill_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;ext&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">fill_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span> <span class="n">Yn</span><span class="p">[:,</span><span class="n">Xnew</span> <span class="o">&lt;</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">fill_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fill_value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;ext&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">fill_value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span> <span class="n">Yn</span><span class="p">[:,</span><span class="n">Xnew</span> <span class="o">&gt;</span> <span class="n">X</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">fill_value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">Yn</span></div>


<div class="viewcode-block" id="_interpolate_with_nans">
<a class="viewcode-back" href="../../../math.html#luxpy.math._interpolate_with_nans">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_interpolate_with_nans</span><span class="p">(</span><span class="n">fintp</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">,</span> 
                           <span class="n">delete_nans</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">nan_indices</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Deal with possible NaNs in Y&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">delete_nans</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span> <span class="c1"># interpolate with potential NaNs present</span>
        <span class="n">Yn</span> <span class="o">=</span> <span class="n">fintp</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Xnew</span><span class="p">)</span> 
    <span class="k">else</span><span class="p">:</span> <span class="c1"># deal with NaNs by deleting them and then interpolating</span>
        <span class="k">if</span> <span class="n">nan_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">nan_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nan_indices</span><span class="o">.</span><span class="n">any</span><span class="p">():</span> <span class="c1"># NaNs are present</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">all_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">rows_with_nans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nan_indices</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">rows_with_no_nans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">all_rows</span><span class="p">,</span><span class="n">rows_with_nans</span><span class="p">)</span>
            <span class="n">Yn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">N</span><span class="p">,</span><span class="n">Xnew</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">Yn</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

            <span class="c1"># Interpolate part not containing any NaNs</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">rows_with_no_nans</span><span class="o">.</span><span class="n">size</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">):</span> 
                <span class="n">Y_no_nans</span> <span class="o">=</span> <span class="n">Y</span><span class="p">[</span><span class="n">rows_with_no_nans</span><span class="p">]</span>
                <span class="n">N_no_nans</span> <span class="o">=</span> <span class="n">Y_no_nans</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">Yn_no_nans</span> <span class="o">=</span> <span class="n">fintp</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y_no_nans</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">)</span>
                <span class="n">Yn</span><span class="p">[</span><span class="n">rows_with_no_nans</span><span class="p">]</span> <span class="o">=</span> <span class="n">Yn_no_nans</span>

            <span class="c1"># In case there are NaN&#39;s:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">rows_with_nans</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>

                <span class="c1"># looping required as some values are NaN&#39;s:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rows_with_nans</span><span class="p">:</span>
                    <span class="n">nonan_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">nan_indices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">Xi_no_nans</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">nonan_indices</span><span class="p">]</span>
                    <span class="n">Yi_no_nans</span> <span class="o">=</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">nonan_indices</span><span class="p">]</span>
                    <span class="n">Yni_no_nans</span> <span class="o">=</span> <span class="n">fintp</span><span class="p">(</span><span class="n">Xi_no_nans</span><span class="p">,</span> <span class="n">Yi_no_nans</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">)</span>
                    <span class="n">Yn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Yni_no_nans</span>  
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Yn</span> <span class="o">=</span> <span class="n">fintp</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Xnew</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Yn</span></div>


<span class="k">def</span><span class="w"> </span><span class="nf">_interp1d</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">ext</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> 
              <span class="n">interp_log</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">extrap_log</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform 1-D interpolation using scipy.interpolate.interp1d().</span>
<span class="sd">    (Private: for use with interp1 function)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">interpolate</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">ext</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;ext&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ext</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)):</span><span class="c1"># | (ext in (&#39;linear&#39;,&#39;quadratic&#39;,&#39;cubic&#39;)): </span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="s1">&#39;extrapolate&#39;</span>
    <span class="k">elif</span> <span class="p">((</span><span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;const&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;flat&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;nearest&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ext</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)):</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">fi</span><span class="p">,</span><span class="n">fii</span> <span class="o">=</span> <span class="n">_use_log</span><span class="p">(</span><span class="n">use_log</span> <span class="o">=</span> <span class="n">interp_log</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fii</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">fi</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span><span class="n">Y</span><span class="p">),</span> <span class="n">kind</span> <span class="o">=</span> <span class="n">kind</span><span class="p">,</span> <span class="n">bounds_error</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="n">fill_value</span><span class="p">)(</span><span class="n">Xnew</span><span class="p">))</span>
 
<span class="k">def</span><span class="w"> </span><span class="nf">_get_fintp</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Xnew</span><span class="p">,</span><span class="n">kind</span><span class="p">,</span><span class="n">ext</span><span class="p">,</span><span class="n">fill_value</span><span class="p">,</span>
               <span class="n">force_scipy_interpolator</span><span class="p">,</span><span class="n">scipy_interpolator</span><span class="p">,</span>
               <span class="n">w</span><span class="p">,</span> <span class="n">bbox</span><span class="p">,</span> <span class="n">check_finite</span><span class="p">,</span>
               <span class="n">interp_log</span><span class="p">,</span> <span class="n">extrap_log</span><span class="p">,</span> <span class="n">verbosity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">force_scipy_interpolator</span> <span class="o">==</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Interpolation/Extrapolation: using linterp() numpy wrapper&#39;</span><span class="p">)</span>
        <span class="n">fintp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Xnew</span><span class="p">:</span>  <span class="n">linterp</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="n">fill_value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">right</span> <span class="o">=</span> <span class="n">fill_value</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                         <span class="n">interp_log</span> <span class="o">=</span> <span class="n">interp_log</span><span class="p">,</span> <span class="n">extrap_log</span> <span class="o">=</span> <span class="n">extrap_log</span><span class="p">)</span>
    
    <span class="k">elif</span> <span class="p">(</span><span class="n">force_scipy_interpolator</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">kind</span> <span class="o">!=</span> <span class="s1">&#39;linear&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">scipy_interpolator</span> <span class="o">==</span> <span class="s1">&#39;InterpolatedUnivariateSpline&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Interpolation/Extrapolation: using interpolatedunivariatespline() scipy wrapper&#39;</span><span class="p">)</span>
            <span class="n">fintp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Xnew</span><span class="p">:</span> <span class="n">interpolatedunivariatespline</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">,</span> <span class="n">kind</span> <span class="o">=</span> <span class="n">kind</span><span class="p">,</span> 
                                                                    <span class="n">ext</span> <span class="o">=</span> <span class="n">ext</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="n">fill_value</span><span class="p">,</span>
                                                                    <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="p">,</span> <span class="n">bbox</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">,</span> <span class="n">check_finite</span> <span class="o">=</span> <span class="n">check_finite</span><span class="p">,</span>
                                                                    <span class="n">interp_log</span> <span class="o">=</span> <span class="n">interp_log</span><span class="p">,</span> <span class="n">extrap_log</span> <span class="o">=</span> <span class="n">extrap_log</span><span class="p">)</span>    
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Interpolation/Extrapolation: using scipy.interpolate.interp1d()&#39;</span><span class="p">)</span>
            <span class="n">fintp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Xnew</span><span class="p">:</span> <span class="n">_interp1d</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">ext</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">interp_log</span> <span class="o">=</span> <span class="n">interp_log</span><span class="p">,</span> <span class="n">extrap_log</span> <span class="o">=</span> <span class="n">extrap_log</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">fintp</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_get_most_time_efficient_interpolator</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">ext</span><span class="p">,</span> <span class="n">force_scipy_interpolator</span><span class="p">,</span><span class="n">extrap_required</span><span class="p">):</span>
    <span class="c1"># Use most time-efficient interpolator:</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
        <span class="n">scipy_interpolator_int</span> <span class="o">=</span> <span class="s1">&#39;interp1d&#39;</span> <span class="k">if</span> <span class="p">(</span><span class="n">N</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;InterpolatedUnivariateSpline&#39;</span> <span class="c1"># &#39;interp1d&#39; faster than &#39;InterpolatedUnivariateSpline&#39; for Y(N,...) with N == 1 and kind == &#39;linear&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">scipy_interpolator_int</span> <span class="o">=</span> <span class="s1">&#39;InterpolatedUnivariateSpline&#39;</span> <span class="k">if</span> <span class="p">(</span><span class="n">N</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;interp1d&#39;</span> <span class="c1"># &#39;InterpolatedUnivariateSpline&#39; faster than &#39;interp1d&#39; for Y(N,...) with N == 1 and kind == &#39;cubic&#39;</span>
    <span class="k">if</span> <span class="n">extrap_required</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ext</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">,</span> <span class="s1">&#39;cubic&#39;</span><span class="p">):</span>
            <span class="n">ext</span> <span class="o">=</span> <span class="n">kind</span> <span class="c1"># because ext is &#39;ext&#39;, &#39;zeros&#39;, &#39;flat&#39;, &#39;nearest&#39;, &#39;const&#39; or &#39;fill_value&#39;</span>
        <span class="k">if</span> <span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
            <span class="n">scipy_interpolator_ext</span> <span class="o">=</span> <span class="s1">&#39;interp1d&#39;</span> <span class="k">if</span> <span class="p">(</span><span class="n">N</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;InterpolatedUnivariateSpline&#39;</span> <span class="c1"># &#39;interp1d&#39; faster than &#39;InterpolatedUnivariateSpline&#39; for Y(N,...) with N == 1 and kind == &#39;linear&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scipy_interpolator_ext</span> <span class="o">=</span> <span class="s1">&#39;InterpolatedUnivariateSpline&#39;</span> <span class="k">if</span> <span class="p">(</span><span class="n">N</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;interp1d&#39;</span> <span class="c1"># &#39;InterpolatedUnivariateSpline&#39; faster than &#39;interp1d&#39; for Y(N,...) with N == 1 and kind == &#39;cubic&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">scipy_interpolator_ext</span> <span class="o">=</span> <span class="n">scipy_interpolator_int</span>
    <span class="k">return</span> <span class="n">scipy_interpolator_int</span><span class="p">,</span> <span class="n">scipy_interpolator_ext</span>

<div class="viewcode-block" id="interp1">
<a class="viewcode-back" href="../../../math.html#luxpy.math.interp1">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">interp1</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">,</span> <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="s1">&#39;extrapolate&#39;</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="s1">&#39;extrapolate&#39;</span><span class="p">,</span> 
            <span class="n">force_scipy_interpolator</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">scipy_interpolator</span> <span class="o">=</span> <span class="s1">&#39;InterpolatedUnivariateSpline&#39;</span><span class="p">,</span>
            <span class="n">delete_nans</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">w</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">bbox</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">check_finite</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="c1"># scipy.interpolate.InterpolatedUnivariateSpline kwargs</span>
            <span class="n">interp_log</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">extrap_log</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="c1"># perform interpolation method (and/or extrapolation method in log space)</span>
            <span class="n">choose_most_efficient_interpolator</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">verbosity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform a 1-dimensional interpolation </span>
<span class="sd">    (wrapper around linterp, interpolatedunivariatespline, interp1d).</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :X: </span>
<span class="sd">            | ndarray with n-dimensional coordinates (last axis represents dimension)</span>
<span class="sd">        :Y: </span>
<span class="sd">            | ndarray with values at coordinates in X</span>
<span class="sd">        :Xnew: </span>
<span class="sd">            | ndarray of new coordinates (last axis represents dimension)</span>
<span class="sd">        :kind:</span>
<span class="sd">            | str,  optional</span>
<span class="sd">            | supported options for str: &#39;linear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">        :ext:</span>
<span class="sd">            | &#39;extrapolate&#39;, optional</span>
<span class="sd">            | options: </span>
<span class="sd">            |   - &#39;extrapolate&#39;, &#39;ext&#39;: use method specified in :kind: to extrapolate.</span>
<span class="sd">            |   - &#39;linear&#39;, &#39;quadratic&#39;, &#39;cubic&#39; extrapolation</span>
<span class="sd">            |   - &#39;zeros&#39;: out-of-bounds values are filled with zeros</span>
<span class="sd">            |   - &#39;const&#39;,&#39;flat&#39;,&#39;nearest&#39;: out-of-bounds values are filled with nearest value</span>
<span class="sd">            |   - &#39;fill_value&#39;: value of tuple (2,) of values is used to fill out-of-bounds values</span>
<span class="sd">        :fill_value:</span>
<span class="sd">            | &#39;extrapolate&#39; or float or int or tupple, optional</span>
<span class="sd">            | If ext == &#39;fill_value&#39;: use fill_value to set lower- and upper-out-of-bounds values when extrapolating</span>
<span class="sd">        :force_scipy_interpolator:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | If False: numpy.interp function is used for linear interpolation when no or linear extrapolation is used/required (fast!). </span>
<span class="sd">        :scipy_interpolator:</span>
<span class="sd">            | &#39;InterpolatedUnivariateSpline&#39;, optional</span>
<span class="sd">            | options: &#39;InterpolatedUnivariateSpline&#39;, &#39;interp1d&#39;</span>
<span class="sd">        :delete_nans:</span>
<span class="sd">            | True, optional</span>
<span class="sd">            | If NaNs are present, remove them and (and try to) interpolate without them.</span>
<span class="sd">        :w,bbox,check_finite:</span>
<span class="sd">            | see scipy.interpolate.InterpolatedUnivariateSpline()</span>
<span class="sd">        :interp_log:</span>
<span class="sd">            | Perform interpolation method (&#39;linear&#39;, &#39;quadratic&#39;, or &#39;cubic&#39;) in log space.</span>
<span class="sd">        :extrap_log:</span>
<span class="sd">            | Perform extrapolation method (&#39;linear&#39;, &#39;quadratic&#39;, or &#39;cubic&#39;) in log space.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        :Ynew:</span>
<span class="sd">            | ndarray with new values at coordinates in Xnew</span>
<span class="sd">    </span>
<span class="sd">    Note:</span>
<span class="sd">        1. &#39;numpy.interp&#39; is fastest (but only works for linear interpolation and linear or no extrapolation)</span>
<span class="sd">        2. For linear interpolation: &#39;interp1d&#39; is faster for Y (N,...) with N &gt; 1, else &#39;InterpolatedUnivariateSpline&#39; is faster</span>
<span class="sd">        3. For &#39;cubic&#39; interpolation: &#39;InterpolatedUnivariateSpline&#39; is faster for Y (N,...) with N &gt; 1, else &#39;interp1d&#39; is faster</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">Xnew</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="n">Xnew</span> <span class="o">=</span> <span class="n">Xnew</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># avoid interpolation/extrapolation if none is needed:</span>
    <span class="n">nan_indices</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Xnew</span><span class="p">):</span> 
        <span class="k">if</span> <span class="n">delete_nans</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span> 
            <span class="k">return</span> <span class="n">Y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># keep NaNs if any and return original Y as copy</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nan_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">nan_indices</span><span class="o">.</span><span class="n">any</span><span class="p">():</span> <span class="k">return</span> <span class="n">Y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># return original Y as copy (doesn&#39;t contain any NaNs)</span>
    <span class="k">if</span> <span class="n">nan_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">nan_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
    
    <span class="c1"># setup extrapolation:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Xnew</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">Xnew</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">X</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">extrap_required</span> <span class="o">=</span> <span class="kc">True</span> 
        <span class="n">ext_is_lqc_method</span> <span class="o">=</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">,</span> <span class="s1">&#39;cubic&#39;</span><span class="p">)</span> <span class="c1"># method for ext (&#39;linear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;) is same as in kind</span>
        <span class="n">ext_original</span> <span class="o">=</span> <span class="n">ext</span>
        <span class="k">if</span> <span class="n">ext_is_lqc_method</span><span class="p">:</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;ext&#39;</span><span class="p">,</span><span class="s1">&#39;ext&#39;</span><span class="p">)</span>
            <span class="n">ext</span> <span class="o">=</span> <span class="s1">&#39;extrapolate&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">ext</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;ext&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ext</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)):</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;ext&#39;</span><span class="p">,</span><span class="s1">&#39;ext&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">((</span><span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;zeros&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ext</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)):</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">)</span> 
            <span class="k">elif</span> <span class="p">((</span><span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;const&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;flat&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;nearest&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ext</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)):</span> 
                <span class="n">fill_value</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">((</span><span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;fill_value&#39;</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span><span class="nb">int</span><span class="p">)):</span> 
                    <span class="n">fill_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span> 
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;ext&#39;</span><span class="p">,</span><span class="s1">&#39;ext&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">extrap_required</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">ext_is_lqc_method</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="s1">&#39;extrapolate&#39;</span>

    <span class="k">if</span> <span class="n">choose_most_efficient_interpolator</span><span class="p">:</span>
        <span class="n">scipy_interpolator_int</span><span class="p">,</span> <span class="n">scipy_interpolator_ext</span> <span class="o">=</span> <span class="n">_get_most_time_efficient_interpolator</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">ext</span><span class="p">,</span> <span class="n">force_scipy_interpolator</span><span class="p">,</span> <span class="n">extrap_required</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">scipy_interpolator_int</span><span class="p">,</span> <span class="n">scipy_interpolator_ext</span> <span class="o">=</span> <span class="n">scipy_interpolator</span><span class="p">,</span> <span class="n">scipy_interpolator</span>

    <span class="n">fintp</span> <span class="o">=</span> <span class="n">_get_fintp</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Xnew</span><span class="p">,</span><span class="n">kind</span><span class="p">,</span><span class="n">ext</span><span class="p">,</span><span class="n">fill_value</span><span class="p">,</span>
               <span class="n">force_scipy_interpolator</span><span class="p">,</span><span class="n">scipy_interpolator_int</span><span class="p">,</span>
               <span class="n">w</span><span class="p">,</span> <span class="n">bbox</span><span class="p">,</span> <span class="n">check_finite</span><span class="p">,</span>
               <span class="n">interp_log</span><span class="p">,</span> <span class="n">extrap_log</span><span class="p">,</span> <span class="n">verbosity</span><span class="p">)</span> 
    
    <span class="n">Yni</span> <span class="o">=</span> <span class="n">_interpolate_with_nans</span><span class="p">(</span><span class="n">fintp</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">,</span> 
                                  <span class="n">delete_nans</span> <span class="o">=</span> <span class="n">delete_nans</span><span class="p">,</span> 
                                  <span class="n">nan_indices</span> <span class="o">=</span> <span class="n">nan_indices</span><span class="p">)</span> 
    
    <span class="c1"># Deal with request for different (from itype/kind) extrapolation method</span>
    <span class="k">if</span> <span class="n">extrap_required</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ext_is_lqc_method</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ext_original</span> <span class="o">!=</span> <span class="n">kind</span><span class="p">:</span>
                <span class="c1"># do extra interpolation to get the extrapolated values according to the desired extrap. method</span>
                <span class="n">fextp</span> <span class="o">=</span> <span class="n">_get_fintp</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Xnew</span><span class="p">,</span><span class="n">ext_original</span><span class="p">,</span><span class="s1">&#39;extrapolate&#39;</span><span class="p">,(</span><span class="s1">&#39;ext&#39;</span><span class="p">,</span> <span class="s1">&#39;ext&#39;</span><span class="p">),</span>
                                  <span class="n">force_scipy_interpolator</span><span class="p">,</span><span class="n">scipy_interpolator_ext</span><span class="p">,</span>
                                  <span class="n">w</span><span class="p">,</span> <span class="n">bbox</span><span class="p">,</span> <span class="n">check_finite</span><span class="p">,</span>
                                  <span class="n">interp_log</span><span class="p">,</span> <span class="n">extrap_log</span><span class="p">,</span> <span class="n">verbosity</span><span class="p">)</span> 
                <span class="n">Yne</span> <span class="o">=</span> <span class="n">_interpolate_with_nans</span><span class="p">(</span><span class="n">fextp</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">,</span> 
                                             <span class="n">delete_nans</span> <span class="o">=</span> <span class="n">delete_nans</span><span class="p">,</span> 
                                             <span class="n">nan_indices</span> <span class="o">=</span> <span class="n">nan_indices</span><span class="p">)</span> 
                <span class="n">cnd</span> <span class="o">=</span> <span class="o">~</span><span class="p">((</span><span class="n">Xnew</span> <span class="o">&gt;=</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Xnew</span> <span class="o">&lt;=</span> <span class="n">X</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">Yni</span><span class="p">[:,</span><span class="n">cnd</span><span class="p">]</span> <span class="o">=</span> <span class="n">Yne</span><span class="p">[:,</span><span class="n">cnd</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">Yni</span></div>



<span class="c1">#------------------------------------------------------------------------------</span>
<span class="n">_SPRAGUE_COEFFICIENTS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                                 <span class="p">[</span><span class="mi">884</span><span class="p">,</span> <span class="o">-</span><span class="mi">1960</span><span class="p">,</span> <span class="mi">3033</span><span class="p">,</span> <span class="o">-</span><span class="mi">2648</span><span class="p">,</span> <span class="mi">1080</span><span class="p">,</span> <span class="o">-</span><span class="mi">180</span><span class="p">],</span>
                                 <span class="p">[</span><span class="mi">508</span><span class="p">,</span> <span class="o">-</span><span class="mi">540</span><span class="p">,</span> <span class="mi">488</span><span class="p">,</span> <span class="o">-</span><span class="mi">367</span><span class="p">,</span> <span class="mi">144</span><span class="p">,</span> <span class="o">-</span><span class="mi">24</span><span class="p">],</span>
                                 <span class="p">[</span><span class="o">-</span><span class="mi">24</span><span class="p">,</span> <span class="mi">144</span><span class="p">,</span> <span class="o">-</span><span class="mi">367</span><span class="p">,</span> <span class="mi">488</span><span class="p">,</span> <span class="o">-</span><span class="mi">540</span><span class="p">,</span> <span class="mi">508</span><span class="p">],</span>
                                 <span class="p">[</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span> <span class="mi">1080</span><span class="p">,</span> <span class="o">-</span><span class="mi">2648</span><span class="p">,</span> <span class="mi">3033</span><span class="p">,</span> <span class="o">-</span><span class="mi">1960</span><span class="p">,</span> <span class="mi">884</span><span class="p">],</span>
                                 <span class="p">])</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="mf">209.0</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_pre_extrap_left_right_with_2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="c1"># Check equal x-spacing:</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dx</span> <span class="o">==</span> <span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Elements in x are not equally spaced!&#39;</span><span class="p">)</span>
        
    <span class="c1"># Extrapolate x, y with required additional elements for Sprague to work:</span>
    <span class="n">xe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">dx</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">dx</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dx</span><span class="p">))</span>
    
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">ye1</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">@</span> <span class="n">_SPRAGUE_COEFFICIENTS</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])[:,</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">ye2</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">@</span> <span class="n">_SPRAGUE_COEFFICIENTS</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])[:,</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">ye3</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">[:,</span><span class="o">-</span><span class="mi">6</span><span class="p">:]</span> <span class="o">@</span> <span class="n">_SPRAGUE_COEFFICIENTS</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])[:,</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">ye4</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">[:,</span><span class="o">-</span><span class="mi">6</span><span class="p">:]</span> <span class="o">@</span> <span class="n">_SPRAGUE_COEFFICIENTS</span><span class="p">[:,</span><span class="mi">3</span><span class="p">])[:,</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">ye</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">ye1</span><span class="p">,</span><span class="n">ye2</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">ye3</span><span class="p">,</span><span class="n">ye4</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">xe</span><span class="p">,</span> <span class="n">ye</span>

<div class="viewcode-block" id="_extrap_y">
<a class="viewcode-back" href="../../../math.html#luxpy.math._extrap_y">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">_extrap_y</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xn</span><span class="p">,</span> <span class="n">extrap</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> 
            <span class="n">force_scipy_interpolator</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">scipy_interpolator</span> <span class="o">=</span> <span class="s1">&#39;InterpolatedUnivariateSpline&#39;</span><span class="p">,</span>
            <span class="n">delete_nans</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">choose_most_efficient_interpolator</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extrapolate y if needed&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">xn</span><span class="o">&lt;</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">xn</span><span class="o">&gt;</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">any</span><span class="p">():</span> <span class="c1"># extrapolation needed !</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">extrap</span><span class="p">,</span><span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">extrap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">extrap</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> 
                <span class="n">yne</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">xn</span><span class="p">)))</span><span class="o">*</span><span class="n">extrap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">yne</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">xn</span><span class="p">)))</span>
                <span class="n">yne</span><span class="p">[:,(</span><span class="n">xn</span><span class="o">&lt;</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">extrap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">yne</span><span class="p">[:,(</span><span class="n">xn</span><span class="o">&gt;</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">extrap</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">extrap</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">extrap</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;ext&#39;</span><span class="p">:</span> 
                <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span>
                <span class="n">ext</span> <span class="o">=</span> <span class="n">extrap</span>
            <span class="k">elif</span> <span class="n">extrap</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span><span class="s1">&#39;quadratic&#39;</span><span class="p">,</span><span class="s1">&#39;cubic&#39;</span><span class="p">):</span>
                <span class="n">kind</span> <span class="o">=</span> <span class="n">extrap</span> 
                <span class="n">ext</span> <span class="o">=</span> <span class="s1">&#39;extrapolate&#39;</span>
            <span class="k">elif</span> <span class="n">extrap</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;zeros&#39;</span><span class="p">,</span><span class="s1">&#39;flat&#39;</span><span class="p">,</span><span class="s1">&#39;const&#39;</span><span class="p">,</span> <span class="s1">&#39;nearest&#39;</span><span class="p">):</span>
                <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span>
                <span class="n">ext</span> <span class="o">=</span> <span class="n">extrap</span>
            <span class="k">elif</span> <span class="n">extrap</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;sprague5&#39;</span><span class="p">,</span> <span class="s1">&#39;sprague_cie224_2017&#39;</span><span class="p">,</span><span class="s1">&#39;lagrange5&#39;</span><span class="p">):</span>
                <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span>
                <span class="n">ext</span> <span class="o">=</span> <span class="s1">&#39;extrapolate&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unsupported extrapolation type: </span><span class="si">{</span><span class="n">extrap</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">yne</span> <span class="o">=</span> <span class="n">interp1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xn</span><span class="p">,</span> <span class="n">kind</span> <span class="o">=</span> <span class="n">kind</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">ext</span><span class="p">,</span> 
                            <span class="n">force_scipy_interpolator</span> <span class="o">=</span> <span class="n">force_scipy_interpolator</span><span class="p">,</span> 
                            <span class="n">scipy_interpolator</span> <span class="o">=</span> <span class="n">scipy_interpolator</span><span class="p">,</span>
                            <span class="n">delete_nans</span> <span class="o">=</span> <span class="n">delete_nans</span><span class="p">,</span>
                            <span class="n">choose_most_efficient_interpolator</span> <span class="o">=</span> <span class="n">choose_most_efficient_interpolator</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Invalid option for extrap argument. Only tuple and string allowed.&#39;</span><span class="p">)</span>
        <span class="n">xn_x</span> <span class="o">=</span> <span class="n">xn</span><span class="p">[(</span><span class="n">xn</span><span class="o">&gt;=</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">xn</span><span class="o">&lt;=</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xn_x</span> <span class="o">=</span> <span class="n">xn</span>
        <span class="n">yne</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">xn_x</span><span class="p">,</span> <span class="n">yne</span></div>


<span class="k">def</span><span class="w"> </span><span class="nf">_interp1_sprague5</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xn</span><span class="p">,</span> <span class="n">extrap</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> 
                     <span class="n">force_scipy_interpolator</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                     <span class="n">scipy_interpolator</span> <span class="o">=</span> <span class="s1">&#39;InterpolatedUnivariateSpline&#39;</span><span class="p">,</span>
                     <span class="n">delete_nans</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                     <span class="n">choose_most_efficient_interpolator</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Perform a 1-dimensional 5th order Sprague interpolation.</span>
<span class="sd">    (Private: for use with interp1_sprague5 function)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Do extrapolation:</span>
    <span class="n">xn_x</span><span class="p">,</span> <span class="n">yne</span> <span class="o">=</span> <span class="n">_extrap_y</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xn</span><span class="p">,</span> <span class="n">extrap</span> <span class="o">=</span> <span class="n">extrap</span><span class="p">,</span> 
                        <span class="n">force_scipy_interpolator</span> <span class="o">=</span> <span class="n">force_scipy_interpolator</span><span class="p">,</span>
                        <span class="n">scipy_interpolator</span> <span class="o">=</span> <span class="n">scipy_interpolator</span><span class="p">,</span>
                        <span class="n">delete_nans</span> <span class="o">=</span> <span class="n">delete_nans</span><span class="p">,</span>
                        <span class="n">choose_most_efficient_interpolator</span> <span class="o">=</span> <span class="n">choose_most_efficient_interpolator</span><span class="p">)</span>
     
            
    <span class="c1"># Extrapolate x, y with required additional elements for Sprague to work:</span>
    <span class="n">xe</span><span class="p">,</span> <span class="n">ye</span> <span class="o">=</span> <span class="n">_pre_extrap_left_right_with_2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
    
    <span class="c1"># Evaluate at xn_x (no extrapolation!!):</span>
    <span class="c1">#i = np.searchsorted(xe, xn_x, side = &#39;right&#39;) - 1</span>
    <span class="c1">#i[i &gt; ye.shape[0] - 4] = ye.shape[0] - 4 # deal with end-point</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">xe</span><span class="p">,</span> <span class="n">xn_x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">((</span><span class="n">xn_x</span> <span class="o">-</span> <span class="n">xe</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">xe</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">xe</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span>

    <span class="n">ye</span> <span class="o">=</span> <span class="n">ye</span><span class="o">.</span><span class="n">T</span>
    <span class="n">a0</span> <span class="o">=</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">16</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">16</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="mi">24</span><span class="p">)</span>  
    <span class="n">a2</span> <span class="o">=</span> <span class="p">((</span><span class="o">-</span><span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">16</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">30</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">16</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="mi">24</span><span class="p">)</span> 
    <span class="n">a3</span> <span class="o">=</span> <span class="p">((</span><span class="o">-</span><span class="mi">9</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">39</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">70</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">66</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">33</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">7</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="mi">24</span><span class="p">)</span>
    <span class="n">a4</span> <span class="o">=</span> <span class="p">((</span><span class="mi">13</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">64</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">126</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">124</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">61</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">12</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="mi">24</span><span class="p">)</span>
    <span class="n">a5</span> <span class="o">=</span> <span class="p">((</span><span class="o">-</span><span class="mi">5</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">25</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">50</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">50</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">25</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="mi">24</span><span class="p">)</span>

    <span class="n">yn</span> <span class="o">=</span> <span class="p">(</span><span class="n">a0</span> <span class="o">+</span> <span class="n">a1</span><span class="o">*</span><span class="n">X</span> <span class="o">+</span> <span class="n">a2</span><span class="o">*</span><span class="n">X</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">a3</span><span class="o">*</span><span class="n">X</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="n">a4</span><span class="o">*</span><span class="n">X</span><span class="o">**</span><span class="mi">4</span> <span class="o">+</span> <span class="n">a5</span><span class="o">*</span><span class="n">X</span><span class="o">**</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    
    <span class="k">if</span> <span class="n">yne</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">yn</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">yne</span><span class="p">[:,(</span><span class="n">xn</span><span class="o">&gt;=</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">xn</span><span class="o">&lt;=</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">yn</span>
        <span class="k">return</span> <span class="n">yne</span>
    
<div class="viewcode-block" id="interp1_sprague5">
<a class="viewcode-back" href="../../../math.html#luxpy.math.interp1_sprague5">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">interp1_sprague5</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">,</span> <span class="n">extrap</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> 
                     <span class="n">force_scipy_interpolator</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                     <span class="n">scipy_interpolator</span> <span class="o">=</span> <span class="s1">&#39;InterpolatedUnivariateSpline&#39;</span><span class="p">,</span>
                     <span class="n">delete_nans</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                     <span class="n">choose_most_efficient_interpolator</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">verbosity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Perform a 1-dimensional 5th order Sprague interpolation.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :X:</span>
<span class="sd">            | ndarray with n-dimensional coordinates.</span>
<span class="sd">        :Y: </span>
<span class="sd">            | ndarray with values at coordinates in X.</span>
<span class="sd">        :Xnew:</span>
<span class="sd">            | ndarray of new coordinates.</span>
<span class="sd">        :extrap:</span>
<span class="sd">            | (np.nan, np.nan) or string, optional</span>
<span class="sd">            | If tuple: fill with values in tuple (&lt;X[0],&gt;X[-1])</span>
<span class="sd">            | If string:  (&#39;linear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;, &#39;zeros&#39;, &#39;const&#39;)</span>
<span class="sd">        :force_scipy_interpolator:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | If False: numpy.interp function is used for linear interpolation when no or linear extrapolation is used/required (fast!). </span>
<span class="sd">        :scipy_interpolator:</span>
<span class="sd">            | &#39;InterpolatedUnivariateSpline&#39;, optional</span>
<span class="sd">            | options: &#39;InterpolatedUnivariateSpline&#39;, &#39;interp1d&#39;</span>
<span class="sd">        :delete_nans:</span>
<span class="sd">            | True, optional</span>
<span class="sd">            | If NaNs are present, remove them and (and try to) interpolate without them.</span>

<span class="sd">    Returns:</span>
<span class="sd">        :Yn:</span>
<span class="sd">            | ndarray with values at new coordinates in Xnew.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Interpolation: using luxpy interp1_sprague5&#39;</span><span class="p">)</span>
    <span class="n">fintp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Xnew</span><span class="p">:</span> <span class="n">_interp1_sprague5</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">,</span> <span class="n">extrap</span> <span class="o">=</span> <span class="n">extrap</span><span class="p">,</span> 
                                                <span class="n">force_scipy_interpolator</span> <span class="o">=</span> <span class="n">force_scipy_interpolator</span><span class="p">,</span>
                                                <span class="n">scipy_interpolator</span> <span class="o">=</span> <span class="n">scipy_interpolator</span><span class="p">,</span> 
                                                <span class="n">delete_nans</span> <span class="o">=</span> <span class="n">delete_nans</span><span class="p">,</span>
                                                 <span class="n">choose_most_efficient_interpolator</span> <span class="o">=</span> <span class="n">choose_most_efficient_interpolator</span><span class="p">)</span> 
    <span class="k">return</span> <span class="n">_interpolate_with_nans</span><span class="p">(</span><span class="n">fintp</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">,</span> 
                                <span class="n">delete_nans</span> <span class="o">=</span> <span class="n">delete_nans</span><span class="p">,</span> 
                                <span class="n">nan_indices</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span>  </div>


<span class="c1">#----------------------------------------------------------------------------------------</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_interp1_sprague_cie224_2017</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">xn</span><span class="p">,</span>
                                <span class="n">extrap</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> 
                                <span class="n">force_scipy_interpolator</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                <span class="n">scipy_interpolator</span> <span class="o">=</span> <span class="s1">&#39;InterpolatedUnivariateSpline&#39;</span><span class="p">,</span>
                                <span class="n">delete_nans</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                <span class="n">choose_most_efficient_interpolator</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Perform a 1-dimensional Sprague interpolation as defined in (CIE-224-2017).</span>
<span class="sd">    (Private: for use with interp1_sprague_cie224_2017 function)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Use sprague interpolation as defined in CIE227-2017</span>


    <span class="c1"># Do extrapolation:</span>
    <span class="n">xn_x</span><span class="p">,</span> <span class="n">yne</span> <span class="o">=</span> <span class="n">_extrap_y</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xn</span><span class="p">,</span> <span class="n">extrap</span> <span class="o">=</span> <span class="n">extrap</span><span class="p">,</span> 
                        <span class="n">force_scipy_interpolator</span> <span class="o">=</span> <span class="n">force_scipy_interpolator</span><span class="p">,</span>
                        <span class="n">scipy_interpolator</span> <span class="o">=</span> <span class="n">scipy_interpolator</span><span class="p">,</span>
                        <span class="n">delete_nans</span> <span class="o">=</span> <span class="n">delete_nans</span><span class="p">,</span>
                        <span class="n">choose_most_efficient_interpolator</span> <span class="o">=</span> <span class="n">choose_most_efficient_interpolator</span><span class="p">)</span>


    <span class="c1"># Extrapolate 2 extra values beyond x-boundary:</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">],(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span><span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dx</span> <span class="o">==</span> <span class="n">dx</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span><span class="o">.</span><span class="n">all</span><span class="p">():</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="o">|</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span><span class="nb">int</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Sprague interpolation method only defined for equally spaced x!&#39;</span><span class="p">)</span>
    <span class="n">xe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">dx</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">dx</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">dx</span><span class="p">))</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">ye</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">y</span><span class="p">[:,:</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">[:,:</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">:],</span> <span class="n">y</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">:],</span><span class="n">y</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">:]))</span>

    <span class="c1"># Sprague coefficients for spacing of 5 to 1:</span>
    <span class="n">Smn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0000</span><span class="p">,</span>  <span class="mf">0.0000</span><span class="p">,</span> <span class="mf">1.0000</span><span class="p">,</span> <span class="mf">0.0000</span><span class="p">,</span>  <span class="mf">0.0000</span><span class="p">,</span> <span class="mf">0.0000</span><span class="p">],</span>
                    <span class="p">[</span><span class="mf">0.0128</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.0976</span><span class="p">,</span> <span class="mf">0.9344</span><span class="p">,</span> <span class="mf">0.1744</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.0256</span><span class="p">,</span> <span class="mf">0.0016</span><span class="p">],</span>
                    <span class="p">[</span><span class="mf">0.0144</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.1136</span><span class="p">,</span> <span class="mf">0.7264</span><span class="p">,</span> <span class="mf">0.4384</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.0736</span><span class="p">,</span> <span class="mf">0.0080</span><span class="p">],</span>
                    <span class="p">[</span><span class="mf">0.0080</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.0736</span><span class="p">,</span> <span class="mf">0.4384</span><span class="p">,</span> <span class="mf">0.7264</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.1136</span><span class="p">,</span> <span class="mf">0.0144</span><span class="p">],</span>
                    <span class="p">[</span><span class="mf">0.0016</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.0256</span><span class="p">,</span> <span class="mf">0.1744</span><span class="p">,</span> <span class="mf">0.9344</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.0976</span><span class="p">,</span> <span class="mf">0.0128</span><span class="p">]</span>
                    <span class="p">])</span>

    <span class="c1"># Find indices of Smn for bulk processing:</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">xe</span><span class="p">,</span> <span class="n">xn</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">Iu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">((</span><span class="n">I</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># process xe (as check):</span>
    <span class="n">xe_</span> <span class="o">=</span> <span class="p">(</span><span class="n">Smn</span> <span class="nd">@xe</span><span class="p">[</span><span class="n">Iu</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">xe__</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">xe_</span><span class="p">,(</span><span class="mi">5</span><span class="o">*</span><span class="n">xe_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],))</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">xe__</span><span class="o">&gt;=</span><span class="n">xn</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">xe__</span><span class="o">&lt;=</span><span class="n">xn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">xe__</span> <span class="o">=</span> <span class="n">xe__</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>

    <span class="c1"># Process ye:</span>
    <span class="n">ye</span> <span class="o">=</span> <span class="n">ye</span><span class="o">.</span><span class="n">T</span>
    <span class="n">ye_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="n">Smn</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">ye</span><span class="p">[</span><span class="n">Iu</span><span class="p">],(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">ye__</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ye_</span><span class="p">,(</span><span class="n">ye_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">5</span><span class="o">*</span><span class="n">xe_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">ye__</span> <span class="o">=</span> <span class="n">ye__</span><span class="p">[:,</span><span class="n">c</span><span class="p">]</span>
    <span class="n">yn</span> <span class="o">=</span> <span class="n">ye__</span>

    <span class="k">if</span> <span class="n">yne</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">yn</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">yne</span><span class="p">[:,(</span><span class="n">xn_x</span><span class="o">&gt;=</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">xn_x</span><span class="o">&lt;=</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">yn</span>
        <span class="k">return</span> <span class="n">yne</span>


<div class="viewcode-block" id="interp1_sprague_cie224_2017">
<a class="viewcode-back" href="../../../math.html#luxpy.math.interp1_sprague_cie224_2017">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">interp1_sprague_cie224_2017</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">,</span> <span class="n">extrap</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> 
                     <span class="n">force_scipy_interpolator</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                     <span class="n">scipy_interpolator</span> <span class="o">=</span> <span class="s1">&#39;InterpolatedUnivariateSpline&#39;</span><span class="p">,</span>
                     <span class="n">delete_nans</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                     <span class="n">choose_most_efficient_interpolator</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">verbosity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Perform a 1-dimensional Sprague interpolation according to CIE-224-2017.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :X:</span>
<span class="sd">            | ndarray with n-dimensional coordinates.</span>
<span class="sd">        :Y: </span>
<span class="sd">            | ndarray with values at coordinates in X.</span>
<span class="sd">        :Xnew:</span>
<span class="sd">            | ndarray of new coordinates.</span>
<span class="sd">        :extrap:</span>
<span class="sd">            | (np.nan, np.nan) or string, optional</span>
<span class="sd">            | If tuple: fill with values in tuple (&lt;X[0],&gt;X[-1])</span>
<span class="sd">            | If string:  (&#39;linear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;, &#39;zeros&#39;, &#39;const&#39;)</span>
<span class="sd">        :force_scipy_interpolator:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | If False: numpy.interp function is used for linear interpolation when no or linear extrapolation is used/required (fast!). </span>
<span class="sd">        :scipy_interpolator:</span>
<span class="sd">            | &#39;InterpolatedUnivariateSpline&#39;, optional</span>
<span class="sd">            | options: &#39;InterpolatedUnivariateSpline&#39;, &#39;interp1d&#39;</span>
<span class="sd">        :delete_nans:</span>
<span class="sd">            | True, optional</span>
<span class="sd">            | If NaNs are present, remove them and (and try to) interpolate without them.</span>

<span class="sd">    Returns:</span>
<span class="sd">        :Yn:</span>
<span class="sd">            | ndarray with values at new coordinates in Xnew.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Interpolation: using luxpy interp1_sprague_cie227_2017&#39;</span><span class="p">)</span>
    <span class="n">fintp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Xnew</span><span class="p">:</span> <span class="n">_interp1_sprague_cie224_2017</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">,</span> <span class="n">extrap</span> <span class="o">=</span> <span class="n">extrap</span><span class="p">,</span> 
                                                        <span class="n">force_scipy_interpolator</span> <span class="o">=</span> <span class="n">force_scipy_interpolator</span><span class="p">,</span>
                                                        <span class="n">scipy_interpolator</span> <span class="o">=</span> <span class="n">scipy_interpolator</span><span class="p">,</span> 
                                                        <span class="n">delete_nans</span> <span class="o">=</span> <span class="n">delete_nans</span><span class="p">,</span>
                                                        <span class="n">choose_most_efficient_interpolator</span> <span class="o">=</span> <span class="n">choose_most_efficient_interpolator</span><span class="p">)</span> 
    <span class="k">return</span> <span class="n">_interpolate_with_nans</span><span class="p">(</span><span class="n">fintp</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">,</span> 
                                <span class="n">delete_nans</span> <span class="o">=</span> <span class="n">delete_nans</span><span class="p">,</span> 
                                <span class="n">nan_indices</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> </div>

<span class="c1">#----------------------------------------------------------------------------------------</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_cardinal_lagrange</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">ydata</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    cardinal(xdata, x):</span>
<span class="sd">    In: xdata, array with the nodes x_i.</span>
<span class="sd">    x, array or a scalar of values in which the cardinal functions are evaluated.</span>
<span class="sd">    Return: l: a list of arrays of the cardinal functions evaluated in x.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ydata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span> <span class="o">=</span> <span class="n">_pre_extrap_left_right_with_2</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span><span class="n">ydata</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
    <span class="n">ks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">indices</span> <span class="o">+</span> <span class="n">ks</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">idx</span><span class="p">[:,</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[:,</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">idx</span><span class="p">[:,</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">xdata</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">idx</span><span class="p">[:,</span><span class="n">idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[:,</span><span class="n">idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">idx</span><span class="p">[:,</span><span class="n">idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">li</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">li</span> <span class="o">=</span> <span class="n">li</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">xdata</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span><span class="o">/</span><span class="p">(</span><span class="n">xdata</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">-</span><span class="n">xdata</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>
        <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">li</span><span class="p">)</span> <span class="c1"># Append the array to the list</span>
    <span class="k">return</span> <span class="n">l</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">)</span>
  

<span class="k">def</span><span class="w"> </span><span class="nf">_interp1_lagrange</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xn</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">pre_extrap</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                     <span class="n">extrap</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> 
                     <span class="n">force_scipy_interpolator</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                     <span class="n">scipy_interpolator</span> <span class="o">=</span> <span class="s1">&#39;InterpolatedUnivariateSpline&#39;</span><span class="p">,</span>
                     <span class="n">delete_nans</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                     <span class="n">choose_most_efficient_interpolator</span> <span class="o">=</span> <span class="kc">False</span>
                     <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform k-th order Lagrange interpolation to new xn.</span>
<span class="sd">    (Optionally pre-extrapolate data with additional 2 point to the left and 2 to the right)</span>
<span class="sd">    (Private: for use with interp1_lagrange function)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Do extrapolation:</span>
    <span class="n">xn_x</span><span class="p">,</span> <span class="n">yne</span> <span class="o">=</span> <span class="n">_extrap_y</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xn</span><span class="p">,</span> <span class="n">extrap</span> <span class="o">=</span> <span class="n">extrap</span><span class="p">,</span> 
                        <span class="n">force_scipy_interpolator</span> <span class="o">=</span> <span class="n">force_scipy_interpolator</span><span class="p">,</span>
                        <span class="n">scipy_interpolator</span> <span class="o">=</span> <span class="n">scipy_interpolator</span><span class="p">,</span>
                        <span class="n">delete_nans</span> <span class="o">=</span> <span class="n">delete_nans</span><span class="p">,</span>
                        <span class="n">choose_most_efficient_interpolator</span> <span class="o">=</span> <span class="n">choose_most_efficient_interpolator</span><span class="p">)</span>

    <span class="n">y_</span> <span class="o">=</span> <span class="n">y</span> <span class="k">if</span> <span class="n">pre_extrap</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">l</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">xdata</span><span class="p">,</span><span class="n">ydata</span><span class="p">)</span> <span class="o">=</span> <span class="n">_cardinal_lagrange</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xn</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="p">,</span> <span class="n">ydata</span> <span class="o">=</span> <span class="n">y_</span><span class="p">)</span> <span class="c1"># Find the cardinal functions evaluated in x</span>
    <span class="k">if</span> <span class="n">ydata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ydata</span>
    <span class="n">yn</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">idx</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">l</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">ndim</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># multiply yi (points corresponding to xi for each of the k+1 lagrange polynomials) with lagrange polymials and sum</span>
    
    <span class="k">if</span> <span class="n">yne</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">yn</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># copy lagrange interpolation part into full extrapolated result:</span>
        <span class="n">yne</span><span class="p">[:,(</span><span class="n">xn</span><span class="o">&gt;=</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">xn</span><span class="o">&lt;=</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">yn</span><span class="p">[:,(</span><span class="n">xn</span><span class="o">&gt;=</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">xn</span><span class="o">&lt;=</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>
        <span class="k">return</span> <span class="n">yne</span>

<div class="viewcode-block" id="interp1_lagrange">
<a class="viewcode-back" href="../../../math.html#luxpy.math.interp1_lagrange">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">interp1_lagrange</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
                     <span class="n">extrap</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> 
                     <span class="n">force_scipy_interpolator</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                     <span class="n">scipy_interpolator</span> <span class="o">=</span> <span class="s1">&#39;InterpolatedUnivariateSpline&#39;</span><span class="p">,</span>
                     <span class="n">delete_nans</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                     <span class="n">choose_most_efficient_interpolator</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">verbosity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Perform a 1-dimensional k-th order Lagrange interpolation.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :X:</span>
<span class="sd">            | ndarray with n-dimensional coordinates.</span>
<span class="sd">        :Y: </span>
<span class="sd">            | ndarray with values at coordinates in X.</span>
<span class="sd">        :Xnew:</span>
<span class="sd">            | ndarray of new coordinates.</span>
<span class="sd">        :k:</span>
<span class="sd">            | 5 or int, optional</span>
<span class="sd">            | Order of Lagrange interpolation</span>
<span class="sd">        :extrap:</span>
<span class="sd">            | (np.nan, np.nan) or string, optional</span>
<span class="sd">            | If tuple: fill with values in tuple (&lt;X[0],&gt;X[-1])</span>
<span class="sd">            | If string:  (&#39;linear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;, &#39;zeros&#39;, &#39;const&#39;)</span>
<span class="sd">        :force_scipy_interpolator:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | If False: numpy.interp function is used for linear interpolation when no or linear extrapolation is used/required (fast!). </span>
<span class="sd">        :scipy_interpolator:</span>
<span class="sd">            | &#39;InterpolatedUnivariateSpline&#39;, optional</span>
<span class="sd">            | options: &#39;InterpolatedUnivariateSpline&#39;, &#39;interp1d&#39;</span>
<span class="sd">        :delete_nans:</span>
<span class="sd">            | True, optional</span>
<span class="sd">            | If NaNs are present, remove them and (and try to) interpolate without them.</span>

<span class="sd">    Returns:</span>
<span class="sd">        :Yn:</span>
<span class="sd">            | ndarray with values at new coordinates in Xnew.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Interpolation: using luxpy interp1_lagrange</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">fintp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Xnew</span><span class="p">:</span> <span class="n">_interp1_lagrange</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="p">,</span>  
                                              <span class="n">extrap</span> <span class="o">=</span> <span class="n">extrap</span><span class="p">,</span> 
                                              <span class="n">force_scipy_interpolator</span> <span class="o">=</span> <span class="n">force_scipy_interpolator</span><span class="p">,</span>
                                              <span class="n">scipy_interpolator</span> <span class="o">=</span> <span class="n">scipy_interpolator</span><span class="p">,</span> 
                                              <span class="n">delete_nans</span> <span class="o">=</span> <span class="n">delete_nans</span><span class="p">,</span>
                                              <span class="n">choose_most_efficient_interpolator</span> <span class="o">=</span> <span class="n">choose_most_efficient_interpolator</span><span class="p">)</span> 
    <span class="k">return</span> <span class="n">_interpolate_with_nans</span><span class="p">(</span><span class="n">fintp</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">,</span> 
                                <span class="n">delete_nans</span> <span class="o">=</span> <span class="n">delete_nans</span><span class="p">,</span> 
                                <span class="n">nan_indices</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span>  </div>





<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ndinterp1_scipy">
<a class="viewcode-back" href="../../../math.html#luxpy.math.ndinterp1_scipy">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ndinterp1_scipy</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Xnew</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>  <span class="n">rescale</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>    
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform a n-dimensional linear interpolation (wrapper around scipy.interpolate.LinearNDInterpolator).</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :X: </span>
<span class="sd">            | ndarray with n-dimensional coordinates (last axis represents dimension)</span>
<span class="sd">        :Y: </span>
<span class="sd">            | ndarray with values at coordinates in X</span>
<span class="sd">        :Xnew: </span>
<span class="sd">            | ndarray of new coordinates (last axis represents dimension)</span>
<span class="sd">        :fill_value: </span>
<span class="sd">            | float, optional</span>
<span class="sd">            | Value used to fill in for requested points outside of the</span>
<span class="sd">            | convex hull of the input points.  If not provided, then</span>
<span class="sd">            | the default is ``nan``.</span>
<span class="sd">        :rescale:</span>
<span class="sd">            | bool, optional</span>
<span class="sd">            | Rescale points to unit cube before performing interpolation.</span>
<span class="sd">            | This is useful if some of the input dimensions have</span>
<span class="sd">            | incommensurable units and differ by many orders of magnitude.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        :Ynew:</span>
<span class="sd">            | ndarray with new values at coordinates in Xnew</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">interpolate</span> <span class="c1"># lazy import</span>
    <span class="k">return</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">LinearNDInterpolator</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="n">fill_value</span><span class="p">,</span>  <span class="n">rescale</span> <span class="o">=</span> <span class="n">rescale</span><span class="p">)</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="n">Xnew</span><span class="p">)</span></div>


<div class="viewcode-block" id="ndinterp1">
<a class="viewcode-back" href="../../../math.html#luxpy.math.ndinterp1">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ndinterp1</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform nd-dimensional linear interpolation using Delaunay triangulation.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :X: </span>
<span class="sd">            | ndarray with n-dimensional coordinates (last axis represents dimension).</span>
<span class="sd">        :Y: </span>
<span class="sd">            | ndarray with values at coordinates in X.</span>
<span class="sd">        :Xnew: </span>
<span class="sd">            | ndarray of new coordinates (last axis represents dimension).</span>
<span class="sd">            | When outside of the convex hull of X, then a best estimate is </span>
<span class="sd">            | given based on the closest vertices.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        :Ynew:</span>
<span class="sd">            | ndarray with new values at coordinates in Xnew.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#get dimensions:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">Xnew</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># create an object with triangulation</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">Delaunay</span> <span class="c1"># lazy import</span>
    <span class="n">tri</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> 
    <span class="c1"># find simplexes that contain interpolated points</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">tri</span><span class="o">.</span><span class="n">find_simplex</span><span class="p">(</span><span class="n">Xnew</span><span class="p">)</span>
    <span class="c1"># get the vertices for each simplex</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">tri</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
    <span class="c1"># get transform matrices for each simplex (see explanation bellow)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">tri</span><span class="o">.</span><span class="n">transform</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
    <span class="c1"># for each interpolated point p, mutliply the transform matrix by </span>
    <span class="c1"># vector p-r, where r=m[:,n,:] is one of the simplex vertices to which </span>
    <span class="c1"># the matrix m is related to (again, see below)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,ik-&gt;ij&#39;</span><span class="p">,</span> <span class="n">m</span><span class="p">[:,:</span><span class="n">n</span><span class="p">,:</span><span class="n">n</span><span class="p">],</span> <span class="n">Xnew</span><span class="o">-</span><span class="n">m</span><span class="p">[:,</span><span class="n">n</span><span class="p">,:])</span>
    
    <span class="c1"># get the weights for the vertices; `b` contains an n-dimensional vector</span>
    <span class="c1"># with weights for all but the last vertices of the simplex</span>
    <span class="c1"># (note that for n-D grid, each simplex consists of n+1 vertices);</span>
    <span class="c1"># the remaining weight for the last vertex can be copmuted from</span>
    <span class="c1"># the condition that sum of weights must be equal to 1</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">b</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
    
    <span class="c1"># normalize weigths:</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">/</span><span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="c1"># interpolate:</span>
    <span class="k">if</span> <span class="n">Y</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">Ynew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,ij-&gt;ik&#39;</span><span class="p">,</span> <span class="n">Y</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">w</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Ynew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,ij-&gt;i&#39;</span><span class="p">,</span> <span class="n">Y</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">w</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">Ynew</span></div>


<div class="viewcode-block" id="box_m">
<a class="viewcode-back" href="../../../math.html#luxpy.math.box_m">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">box_m</span><span class="p">(</span><span class="o">*</span><span class="n">X</span><span class="p">,</span> <span class="n">ni</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbosity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">robust</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">robust_alpha</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform Box&#39;s M test (p&gt;=2) to check equality of covariance matrices or Bartlett&#39;s test (p==1) for equality of variances.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :X: </span>
<span class="sd">            | A number  (k groups) or list of 2d-ndarrays (rows: samples, cols: variables) with data.</span>
<span class="sd">            | or a number of 2d-ndarrays with covariance matrices (supply ni!)</span>
<span class="sd">        :ni:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | If None: X contains data, else, X contains covariance matrices.</span>
<span class="sd">        :verbosity: </span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | If 1: print results.</span>
<span class="sd">        :robust:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | If True: remove outliers beyond the confidence ellipsoid before calculating</span>
<span class="sd">            |          the covariances.</span>
<span class="sd">        :robust_alpha:</span>
<span class="sd">            | 0.01, optional</span>
<span class="sd">            | Significance level of confidence ellipsoid marking the boundary for outliers.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :statistic:</span>
<span class="sd">            | F or chi2 value (see len(dfs))</span>
<span class="sd">        :pval:</span>
<span class="sd">            | p-value</span>
<span class="sd">        :df:</span>
<span class="sd">            | degrees of freedom.</span>
<span class="sd">            | if len(dfs) == 2: F-test was used.</span>
<span class="sd">            | if len(dfs) == 1: chi2 approx. was used.</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        1. If p==1: Reduces to Bartlett&#39;s test for equal variances.</span>
<span class="sd">        2. If (ni&gt;20).all() &amp; (p&lt;6) &amp; (k&lt;6): then a more appropriate chi2 test is used in a some cases.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">stats</span> <span class="c1"># lazy import</span>
    
    <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="c1"># groups</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># variables</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># for p == 1: only variance!</span>
        <span class="n">det</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">det</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ni</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># samples in each group</span>
        
        <span class="c1"># remove outliers before calculation of box M:</span>
        <span class="k">if</span> <span class="n">robust</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="n">remove_outliers</span><span class="p">(</span><span class="n">Xi</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">robust_alpha</span><span class="p">)</span> <span class="k">for</span> <span class="n">Xi</span> <span class="ow">in</span> <span class="n">X</span><span class="p">]</span>
            
        <span class="n">ni</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Xi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">Xi</span> <span class="ow">in</span> <span class="n">X</span><span class="p">])</span>
        <span class="n">Si</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">Xi</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="k">for</span> <span class="n">Xi</span> <span class="ow">in</span> <span class="n">X</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">Si</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">Si</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Si</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Xi</span> <span class="k">for</span> <span class="n">Xi</span> <span class="ow">in</span> <span class="n">X</span><span class="p">])</span> <span class="c1"># input are already cov matrices!</span>
        <span class="n">ni</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ni</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ni</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ni</span> <span class="o">=</span> <span class="n">ni</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">k</span><span class="p">,))</span>
        
    <span class="n">N</span> <span class="o">=</span> <span class="n">ni</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">ni</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Si</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ni</span><span class="p">))])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span>

    <span class="n">M</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">det</span><span class="p">(</span><span class="n">S</span><span class="p">))</span> <span class="o">-</span> <span class="p">((</span><span class="n">ni</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">det</span><span class="p">(</span><span class="n">Si</span><span class="p">)))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">A1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">p</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="p">((</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">ni</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">k</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">A2</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="p">((</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">ni</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">A2</span> <span class="o">-</span> <span class="n">A1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">v2</span> <span class="o">=</span> <span class="p">(</span><span class="n">v1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">A2</span> <span class="o">-</span> <span class="n">A1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">v1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">A1</span> <span class="o">-</span><span class="p">(</span><span class="n">v1</span><span class="o">/</span><span class="n">v2</span><span class="p">))</span>
        <span class="n">Fv1v2</span> <span class="o">=</span> <span class="n">M</span><span class="o">/</span><span class="n">b</span>
        <span class="n">statistic</span> <span class="o">=</span> <span class="n">Fv1v2</span>
        <span class="n">pval</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">Fv1v2</span><span class="p">,</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">)</span>
        <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">verbosity</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;M = </span><span class="si">{:1.4f}</span><span class="s1">, F = </span><span class="si">{:1.4f}</span><span class="s1">, df1 = </span><span class="si">{:1.1f}</span><span class="s1">, df2 = </span><span class="si">{:1.1f}</span><span class="s1">, p = </span><span class="si">{:1.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">Fv1v2</span><span class="p">,</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="n">pval</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">v2</span> <span class="o">=</span> <span class="p">(</span><span class="n">v1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">A1</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">A2</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">v2</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">A1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="n">v2</span><span class="p">))</span>
        <span class="n">Fv1v2</span> <span class="o">=</span> <span class="n">v2</span><span class="o">*</span><span class="n">M</span><span class="o">/</span><span class="p">(</span><span class="n">v1</span><span class="o">*</span><span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">M</span><span class="p">))</span>
        <span class="n">statistic</span> <span class="o">=</span> <span class="n">Fv1v2</span>
        <span class="n">pval</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">Fv1v2</span><span class="p">,</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">)</span>
        <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">]</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">ni</span><span class="o">&gt;</span><span class="mi">20</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">k</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">):</span> <span class="c1">#use Chi2v1</span>
            <span class="n">chi2v1</span> <span class="o">=</span> <span class="n">M</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">A1</span><span class="p">)</span>
            <span class="n">statistic</span> <span class="o">=</span> <span class="n">chi2v1</span>
            <span class="n">pval</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">chi2v1</span><span class="p">,</span><span class="n">v1</span><span class="p">)</span>
            <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">v1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">verbosity</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;M = </span><span class="si">{:1.4f}</span><span class="s1">, chi2 = </span><span class="si">{:1.4f}</span><span class="s1">, df1 = </span><span class="si">{:1.1f}</span><span class="s1">, p = </span><span class="si">{:1.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">chi2v1</span><span class="p">,</span><span class="n">v1</span><span class="p">,</span><span class="n">pval</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbosity</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;M = </span><span class="si">{:1.4f}</span><span class="s1">, F = </span><span class="si">{:1.4f}</span><span class="s1">, df1 = </span><span class="si">{:1.1f}</span><span class="s1">, df2 = </span><span class="si">{:1.1f}</span><span class="s1">, p = </span><span class="si">{:1.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">Fv1v2</span><span class="p">,</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="n">pval</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">statistic</span><span class="p">,</span> <span class="n">pval</span><span class="p">,</span> <span class="n">dfs</span></div>


<div class="viewcode-block" id="pitman_morgan">
<a class="viewcode-back" href="../../../math.html#luxpy.math.pitman_morgan">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">pitman_morgan</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span> <span class="n">verbosity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pitman-Morgan Test for the difference between correlated variances with paired samples.</span>
<span class="sd">     </span>
<span class="sd">    Args:</span>
<span class="sd">        :X,Y: </span>
<span class="sd">            | ndarrays with data.</span>
<span class="sd">        :verbosity: </span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | If 1: print results. </span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :tval:</span>
<span class="sd">            | statistic</span>
<span class="sd">        :pval:</span>
<span class="sd">            | p-value</span>
<span class="sd">        :df:</span>
<span class="sd">            | degree of freedom.</span>
<span class="sd">        :ratio:</span>
<span class="sd">            | variance ratio var1/var2 (with var1 &gt; var2).</span>

<span class="sd">    Note:</span>
<span class="sd">        1. Based on Gardner, R.C. (2001). Psychological Statistics Using SPSS for Windows. New Jersey, Prentice Hall.</span>
<span class="sd">        2. Python port from matlab code by Janne Kauttonen (https://nl.mathworks.com/matlabcentral/fileexchange/67910-pitmanmorgantest-x-y; accessed Sep 26, 2019)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">stats</span> <span class="c1"># lazy import</span>
    
    <span class="n">N</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">var1</span><span class="p">,</span> <span class="n">var2</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span><span class="n">Y</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">cor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="c1"># must have var1 &gt; var2:</span>
    <span class="k">if</span> <span class="n">var1</span> <span class="o">&lt;</span> <span class="n">var2</span><span class="p">:</span>
        <span class="n">var1</span><span class="p">,</span> <span class="n">var2</span> <span class="o">=</span> <span class="n">var2</span><span class="p">,</span> <span class="n">var1</span>

    <span class="n">ratio</span> <span class="o">=</span> <span class="n">var1</span><span class="o">/</span><span class="n">var2</span>
    
    <span class="c1"># formulas from Garder (2001, p.57):</span>
    <span class="n">numerator1_S1minusS2</span> <span class="o">=</span> <span class="n">var1</span><span class="o">-</span><span class="n">var2</span>
    <span class="n">numerator2_SQRTnminus2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">numerator3</span> <span class="o">=</span> <span class="n">numerator1_S1minusS2</span><span class="o">*</span><span class="n">numerator2_SQRTnminus2</span>
    <span class="n">denominator1_4timesS1timesS2</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">var1</span><span class="o">*</span><span class="n">var2</span>
    <span class="n">denominator2_rSquared</span> <span class="o">=</span> <span class="n">cor</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">denominator3_1minusrSquared</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">denominator2_rSquared</span>
    <span class="n">denominator4_4timesS1timesS2div1minusrSquared</span> <span class="o">=</span> <span class="n">denominator1_4timesS1timesS2</span><span class="o">*</span><span class="n">denominator3_1minusrSquared</span>
    <span class="n">denominator5</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">denominator4_4timesS1timesS2div1minusrSquared</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">N</span><span class="o">-</span><span class="mi">2</span>
    <span class="k">if</span> <span class="n">denominator5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">denominator5</span> <span class="o">=</span> <span class="n">_EPS</span>
    <span class="n">tval</span> <span class="o">=</span> <span class="n">numerator3</span><span class="o">/</span><span class="n">denominator5</span>
    
    <span class="c1"># compute stats:</span>
    <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">tval</span><span class="p">,</span><span class="n">df</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">verbosity</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;tval = </span><span class="si">{:1.4f}</span><span class="s1">, df = </span><span class="si">{:1.1f}</span><span class="s1">, p = </span><span class="si">{:1.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tval</span><span class="p">,</span><span class="n">df</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">tval</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">ratio</span></div>


<div class="viewcode-block" id="stress">
<a class="viewcode-back" href="../../../math.html#luxpy.math.stress">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">stress</span><span class="p">(</span><span class="n">DE</span><span class="p">,</span><span class="n">DV</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">max_scale</span> <span class="o">=</span> <span class="mi">100</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate STandardize-Residual-Sum-of-Squares (STRESS).</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :DE, DV: </span>
<span class="sd">            | ndarrays of data to be compared.</span>
<span class="sd">        :axis:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | axis with samples</span>
<span class="sd">        :max_scale:</span>
<span class="sd">            | 100, optional</span>
<span class="sd">            | Maximum of scale.</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :stress:</span>
<span class="sd">            | nadarray with stress value(s).</span>
<span class="sd">    </span>
<span class="sd">    Reference:</span>
<span class="sd">        1. `Melgosa, M., García, P. A., Gómez-Robledo, L., Shamey, R., Hinks, D., Cui, G., &amp; Luo, M. R. (2011). </span>
<span class="sd">        Notes on the application of the standardized residual sum of squares index </span>
<span class="sd">        for the assessment of intra- and inter-observer variability in color-difference experiments. </span>
<span class="sd">        Journal of the Optical Society of America A, 28(5), 949–953. </span>
<span class="sd">        &lt;https://doi.org/10.1364/JOSAA.28.000949&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">F</span> <span class="o">=</span> <span class="p">(</span><span class="n">DE</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">DE</span><span class="o">*</span><span class="n">DV</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">max_scale</span><span class="o">*</span><span class="p">(((</span><span class="n">DE</span> <span class="o">-</span> <span class="n">F</span><span class="o">*</span><span class="n">DV</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">F</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">DV</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">True</span><span class="p">))</span><span class="o">**</span><span class="mf">0.5</span></div>


<div class="viewcode-block" id="stress_F_test">
<a class="viewcode-back" href="../../../math.html#luxpy.math.stress_F_test">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">stress_F_test</span><span class="p">(</span><span class="n">stressA</span><span class="p">,</span> <span class="n">stressB</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Perform F-test on significance of difference between STRESS A and STRESS B.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :stressA, stressB:</span>
<span class="sd">            | ndarray with stress(es) values for A and B</span>
<span class="sd">        :N:</span>
<span class="sd">            | int or ndarray with number of samples used to determine stress values.</span>
<span class="sd">        :alpha:</span>
<span class="sd">            | 0.05, optional</span>
<span class="sd">            | significance level</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :Fstats:</span>
<span class="sd">            | Dictionary with keys:</span>
<span class="sd">            | - &#39;p&#39;: p-values</span>
<span class="sd">            | - &#39;F&#39;:  F-values</span>
<span class="sd">            | - &#39;Fc&#39;: critcal values</span>
<span class="sd">            | - &#39;H&#39;: string reporting on significance of A compared to B.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">stats</span> <span class="c1"># lazy import</span>
    
    <span class="n">N</span> <span class="o">=</span> <span class="n">N</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">stressA</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">Fvs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">stressA</span><span class="p">)</span>
    <span class="n">ps</span> <span class="o">=</span> <span class="n">Fvs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">Fcs</span> <span class="o">=</span> <span class="n">Fvs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">H</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">stA</span><span class="p">,</span> <span class="n">stB</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">stressA</span><span class="p">,</span><span class="n">stressB</span><span class="p">):</span>
        <span class="n">Ni</span> <span class="o">=</span> <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">Fvs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">stA</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">stB</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">ps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="n">Fvs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Ni</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Ni</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">Fcs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">q</span> <span class="o">=</span> <span class="n">alpha</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">dfn</span> <span class="o">=</span> <span class="n">Ni</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dfd</span> <span class="o">=</span> <span class="n">Ni</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Fvs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">Fcs</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">H_</span> <span class="o">=</span> <span class="s2">&quot;A significantly better than B&quot;</span>
        <span class="k">elif</span> <span class="n">Fvs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">/</span><span class="n">Fcs</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">H_</span> <span class="o">=</span> <span class="s2">&quot;A significantly poorer than B&quot;</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">Fcs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">Fvs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Fvs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">H_</span> <span class="o">=</span> <span class="s2">&quot;A insignificantly better than B&quot;</span>
        <span class="k">elif</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">Fvs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Fvs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">/</span><span class="n">Fcs</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
            <span class="n">H_</span> <span class="o">=</span> <span class="s2">&quot;A insignificantly poorer than B&quot;</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">Fvs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">H_</span> <span class="o">=</span> <span class="s2">&quot;A equals B&quot;</span>
        <span class="n">H</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">H_</span><span class="p">)</span>
        <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
    <span class="n">Fstats</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;p&#39;</span><span class="p">:</span> <span class="n">ps</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">:</span> <span class="n">Fvs</span><span class="p">,</span> <span class="s1">&#39;Fc&#39;</span><span class="p">:</span> <span class="n">Fcs</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="n">H</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">Fstats</span></div>


<div class="viewcode-block" id="mean_distance_weighted">
<a class="viewcode-back" href="../../../math.html#luxpy.math.mean_distance_weighted">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">mean_distance_weighted</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">center_x</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="n">mu</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mu0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recursively calculate distance weighted mean.</span>
<span class="sd">    </span>
<span class="sd">    Args: </span>
<span class="sd">        :x:</span>
<span class="sd">            | ndarray with data</span>
<span class="sd">        :axis:</span>
<span class="sd">            | dimension along which to take mean</span>
<span class="sd">        :keepdims:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | If True: keep dimension of original ndarray</span>
<span class="sd">        :center_x:</span>
<span class="sd">            | True, optional</span>
<span class="sd">            | Center data first.</span>
<span class="sd">        :rtol:</span>
<span class="sd">            | 1e-3, optional</span>
<span class="sd">            | Relative tolerance on recursive mean values. If two sequential</span>
<span class="sd">            | mean values differ less than this amount, the recursion stops.</span>
<span class="sd">        :max_iter:</span>
<span class="sd">            | 100, optional</span>
<span class="sd">            | Maximum amount of recursions. If this number is reached the </span>
<span class="sd">            | recursion stops, even when rtol is not yet achieved. (to avoid</span>
<span class="sd">            | getting stuck in an infinite loop when the recursion doesn&#39;t converge)</span>
<span class="sd">        :cnt,mu,mu0:</span>
<span class="sd">            | Needed for passing values across recursions to be able to stop them.</span>
<span class="sd">            | DO NOT CHANGE.</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :mu_dw:</span>
<span class="sd">            | distance weighted mean of the array</span>
<span class="sd">            </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span> 
    <span class="k">if</span> <span class="n">mu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
        <span class="k">if</span> <span class="n">center_x</span><span class="p">:</span> 
            <span class="n">mu0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">mu0</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        
    <span class="n">w</span> <span class="o">=</span> <span class="p">(((</span><span class="n">x</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="c1"># w = (((x - mu)**2))**0.5</span>
    <span class="n">w</span><span class="p">[</span><span class="n">w</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-100</span>
    <span class="n">w</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">w</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">w</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">mu_prev</span> <span class="o">=</span> <span class="n">mu</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">mu</span><span class="o">-</span><span class="n">mu_prev</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">mu</span> <span class="o">+</span> <span class="mf">1e-100</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">rtol</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">())</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">max_iter</span><span class="p">):</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">mean_distance_weighted</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="n">keepdims</span><span class="p">,</span><span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span><span class="p">,</span> <span class="n">mu0</span> <span class="o">=</span> <span class="n">mu0</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">)</span>     
        <span class="k">return</span> <span class="n">mu</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">keepdims</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mu0</span> <span class="o">+</span> <span class="n">mu</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">mu0</span> <span class="o">+</span> <span class="n">mu</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span><span class="p">)</span></div>

            
<span class="c1">#---------------------------------------------------------------------------------</span>
<span class="k">def</span><span class="w"> </span><span class="nf">round_sigfig</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Round x (int, float, ndarray) to n significant digits.</span>

<span class="sd">    Args:</span>
<span class="sd">        :x: </span>
<span class="sd">            | int, float, ndarray to be rounded</span>
<span class="sd">        :n:</span>
<span class="sd">            | int</span>
<span class="sd">            | Number of significant digits</span>
<span class="sd">    Returns:</span>
<span class="sd">        :y: </span>
<span class="sd">            | rounded value(s)</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        1. From: https://stackoverflow.com/questions/18915378/rounding-to-significant-figures-in-numpy </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x_positive</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">mags</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">x_positive</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">mags</span><span class="p">)</span> <span class="o">/</span> <span class="n">mags</span>

<span class="k">def</span><span class="w"> </span><span class="nf">round_halfwayfromzero</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Round x to n decimal points using round half away from zero.</span>
<span class="sd">    This function is needed because the rounding specified in the CIE</span>
<span class="sd">    recommendation is different from the standard rounding scheme in python</span>
<span class="sd">    (which is following the IEEE recommendation).</span>
<span class="sd">    Args:</span>
<span class="sd">        :x: </span>
<span class="sd">            | int, float, ndarray to be rounded</span>
<span class="sd">        :n:</span>
<span class="sd">            | int</span>
<span class="sd">            | Number of decimal points</span>
<span class="sd">    Returns:</span>
<span class="sd">        :y: </span>
<span class="sd">            | rounded value(s)</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        1. From: CIETC1-97: https://github.com/ifarup/ciefunctions </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="mi">10</span><span class="o">**</span><span class="n">n</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">/</span><span class="mi">10</span><span class="o">**</span><span class="n">n</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_round</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Round helper function (private)&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
        <span class="k">return</span> <span class="n">x</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="nb">tuple</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;sigfig&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">round_sigfig</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;dec&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;nearesteven&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;np&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;halfwayfromzero&#39;</span><span class="p">):</span>
              <span class="k">return</span> <span class="n">round_halfwayfromzero</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    
<div class="viewcode-block" id="round">
<a class="viewcode-back" href="../../../math.html#luxpy.math.round">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">round</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Round x (int, float, ndarray or tuple) to n significant digits, or n decimals (&#39;to nearest even&#39; or &#39;halfway from zero&#39;).</span>

<span class="sd">    Args:</span>
<span class="sd">        :x: </span>
<span class="sd">            | int, float, ndarray or tuple to be rounded.</span>
<span class="sd">        :n:</span>
<span class="sd">            | int or tuple</span>
<span class="sd">            | Number of significant digits, or n decimals.</span>
<span class="sd">            | If int: round to nearest even using numpy&#39;s round() function</span>
<span class="sd">            | if Tuple: first element specifies the number of digits, the second element is a string specifying the method:</span>
<span class="sd">            |   - &#39;sigfig&#39;: round to n significant digits (uses luxpy.math.round_sigfig function).</span>
<span class="sd">            |   - &#39;dec&#39; or &#39;nearesteven&#39; or &#39;numpy&#39; or &#39;np&#39;: round to nearest even using numpy&#39;s round function.</span>
<span class="sd">            |   - &#39;halfwayfromzero&#39;: rounds halfway from zero (uses luxpy.math.round_awayfromzero function).</span>
<span class="sd">    Returns:</span>
<span class="sd">        :y: </span>
<span class="sd">            | rounded value(s).</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        1. &#39;sigfig&#39; from: https://stackoverflow.com/questions/18915378/rounding-to-significant-figures-in-numpy </span>
<span class="sd">        2. &#39;halfwayfromzero&#39; from: CIETC1-97: https://github.com/ifarup/ciefunctions </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">_round</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_round</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">n</span><span class="p">)</span></div>


        
<span class="c1"># if __name__ == &#39;__main__&#39;:</span>
<span class="c1">#     import luxpy as lx </span>
<span class="c1">#     import matplotlib.pyplot as plt</span>
<span class="c1">#     spd = lx._CIE_D65[:,::5]</span>
<span class="c1">#     wln = lx.getwlr([380,830,1])</span>
<span class="c1">#     spdi = interp1_sprague_cie224_2017(spd[0],spd[1:], wln)</span>
<span class="c1">#     plt.plot(spd[0],spd[1],&#39;b-&#39;)</span>
<span class="c1">#     plt.plot(wln,spdi[0],&#39;r:&#39;)</span>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Kevin A.G. Smet.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>