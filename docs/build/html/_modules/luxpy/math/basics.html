<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>luxpy.math.basics &mdash; LuxPy 1.11.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b76e3c8a" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=6cf1fb80"></script>
        <script src="../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            LuxPy
          </a>
              <div class="version">
                1.11.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License: GPLv3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../required_packages.html">Imported (required) packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../luxpy_structure.html">Luxpy package structure</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">LuxPy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">luxpy.math.basics</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for luxpy.math.basics</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">########################################################################</span>
<span class="c1"># &lt;LUXPY: a Python package for lighting and color science.&gt;</span>
<span class="c1"># Copyright (C) &lt;2017&gt;  &lt;Kevin A.G. Smet&gt; (ksmet1977 at gmail.com)</span>
<span class="c1">#</span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#########################################################################</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module with useful basic math functions</span>
<span class="sd">=======================================</span>

<span class="sd"> :normalize_3x3_matrix(): Normalize 3x3 matrix M to xyz0 -- &gt; [1,1,1]</span>

<span class="sd"> :line_intersect(): | Line intersections of series of two line segments a and b. </span>
<span class="sd">                    | https://stackoverflow.com/questions/3252194/numpy-and-line-intersections</span>

<span class="sd"> :positive_arctan(): Calculates the positive angle (0°-360° or 0 - 2*pi rad.) </span>
<span class="sd">                     from x and y.</span>

<span class="sd"> :dot23(): Dot product of a 2-d ndarray </span>
<span class="sd">           with a (N x K x L) 3-d ndarray using einsum().</span>

<span class="sd"> :check_symmetric(): Checks if A is symmetric.</span>

<span class="sd"> :check_posdef(): Checks positive definiteness of a matrix via Cholesky.</span>

<span class="sd"> :symmM_to_posdefM(): | Converts a symmetric matrix to a positive definite one. </span>
<span class="sd">                      | Two methods are supported:</span>
<span class="sd">                      |    * &#39;make&#39;: A Python/Numpy port of Muhammad Asim Mubeen&#39;s</span>
<span class="sd">                      |              matlab function Spd_Mat.m </span>
<span class="sd">                      |       (https://nl.mathworks.com/matlabcentral/fileexchange/45873-positive-definite-matrix)</span>
<span class="sd">                      |    * &#39;nearest&#39;: A Python/Numpy port of John D&#39;Errico&#39;s </span>
<span class="sd">                      |                &#39;nearestSPD&#39; MATLAB code. </span>
<span class="sd">                      |        (https://stackoverflow.com/questions/43238173/python-convert-matrix-to-positive-semi-definite)</span>

<span class="sd"> :bvgpdf(): Evaluate bivariate Gaussian probability density function (BVGPDF) </span>
<span class="sd">            at (x,y) with center mu and inverse covariance matric, sigmainv.</span>

<span class="sd"> :mahalanobis2(): Evaluate the squared mahalanobis distance with center mu and </span>
<span class="sd">                  shape and orientation determined by sigmainv. </span>

<span class="sd"> :rms(): Calculates root-mean-square along axis.</span>

<span class="sd"> :geomean(): Calculates geometric mean along axis.</span>

<span class="sd"> :polyarea(): | Calculates area of polygon. </span>
<span class="sd">              | (First coordinate should also be last)</span>

<span class="sd"> :erf(), erfinv(): erf-function and its inverse, imported from scipy.special</span>

<span class="sd"> :cart2pol(): Converts Cartesian to polar coordinates.</span>

<span class="sd"> :pol2cart(): Converts polar to Cartesian coordinates.</span>
<span class="sd"> </span>
<span class="sd"> :cart2spher(): Converts Cartesian to spherical coordinates.</span>
<span class="sd"> </span>
<span class="sd"> :spher2cart(): Converts spherical to Cartesian coordinates.</span>

<span class="sd"> :magnitude_v():  Calculates magnitude of vector.</span>

<span class="sd"> :angle_v1v2():  Calculates angle between two vectors.</span>

<span class="sd"> :histogram(): | Histogram function that can take as bins either the center</span>
<span class="sd">               | (cfr. matlab hist) or bin-edges.</span>

<span class="sd"> :v_to_cik(): Calculate 2x2 &#39;(covariance matrix)^-1&#39; elements cik from v-format ellipse descriptor.</span>

<span class="sd"> :cik_to_v(): Calculate v-format ellipse descriptor from 2x2 &#39;covariance matrix&#39;^-1 cik.</span>
<span class="sd"> </span>
<span class="sd"> :fmod(): Floating point modulus, e.g.: fmod(theta, np.pi * 2) would keep an angle in [0, 2pi]b</span>
<span class="sd"> </span>
<span class="sd"> :remove_outliers(): Remove multivariate outliers from data when outside of alpha-level confidence ellipsoid.</span>

<span class="sd"> :fit_ellipse(): Fit an ellipse to supplied data points.</span>
<span class="sd"> </span>
<span class="sd"> :fit_cov_ellipse(): Fit an covariance ellipse to supplied data points.</span>
<span class="sd"> </span>
<span class="sd"> :interp1_sprague5(): Perform a 1-dimensional 5th order Sprague interpolation.</span>
<span class="sd"> </span>
<span class="sd"> :interp1(): Perform a 1-dimensional linear interpolation (wrapper around scipy.interpolate.InterpolatedUnivariateSpline).</span>
<span class="sd"> </span>
<span class="sd"> :ndinterp1(): Perform n-dimensional interpolation using Delaunay triangulation.</span>
<span class="sd"> </span>
<span class="sd"> :ndinterp1_scipy(): Perform n-dimensional interpolation using Delaunay triangulation (wrapper around scipy.interpolate.LinearNDInterpolator)</span>
<span class="sd"> </span>
<span class="sd"> :box_m(): Performs a Box M test on covariance matrices.</span>
<span class="sd"> </span>
<span class="sd"> :pitman_morgan(): Pitman-Morgan Test for the difference between correlated variances with paired samples.</span>
<span class="sd">     </span>
<span class="sd"> :stress(): Calculate STandardize-Residual-Sum-of-Squares (STRESS)</span>
<span class="sd"> </span>
<span class="sd"> :stress_F_test(): Perform F-test on significance of difference between STRESS A and STRESS B.</span>
<span class="sd"> </span>
<span class="sd"> :mean_distance_weighted(): Recursively calculates distance weighted mean.</span>
<span class="sd"> </span>
<span class="sd">.. codeauthor:: Kevin A.G. Smet (ksmet1977 at gmail.com)</span>
<span class="sd">===============================================================================</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">luxpy.utils</span> <span class="kn">import</span> <span class="n">np2d</span><span class="p">,</span> <span class="n">_EPS</span><span class="p">,</span> <span class="n">asplit</span>
<span class="c1"># from scipy import stats # has become a lazy import</span>

<span class="n">__all__</span>  <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;normalize_3x3_matrix&#39;</span><span class="p">,</span><span class="s1">&#39;symmM_to_posdefM&#39;</span><span class="p">,</span><span class="s1">&#39;check_symmetric&#39;</span><span class="p">,</span>
            <span class="s1">&#39;check_posdef&#39;</span><span class="p">,</span><span class="s1">&#39;positive_arctan&#39;</span><span class="p">,</span><span class="s1">&#39;line_intersect&#39;</span><span class="p">,</span><span class="s1">&#39;erf&#39;</span><span class="p">,</span> <span class="s1">&#39;erfinv&#39;</span><span class="p">,</span> 
            <span class="s1">&#39;histogram&#39;</span><span class="p">,</span> <span class="s1">&#39;pol2cart&#39;</span><span class="p">,</span> <span class="s1">&#39;cart2pol&#39;</span><span class="p">,</span> <span class="s1">&#39;spher2cart&#39;</span><span class="p">,</span> <span class="s1">&#39;cart2spher&#39;</span><span class="p">]</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;bvgpdf&#39;</span><span class="p">,</span><span class="s1">&#39;mahalanobis2&#39;</span><span class="p">,</span><span class="s1">&#39;dot23&#39;</span><span class="p">,</span> <span class="s1">&#39;rms&#39;</span><span class="p">,</span><span class="s1">&#39;geomean&#39;</span><span class="p">,</span><span class="s1">&#39;polyarea&#39;</span><span class="p">]</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;magnitude_v&#39;</span><span class="p">,</span><span class="s1">&#39;angle_v1v2&#39;</span><span class="p">]</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;v_to_cik&#39;</span><span class="p">,</span> <span class="s1">&#39;cik_to_v&#39;</span><span class="p">,</span> <span class="s1">&#39;fmod&#39;</span><span class="p">,</span> <span class="s1">&#39;remove_outliers&#39;</span><span class="p">,</span><span class="s1">&#39;fit_ellipse&#39;</span><span class="p">,</span><span class="s1">&#39;fit_cov_ellipse&#39;</span><span class="p">]</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;in_hull&#39;</span><span class="p">,</span><span class="s1">&#39;interp1_sprague5&#39;</span><span class="p">,</span><span class="s1">&#39;interp1&#39;</span><span class="p">,</span> <span class="s1">&#39;ndinterp1&#39;</span><span class="p">,</span><span class="s1">&#39;ndinterp1_scipy&#39;</span><span class="p">]</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;box_m&#39;</span><span class="p">,</span><span class="s1">&#39;pitman_morgan&#39;</span><span class="p">,</span> <span class="s1">&#39;stress&#39;</span><span class="p">,</span><span class="s1">&#39;stress_F_test&#39;</span><span class="p">,</span><span class="s1">&#39;mean_distance_weighted&#39;</span><span class="p">]</span>


<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="erf">
<a class="viewcode-back" href="../../../math.html#luxpy.math.erf">[docs]</a>
<span class="k">def</span> <span class="nf">erf</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    erf(x, /, out=None, *, where=True, casting=&#39;same_kind&#39;, order=&#39;K&#39;, dtype=None, subok=True[, signature, extobj])</span>
<span class="sd">    erf(z) Returns the error function of complex argument.</span>
<span class="sd">    </span>
<span class="sd">    It is defined as ``2/sqrt(pi)*integral(exp(-t**2), t=0..z)``.</span>
<span class="sd">    Args: </span>
<span class="sd">        :x: </span>
<span class="sd">            | ndarray</span>
<span class="sd">            | Input array.</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :res:</span>
<span class="sd">            | ndarray</span>
<span class="sd">            | The values of the error function at the given points `x`.</span>
<span class="sd">    See Also:</span>
<span class="sd">        | nerfc, erfinv, erfcinv, wofz, erfcx, erfi</span>
<span class="sd">        </span>
<span class="sd">    Notes:</span>
<span class="sd">        1. The cumulative of the unit normal distribution is given by</span>
<span class="sd">        ``Phi(z) = 1/2[1 + erf(z/sqrt(2))]``.</span>
<span class="sd">        </span>
<span class="sd">    References:</span>
<span class="sd">        1. https://en.wikipedia.org/wiki/Error_function</span>
<span class="sd">        2. Milton Abramowitz and Irene A. Stegun, eds.</span>
<span class="sd">        Handbook of Mathematical Functions with Formulas, Graphs, and Mathematical Tables. µ</span>
<span class="sd">        New York: Dover, 1972. http://www.math.sfu.ca/~cbm/aands/page_297.htm </span>
<span class="sd">        3. Steven G. Johnson, Faddeeva W function implementation.</span>
<span class="sd">        http://ab-initio.mit.edu/Faddeeva </span>
<span class="sd">        </span>
<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from scipy import special</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; x = np.linspace(-3, 3)</span>
<span class="sd">        &gt;&gt;&gt; plt.plot(x, special.erf(x))</span>
<span class="sd">        &gt;&gt;&gt; plt.xlabel(&#39;$x$&#39;)</span>
<span class="sd">        &gt;&gt;&gt; plt.ylabel(&#39;$erf(x)$&#39;)</span>
<span class="sd">        &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">erf</span> <span class="c1"># lazy import</span>
    <span class="k">return</span> <span class="n">erf</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="erfinv">
<a class="viewcode-back" href="../../../math.html#luxpy.math.erfinv">[docs]</a>
<span class="k">def</span> <span class="nf">erfinv</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    erfinv(x, /, out=None, *, where=True, casting=&#39;same_kind&#39;, order=&#39;K&#39;, dtype=None, subok=True[, signature, extobj])</span>
<span class="sd">    Inverse of the error function.</span>
<span class="sd">    Computes the inverse of the error function.</span>
<span class="sd">    </span>
<span class="sd">    In the complex domain, there is no unique complex number w satisfying erf(w)=z. </span>
<span class="sd">    This indicates a true inverse function would have multi-value.</span>
<span class="sd">    When the domain restricts to the real, -1 &lt; x &lt; 1, there is a unique real number</span>
<span class="sd">    satisfying erf(erfinv(x)) = x.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :y:</span>
<span class="sd">            | ndarray</span>
<span class="sd">            | Argument at which to evaluate. Domain: [-1, 1]</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :erfinv: </span>
<span class="sd">            | ndarray</span>
<span class="sd">            | The inverse of erf of y, element-wise)</span>
<span class="sd">    </span>
<span class="sd">    See Also:</span>
<span class="sd">        - erf : Error function of a complex argument</span>
<span class="sd">        - erfc : Complementary error function, ``1 - erf(x)``</span>
<span class="sd">        - erfcinv : Inverse of the complementary error function</span>
<span class="sd">        </span>
<span class="sd">    Examples:</span>
<span class="sd">        1) evaluating a float number</span>
<span class="sd">            &gt;&gt;&gt; from scipy import special</span>
<span class="sd">            &gt;&gt;&gt; special.erfinv(0.5)</span>
<span class="sd">            0.4769362762044698</span>
<span class="sd">        2) evaluating an ndarray</span>
<span class="sd">            &gt;&gt;&gt; from scipy import special</span>
<span class="sd">            &gt;&gt;&gt; y = np.linspace(-1.0, 1.0, num=10)</span>
<span class="sd">            &gt;&gt;&gt; special.erfinv(y)</span>
<span class="sd">            array([       -inf, -0.86312307, -0.5407314 , -0.30457019, -0.0987901 ,</span>
<span class="sd">                   0.0987901 ,  0.30457019,  0.5407314 ,  0.86312307,         inf])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">erfinv</span> <span class="c1"># lazy import</span>
    <span class="k">return</span> <span class="n">erfinv</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="normalize_3x3_matrix">
<a class="viewcode-back" href="../../../math.html#luxpy.math.normalize_3x3_matrix">[docs]</a>
<span class="k">def</span> <span class="nf">normalize_3x3_matrix</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">xyz0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">]])):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize 3x3 matrix M to xyz0 -- &gt; [1,1,1]</span>
<span class="sd">    </span>
<span class="sd">    | If M.shape == (1,9): M is reshaped to (3,3)</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :M: </span>
<span class="sd">            | ndarray((3,3) or ndarray((1,9))</span>
<span class="sd">        :xyz0: </span>
<span class="sd">            | 2darray, optional </span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | normalized matrix such that M*xyz0 = [1,1,1]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">9</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">xyz0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagflat</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">xyz0</span><span class="o">.</span><span class="n">T</span><span class="p">))),</span><span class="n">M</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagflat</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">xyz0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">))),</span><span class="n">M</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xyz0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">xyz0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span></div>


<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="line_intersect">
<a class="viewcode-back" href="../../../math.html#luxpy.math.line_intersect">[docs]</a>
<span class="k">def</span> <span class="nf">line_intersect</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Line intersections of series of two line segments a and b. </span>
<span class="sd">        </span>
<span class="sd">    Args:</span>
<span class="sd">        :a1: </span>
<span class="sd">            | ndarray (.shape  = (N,2)) specifying end-point 1 of line a</span>
<span class="sd">        :a2: </span>
<span class="sd">            | ndarray (.shape  = (N,2)) specifying end-point 2 of line a</span>
<span class="sd">        :b1: </span>
<span class="sd">            | ndarray (.shape  = (N,2)) specifying end-point 1 of line b</span>
<span class="sd">        :b2: </span>
<span class="sd">            | ndarray (.shape  = (N,2)) specifying end-point 2 of line b</span>
<span class="sd">    </span>
<span class="sd">    Note: </span>
<span class="sd">        N is the number of line segments a and b.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | ndarray with line-intersections (.shape = (N,2))</span>
<span class="sd">    </span>
<span class="sd">    References:</span>
<span class="sd">        1. https://stackoverflow.com/questions/3252194/numpy-and-line-intersections</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]])</span>
    <span class="n">da</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">a2</span> <span class="o">-</span> <span class="n">a1</span><span class="p">)</span>
    <span class="n">db</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">b2</span> <span class="o">-</span> <span class="n">b1</span><span class="p">)</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">a1</span> <span class="o">-</span> <span class="n">b1</span><span class="p">)</span>
    <span class="n">dap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dap</span> <span class="o">*</span> <span class="n">db</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dap</span> <span class="o">*</span> <span class="n">dp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">num</span> <span class="o">/</span> <span class="n">denom</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">db</span> <span class="o">+</span> <span class="n">b1</span></div>


<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="positive_arctan">
<a class="viewcode-back" href="../../../math.html#luxpy.math.positive_arctan">[docs]</a>
<span class="k">def</span> <span class="nf">positive_arctan</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="n">htype</span> <span class="o">=</span> <span class="s1">&#39;deg&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate positive angle (0°-360° or 0 - 2*pi rad.) from x and y.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :x: </span>
<span class="sd">            | ndarray of x-coordinates</span>
<span class="sd">        :y: </span>
<span class="sd">            | ndarray of y-coordinates</span>
<span class="sd">        :htype:</span>
<span class="sd">            | &#39;deg&#39; or &#39;rad&#39;, optional</span>
<span class="sd">            |   - &#39;deg&#39;: hue angle between 0° and 360°</span>
<span class="sd">            |   - &#39;rad&#39;: hue angle between 0 and 2pi radians</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | ndarray of positive angles.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">htype</span> <span class="o">==</span> <span class="s1">&#39;deg&#39;</span><span class="p">:</span>
        <span class="n">r2d</span> <span class="o">=</span> <span class="mf">180.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">h360</span> <span class="o">=</span> <span class="mf">360.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">r2d</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">h360</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">r2d</span><span class="p">))</span>
    <span class="n">h</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">h</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">h</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)]</span> <span class="o">+</span> <span class="n">h360</span>
    <span class="k">return</span> <span class="n">h</span></div>



<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="dot23">
<a class="viewcode-back" href="../../../math.html#luxpy.math.dot23">[docs]</a>
<span class="k">def</span> <span class="nf">dot23</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dot product of a 2-d ndarray with a (N x K x L) 3-d ndarray </span>
<span class="sd">    using einsum().</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :A: </span>
<span class="sd">            | ndarray (.shape = (M,N))</span>
<span class="sd">        :B: </span>
<span class="sd">            | ndarray (.shape = (N,K,L))</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | ndarray (.shape = (M,K,L))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">dotAB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,jkl-&gt;ikl&#39;</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">keepdims</span> <span class="o">==</span> <span class="kc">True</span><span class="p">):</span>
            <span class="n">dotAB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">dotAB</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">dotAB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,jk-&gt;ik&#39;</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">keepdims</span> <span class="o">==</span> <span class="kc">True</span><span class="p">):</span>
            <span class="n">dotAB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">dotAB</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            
    <span class="k">return</span> <span class="n">dotAB</span></div>


<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="check_symmetric">
<a class="viewcode-back" href="../../../math.html#luxpy.math.check_symmetric">[docs]</a>
<span class="k">def</span> <span class="nf">check_symmetric</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1.0e-9</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1.0e-9</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if A is symmetric.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :A: </span>
<span class="sd">            | ndarray</span>
<span class="sd">        :atol:</span>
<span class="sd">            | float, optional</span>
<span class="sd">            | The absolute tolerance parameter (see Notes of numpy.allclose())</span>
<span class="sd">        :rtol:</span>
<span class="sd">            | float, optional</span>
<span class="sd">            | The relative tolerance parameter (see Notes of numpy.allclose())</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | Bool</span>
<span class="sd">            | True: the array is symmetric within the given tolerance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="n">rtol</span><span class="p">)</span></div>



<div class="viewcode-block" id="check_posdef">
<a class="viewcode-back" href="../../../math.html#luxpy.math.check_posdef">[docs]</a>
<span class="k">def</span> <span class="nf">check_posdef</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1.0e-9</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1.0e-9</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks positive definiteness of a matrix via Cholesky.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :A: </span>
<span class="sd">            | ndarray</span>
<span class="sd">        :atol:</span>
<span class="sd">            | float, optional</span>
<span class="sd">            | The absolute tolerance parameter (see Notes of numpy.allclose())</span>
<span class="sd">        :rtol:</span>
<span class="sd">            | float, optional</span>
<span class="sd">            | The relative tolerance parameter (see Notes of numpy.allclose())</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | Bool</span>
<span class="sd">            | True: the array is positive-definite within the given tolerance</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">atol</span> <span class="o">=</span> <span class="n">atol</span><span class="p">,</span><span class="n">rtol</span> <span class="o">=</span> <span class="n">rtol</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>



<div class="viewcode-block" id="symmM_to_posdefM">
<a class="viewcode-back" href="../../../math.html#luxpy.math.symmM_to_posdefM">[docs]</a>
<span class="k">def</span> <span class="nf">symmM_to_posdefM</span><span class="p">(</span><span class="n">A</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1.0e-9</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1.0e-9</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;make&#39;</span><span class="p">,</span> <span class="n">forcesymm</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a symmetric matrix to a positive definite one. </span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :A: </span>
<span class="sd">            | ndarray</span>
<span class="sd">        :atol:</span>
<span class="sd">            | float, optional</span>
<span class="sd">            | The absolute tolerance parameter (see Notes of numpy.allclose())</span>
<span class="sd">        :rtol:</span>
<span class="sd">            | float, optional</span>
<span class="sd">            | The relative tolerance parameter (see Notes of numpy.allclose())</span>
<span class="sd">        :method: </span>
<span class="sd">            | &#39;make&#39; or &#39;nearest&#39;, optional (see notes for more info)</span>
<span class="sd">        :forcesymm: </span>
<span class="sd">            | True or False, optional</span>
<span class="sd">            | If A is not symmetric, force symmetry using: </span>
<span class="sd">            |    A = numpy.triu(A) + numpy.triu(A).T - numpy.diag(numpy.diag(A))</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | ndarray with positive-definite matrix.</span>
<span class="sd">        </span>
<span class="sd">    Notes on supported methods:</span>
<span class="sd">        1. `&#39;make&#39;: A Python/Numpy port of Muhammad Asim Mubeen&#39;s matlab function </span>
<span class="sd">        Spd_Mat.m </span>
<span class="sd">        &lt;https://nl.mathworks.com/matlabcentral/fileexchange/45873-positive-definite-matrix&gt;`_</span>
<span class="sd">        2. `&#39;nearest&#39;: A Python/Numpy port of John D&#39;Errico&#39;s `nearestSPD` </span>
<span class="sd">        MATLAB code. </span>
<span class="sd">        &lt;https://stackoverflow.com/questions/43238173/python-convert-matrix-to-positive-semi-definite&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">A</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        
        
        <span class="c1"># Make sure matrix A is symmetric up to a certain tolerance:</span>
        <span class="n">sn</span> <span class="o">=</span> <span class="n">check_symmetric</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="n">rtol</span><span class="p">)</span> 
        <span class="k">if</span> <span class="p">((</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">sn</span> <span class="o">!=</span> <span class="kc">True</span><span class="p">)):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">forcesymm</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)</span>  <span class="o">&amp;</span>  <span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;symmM_to_posdefM(): matrix A not symmetric.&#39;</span><span class="p">)</span>
        
        
        <span class="k">if</span> <span class="n">check_posdef</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="n">rtol</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">A</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;make&#39;</span><span class="p">:</span>

                <span class="c1"># A Python/Numpy port of Muhammad Asim Mubeen&#39;s matlab function Spd_Mat.m</span>
                <span class="c1">#</span>
                <span class="c1"># See: https://nl.mathworks.com/matlabcentral/fileexchange/45873-positive-definite-matrix</span>
                <span class="n">Val</span><span class="p">,</span> <span class="n">Vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> 
                <span class="n">Val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">Val</span><span class="p">)</span>
                <span class="n">Vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">Vec</span><span class="p">)</span>
                <span class="n">Val</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Val</span><span class="o">==</span><span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_EPS</span> <span class="c1">#making zero eigenvalues non-zero</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Val</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">Val</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">Val</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="c1">#making negative eigenvalues positive</span>
                <span class="k">return</span>   <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Vec</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Val</span><span class="p">)</span> <span class="p">,</span> <span class="n">Vec</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
 
            
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;nearest&#39;</span><span class="p">:</span>
                
                 <span class="c1"># A Python/Numpy port of John D&#39;Errico&#39;s `nearestSPD` MATLAB code [1], which</span>
                 <span class="c1"># credits [2].</span>
                 <span class="c1">#</span>
                 <span class="c1"># [1] https://www.mathworks.com/matlabcentral/fileexchange/42885-nearestspd</span>
                 <span class="c1">#</span>
                 <span class="c1"># [2] N.J. Higham, &quot;Computing a nearest symmetric positive semidefinite</span>
                 <span class="c1"># matrix&quot; (1988): https://doi.org/10.1016/0024-3795(88)90223-6</span>
                 <span class="c1">#</span>
                 <span class="c1"># See: https://stackoverflow.com/questions/43238173/python-convert-matrix-to-positive-semi-definite</span>
                
                <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span> <span class="o">+</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>

                <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">V</span><span class="p">))</span>

                <span class="n">A2</span> <span class="o">=</span> <span class="p">(</span><span class="n">B</span> <span class="o">+</span> <span class="n">H</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>

                <span class="n">A3</span> <span class="o">=</span> <span class="p">(</span><span class="n">A2</span> <span class="o">+</span> <span class="n">A2</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>

                <span class="k">if</span> <span class="n">check_posdef</span><span class="p">(</span><span class="n">A3</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="n">rtol</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">A3</span>

                <span class="n">spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">spacing</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
                <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">while</span> <span class="ow">not</span> <span class="n">check_posdef</span><span class="p">(</span><span class="n">A3</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="n">rtol</span><span class="p">):</span>
                    <span class="n">mineig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">A3</span><span class="p">)))</span>
                    <span class="n">A3</span> <span class="o">+=</span> <span class="n">I</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">mineig</span> <span class="o">*</span> <span class="n">k</span><span class="o">**</span><span class="mf">2.0</span><span class="o">+</span> <span class="n">spacing</span><span class="p">)</span>
                    <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">return</span> <span class="n">A3</span></div>



<span class="c1">#-----------------------------------------------------------------------------</span>
<div class="viewcode-block" id="bvgpdf">
<a class="viewcode-back" href="../../../math.html#luxpy.math.bvgpdf">[docs]</a>
<span class="k">def</span> <span class="nf">bvgpdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mu</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">sigmainv</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate bivariate Gaussian probability density function (BVGPDF)</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :x: </span>
<span class="sd">            | scalar or list or ndarray (.ndim = 1 or 2) with </span>
<span class="sd">            | x(y)-coordinates at which to evaluate bivariate Gaussian PD.</span>
<span class="sd">        :y: </span>
<span class="sd">            | None or scalar or list or ndarray (.ndim = 1) with </span>
<span class="sd">            | y-coordinates at which to evaluate bivariate Gaussian PD, optional.</span>
<span class="sd">            | If :y: is None, :x: should be a 2d array.</span>
<span class="sd">        :mu: </span>
<span class="sd">            | None or ndarray (.ndim = 2) with center coordinates of </span>
<span class="sd">            | bivariate Gaussian PD, optional. </span>
<span class="sd">            | None defaults to ndarray([0,0]).</span>
<span class="sd">        :sigmainv:</span>
<span class="sd">            | None or ndarray with &#39;inverse covariance matrix&#39;, optional </span>
<span class="sd">            | Determines the shape and orientation of the PD.</span>
<span class="sd">            | None default to numpy.eye(2).</span>
<span class="sd">     </span>
<span class="sd">    Returns:</span>
<span class="sd">         :returns:</span>
<span class="sd">             | ndarray with magnitude of BVGPDF(x,y)   </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">mahalanobis2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span> <span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigmainv</span> <span class="o">=</span> <span class="n">sigmainv</span><span class="p">))</span></div>


<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="mahalanobis2">
<a class="viewcode-back" href="../../../math.html#luxpy.math.mahalanobis2">[docs]</a>
<span class="k">def</span> <span class="nf">mahalanobis2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mu</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">sigmainv</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the squared mahalanobis distance</span>
<span class="sd">    </span>
<span class="sd">    Args: </span>
<span class="sd">        :x: </span>
<span class="sd">            | scalar or list or ndarray (.ndim = 1 or 2) with x(y)-coordinates </span>
<span class="sd">              at which to evaluate the mahalanobis distance squared.</span>
<span class="sd">        :y: </span>
<span class="sd">            | None or scalar or list or ndarray (.ndim = 1) with y-coordinates </span>
<span class="sd">              at which to evaluate the mahalanobis distance squared, optional.</span>
<span class="sd">            | If :y: is None, :x: should be a 2d array.</span>
<span class="sd">        :z: </span>
<span class="sd">            | None or scalar or list or ndarray (.ndim = 1) with z-coordinates </span>
<span class="sd">              at which to evaluate the mahalanobis distance squared, optional.</span>
<span class="sd">            | If :z: is None &amp; :y: is None, then :x: should be a 2d array.</span>
<span class="sd">        :mu: </span>
<span class="sd">            | None or ndarray (.ndim = 1) with center coordinates of the </span>
<span class="sd">              mahalanobis ellipse, optional. </span>
<span class="sd">            | None defaults to zeros(2) or zeros(3).</span>
<span class="sd">        :sigmainv:</span>
<span class="sd">            | None or ndarray with &#39;inverse covariance matrix&#39;, optional </span>
<span class="sd">            | Determines the shape and orientation of the PD.</span>
<span class="sd">            | None default to np.eye(2) or eye(3).</span>
<span class="sd">    Returns:</span>
<span class="sd">         :returns: </span>
<span class="sd">             | ndarray with magnitude of mahalanobis2(x,y[,z])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="mi">2</span>
    
    <span class="k">if</span> <span class="n">mu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sigmainv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sigmainv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    
    <span class="n">x</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">mu</span>
        <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">asplit</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">p</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">asplit</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">mu</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">asplit</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">mu</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># center data on mu </span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">mu</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># center data on mu </span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">mu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># center data on mu </span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">mu</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># center data on mu </span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">-</span> <span class="n">mu</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># center data on mu </span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">mu</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># center data on mu </span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">-</span> <span class="n">mu</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># center data on mu </span>
            
    <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">sigmainv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">sigmainv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">sigmainv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">sigmainv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">sigmainv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">sigmainv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> 
                <span class="n">sigmainv</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">z</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">sigmainv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span>  <span class="mf">2.0</span><span class="o">*</span><span class="n">sigmainv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="n">z</span><span class="p">))</span></div>





<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="rms">
<a class="viewcode-back" href="../../../math.html#luxpy.math.rms">[docs]</a>
<span class="k">def</span> <span class="nf">rms</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate root-mean-square along axis.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :data: </span>
<span class="sd">            | list of values or ndarray</span>
<span class="sd">        :axis:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | Axis along which to calculate rms.</span>
<span class="sd">        :keepdims:</span>
<span class="sd">            | False or True, optional</span>
<span class="sd">            | Keep original dimensions of array.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | ndarray with rms values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="n">keepdims</span><span class="p">))</span></div>


<span class="c1">#-----------------------------------------------------------------------------</span>
<div class="viewcode-block" id="geomean">
<a class="viewcode-back" href="../../../math.html#luxpy.math.geomean">[docs]</a>
<span class="k">def</span> <span class="nf">geomean</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate geometric mean along axis.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :data:</span>
<span class="sd">            | list of values or ndarray</span>
<span class="sd">        :axis:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | Axis along which to calculate geomean.</span>
<span class="sd">        :keepdims:</span>
<span class="sd">            | False or True, optional</span>
<span class="sd">            | Keep original dimensions of array.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | ndarray with geomean values. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="n">keepdims</span><span class="p">),</span><span class="mi">1</span><span class="o">/</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span></div>

 
<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="polyarea">
<a class="viewcode-back" href="../../../math.html#luxpy.math.polyarea">[docs]</a>
<span class="k">def</span> <span class="nf">polyarea</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates area of polygon. </span>
<span class="sd">    </span>
<span class="sd">    | First coordinate should also be last.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :x: </span>
<span class="sd">            | ndarray of x-coordinates of polygon vertices.</span>
<span class="sd">        :y: </span>
<span class="sd">            | ndarray of x-coordinates of polygon vertices.     </span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | float (area or polygon)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">))</span></div>


<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="cart2pol">
<a class="viewcode-back" href="../../../math.html#luxpy.math.cart2pol">[docs]</a>
<span class="k">def</span> <span class="nf">cart2pol</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">htype</span> <span class="o">=</span> <span class="s1">&#39;deg&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert Cartesion to polar coordinates.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :x: </span>
<span class="sd">            | float or ndarray with x-coordinates</span>
<span class="sd">        :y: </span>
<span class="sd">            | None or float or ndarray with x-coordinates, optional</span>
<span class="sd">            | If None, y-coordinates are assumed to be in :x:.</span>
<span class="sd">        :htype:</span>
<span class="sd">            | &#39;deg&#39; or &#39;rad, optional</span>
<span class="sd">            | Output type of theta.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | (float or ndarray of theta, float or ndarray of r) values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">positive_arctan</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="n">htype</span> <span class="o">=</span> <span class="n">htype</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="pol2cart">
<a class="viewcode-back" href="../../../math.html#luxpy.math.pol2cart">[docs]</a>
<span class="k">def</span> <span class="nf">pol2cart</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">htype</span> <span class="o">=</span> <span class="s1">&#39;deg&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert Cartesion to polar coordinates.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :theta: </span>
<span class="sd">            | float or ndarray with theta-coordinates</span>
<span class="sd">        :r: </span>
<span class="sd">            | None or float or ndarray with r-coordinates, optional</span>
<span class="sd">            | If None, r-coordinates are assumed to be in :theta:.</span>
<span class="sd">        :htype:</span>
<span class="sd">            | &#39;deg&#39; or &#39;rad, optional</span>
<span class="sd">            | Intput type of :theta:.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | (float or ndarray of x, float or ndarray of y) coordinates </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">htype</span> <span class="o">==</span> <span class="s1">&#39;deg&#39;</span><span class="p">:</span>
        <span class="n">d2r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">d2r</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="o">*</span><span class="n">d2r</span>
    <span class="k">return</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span></div>


<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="spher2cart">
<a class="viewcode-back" href="../../../math.html#luxpy.math.spher2cart">[docs]</a>
<span class="k">def</span> <span class="nf">spher2cart</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">deg</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert spherical to cartesian coordinates.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :theta:</span>
<span class="sd">            | Float, int or ndarray</span>
<span class="sd">            | Angle with positive z-axis.</span>
<span class="sd">        :phi:</span>
<span class="sd">            | Float, int or ndarray</span>
<span class="sd">            | Angle around positive z-axis starting from x-axis.</span>
<span class="sd">        :r:</span>
<span class="sd">            | 1, optional</span>
<span class="sd">            | Float, int or ndarray</span>
<span class="sd">            | radius</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :x, y, z:</span>
<span class="sd">            | tuple of floats, ints or ndarrays</span>
<span class="sd">            | Cartesian coordinates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">deg</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    <span class="n">x</span><span class="o">=</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    <span class="n">y</span><span class="o">=</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    <span class="n">z</span><span class="o">=</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span></div>


<div class="viewcode-block" id="cart2spher">
<a class="viewcode-back" href="../../../math.html#luxpy.math.cart2spher">[docs]</a>
<span class="k">def</span> <span class="nf">cart2spher</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span> <span class="n">deg</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert cartesian to spherical coordinates.</span>
<span class="sd">    </span>
<span class="sd">    Args:        </span>
<span class="sd">        :x, y, z:</span>
<span class="sd">            | tuple of floats, ints or ndarrays</span>
<span class="sd">            | Cartesian coordinates</span>
<span class="sd">    Returns:</span>
<span class="sd">        :theta:</span>
<span class="sd">            | Float, int or ndarray</span>
<span class="sd">            | Angle with positive z-axis.</span>
<span class="sd">        :phi:</span>
<span class="sd">            | Float, int or ndarray</span>
<span class="sd">            | Angle around positive z-axis starting from x-axis.</span>
<span class="sd">        :r:</span>
<span class="sd">            | 1, optional</span>
<span class="sd">            | Float, int or ndarray</span>
<span class="sd">            | radius</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="o">*</span><span class="n">z</span><span class="p">)</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
    <span class="n">phi</span><span class="p">[</span><span class="n">phi</span><span class="o">&lt;</span><span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="n">phi</span><span class="p">[</span><span class="n">phi</span><span class="o">&lt;</span><span class="mf">0.</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">zdr</span> <span class="o">=</span> <span class="n">z</span><span class="o">/</span><span class="n">r</span>
    <span class="n">zdr</span><span class="p">[</span><span class="n">zdr</span> <span class="o">&gt;</span> <span class="mf">1.</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="n">zdr</span><span class="p">[</span><span class="n">zdr</span><span class="o">&lt;-</span><span class="mf">1.</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">zdr</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">deg</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">phi</span> <span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">return</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">r</span>   </div>



<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># magnitude of a vector</span>
<div class="viewcode-block" id="magnitude_v">
<a class="viewcode-back" href="../../../math.html#luxpy.math.magnitude_v">[docs]</a>
<span class="k">def</span> <span class="nf">magnitude_v</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates magnitude of vector.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :v: </span>
<span class="sd">            | ndarray with vector</span>
<span class="sd"> </span>
<span class="sd">    Returns:</span>
<span class="sd">        :magnitude:</span>
<span class="sd">            | ndarray </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">v</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">magnitude</span></div>



<span class="c1"># angle between vectors</span>
<div class="viewcode-block" id="angle_v1v2">
<a class="viewcode-back" href="../../../math.html#luxpy.math.angle_v1v2">[docs]</a>
<span class="k">def</span> <span class="nf">angle_v1v2</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="n">htype</span> <span class="o">=</span> <span class="s1">&#39;deg&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates angle between two vectors.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :v1: </span>
<span class="sd">            | ndarray with vector 1</span>
<span class="sd">        :v2: </span>
<span class="sd">            | ndarray with vector 2</span>
<span class="sd">        :htype:</span>
<span class="sd">            | &#39;deg&#39; or &#39;rad&#39;, optional</span>
<span class="sd">            | Requested angle type.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :ang: </span>
<span class="sd">            | ndarray </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="n">magnitude_v</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span><span class="o">*</span><span class="n">magnitude_v</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>
    <span class="n">denom</span><span class="p">[</span><span class="n">denom</span><span class="o">==</span><span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">ang</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v1</span><span class="o">*</span><span class="n">v2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">denom</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">htype</span> <span class="o">==</span> <span class="s1">&#39;deg&#39;</span><span class="p">:</span>
        <span class="n">ang</span> <span class="o">=</span> <span class="n">ang</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">return</span> <span class="n">ang</span></div>

    
<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="histogram">
<a class="viewcode-back" href="../../../math.html#luxpy.math.histogram">[docs]</a>
<span class="k">def</span> <span class="nf">histogram</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">bin_center</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Histogram function that can take as bins either the center (cfr. matlab hist) or bin-edges.</span>
<span class="sd">    </span>
<span class="sd">    Args: </span>
<span class="sd">        :bin_center:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | False: if :bins: int, str or sequence of scalars:</span>
<span class="sd">            |       default to numpy.histogram (uses bin edges).</span>
<span class="sd">            | True: if :bins: is a sequence of scalars:</span>
<span class="sd">            |         bins (containing centers) are transformed to edges</span>
<span class="sd">            |         and nump.histogram is run. </span>
<span class="sd">            |         Mimicks matlab hist (uses bin centers).</span>
<span class="sd">        </span>
<span class="sd">    Note:</span>
<span class="sd">        For other armuments and output, see ?numpy.histogram</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | ndarray with histogram</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="o">|</span>  <span class="nb">isinstance</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">bin_center</span> <span class="o">==</span> <span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">centers</span> <span class="o">=</span> <span class="n">bins</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">centers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">centers</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span><span class="p">,</span> <span class="n">centers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">edges</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="nb">range</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="n">density</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="nb">range</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="n">density</span><span class="p">)</span></div>

    
<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="v_to_cik">
<a class="viewcode-back" href="../../../math.html#luxpy.math.v_to_cik">[docs]</a>
<span class="k">def</span> <span class="nf">v_to_cik</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">inverse</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate 2x2 &#39;(covariance matrix)^-1&#39; elements cik </span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :v: </span>
<span class="sd">            | (Nx5) np.ndarray</span>
<span class="sd">            | ellipse parameters [Rmax,Rmin,xc,yc,theta]</span>
<span class="sd">        :inverse:</span>
<span class="sd">            | If True: return inverse of cik.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :cik: </span>
<span class="sd">            | &#39;Nx2x2&#39; (covariance matrix)^-1</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        | cik is not actually a covariance matrix,</span>
<span class="sd">        | only for a Gaussian or normal distribution!</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">g11</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">v</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">v</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">g22</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">v</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">v</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">g12</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">v</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="n">v</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span><span class="mi">4</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span><span class="mi">4</span><span class="p">])</span>
    <span class="n">cik</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">g11</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">g11</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">cik</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">g11</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">g12</span><span class="p">[</span><span class="n">i</span><span class="p">])),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">g12</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">g22</span><span class="p">[</span><span class="n">i</span><span class="p">]))))</span>
        <span class="k">if</span> <span class="n">inverse</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">cik</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">cik</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:])</span>
    <span class="k">return</span> <span class="n">cik</span></div>

<span class="c1">#------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="cik_to_v">
<a class="viewcode-back" href="../../../math.html#luxpy.math.cik_to_v">[docs]</a>
<span class="k">def</span> <span class="nf">cik_to_v</span><span class="p">(</span><span class="n">cik</span><span class="p">,</span> <span class="n">xyc</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">inverse</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate v-format ellipse descriptor from 2x2 &#39;covariance matrix&#39;^-1 cik </span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :cik: </span>
<span class="sd">            | &#39;Nx2x2&#39; (covariance matrix)^-1</span>
<span class="sd">        :inverse:</span>
<span class="sd">            | If True: input is inverse of cik.</span>
<span class="sd">              </span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :v: </span>
<span class="sd">            | (Nx5) np.ndarray</span>
<span class="sd">            | ellipse parameters [Rmax,Rmin,xc,yc,theta]</span>

<span class="sd">    Notes:</span>
<span class="sd">        | cik is not actually the inverse covariance matrix,</span>
<span class="sd">        | only for a Gaussian or normal distribution!</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">cik</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">cik</span> <span class="o">=</span> <span class="n">cik</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">inverse</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cik</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">cik</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">cik</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:])</span>
            
    <span class="n">g11</span> <span class="o">=</span> <span class="n">cik</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">g22</span> <span class="o">=</span> <span class="n">cik</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> 
    <span class="n">g12</span> <span class="o">=</span> <span class="n">cik</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">theta</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">g12</span><span class="p">,(</span><span class="n">g11</span><span class="o">-</span><span class="n">g22</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">g12</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1">#theta = theta2 + (np.pi/2)*(g12&lt;0)</span>
    <span class="c1">#theta2 = theta</span>
    <span class="n">cottheta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="c1">#np.cot(theta)</span>
    <span class="n">cottheta</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">cottheta</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">g22</span> <span class="o">+</span> <span class="n">g12</span><span class="o">*</span><span class="n">cottheta</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">g11</span> <span class="o">-</span> <span class="n">g12</span><span class="o">*</span><span class="n">cottheta</span><span class="p">))</span>

    <span class="c1"># ensure largest ellipse axis is first (correct angle):</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="o">&gt;</span><span class="n">a</span><span class="p">;</span> <span class="n">a</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">theta</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">c</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="n">c</span><span class="p">],</span><span class="n">theta</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">theta</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    
    <span class="c1"># add center coordinates:</span>
    <span class="k">if</span> <span class="n">xyc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">v</span><span class="p">[:,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">xyc</span>
    
    <span class="k">return</span> <span class="n">v</span></div>


<div class="viewcode-block" id="fmod">
<a class="viewcode-back" href="../../../math.html#luxpy.math.fmod">[docs]</a>
<span class="k">def</span> <span class="nf">fmod</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Floating point modulus </span>
<span class="sd">    </span>
<span class="sd">    | e.g., fmod(theta, np.pi * 2) would keep an angle in [0, 2pi]</span>

<span class="sd">    Args:</span>
<span class="sd">        :x:</span>
<span class="sd">            | angle to restrict</span>
<span class="sd">        :y: </span>
<span class="sd">            | end of  interval [0, y] to restrict to</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :r: floating point modulus</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">while</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="n">y</span>
    <span class="k">while</span><span class="p">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="n">y</span>
    <span class="k">return</span> <span class="n">r</span></div>


<div class="viewcode-block" id="remove_outliers">
<a class="viewcode-back" href="../../../math.html#luxpy.math.remove_outliers">[docs]</a>
<span class="k">def</span> <span class="nf">remove_outliers</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove multivariate outliers from data when outside of alpha-level confidence ellipsoid.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :data:</span>
<span class="sd">            | Nxp ndarray with multivariate data (N samples, p variables)</span>
<span class="sd">        :alpha:</span>
<span class="sd">            | 0.01, optional</span>
<span class="sd">            | Significance level of confidence ellipsoid marking the boundary for outliers.</span>
<span class="sd">            </span>
<span class="sd">    Return:</span>
<span class="sd">        :data:</span>
<span class="sd">            | (N-... x p) ndarray with multivariate data; outliers removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span> <span class="c1"># lazy import</span>
    
    <span class="c1"># delete outliers:    </span>
    <span class="n">datac</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">cov_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">mahalanobis2</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mu</span> <span class="o">=</span> <span class="n">datac</span><span class="p">,</span> <span class="n">sigmainv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">cov_</span><span class="p">)</span><span class="o">/</span><span class="n">f</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
    <span class="n">datan</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">datan</span> <span class="o">=</span> <span class="n">datan</span><span class="p">[</span><span class="n">D</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">datan</span></div>


<div class="viewcode-block" id="fit_ellipse">
<a class="viewcode-back" href="../../../math.html#luxpy.math.fit_ellipse">[docs]</a>
<span class="k">def</span> <span class="nf">fit_ellipse</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">center_on_mean_xy</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fit an ellipse to supplied data points.</span>

<span class="sd">    Args:</span>
<span class="sd">        :xy: </span>
<span class="sd">            | coordinates of points to fit (Nx2 array)</span>
<span class="sd">        :center_on_mean_xy:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | Center ellipse on mean of xy </span>
<span class="sd">            | (otherwise it might be offset due to solving </span>
<span class="sd">            | the contrained minization problem: aT*S*a, see ref below.)</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :v:</span>
<span class="sd">            | vector with ellipse parameters [Rmax,Rmin, xc,yc, theta (rad.)]</span>
<span class="sd">            </span>
<span class="sd">    Reference:</span>
<span class="sd">        1. Fitzgibbon, A.W., Pilu, M., and Fischer R.B., </span>
<span class="sd">        Direct least squares fitting of ellipsees, </span>
<span class="sd">        Proc. of the 13th Internation Conference on Pattern Recognition, </span>
<span class="sd">        pp 253–257, Vienna, 1996.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># remove centroid:</span>
<span class="c1">#    center = xy.mean(axis=0)</span>
<span class="c1">#    xy = xy - center</span>
    
    <span class="c1"># Fit ellipse:</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span> <span class="n">xy</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
    <span class="n">S</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
    <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">C</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">U</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="n">C</span><span class="p">))</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">U</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
<span class="c1">#    E, V =  np.linalg.eig(np.dot(np.linalg.inv(S), C))</span>
<span class="c1">#    n = np.argmax(np.abs(E))</span>
<span class="c1">#    e = V[:,n]</span>
        
    <span class="c1"># get ellipse axis lengths, center and orientation:</span>
    <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># get ellipse center:</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">xc</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">yc</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xc</span> <span class="o">=</span> <span class="p">((</span><span class="n">c</span> <span class="o">*</span> <span class="n">d</span> <span class="o">-</span> <span class="n">b</span> <span class="o">*</span> <span class="n">f</span><span class="p">)</span> <span class="o">/</span> <span class="n">num</span><span class="p">)</span> 
        <span class="n">yc</span> <span class="o">=</span> <span class="p">((</span><span class="n">a</span> <span class="o">*</span> <span class="n">f</span> <span class="o">-</span> <span class="n">b</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span> <span class="o">/</span> <span class="n">num</span><span class="p">)</span> 
    
    <span class="c1"># get ellipse orientation:</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">b</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">a</span> <span class="o">-</span> <span class="n">c</span><span class="p">)))</span> <span class="o">/</span> <span class="mi">2</span>
<span class="c1">#    if b == 0:</span>
<span class="c1">#        if a &gt; c:</span>
<span class="c1">#            theta = 0</span>
<span class="c1">#        else:</span>
<span class="c1">#            theta = np.pi/2</span>
<span class="c1">#    else:</span>
<span class="c1">#        if a &gt; c:</span>
<span class="c1">#            theta = np.arctan2(2*b,(a-c))/2</span>
<span class="c1">#        else:</span>
<span class="c1">#            theta =  np.arctan2(2*b,(a-c))/2 + np.pi/2</span>
        
    <span class="c1"># axis lengths:</span>
    <span class="n">up</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">f</span> <span class="o">*</span> <span class="n">f</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">d</span> <span class="o">+</span> <span class="n">g</span> <span class="o">*</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">f</span> <span class="o">-</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span> <span class="o">*</span> <span class="n">g</span><span class="p">)</span>
    <span class="n">down1</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">c</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">/</span> <span class="p">((</span><span class="n">a</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">c</span><span class="p">)))</span> <span class="o">-</span> <span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="n">a</span><span class="p">))</span>
    <span class="n">down2</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">a</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">/</span> <span class="p">((</span><span class="n">a</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">c</span><span class="p">)))</span> <span class="o">-</span> <span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="n">a</span><span class="p">))</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">up</span> <span class="o">/</span> <span class="n">down1</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">up</span> <span class="o">/</span> <span class="n">down2</span><span class="p">))</span>


    <span class="c1"># assert that a is the major axis (otherwise swap and correct angle)</span>
    <span class="k">if</span><span class="p">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">):</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
        <span class="c1"># ensure the angle is betwen 0 and 2*pi</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">fmod</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">center_on_mean_xy</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">xc</span><span class="p">,</span><span class="n">yc</span> <span class="o">=</span> <span class="n">xy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">xc</span><span class="p">,</span> <span class="n">yc</span><span class="p">,</span> <span class="n">theta</span><span class="p">))</span></div>



<div class="viewcode-block" id="fit_cov_ellipse">
<a class="viewcode-back" href="../../../math.html#luxpy.math.fit_cov_ellipse">[docs]</a>
<span class="k">def</span> <span class="nf">fit_cov_ellipse</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span> <span class="n">pdf</span> <span class="o">=</span> <span class="s1">&#39;chi2&#39;</span><span class="p">,</span> <span class="n">SE</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                    <span class="n">robust</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">robust_alpha</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fit covariance ellipse to xy data.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :xy: </span>
<span class="sd">            | coordinates of points to fit (Nx2 array)</span>
<span class="sd">        :alpha:</span>
<span class="sd">            | 0.05, optional</span>
<span class="sd">            | alpha significance level </span>
<span class="sd">            | (e.g alpha = 0.05 for 95% confidence ellipse)</span>
<span class="sd">        :pdf:</span>
<span class="sd">            | chi2, optional</span>
<span class="sd">            | - &#39;chi2&#39;: Rescale using Chi2-distribution</span>
<span class="sd">            | - &#39;t&#39;: Rescale using Student t-distribution</span>
<span class="sd">            | - &#39;norm&#39;: Rescale using normal-distribution</span>
<span class="sd">            | - None: don&#39;t rescale using pdf, use alpha as scalefactor (cfr. alpha* 1SD or alpha * 1SE)</span>
<span class="sd">        :SE:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | If false, fit standard error ellipse at alpha significance level</span>
<span class="sd">            | If true, fit standard deviation ellipse at alpha significance level</span>
<span class="sd">        :robust:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | If True: remove outliers beyond the confidence ellipsoid before calculating</span>
<span class="sd">            |          the covariances.</span>
<span class="sd">        :robust_alpha:</span>
<span class="sd">            | 0.01, optional</span>
<span class="sd">            | Significance level of confidence ellipsoid marking the boundary for outliers.</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :v:</span>
<span class="sd">            | vector with ellipse parameters [Rmax,Rmin, xc,yc, theta (rad.)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span> <span class="c1"># lazy import </span>
    
    <span class="c1"># delete outliers:    </span>
    <span class="k">if</span> <span class="n">robust</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="n">remove_outliers</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">robust_alpha</span><span class="p">)</span>
    
    <span class="n">xyc</span> <span class="o">=</span> <span class="n">xy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">cov_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">xy</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    
    
    <span class="n">cik</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">cov_</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">pdf</span> <span class="o">==</span> <span class="s1">&#39;chi2&#39;</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">,</span> <span class="n">xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">pdf</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">,</span> <span class="n">xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">pdf</span> <span class="o">==</span><span class="s1">&#39;norm&#39;</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">pdf</span> <span class="o">==</span> <span class="s1">&#39;sample&#39;</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">p</span><span class="p">)</span><span class="o">*</span><span class="n">stats</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="n">p</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">alpha</span> <span class="c1">#  -&gt; fraction of Mahalanobis distance</span>
        
    <span class="k">if</span> <span class="n">SE</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">/</span><span class="n">xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
    <span class="n">v</span> <span class="o">=</span> <span class="n">cik_to_v</span><span class="p">(</span><span class="n">cik</span><span class="o">/</span><span class="n">f</span><span class="p">,</span> <span class="n">xyc</span><span class="o">=</span><span class="n">xyc</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">v</span></div>


<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="in_hull">
<a class="viewcode-back" href="../../../math.html#luxpy.math.in_hull">[docs]</a>
<span class="k">def</span> <span class="nf">in_hull</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">hull</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test if points in `p` are in `hull`</span>

<span class="sd">    Args:</span>
<span class="sd">        :p: </span>
<span class="sd">            | NxK coordinates of N points in K dimensions</span>
<span class="sd">        :hull:</span>
<span class="sd">            | Either a scipy.spatial.Delaunay object or the MxK array of the </span>
<span class="sd">            | coordinates of M points in K dimensions for which Delaunay </span>
<span class="sd">            | triangulation will be computed</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :bool:</span>
<span class="sd">            | boolean ndarray with True for in-gamut and False for out-of-gamut points</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">Delaunay</span> <span class="c1"># lazy import</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hull</span><span class="p">,</span><span class="n">Delaunay</span><span class="p">):</span>
        <span class="n">hull</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="n">hull</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hull</span><span class="o">.</span><span class="n">find_simplex</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">0</span></div>


<span class="c1">#------------------------------------------------------------------------------</span>
<span class="n">_SPRAGUE_COEFFICIENTS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                                 <span class="p">[</span><span class="mi">884</span><span class="p">,</span> <span class="o">-</span><span class="mi">1960</span><span class="p">,</span> <span class="mi">3033</span><span class="p">,</span> <span class="o">-</span><span class="mi">2648</span><span class="p">,</span> <span class="mi">1080</span><span class="p">,</span> <span class="o">-</span><span class="mi">180</span><span class="p">],</span>
                                 <span class="p">[</span><span class="mi">508</span><span class="p">,</span> <span class="o">-</span><span class="mi">540</span><span class="p">,</span> <span class="mi">488</span><span class="p">,</span> <span class="o">-</span><span class="mi">367</span><span class="p">,</span> <span class="mi">144</span><span class="p">,</span> <span class="o">-</span><span class="mi">24</span><span class="p">],</span>
                                 <span class="p">[</span><span class="o">-</span><span class="mi">24</span><span class="p">,</span> <span class="mi">144</span><span class="p">,</span> <span class="o">-</span><span class="mi">367</span><span class="p">,</span> <span class="mi">488</span><span class="p">,</span> <span class="o">-</span><span class="mi">540</span><span class="p">,</span> <span class="mi">508</span><span class="p">],</span>
                                 <span class="p">[</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span> <span class="mi">1080</span><span class="p">,</span> <span class="o">-</span><span class="mi">2648</span><span class="p">,</span> <span class="mi">3033</span><span class="p">,</span> <span class="o">-</span><span class="mi">1960</span><span class="p">,</span> <span class="mi">884</span><span class="p">],</span>
                                 <span class="p">])</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="mf">209.0</span>
<div class="viewcode-block" id="interp1_sprague5">
<a class="viewcode-back" href="../../../math.html#luxpy.math.interp1_sprague5">[docs]</a>
<span class="k">def</span> <span class="nf">interp1_sprague5</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xn</span><span class="p">,</span> <span class="n">extrap</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span> <span class="n">scipy_interpolator</span> <span class="o">=</span> <span class="s1">&#39;interp1d&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Perform a 1-dimensional 5th order Sprague interpolation.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :x:</span>
<span class="sd">            | ndarray with n-dimensional coordinates.</span>
<span class="sd">        :y: </span>
<span class="sd">            | ndarray with values at coordinates in x.</span>
<span class="sd">        :xn:</span>
<span class="sd">            | ndarray of new coordinates.</span>
<span class="sd">        :extrap:</span>
<span class="sd">            | (np.nan, np.nan) or string, optional</span>
<span class="sd">            | If tuple: fill with values in tuple (&lt;x[0],&gt;x[-1])</span>
<span class="sd">            | If string:  (&#39;zeros&#39;,&#39;linear&#39;, &#39;nearest&#39;, &#39;nearest-up&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;, &#39;previous&#39;,&#39;next&#39;)</span>
<span class="sd">            |           for more info on the other options see: scipy.interpolate.interp1d?</span>
<span class="sd">    Returns:</span>
<span class="sd">        :yn:</span>
<span class="sd">            | ndarray with values at new coordinates in xn.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Do extrapolation:</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">xn</span><span class="o">&lt;</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">xn</span><span class="o">&gt;</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">any</span><span class="p">():</span> <span class="c1"># extrapolation needed !</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">extrap</span><span class="p">,</span><span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">extrap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">extrap</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> 
                <span class="n">yne</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">xn</span><span class="p">)))</span><span class="o">*</span><span class="n">extrap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">yne</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">xn</span><span class="p">)))</span>
                <span class="n">yne</span><span class="p">[:,(</span><span class="n">xn</span><span class="o">&lt;</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">extrap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">yne</span><span class="p">[:,(</span><span class="n">xn</span><span class="o">&gt;</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">extrap</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">extrap</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="c1">#from scipy.interpolate import interp1d # lazy import</span>
            <span class="c1">#yne = interp1d(x, y, kind = extrap, bounds_error = False, fill_value = &#39;extrapolate&#39;)(xn)</span>
            <span class="n">yne</span> <span class="o">=</span> <span class="n">interp1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xn</span><span class="p">,</span> <span class="n">kind</span> <span class="o">=</span> <span class="n">extrap</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="s1">&#39;extrapolate&#39;</span><span class="p">,</span> <span class="n">scipy_interpolator</span> <span class="o">=</span> <span class="n">scipy_interpolator</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Invalid option for extrap argument. Only tuple and string allowed.&#39;</span><span class="p">)</span>
        <span class="n">xn_x</span> <span class="o">=</span> <span class="n">xn</span><span class="p">[(</span><span class="n">xn</span><span class="o">&gt;=</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">xn</span><span class="o">&lt;=</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xn_x</span> <span class="o">=</span> <span class="n">xn</span>
        <span class="n">yne</span> <span class="o">=</span> <span class="kc">None</span>
     
    <span class="c1"># Check equal x-spacing:</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dx</span> <span class="o">==</span> <span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Elements in x are not equally spaced!&#39;</span><span class="p">)</span>
        
    <span class="c1"># Extrapolate x, y with required additional elements for Sprague to work:</span>
    <span class="n">xe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">dx</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">dx</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dx</span><span class="p">))</span>
    
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">ye1</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">@</span> <span class="n">_SPRAGUE_COEFFICIENTS</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])[:,</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">ye2</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">@</span> <span class="n">_SPRAGUE_COEFFICIENTS</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])[:,</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">ye3</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">[:,</span><span class="o">-</span><span class="mi">6</span><span class="p">:]</span> <span class="o">@</span> <span class="n">_SPRAGUE_COEFFICIENTS</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])[:,</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">ye4</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">[:,</span><span class="o">-</span><span class="mi">6</span><span class="p">:]</span> <span class="o">@</span> <span class="n">_SPRAGUE_COEFFICIENTS</span><span class="p">[:,</span><span class="mi">3</span><span class="p">])[:,</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">ye</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">ye1</span><span class="p">,</span><span class="n">ye2</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">ye3</span><span class="p">,</span><span class="n">ye4</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    
    
    <span class="c1"># Evaluate at xn_x (no extrapolation!!):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">xe</span><span class="p">,</span> <span class="n">xn_x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">((</span><span class="n">xn_x</span> <span class="o">-</span> <span class="n">xe</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">xe</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">xe</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span>

    <span class="n">a0</span> <span class="o">=</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">16</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">16</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="mi">24</span><span class="p">)</span>  
    <span class="n">a2</span> <span class="o">=</span> <span class="p">((</span><span class="o">-</span><span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">16</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">30</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">16</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="mi">24</span><span class="p">)</span> 
    <span class="n">a3</span> <span class="o">=</span> <span class="p">((</span><span class="o">-</span><span class="mi">9</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">39</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">70</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">66</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">33</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">7</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="mi">24</span><span class="p">)</span>
    <span class="n">a4</span> <span class="o">=</span> <span class="p">((</span><span class="mi">13</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">64</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">126</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">124</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">61</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">12</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="mi">24</span><span class="p">)</span>
    <span class="n">a5</span> <span class="o">=</span> <span class="p">((</span><span class="o">-</span><span class="mi">5</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">25</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">50</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">50</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">25</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">ye</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="mi">24</span><span class="p">)</span>

    <span class="n">yn</span> <span class="o">=</span> <span class="p">(</span><span class="n">a0</span> <span class="o">+</span> <span class="n">a1</span><span class="o">*</span><span class="n">X</span> <span class="o">+</span> <span class="n">a2</span><span class="o">*</span><span class="n">X</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">a3</span><span class="o">*</span><span class="n">X</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="n">a4</span><span class="o">*</span><span class="n">X</span><span class="o">**</span><span class="mi">4</span> <span class="o">+</span> <span class="n">a5</span><span class="o">*</span><span class="n">X</span><span class="o">**</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    
    <span class="k">if</span> <span class="n">yne</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">yn</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">yne</span><span class="p">[:,(</span><span class="n">xn</span><span class="o">&gt;=</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">xn</span><span class="o">&lt;=</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">yn</span>
        <span class="k">return</span> <span class="n">yne</span></div>


<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="interp1">
<a class="viewcode-back" href="../../../math.html#luxpy.math.interp1">[docs]</a>
<span class="k">def</span> <span class="nf">interp1</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Xnew</span><span class="p">,</span> <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="s1">&#39;extrapolate&#39;</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="s1">&#39;extrapolate&#39;</span><span class="p">,</span> 
            <span class="n">force_scipy_interpolator</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">scipy_interpolator</span> <span class="o">=</span> <span class="s1">&#39;interp1d&#39;</span><span class="p">,</span>
            <span class="n">w</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">check_finite</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform a 1-dimensional interpolation </span>
<span class="sd">    (wrapper around scipy.interpolate.InterpolatedUnivariateSpline, scipy.interpolate.interp1d and numpy.interp).</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :X: </span>
<span class="sd">            | ndarray with n-dimensional coordinates (last axis represents dimension)</span>
<span class="sd">        :Y: </span>
<span class="sd">            | ndarray with values at coordinates in X</span>
<span class="sd">        :Xnew: </span>
<span class="sd">            | ndarray of new coordinates (last axis represents dimension)</span>
<span class="sd">        :kind:</span>
<span class="sd">            | str or int,  optional</span>
<span class="sd">            | supported options for str: &#39;linear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">        :ext:</span>
<span class="sd">            | &#39;extrapolate&#39;, optional</span>
<span class="sd">            | options: </span>
<span class="sd">            |   - &#39;extrapolate&#39;</span>
<span class="sd">            |   - &#39;zeros&#39;: out-of-bounds values are filled with zeros</span>
<span class="sd">            |   - &#39;const&#39;: out-of-bounds values are filled with nearest value</span>
<span class="sd">            |   - &#39;fill_value&#39;: value of tuple (2,) of values is used to fill out-of-bounds values</span>
<span class="sd">        :fill_value:</span>
<span class="sd">            | &#39;extrpolate&#39; or float or int or tupple, optional</span>
<span class="sd">            | If ext == &#39;fill_value&#39;: use fill_value to set lower- and upper-out-of-bounds values when extrapolating</span>
<span class="sd">        :force_scipy_interpolator:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | If False: numpy.interp function is used for linear interpolation when no extrapolation is used/required (fast!). </span>
<span class="sd">        :scipy_interpolator:</span>
<span class="sd">            | &#39;interp1d&#39;, optional</span>
<span class="sd">            | options: [&#39;InterpolatedUnivariateSpline&#39;, &#39;interp1d&#39;] (or 0 or 1)</span>
<span class="sd">        :other args:</span>
<span class="sd">            | see scipy.interpolate.InterpolatedUnivariateSpline()</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        :Ynew:</span>
<span class="sd">            | ndarray with new values at coordinates in Xnew</span>
<span class="sd">    </span>
<span class="sd">    Note:</span>
<span class="sd">        1. &#39;numpy.interp&#39; is fastest (but only works for linear interpolation without extrapolation)</span>
<span class="sd">        2. For linear interpolation: &#39;interp1d&#39; is faster for Y (N,...) with N &gt; 1, else &#39;InterpolatedUnivariateSpline&#39; is faster</span>
<span class="sd">        3. For &#39;cubic&#39; interpolation: &#39;InterpolatedUnivariateSpline&#39; is faster for Y (N,...) with N &gt; 1, else &#39;interp1d&#39; is faster</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">Xnew</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="n">Xnew</span> <span class="o">=</span> <span class="n">Xnew</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># avoid interpolation/extrapolation if none is needed:</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Xnew</span><span class="p">):</span> <span class="k">return</span> <span class="n">Y</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scipy_interpolator</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span> <span class="n">scipy_interpolator</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;InterpolatedUnivariateSpline&#39;</span><span class="p">,</span> <span class="s1">&#39;interp1d&#39;</span><span class="p">][</span><span class="n">scipy_interpolator</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;nearest&#39;</span><span class="p">:</span> <span class="n">kind</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;const&#39;</span>
        <span class="k">if</span> <span class="n">scipy_interpolator</span> <span class="o">==</span> <span class="s1">&#39;InterpolatedUnivariateSpline&#39;</span><span class="p">:</span> 
            <span class="n">k</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">,</span> <span class="s1">&#39;cubic&#39;</span><span class="p">,</span> <span class="s1">&#39;quartic&#39;</span><span class="p">,</span> <span class="s1">&#39;quintic&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;zero&#39;</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">,</span> <span class="s1">&#39;cubic&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">kind</span>
    <span class="k">if</span> <span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;nearest&#39;</span><span class="p">:</span> <span class="n">ext</span> <span class="o">=</span> <span class="s1">&#39;const&#39;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">force_scipy_interpolator</span> <span class="o">==</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(((((</span><span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;const&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ext</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;zeros&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ext</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">|</span> 
            <span class="p">((</span><span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;fill_value&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="ow">not</span> <span class="p">(</span><span class="n">fill_value</span> <span class="o">==</span> <span class="s1">&#39;extrapolate&#39;</span><span class="p">))))</span> <span class="o">|</span>
            <span class="p">((</span><span class="n">Xnew</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Xnew</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])))):</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;zeros&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ext</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)):</span>
                <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">)</span> 
            <span class="k">elif</span> <span class="p">((</span><span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;const&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ext</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)):</span> 
                <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">((</span><span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;fill_value&#39;</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span><span class="nb">int</span><span class="p">)):</span> 
                    <span class="n">fill_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span> 
                <span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="n">right</span><span class="p">)</span> <span class="o">=</span> <span class="n">fill_value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">Y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">Xnew</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">Xnew</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
    
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">interpolate</span> <span class="c1"># lazy import</span>
    <span class="k">if</span> <span class="n">scipy_interpolator</span> <span class="o">==</span> <span class="s1">&#39;InterpolatedUnivariateSpline&#39;</span><span class="p">:</span>
        <span class="n">ext_original</span> <span class="o">=</span> <span class="n">ext</span>
        <span class="k">if</span> <span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;fill_value&#39;</span><span class="p">:</span>
            <span class="n">ext</span> <span class="o">=</span> <span class="s1">&#39;extrapolate&#39;</span>
        <span class="k">if</span> <span class="n">Y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">Yn</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">InterpolatedUnivariateSpline</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">ext</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="p">,</span> <span class="n">bbox</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">,</span> <span class="n">check_finite</span> <span class="o">=</span> <span class="n">check_finite</span><span class="p">)(</span><span class="n">Xnew</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
           <span class="n">Yn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">interpolate</span><span class="o">.</span><span class="n">InterpolatedUnivariateSpline</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">ext</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="p">,</span> <span class="n">bbox</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">,</span> <span class="n">check_finite</span> <span class="o">=</span> <span class="n">check_finite</span><span class="p">)(</span><span class="n">Xnew</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ext_original</span> <span class="o">==</span> <span class="s1">&#39;fill_value&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="ow">not</span> <span class="p">(</span><span class="n">fill_value</span> <span class="o">==</span> <span class="s1">&#39;extrapolate&#39;</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span><span class="nb">int</span><span class="p">)):</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
            <span class="n">Yn</span><span class="p">[:,</span><span class="n">Xnew</span> <span class="o">&lt;</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">fill_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">Yn</span><span class="p">[:,</span><span class="n">Xnew</span> <span class="o">&gt;</span> <span class="n">X</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">fill_value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">Yn</span>
            
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;extrapolate&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ext</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)):</span> 
            <span class="n">fill_value</span> <span class="o">=</span> <span class="s1">&#39;extrapolate&#39;</span>
        <span class="k">elif</span> <span class="p">((</span><span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;zeros&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ext</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">)</span> 
        <span class="k">elif</span> <span class="p">((</span><span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;const&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ext</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)):</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="p">((</span><span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;fill_value&#39;</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span><span class="nb">int</span><span class="p">)):</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span> 
        <span class="k">return</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">kind</span> <span class="o">=</span> <span class="n">k</span><span class="p">,</span> <span class="n">bounds_error</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="n">fill_value</span><span class="p">)(</span><span class="n">Xnew</span><span class="p">)</span></div>


<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ndinterp1_scipy">
<a class="viewcode-back" href="../../../math.html#luxpy.math.ndinterp1_scipy">[docs]</a>
<span class="k">def</span> <span class="nf">ndinterp1_scipy</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Xnew</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>  <span class="n">rescale</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>    
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform a n-dimensional linear interpolation (wrapper around scipy.interpolate.LinearNDInterpolator).</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :X: </span>
<span class="sd">            | ndarray with n-dimensional coordinates (last axis represents dimension)</span>
<span class="sd">        :Y: </span>
<span class="sd">            | ndarray with values at coordinates in X</span>
<span class="sd">        :Xnew: </span>
<span class="sd">            | ndarray of new coordinates (last axis represents dimension)</span>
<span class="sd">        :fill_value: </span>
<span class="sd">            | float, optional</span>
<span class="sd">            | Value used to fill in for requested points outside of the</span>
<span class="sd">            | convex hull of the input points.  If not provided, then</span>
<span class="sd">            | the default is ``nan``.</span>
<span class="sd">        :rescale:</span>
<span class="sd">            | bool, optional</span>
<span class="sd">            | Rescale points to unit cube before performing interpolation.</span>
<span class="sd">            | This is useful if some of the input dimensions have</span>
<span class="sd">            | incommensurable units and differ by many orders of magnitude.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        :Ynew:</span>
<span class="sd">            | ndarray with new values at coordinates in Xnew</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">interpolate</span> <span class="c1"># lazy import</span>
    <span class="k">return</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">LinearNDInterpolator</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="n">fill_value</span><span class="p">,</span>  <span class="n">rescale</span> <span class="o">=</span> <span class="n">rescale</span><span class="p">)</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="n">Xnew</span><span class="p">)</span></div>


<div class="viewcode-block" id="ndinterp1">
<a class="viewcode-back" href="../../../math.html#luxpy.math.ndinterp1">[docs]</a>
<span class="k">def</span> <span class="nf">ndinterp1</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Xnew</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform nd-dimensional linear interpolation using Delaunay triangulation.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :X: </span>
<span class="sd">            | ndarray with n-dimensional coordinates (last axis represents dimension).</span>
<span class="sd">        :Y: </span>
<span class="sd">            | ndarray with values at coordinates in X.</span>
<span class="sd">        :Xnew: </span>
<span class="sd">            | ndarray of new coordinates (last axis represents dimension).</span>
<span class="sd">            | When outside of the convex hull of X, then a best estimate is </span>
<span class="sd">            | given based on the closest vertices.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        :Ynew:</span>
<span class="sd">            | ndarray with new values at coordinates in Xnew.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#get dimensions:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">Xnew</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># create an object with triangulation</span>
    <span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">Delaunay</span> <span class="c1"># lazy import</span>
    <span class="n">tri</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> 
    <span class="c1"># find simplexes that contain interpolated points</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">tri</span><span class="o">.</span><span class="n">find_simplex</span><span class="p">(</span><span class="n">Xnew</span><span class="p">)</span>
    <span class="c1"># get the vertices for each simplex</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">tri</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
    <span class="c1"># get transform matrices for each simplex (see explanation bellow)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">tri</span><span class="o">.</span><span class="n">transform</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
    <span class="c1"># for each interpolated point p, mutliply the transform matrix by </span>
    <span class="c1"># vector p-r, where r=m[:,n,:] is one of the simplex vertices to which </span>
    <span class="c1"># the matrix m is related to (again, see below)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,ik-&gt;ij&#39;</span><span class="p">,</span> <span class="n">m</span><span class="p">[:,:</span><span class="n">n</span><span class="p">,:</span><span class="n">n</span><span class="p">],</span> <span class="n">Xnew</span><span class="o">-</span><span class="n">m</span><span class="p">[:,</span><span class="n">n</span><span class="p">,:])</span>
    
    <span class="c1"># get the weights for the vertices; `b` contains an n-dimensional vector</span>
    <span class="c1"># with weights for all but the last vertices of the simplex</span>
    <span class="c1"># (note that for n-D grid, each simplex consists of n+1 vertices);</span>
    <span class="c1"># the remaining weight for the last vertex can be copmuted from</span>
    <span class="c1"># the condition that sum of weights must be equal to 1</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">b</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
    
    <span class="c1"># normalize weigths:</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">/</span><span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="c1"># interpolate:</span>
    <span class="k">if</span> <span class="n">Y</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">Ynew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,ij-&gt;ik&#39;</span><span class="p">,</span> <span class="n">Y</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">w</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Ynew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,ij-&gt;i&#39;</span><span class="p">,</span> <span class="n">Y</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">w</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">Ynew</span></div>


<div class="viewcode-block" id="box_m">
<a class="viewcode-back" href="../../../math.html#luxpy.math.box_m">[docs]</a>
<span class="k">def</span> <span class="nf">box_m</span><span class="p">(</span><span class="o">*</span><span class="n">X</span><span class="p">,</span> <span class="n">ni</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbosity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">robust</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">robust_alpha</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform Box&#39;s M test (p&gt;=2) to check equality of covariance matrices or Bartlett&#39;s test (p==1) for equality of variances.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :X: </span>
<span class="sd">            | A number  (k groups) or list of 2d-ndarrays (rows: samples, cols: variables) with data.</span>
<span class="sd">            | or a number of 2d-ndarrays with covariance matrices (supply ni!)</span>
<span class="sd">        :ni:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | If None: X contains data, else, X contains covariance matrices.</span>
<span class="sd">        :verbosity: </span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | If 1: print results.</span>
<span class="sd">        :robust:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | If True: remove outliers beyond the confidence ellipsoid before calculating</span>
<span class="sd">            |          the covariances.</span>
<span class="sd">        :robust_alpha:</span>
<span class="sd">            | 0.01, optional</span>
<span class="sd">            | Significance level of confidence ellipsoid marking the boundary for outliers.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :statistic:</span>
<span class="sd">            | F or chi2 value (see len(dfs))</span>
<span class="sd">        :pval:</span>
<span class="sd">            | p-value</span>
<span class="sd">        :df:</span>
<span class="sd">            | degrees of freedom.</span>
<span class="sd">            | if len(dfs) == 2: F-test was used.</span>
<span class="sd">            | if len(dfs) == 1: chi2 approx. was used.</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        1. If p==1: Reduces to Bartlett&#39;s test for equal variances.</span>
<span class="sd">        2. If (ni&gt;20).all() &amp; (p&lt;6) &amp; (k&lt;6): then a more appropriate chi2 test is used in a some cases.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span> <span class="c1"># lazy import</span>
    
    <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="c1"># groups</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># variables</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># for p == 1: only variance!</span>
        <span class="n">det</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">det</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ni</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># samples in each group</span>
        
        <span class="c1"># remove outliers before calculation of box M:</span>
        <span class="k">if</span> <span class="n">robust</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="n">remove_outliers</span><span class="p">(</span><span class="n">Xi</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">robust_alpha</span><span class="p">)</span> <span class="k">for</span> <span class="n">Xi</span> <span class="ow">in</span> <span class="n">X</span><span class="p">]</span>
            
        <span class="n">ni</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Xi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">Xi</span> <span class="ow">in</span> <span class="n">X</span><span class="p">])</span>
        <span class="n">Si</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">Xi</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="k">for</span> <span class="n">Xi</span> <span class="ow">in</span> <span class="n">X</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">Si</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">Si</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Si</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Xi</span> <span class="k">for</span> <span class="n">Xi</span> <span class="ow">in</span> <span class="n">X</span><span class="p">])</span> <span class="c1"># input are already cov matrices!</span>
        <span class="n">ni</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ni</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ni</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ni</span> <span class="o">=</span> <span class="n">ni</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">k</span><span class="p">,))</span>
        
    <span class="n">N</span> <span class="o">=</span> <span class="n">ni</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">ni</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Si</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ni</span><span class="p">))])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span>

    <span class="n">M</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">det</span><span class="p">(</span><span class="n">S</span><span class="p">))</span> <span class="o">-</span> <span class="p">((</span><span class="n">ni</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">det</span><span class="p">(</span><span class="n">Si</span><span class="p">)))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">A1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">p</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="p">((</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">ni</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">k</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">A2</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="p">((</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">ni</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">A2</span> <span class="o">-</span> <span class="n">A1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">v2</span> <span class="o">=</span> <span class="p">(</span><span class="n">v1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">A2</span> <span class="o">-</span> <span class="n">A1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">v1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">A1</span> <span class="o">-</span><span class="p">(</span><span class="n">v1</span><span class="o">/</span><span class="n">v2</span><span class="p">))</span>
        <span class="n">Fv1v2</span> <span class="o">=</span> <span class="n">M</span><span class="o">/</span><span class="n">b</span>
        <span class="n">statistic</span> <span class="o">=</span> <span class="n">Fv1v2</span>
        <span class="n">pval</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">Fv1v2</span><span class="p">,</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">)</span>
        <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">verbosity</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;M = </span><span class="si">{:1.4f}</span><span class="s1">, F = </span><span class="si">{:1.4f}</span><span class="s1">, df1 = </span><span class="si">{:1.1f}</span><span class="s1">, df2 = </span><span class="si">{:1.1f}</span><span class="s1">, p = </span><span class="si">{:1.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">Fv1v2</span><span class="p">,</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="n">pval</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">v2</span> <span class="o">=</span> <span class="p">(</span><span class="n">v1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">A1</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">A2</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">v2</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">A1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="n">v2</span><span class="p">))</span>
        <span class="n">Fv1v2</span> <span class="o">=</span> <span class="n">v2</span><span class="o">*</span><span class="n">M</span><span class="o">/</span><span class="p">(</span><span class="n">v1</span><span class="o">*</span><span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">M</span><span class="p">))</span>
        <span class="n">statistic</span> <span class="o">=</span> <span class="n">Fv1v2</span>
        <span class="n">pval</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">Fv1v2</span><span class="p">,</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">)</span>
        <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">]</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">ni</span><span class="o">&gt;</span><span class="mi">20</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">k</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">):</span> <span class="c1">#use Chi2v1</span>
            <span class="n">chi2v1</span> <span class="o">=</span> <span class="n">M</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">A1</span><span class="p">)</span>
            <span class="n">statistic</span> <span class="o">=</span> <span class="n">chi2v1</span>
            <span class="n">pval</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">chi2v1</span><span class="p">,</span><span class="n">v1</span><span class="p">)</span>
            <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">v1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">verbosity</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;M = </span><span class="si">{:1.4f}</span><span class="s1">, chi2 = </span><span class="si">{:1.4f}</span><span class="s1">, df1 = </span><span class="si">{:1.1f}</span><span class="s1">, p = </span><span class="si">{:1.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">chi2v1</span><span class="p">,</span><span class="n">v1</span><span class="p">,</span><span class="n">pval</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbosity</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;M = </span><span class="si">{:1.4f}</span><span class="s1">, F = </span><span class="si">{:1.4f}</span><span class="s1">, df1 = </span><span class="si">{:1.1f}</span><span class="s1">, df2 = </span><span class="si">{:1.1f}</span><span class="s1">, p = </span><span class="si">{:1.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">Fv1v2</span><span class="p">,</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="n">pval</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">statistic</span><span class="p">,</span> <span class="n">pval</span><span class="p">,</span> <span class="n">dfs</span></div>


<div class="viewcode-block" id="pitman_morgan">
<a class="viewcode-back" href="../../../math.html#luxpy.math.pitman_morgan">[docs]</a>
<span class="k">def</span> <span class="nf">pitman_morgan</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span> <span class="n">verbosity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pitman-Morgan Test for the difference between correlated variances with paired samples.</span>
<span class="sd">     </span>
<span class="sd">    Args:</span>
<span class="sd">        :X,Y: </span>
<span class="sd">            | ndarrays with data.</span>
<span class="sd">        :verbosity: </span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | If 1: print results. </span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :tval:</span>
<span class="sd">            | statistic</span>
<span class="sd">        :pval:</span>
<span class="sd">            | p-value</span>
<span class="sd">        :df:</span>
<span class="sd">            | degree of freedom.</span>
<span class="sd">        :ratio:</span>
<span class="sd">            | variance ratio var1/var2 (with var1 &gt; var2).</span>

<span class="sd">    Note:</span>
<span class="sd">        1. Based on Gardner, R.C. (2001). Psychological Statistics Using SPSS for Windows. New Jersey, Prentice Hall.</span>
<span class="sd">        2. Python port from matlab code by Janne Kauttonen (https://nl.mathworks.com/matlabcentral/fileexchange/67910-pitmanmorgantest-x-y; accessed Sep 26, 2019)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span> <span class="c1"># lazy import</span>
    
    <span class="n">N</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">var1</span><span class="p">,</span> <span class="n">var2</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span><span class="n">Y</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">cor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="c1"># must have var1 &gt; var2:</span>
    <span class="k">if</span> <span class="n">var1</span> <span class="o">&lt;</span> <span class="n">var2</span><span class="p">:</span>
        <span class="n">var1</span><span class="p">,</span> <span class="n">var2</span> <span class="o">=</span> <span class="n">var2</span><span class="p">,</span> <span class="n">var1</span>

    <span class="n">ratio</span> <span class="o">=</span> <span class="n">var1</span><span class="o">/</span><span class="n">var2</span>
    
    <span class="c1"># formulas from Garder (2001, p.57):</span>
    <span class="n">numerator1_S1minusS2</span> <span class="o">=</span> <span class="n">var1</span><span class="o">-</span><span class="n">var2</span>
    <span class="n">numerator2_SQRTnminus2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">numerator3</span> <span class="o">=</span> <span class="n">numerator1_S1minusS2</span><span class="o">*</span><span class="n">numerator2_SQRTnminus2</span>
    <span class="n">denominator1_4timesS1timesS2</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">var1</span><span class="o">*</span><span class="n">var2</span>
    <span class="n">denominator2_rSquared</span> <span class="o">=</span> <span class="n">cor</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">denominator3_1minusrSquared</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">denominator2_rSquared</span>
    <span class="n">denominator4_4timesS1timesS2div1minusrSquared</span> <span class="o">=</span> <span class="n">denominator1_4timesS1timesS2</span><span class="o">*</span><span class="n">denominator3_1minusrSquared</span>
    <span class="n">denominator5</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">denominator4_4timesS1timesS2div1minusrSquared</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">N</span><span class="o">-</span><span class="mi">2</span>
    <span class="k">if</span> <span class="n">denominator5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">denominator5</span> <span class="o">=</span> <span class="n">_EPS</span>
    <span class="n">tval</span> <span class="o">=</span> <span class="n">numerator3</span><span class="o">/</span><span class="n">denominator5</span>
    
    <span class="c1"># compute stats:</span>
    <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">tval</span><span class="p">,</span><span class="n">df</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">verbosity</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;tval = </span><span class="si">{:1.4f}</span><span class="s1">, df = </span><span class="si">{:1.1f}</span><span class="s1">, p = </span><span class="si">{:1.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tval</span><span class="p">,</span><span class="n">df</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">tval</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">ratio</span></div>


<div class="viewcode-block" id="stress">
<a class="viewcode-back" href="../../../math.html#luxpy.math.stress">[docs]</a>
<span class="k">def</span> <span class="nf">stress</span><span class="p">(</span><span class="n">DE</span><span class="p">,</span><span class="n">DV</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">max_scale</span> <span class="o">=</span> <span class="mi">100</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate STandardize-Residual-Sum-of-Squares (STRESS).</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :DE, DV: </span>
<span class="sd">            | ndarrays of data to be compared.</span>
<span class="sd">        :axis:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | axis with samples</span>
<span class="sd">        :max_scale:</span>
<span class="sd">            | 100, optional</span>
<span class="sd">            | Maximum of scale.</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :stress:</span>
<span class="sd">            | nadarray with stress value(s).</span>
<span class="sd">    </span>
<span class="sd">    Reference:</span>
<span class="sd">        1. `Melgosa, M., García, P. A., Gómez-Robledo, L., Shamey, R., Hinks, D., Cui, G., &amp; Luo, M. R. (2011). </span>
<span class="sd">        Notes on the application of the standardized residual sum of squares index </span>
<span class="sd">        for the assessment of intra- and inter-observer variability in color-difference experiments. </span>
<span class="sd">        Journal of the Optical Society of America A, 28(5), 949–953. </span>
<span class="sd">        &lt;https://doi.org/10.1364/JOSAA.28.000949&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">F</span> <span class="o">=</span> <span class="p">(</span><span class="n">DE</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">DE</span><span class="o">*</span><span class="n">DV</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">max_scale</span><span class="o">*</span><span class="p">(((</span><span class="n">DE</span> <span class="o">-</span> <span class="n">F</span><span class="o">*</span><span class="n">DV</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">F</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">DV</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">True</span><span class="p">))</span><span class="o">**</span><span class="mf">0.5</span></div>


<div class="viewcode-block" id="stress_F_test">
<a class="viewcode-back" href="../../../math.html#luxpy.math.stress_F_test">[docs]</a>
<span class="k">def</span> <span class="nf">stress_F_test</span><span class="p">(</span><span class="n">stressA</span><span class="p">,</span> <span class="n">stressB</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Perform F-test on significance of difference between STRESS A and STRESS B.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :stressA, stressB:</span>
<span class="sd">            | ndarray with stress(es) values for A and B</span>
<span class="sd">        :N:</span>
<span class="sd">            | int or ndarray with number of samples used to determine stress values.</span>
<span class="sd">        :alpha:</span>
<span class="sd">            | 0.05, optional</span>
<span class="sd">            | significance level</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :Fstats:</span>
<span class="sd">            | Dictionary with keys:</span>
<span class="sd">            | - &#39;p&#39;: p-values</span>
<span class="sd">            | - &#39;F&#39;:  F-values</span>
<span class="sd">            | - &#39;Fc&#39;: critcal values</span>
<span class="sd">            | - &#39;H&#39;: string reporting on significance of A compared to B.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span> <span class="c1"># lazy import</span>
    
    <span class="n">N</span> <span class="o">=</span> <span class="n">N</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">stressA</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">Fvs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">stressA</span><span class="p">)</span>
    <span class="n">ps</span> <span class="o">=</span> <span class="n">Fvs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">Fcs</span> <span class="o">=</span> <span class="n">Fvs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">H</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">stA</span><span class="p">,</span> <span class="n">stB</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">stressA</span><span class="p">,</span><span class="n">stressB</span><span class="p">):</span>
        <span class="n">Ni</span> <span class="o">=</span> <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">Fvs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">stA</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">stB</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">ps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="n">Fvs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Ni</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Ni</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">Fcs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">q</span> <span class="o">=</span> <span class="n">alpha</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">dfn</span> <span class="o">=</span> <span class="n">Ni</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dfd</span> <span class="o">=</span> <span class="n">Ni</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Fvs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">Fcs</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">H_</span> <span class="o">=</span> <span class="s2">&quot;A significantly better than B&quot;</span>
        <span class="k">elif</span> <span class="n">Fvs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">/</span><span class="n">Fcs</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">H_</span> <span class="o">=</span> <span class="s2">&quot;A significantly poorer than B&quot;</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">Fcs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">Fvs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Fvs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">H_</span> <span class="o">=</span> <span class="s2">&quot;A insignificantly better than B&quot;</span>
        <span class="k">elif</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">Fvs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Fvs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">/</span><span class="n">Fcs</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
            <span class="n">H_</span> <span class="o">=</span> <span class="s2">&quot;A insignificanty poorer than B&quot;</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">Fvs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">H_</span> <span class="o">=</span> <span class="s2">&quot;A equals B&quot;</span>
        <span class="n">H</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">H_</span><span class="p">)</span>
        <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
    <span class="n">Fstats</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;p&#39;</span><span class="p">:</span> <span class="n">ps</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">:</span> <span class="n">Fvs</span><span class="p">,</span> <span class="s1">&#39;Fc&#39;</span><span class="p">:</span> <span class="n">Fcs</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="n">H</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">Fstats</span></div>


<div class="viewcode-block" id="mean_distance_weighted">
<a class="viewcode-back" href="../../../math.html#luxpy.math.mean_distance_weighted">[docs]</a>
<span class="k">def</span> <span class="nf">mean_distance_weighted</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">center_x</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="n">mu</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mu0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recursively calculate distance weighted mean.</span>
<span class="sd">    </span>
<span class="sd">    Args: </span>
<span class="sd">        :x:</span>
<span class="sd">            | ndarray with data</span>
<span class="sd">        :axis:</span>
<span class="sd">            | dimension along which to take mean</span>
<span class="sd">        :keepdims:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | If True: keep dimension of original ndarray</span>
<span class="sd">        :center_x:</span>
<span class="sd">            | True, optional</span>
<span class="sd">            | Center data first.</span>
<span class="sd">        :rtol:</span>
<span class="sd">            | 1e-3, optional</span>
<span class="sd">            | Relative tolerance on recursive mean values. If two sequential</span>
<span class="sd">            | mean values differ less than this amount, the recursion stops.</span>
<span class="sd">        :max_iter:</span>
<span class="sd">            | 100, optional</span>
<span class="sd">            | Maximum amount of recursions. If this number is reached the </span>
<span class="sd">            | recursion stops, even when rtol is not yet achieved. (to avoid</span>
<span class="sd">            | getting stuck in an infinite loop when the recursion doesn&#39;t converge)</span>
<span class="sd">        :cnt,mu,mu0:</span>
<span class="sd">            | Needed for passing values across recursions to be able to stop them.</span>
<span class="sd">            | DO NOT CHANGE.</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :mu_dw:</span>
<span class="sd">            | distance weighted mean of the array</span>
<span class="sd">            </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span> 
    <span class="k">if</span> <span class="n">mu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
        <span class="k">if</span> <span class="n">center_x</span><span class="p">:</span> 
            <span class="n">mu0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">mu0</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        
    <span class="n">w</span> <span class="o">=</span> <span class="p">(((</span><span class="n">x</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="c1"># w = (((x - mu)**2))**0.5</span>
    <span class="n">w</span><span class="p">[</span><span class="n">w</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-100</span>
    <span class="n">w</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">w</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">w</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">mu_prev</span> <span class="o">=</span> <span class="n">mu</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">mu</span><span class="o">-</span><span class="n">mu_prev</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">mu</span> <span class="o">+</span> <span class="mf">1e-100</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">rtol</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">())</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">max_iter</span><span class="p">):</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">mean_distance_weighted</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="n">keepdims</span><span class="p">,</span><span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span><span class="p">,</span> <span class="n">mu0</span> <span class="o">=</span> <span class="n">mu0</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">)</span>     
        <span class="k">return</span> <span class="n">mu</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">keepdims</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mu0</span> <span class="o">+</span> <span class="n">mu</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">mu0</span> <span class="o">+</span> <span class="n">mu</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span><span class="p">)</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Kevin A.G. Smet.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>