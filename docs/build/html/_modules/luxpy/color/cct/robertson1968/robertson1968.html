<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>luxpy.color.cct.robertson1968.robertson1968 &mdash; LuxPy 1.11.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../_static/pygments.css?v=b76e3c8a" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../../../_static/documentation_options.js?v=6cf1fb80"></script>
        <script src="../../../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../index.html" class="icon icon-home">
            LuxPy
          </a>
              <div class="version">
                1.11.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../license.html">License: GPLv3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../required_packages.html">Imported (required) packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../luxpy_structure.html">Luxpy package structure</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">LuxPy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">luxpy.color.cct.robertson1968.robertson1968</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for luxpy.color.cct.robertson1968.robertson1968</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Standalone Robertson1968 implementation </span>
<span class="sd">=======================================</span>
<span class="sd"> </span>
<span class="sd"> (includes correction near slope-sign-change of iso-temperature-lines)</span>

<span class="sd"> :cct_to_xyz(): Calculates xyz from CCT, Duv by estimating the line perpendicular to the planckian locus (=iso-T line).</span>

<span class="sd"> :cct_to_xyz(): Calculates xyz from CCT, Duv [_CCT_MIN &lt; CCT &lt; _CCT_MAX]</span>
<span class="sd"> </span>
<span class="sd"> </span>
<span class="sd">References:</span>
<span class="sd">   1. `Robertson, A. R. (1968). </span>
<span class="sd">   Computation of Correlated Color Temperature and Distribution Temperature. </span>
<span class="sd">   Journal of the Optical Society of America,  58(11), 1528â€“1535. </span>
<span class="sd">   &lt;https://doi.org/10.1364/JOSA.58.001528&gt;`_</span>
<span class="sd">   </span>
<span class="sd">   2. Smet K.A.G., Royer M., Baxter D., Bretschneider E., Esposito E., Houser K., Luedtke W., Man K., Ohno Y. (2022),</span>
<span class="sd">   Recommended method for determining the correlated color temperature and distance from the Planckian Locus of a light source</span>
<span class="sd">   (in preparation, LEUKOS?)</span>
<span class="sd">   </span>
<span class="sd">   3. Baxter D., Royer M., Smet K.A.G. (2022)</span>
<span class="sd">   Modifications of the Robertson Method for Calculating Correlated Color Temperature to Improve Accuracy and Speed</span>
<span class="sd">   (in preparation, LEUKOS?)</span>
<span class="sd">   </span>
<span class="sd">Created on Thu June 8 15:36:29 2022</span>

<span class="sd">@author: ksmet1977 [at] gmail.com</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># get path to module:</span>
<span class="n">_PATH</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">);</span><span class="s2">&quot;&quot;&quot; Absolute path to module &quot;&quot;&quot;</span> 
<span class="n">_SEP</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">;</span> <span class="s2">&quot;&quot;&quot; Operating system separator &quot;&quot;&quot;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;_CCT_LUT_WL3&#39;</span><span class="p">,</span><span class="s1">&#39;_CCT_AVOID_ZERO_DIV&#39;</span><span class="p">,</span><span class="s1">&#39;_CCT_AVOID_INF&#39;</span><span class="p">,</span><span class="s1">&#39;_CCT_MIN&#39;</span><span class="p">,</span><span class="s1">&#39;_CCT_MAX&#39;</span><span class="p">,</span>
          <span class="s1">&#39;_CCT_FAST_DUV&#39;</span><span class="p">,</span><span class="s1">&#39;_CCT_MAX_ITER&#39;</span><span class="p">,</span><span class="s1">&#39;_CCT_SPLIT_CALC_AT_N&#39;</span><span class="p">,</span>
          <span class="s1">&#39;_CCT_LUT_PATH&#39;</span><span class="p">,</span><span class="s1">&#39;_CCT_LUT&#39;</span><span class="p">,</span><span class="s1">&#39;_CCT_LIST_OF_CIEOBS_LUTS&#39;</span><span class="p">,</span><span class="s1">&#39;_CCT_CIEOBS&#39;</span><span class="p">,</span>
          <span class="s1">&#39;_BB&#39;</span><span class="p">,</span><span class="s1">&#39;_WL3&#39;</span><span class="p">,</span>
          <span class="s1">&#39;save_pkl&#39;</span><span class="p">,</span><span class="s1">&#39;load_pkl&#39;</span><span class="p">,</span><span class="s1">&#39;get_tcs4&#39;</span><span class="p">,</span><span class="s1">&#39;calculate_lut&#39;</span><span class="p">,</span><span class="s1">&#39;loadtxt&#39;</span><span class="p">,</span>
          <span class="s1">&#39;xyz_to_cct&#39;</span><span class="p">,</span><span class="s1">&#39;xyz_to_duv&#39;</span><span class="p">,</span><span class="s1">&#39;cct_to_xyz&#39;</span><span class="p">]</span>

<span class="c1">#==============================================================================</span>
<span class="c1"># define global variables:</span>
<span class="c1">#==============================================================================</span>
<span class="n">_CCT_LUT_WL3</span> <span class="o">=</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span><span class="mi">830</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">_CCT_AVOID_ZERO_DIV</span> <span class="o">=</span> <span class="mf">1e-100</span>
<span class="n">_CCT_AVOID_INF</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">_CCT_AVOID_ZERO_DIV</span>

<span class="n">_CCT_MIN</span> <span class="o">=</span> <span class="mi">450</span> 
<span class="n">_CCT_MAX</span> <span class="o">=</span> <span class="mf">1e11</span> <span class="c1"># don&#39;t set to higher value to avoid overflow and errors</span>

<span class="n">_CCT_FAST_DUV</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># use a fast, but slightly less accurate Duv calculation with Newton-Raphson</span>
<span class="n">_CCT_MAX_ITER</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">_CCT_SPLIT_CALC_AT_N</span> <span class="o">=</span> <span class="mi">25</span> <span class="c1"># some tests show that this seems to be the fastest (for 1000 conversions)</span>

<span class="n">_CCT_LUT_PATH</span> <span class="o">=</span> <span class="n">_PATH</span> <span class="o">+</span> <span class="n">_SEP</span> <span class="o">+</span> <span class="s1">&#39;luts&#39;</span><span class="o">+</span> <span class="n">_SEP</span> <span class="c1">#folder with cct lut data</span>
<span class="n">_CCT_LUT_CALC</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">_CCT_LUT</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">_CCT_USE_EXTENDED_LUT</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># True doesn&#39;t really lead to a gain in computatation time</span>

<span class="n">_CCT_LIST_OF_CIEOBS_LUTS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;1931_2&#39;</span><span class="p">,</span><span class="s1">&#39;1964_10&#39;</span><span class="p">,</span><span class="s1">&#39;2015_2&#39;</span><span class="p">,</span><span class="s1">&#39;2015_10&#39;</span><span class="p">]</span>
<span class="n">_CCT_CIEOBS</span> <span class="o">=</span> <span class="s1">&#39;1931_2&#39;</span> <span class="c1"># default CIE observer</span>


<span class="c1">#--------------------------------------------------------------------------------------------------</span>
<span class="c1"># set coefficients for blackbody radiators (c2 rounded to 1.4388e-2 as defiend for ITS-90 International Temperature Scale):</span>
<span class="n">_BB</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;c1&#39;</span> <span class="p">:</span> <span class="mf">3.74177185e-16</span><span class="p">,</span> <span class="s1">&#39;c2&#39;</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mf">1.4387768775e-2</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span><span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="mf">1.000</span><span class="p">,</span> <span class="s1">&#39;na&#39;</span><span class="p">:</span> <span class="mf">1.00028</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span> <span class="p">:</span> <span class="mi">299792458</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span> <span class="p">:</span> <span class="mf">6.62607015e-34</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span> <span class="p">:</span> <span class="mf">1.380649e-23</span><span class="p">}</span> <span class="c1"># blackbody c1,c2 &amp; n standard values (h,k,c from NIST, CODATA2018)</span>


<span class="c1">#==============================================================================</span>
<span class="c1"># Function definitions:</span>
<span class="c1">#==============================================================================</span>

<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># Luxpy copies:</span>
<span class="c1">#------------------------------------------------------------------------------</span>
<span class="n">_WL3</span> <span class="o">=</span> <span class="n">_CCT_LUT_WL3</span>
<div class="viewcode-block" id="save_pkl">
<a class="viewcode-back" href="../../../../../color.html#luxpy.color.cct.robertson1968.save_pkl">[docs]</a>
<span class="k">def</span> <span class="nf">save_pkl</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span> 
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Save an object in a pickle file.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :filename:</span>
<span class="sd">            | str with filename of pickle file.</span>
<span class="sd">        :obj:</span>
<span class="sd">            | python object to save</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :None:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">handle</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="load_pkl">
<a class="viewcode-back" href="../../../../../color.html#luxpy.color.cct.robertson1968.load_pkl">[docs]</a>
<span class="k">def</span> <span class="nf">load_pkl</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Load the object in a pickle file.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :filename:</span>
<span class="sd">            | str with filename of pickle file.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        :obj:</span>
<span class="sd">            | loaded python object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">obj</span></div>


<div class="viewcode-block" id="loadtxt">
<a class="viewcode-back" href="../../../../../color.html#luxpy.color.cct.robertson1968.loadtxt">[docs]</a>
<span class="k">def</span> <span class="nf">loadtxt</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">header</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">sep</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">float</span><span class="p">,</span> <span class="n">missing_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Load data from text file. </span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :filename:</span>
<span class="sd">            | String with filename [+path]</span>
<span class="sd">        :header:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | None: no header present, &#39;infer&#39; get from file.</span>
<span class="sd">        :sep:</span>
<span class="sd">            | &#39;,&#39;, optional</span>
<span class="sd">            | Delimiter (&#39;,&#39; -&gt; csv file)</span>
<span class="sd">        :dtype:</span>
<span class="sd">            | float, optional</span>
<span class="sd">            | Try casting output array to this datatype.</span>
<span class="sd">        :missing_values:</span>
<span class="sd">            | np.nan, optional</span>
<span class="sd">            | Replace missing values with this.</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :ndarray:</span>
<span class="sd">            | loaded data in ndarray of type dtype or object (in case of mixed types)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">header</span> <span class="o">==</span> <span class="s1">&#39;infer&#39;</span><span class="p">:</span>
        <span class="n">header</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span> 
            <span class="n">out</span><span class="p">[</span><span class="n">out</span><span class="o">==</span><span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">missing_values</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">,</span> <span class="n">header</span></div>


<span class="k">def</span> <span class="nf">positive_arctan</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="n">htype</span> <span class="o">=</span> <span class="s1">&#39;deg&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate positive angle (0Â°-360Â° or 0 - 2*pi rad.) from x and y.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :x: </span>
<span class="sd">            | ndarray of x-coordinates</span>
<span class="sd">        :y: </span>
<span class="sd">            | ndarray of y-coordinates</span>
<span class="sd">        :htype:</span>
<span class="sd">            | &#39;deg&#39; or &#39;rad&#39;, optional</span>
<span class="sd">            |   - &#39;deg&#39;: hue angle between 0Â° and 360Â°</span>
<span class="sd">            |   - &#39;rad&#39;: hue angle between 0 and 2pi radians</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | ndarray of positive angles.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">htype</span> <span class="o">==</span> <span class="s1">&#39;deg&#39;</span><span class="p">:</span>
        <span class="n">r2d</span> <span class="o">=</span> <span class="mf">180.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">h360</span> <span class="o">=</span> <span class="mf">360.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">r2d</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">h360</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">r2d</span><span class="p">))</span>
    <span class="n">h</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">h</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">h</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)]</span> <span class="o">+</span> <span class="n">h360</span>
    <span class="k">return</span> <span class="n">h</span>


<span class="k">def</span> <span class="nf">getwlr</span><span class="p">(</span><span class="n">wl3</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get/construct a wavelength range from a 3-vector (start, stop, spacing).</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :wl3: </span>
<span class="sd">            | list[start, stop, spacing], optional </span>
<span class="sd">            | (defaults to luxpy._WL3)</span>

<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | ndarray (.shape = (n,)) with n wavelengths ranging from</span>
<span class="sd">            | start to stop, with wavelength interval equal to spacing.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">wl3</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">wl3</span> <span class="o">=</span> <span class="n">_WL3</span>
    
    <span class="c1"># Wavelength definition:</span>
    <span class="n">wl</span> <span class="o">=</span> <span class="n">wl3</span> <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">wl3</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">wl3</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">wl3</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">wl3</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">wl3</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="c1"># define wavelengths from [start = l0, stop = ln, spacing = dl]</span>
    <span class="k">return</span> <span class="n">wl</span>

<span class="c1">#------------------------------------------------------------------------------</span>
<span class="k">def</span> <span class="nf">getwld</span><span class="p">(</span><span class="n">wl</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get wavelength spacing. </span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :wl: </span>
<span class="sd">            | ndarray with wavelengths</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | - float:  for equal wavelength spacings</span>
<span class="sd">            | - ndarray (.shape = (n,)): for unequal wavelength spacings</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">wl</span><span class="p">)</span>
    <span class="c1"># dl = (np.hstack((d[0],d[0:-1]/2.0,d[-1])) + np.hstack((0.0,d[1:]/2.0,0.0)))</span>
    <span class="n">dl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">],(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span><span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dl</span> <span class="o">==</span> <span class="n">dl</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span><span class="o">.</span><span class="n">all</span><span class="p">():</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">dl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">dl</span>

<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># Load CMFs:</span>
<span class="c1">#------------------------------------------------------------------------------</span>
<span class="n">_CMF</span> <span class="o">=</span> <span class="n">load_pkl</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_CCT_LUT_PATH</span><span class="p">,</span><span class="s1">&#39;CMFs_360-830-1.pkl&#39;</span><span class="p">))</span>

<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># XYZ to chromaticity conversion functions  </span>
<span class="c1">#------------------------------------------------------------------------------</span>
<span class="k">def</span> <span class="nf">xyz_to_Yxy</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert XYZ tristimulus values CIE Yxy chromaticity values.</span>

<span class="sd">    Args:</span>
<span class="sd">        :xyz: </span>
<span class="sd">            | ndarray with tristimulus values</span>

<span class="sd">    Returns:</span>
<span class="sd">        :Yxy: </span>
<span class="sd">            | ndarray with Yxy chromaticity values</span>
<span class="sd">            |  (Y value refers to luminance or luminance factor)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
    <span class="n">Yxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">sumxyz</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">Yxy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">Yxy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">sumxyz</span>
    <span class="n">Yxy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">sumxyz</span>
    <span class="k">return</span> <span class="n">Yxy</span>


<span class="k">def</span> <span class="nf">Yxy_to_xyz</span><span class="p">(</span><span class="n">Yxy</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert CIE Yxy chromaticity values to XYZ tristimulus values.</span>

<span class="sd">    Args:</span>
<span class="sd">        :Yxy: </span>
<span class="sd">            | ndarray with Yxy chromaticity values</span>
<span class="sd">            |  (Y value refers to luminance or luminance factor)</span>

<span class="sd">    Returns:</span>
<span class="sd">        :xyz: </span>
<span class="sd">            | ndarray with tristimulus values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Yxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">Yxy</span><span class="p">)</span>
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">Yxy</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Yxy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Yxy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">Yxy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">Yxy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">Yxy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">Yxy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">Yxy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">Yxy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">xyz</span>

<span class="c1"># Direct definition causes slight rounding errors with luxpy implementation</span>
<span class="c1"># def xyz_to_Yuv60(xyz):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Convert XYZ tristimulus values CIE 1960 Y,u,v chromaticity values.</span>

<span class="c1">#     Args:</span>
<span class="c1">#         :xyz: </span>
<span class="c1">#             | ndarray with tristimulus values</span>

<span class="c1">#     Returns:</span>
<span class="c1">#         :Yuv: </span>
<span class="c1">#             | ndarray with CIE 1960 Y,u,v chromaticity values</span>
<span class="c1">#             |  (Y value refers to luminance or luminance factor)</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     xyz = np.atleast_2d(xyz)</span>
<span class="c1">#     Yuv = np.empty(xyz.shape)</span>
<span class="c1">#     denom = xyz[...,0] + 15.0*xyz[...,1] + 3.0*xyz[...,2]</span>
<span class="c1">#     Yuv[...,0] = xyz[...,1]</span>
<span class="c1">#     Yuv[...,1] = 4.0*xyz[...,0] / denom</span>
<span class="c1">#     Yuv[...,2] = 6.0*xyz[...,1] / denom</span>
<span class="c1">#     return Yuv</span>


<span class="c1"># def Yuv60_to_xyz(Yuv60):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Convert CIE 1960 Y,u,v chromaticity values to XYZ tristimulus values.</span>

<span class="c1">#     Args:</span>
<span class="c1">#         :Yuv: </span>
<span class="c1">#             | ndarray with CIE 1960 Y,u,v chromaticity values</span>
<span class="c1">#             |  (Y value refers to luminance or luminance factor)</span>

<span class="c1">#     Returns:</span>
<span class="c1">#         :xyz: </span>
<span class="c1">#             | ndarray with tristimulus values</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Yuv = np.atleast_2d(Yuv60)</span>
<span class="c1">#     xyz = np.empty(Yuv.shape)</span>
<span class="c1">#     xyz[...,1] = Yuv[...,0]</span>
<span class="c1">#     xyz[...,0] = Yuv[...,0]*(3.0*Yuv[...,1])/(2.0*Yuv[...,2])</span>
<span class="c1">#     xyz[...,2] = Yuv[...,0]*(4.0 - Yuv[...,1] - 10.0*Yuv[...,2])/(2.0*Yuv[...,2])</span>
<span class="c1">#     return xyz</span>

<span class="k">def</span> <span class="nf">xyz_to_Yuv76</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert XYZ tristimulus values CIE 1976 Y,u&#39;,v&#39; chromaticity values.</span>

<span class="sd">    Args:</span>
<span class="sd">        :xyz: </span>
<span class="sd">            | ndarray with tristimulus values</span>

<span class="sd">    Returns:</span>
<span class="sd">        :Yuv: </span>
<span class="sd">            | ndarray with CIE 1976 Y,u&#39;,v&#39; chromaticity values</span>
<span class="sd">            |  (Y value refers to luminance or luminance factor)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
    <span class="n">Yuv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">15.0</span><span class="o">*</span><span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">3.0</span><span class="o">*</span><span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">Yuv</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">Yuv</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">4.0</span><span class="o">*</span><span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">denom</span>
    <span class="n">Yuv</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">9.0</span><span class="o">*</span><span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">denom</span>
    <span class="k">return</span> <span class="n">Yuv</span>

<span class="k">def</span> <span class="nf">Yuv76_to_xyz</span><span class="p">(</span><span class="n">Yuv</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert CIE 1976 Y,u&#39;,v&#39; chromaticity values to XYZ tristimulus values.</span>

<span class="sd">    Args:</span>
<span class="sd">        :Yuv: </span>
<span class="sd">            | ndarray with CIE 1976 Y,u&#39;,v&#39; chromaticity values</span>
<span class="sd">            |  (Y value refers to luminance or luminance factor)</span>

<span class="sd">    Returns:</span>
<span class="sd">        :xyz: </span>
<span class="sd">            | ndarray with tristimulus values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Yuv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">Yuv</span><span class="p">)</span>
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">Yuv</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Yuv</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Yuv</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mf">9.0</span><span class="o">*</span><span class="n">Yuv</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mf">4.0</span><span class="o">*</span><span class="n">Yuv</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">Yuv</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mf">12.0</span> <span class="o">-</span> <span class="mf">3.0</span><span class="o">*</span><span class="n">Yuv</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">20.0</span><span class="o">*</span><span class="n">Yuv</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mf">4.0</span><span class="o">*</span><span class="n">Yuv</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">xyz</span>


<span class="k">def</span> <span class="nf">xyz_to_Yuv60</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert XYZ tristimulus values CIE 1960 Y,u,v chromaticity values.</span>

<span class="sd">    Args:</span>
<span class="sd">        :xyz: </span>
<span class="sd">            | ndarray with tristimulus values</span>

<span class="sd">    Returns:</span>
<span class="sd">        :Yuv: </span>
<span class="sd">            | ndarray with CIE 1960 Y,u,v chromaticity values</span>
<span class="sd">            |  (Y value refers to luminance or luminance factor)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Yuv</span> <span class="o">=</span> <span class="n">xyz_to_Yuv76</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">Yuv</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span> 
    <span class="k">return</span> <span class="n">Yuv</span>


<span class="k">def</span> <span class="nf">Yuv60_to_xyz</span><span class="p">(</span><span class="n">Yuv</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert CIE 1976 Y,u,v chromaticity values to XYZ tristimulus values.</span>

<span class="sd">    Args:</span>
<span class="sd">        :Yuv: </span>
<span class="sd">            | ndarray with CIE 1976 Yu&#39;v&#39; chromaticity values</span>
<span class="sd">            |  (Y value refers to luminance or luminance factor)</span>

<span class="sd">    Returns:</span>
<span class="sd">        :xyz: </span>
<span class="sd">            | ndarray with tristimulus values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Yuv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">Yuv</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
    <span class="n">Yuv</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">3</span><span class="o">/</span><span class="mi">2</span> 
    <span class="k">return</span> <span class="n">Yuv76_to_xyz</span><span class="p">(</span><span class="n">Yuv</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># XYZ calculation, CMFs and CMFs conversion (apply color space transform already to CMFs!)</span>
<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># import luxpy as lx</span>
<span class="k">def</span> <span class="nf">_get_xyzbar_wl_dl</span><span class="p">(</span><span class="n">cieobs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the xyzbar CMF set corresponding to cieobs.</span>
<span class="sd">    Returns an ndarray with the cmfs (stripped of wavelengths), ndarray with</span>
<span class="sd">    wavelengths and an ndarray with the wavelength differences.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get requested cmf set:</span>
    <span class="n">cmf</span> <span class="o">=</span> <span class="n">_CMF</span><span class="p">[</span><span class="n">cieobs</span><span class="p">][</span><span class="s1">&#39;bar&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cieobs</span><span class="p">,</span><span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">cieobs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">wl</span><span class="p">,</span> <span class="n">cmf</span> <span class="o">=</span> <span class="n">cmf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cmf</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">dl</span> <span class="o">=</span> <span class="n">getwld</span><span class="p">(</span><span class="n">wl</span><span class="p">)</span><span class="o">*</span><span class="mf">1.0</span>  <span class="c1"># get wavelength difference</span>
    <span class="n">c</span> <span class="o">=</span> <span class="o">~</span><span class="p">(((</span><span class="n">cmf</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">cmf</span><span class="p">[:,</span><span class="n">c</span><span class="p">]</span> <span class="o">+=</span> <span class="n">_CCT_AVOID_ZERO_DIV</span> <span class="c1"># avoid nan&#39;s in uvwvbar</span>
    <span class="k">return</span> <span class="n">cmf</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">dl</span>

<span class="k">def</span> <span class="nf">_convert_xyzbar_to_uvwbar</span><span class="p">(</span><span class="n">xyzbar</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert the xyzbar (no wl on row 0!) CMF set to a CMF set representing a different </span>
<span class="sd">    color space/ chromaticity diagram (integration leads to new tristimulus values)</span>
<span class="sd">    Returns an ndarray (no wl on row 0!) of new CMFs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># convert to cspace based cmfs (Eq.6-7):</span>
    <span class="n">Yuvbar</span> <span class="o">=</span> <span class="n">xyz_to_Yuv60</span><span class="p">(</span><span class="n">xyzbar</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="c1"># convert to chromaticity format from xyz (cfr. cmf) format</span>
    <span class="n">uvwbar</span> <span class="o">=</span> <span class="n">Yxy_to_xyz</span><span class="p">(</span><span class="n">Yuvbar</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="c1"># convert from chromaticity format (Vuv) to tristimulus (UVW) format and take transpose (=spectra)</span>
    <span class="k">return</span> <span class="n">uvwbar</span>


<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># Planckian spectrum and colorimetric calculations:</span>
<span class="c1">#------------------------------------------------------------------------------</span>
<span class="k">def</span> <span class="nf">_get_BB_BBp_BBpp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;BB,BBp,BBpp&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Get the blackbody radiatior spectrum, and the spectra corresponding to </span>
<span class="sd">    the first and second derivatives to Tc of the blackbody radiator.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">BBp</span><span class="p">,</span><span class="n">BBpp</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="kc">None</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="o">*</span><span class="mf">1.0</span> <span class="c1"># force float</span>
    <span class="n">wlt</span> <span class="o">=</span> <span class="n">wl</span><span class="o">*</span><span class="mf">1.0e-9</span>
    <span class="n">c_wl_T</span> <span class="o">=</span> <span class="n">_BB</span><span class="p">[</span><span class="s1">&#39;c2&#39;</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">wlt</span><span class="o">*</span><span class="n">T</span><span class="p">)</span>
    <span class="n">exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">c_wl_T</span><span class="p">)</span>
    <span class="n">exp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">exp</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_CCT_AVOID_INF</span>
    
    <span class="c1"># avoid div by inf or zero:</span>
    <span class="n">exp_min_1</span> <span class="o">=</span> <span class="n">exp</span> <span class="o">-</span> <span class="mf">1.0</span>
    <span class="n">exp_min_1</span><span class="p">[</span><span class="n">exp_min_1</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">_CCT_AVOID_ZERO_DIV</span>
    <span class="n">exp_min_1</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">exp_min_1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_CCT_AVOID_INF</span>
        
    <span class="n">BB</span> <span class="o">=</span> <span class="n">_BB</span><span class="p">[</span><span class="s1">&#39;c1&#39;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">wlt</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">exp_min_1</span><span class="p">))</span>
    <span class="n">BB</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">BB</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_CCT_AVOID_INF</span>
        
    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;BBp&#39;</span> <span class="ow">in</span> <span class="n">out</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="s1">&#39;BBpp&#39;</span> <span class="ow">in</span> <span class="n">out</span><span class="p">):</span> 
        
        <span class="n">exp_min_1_squared</span> <span class="o">=</span> <span class="n">exp_min_1</span><span class="o">**</span><span class="mi">2</span>
        
        <span class="c1"># avoid div by inf or zero:</span>
        <span class="n">exp_min_1_squared</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">exp_min_1_squared</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_CCT_AVOID_INF</span> <span class="c1"># avoid warning &quot;invalid value encountered in true_divide&quot;</span>
        <span class="n">exp_min_1_squared</span><span class="p">[</span><span class="n">exp_min_1_squared</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="n">_CCT_AVOID_ZERO_DIV</span>
        
        <span class="n">exp_frac</span> <span class="o">=</span> <span class="n">exp</span><span class="o">/</span><span class="n">exp_min_1_squared</span>

        <span class="n">BBp</span> <span class="o">=</span> <span class="p">(</span><span class="n">_BB</span><span class="p">[</span><span class="s1">&#39;c1&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">_BB</span><span class="p">[</span><span class="s1">&#39;c2&#39;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">T</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">wlt</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">)))</span><span class="o">*</span><span class="n">exp_frac</span>

        
    <span class="k">if</span> <span class="s1">&#39;BBpp&#39;</span> <span class="ow">in</span> <span class="n">out</span><span class="p">:</span>
        <span class="n">exp_plus_1</span> <span class="o">=</span> <span class="n">exp</span> <span class="o">+</span> <span class="mf">1.0</span>
        <span class="n">BBpp</span> <span class="o">=</span> <span class="p">(</span><span class="n">BBp</span><span class="o">/</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_wl_T</span> <span class="o">*</span> <span class="p">(</span><span class="n">exp_plus_1</span> <span class="o">/</span> <span class="n">exp_min_1</span><span class="p">)</span>  <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> 
        
        
    <span class="k">return</span> <span class="n">BB</span><span class="p">,</span> <span class="n">BBp</span><span class="p">,</span> <span class="n">BBpp</span>


<span class="k">def</span> <span class="nf">_get_tristim_of_BB_BBp_BBpp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">xyzbar</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;BB,BBp,BBpp&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Get the tristimulus values for CMF set xyzbar of the blackbody radiatior spectra</span>
<span class="sd">    and the spectra corresponding to the first and second derivatives to Tc </span>
<span class="sd">    of the blackbody radiator.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xyzp</span><span class="p">,</span><span class="n">xyzpp</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="n">BB</span><span class="p">,</span> <span class="n">BBp</span><span class="p">,</span> <span class="n">BBpp</span> <span class="o">=</span>  <span class="n">_get_BB_BBp_BBpp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">)</span>
    <span class="c1">#cnd = np.ones((BB.shape[-1],),dtype=bool)#((xyzbar&gt;0).sum(0)&gt;0).T # keep only wavelengths where not all 3 cmfs are equal (to avoid nan&#39;s for 2015 cmfs which are defined only between 390 and 830 nm)</span>
    <span class="n">xyz</span> <span class="o">=</span> <span class="p">((</span><span class="n">BB</span> <span class="o">*</span> <span class="n">dl</span><span class="p">)</span> <span class="o">@</span> <span class="n">xyzbar</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;BBp&#39;</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">):</span> 
        <span class="n">xyzp</span> <span class="o">=</span> <span class="p">((</span><span class="n">BBp</span> <span class="o">*</span> <span class="n">dl</span><span class="p">)</span> <span class="o">@</span> <span class="n">xyzbar</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">xyzp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">xyzp</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_CCT_AVOID_INF</span> <span class="c1"># # avoid warning &quot;invalid value encountered in subtract&quot; when calculating li</span>

    <span class="k">if</span> <span class="s1">&#39;BBpp&#39;</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">):</span> 
        <span class="n">xyzpp</span> <span class="o">=</span> <span class="p">((</span><span class="n">BBpp</span> <span class="o">*</span> <span class="n">dl</span><span class="p">)</span> <span class="o">@</span> <span class="n">xyzbar</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">xyzpp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">xyzpp</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_CCT_AVOID_INF</span>

    <span class="k">return</span> <span class="n">T</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">xyzp</span><span class="p">,</span> <span class="n">xyzpp</span>


<span class="k">def</span> <span class="nf">_get_uv_uvp_uvpp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">uvwbar</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;BB,BBp,BBpp&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Get the (u,v), (u&#39;,v&#39;) and (u&quot;,v&quot;) coordinates of one or more Planckians</span>
<span class="sd">    with specified Tc. uvwbar (no wavelengths on row0, these are supplied seperately</span>
<span class="sd">    in wl, with wavelength spacing in dl) is the cmf set corresponding to the tristimulus values</span>
<span class="sd">    of the chosen chromaticity diagram or color space to do the CCT calculations in.</span>
<span class="sd">    See: Li et al. (2016). Accurate method for computing correlated color temperature. Optics Express, 24(13), 14066â€“14078.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># calculate U,V,W (Eq. 6) and U&#39;,V&#39;,W&#39; (Eq.10) [Robertson,1986] and U&quot;,V&quot;,W&quot; [Li,2016; started from XYZ, but this is equivalent]:</span>
    <span class="n">T</span><span class="p">,</span> <span class="n">UVW</span><span class="p">,</span> <span class="n">UVWp</span><span class="p">,</span> <span class="n">UVWpp</span> <span class="o">=</span> <span class="n">_get_tristim_of_BB_BBp_BBpp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">uvwbar</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">)</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">T</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span>
    
    <span class="c1"># get u,v &amp; u&#39;,v&#39; and u&quot;,v&quot;:</span>
    <span class="n">S</span> <span class="o">=</span> <span class="p">(</span><span class="n">UVW</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">UVW</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">UVW</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">])[:,</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">uv</span> <span class="o">=</span> <span class="p">(</span><span class="n">UVW</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">S</span> <span class="o">+</span> <span class="n">_CCT_AVOID_ZERO_DIV</span><span class="p">))</span>
    <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="o">=</span> <span class="n">uv</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span> <span class="n">uv</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">UVWp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Sp</span> <span class="o">=</span> <span class="p">(</span><span class="n">UVWp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">UVWp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">UVWp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">])[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">PQ</span> <span class="o">=</span> <span class="p">(</span><span class="n">UVWp</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">S</span> <span class="o">-</span> <span class="n">UVW</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">Sp</span><span class="p">)</span>
        <span class="n">uvp</span> <span class="o">=</span> <span class="p">(</span><span class="n">PQ</span> <span class="o">/</span> <span class="p">((</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">_CCT_AVOID_ZERO_DIV</span><span class="p">))</span>
        <span class="n">up</span><span class="p">,</span><span class="n">vp</span> <span class="o">=</span> <span class="n">uvp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span> <span class="n">uvp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">up</span><span class="p">,</span><span class="n">vp</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        
    <span class="k">if</span> <span class="p">(</span><span class="n">UVWpp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UVWp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">Spp</span> <span class="o">=</span> <span class="p">(</span><span class="n">UVWpp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">UVWpp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">UVWpp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">])[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">PQp</span> <span class="o">=</span> <span class="p">(</span><span class="n">UVWpp</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">S</span> <span class="o">-</span> <span class="n">UVW</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">Spp</span><span class="p">)</span>
        <span class="n">uvpp</span> <span class="o">=</span> <span class="p">((</span><span class="n">PQp</span> <span class="o">*</span> <span class="n">S</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">PQ</span> <span class="o">*</span><span class="n">Sp</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="n">S</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">_CCT_AVOID_ZERO_DIV</span><span class="p">))</span>
        <span class="n">upp</span><span class="p">,</span><span class="n">vpp</span> <span class="o">=</span> <span class="n">uvpp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span> <span class="n">uvpp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">upp</span><span class="p">,</span> <span class="n">vpp</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    
    <span class="k">return</span> <span class="n">T</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">up</span><span class="p">,</span> <span class="n">vp</span><span class="p">,</span> <span class="n">upp</span><span class="p">,</span> <span class="n">vpp</span><span class="p">,</span> <span class="p">(</span><span class="n">UVW</span><span class="p">,</span> <span class="n">UVWp</span><span class="p">,</span> <span class="n">UVWpp</span><span class="p">)</span>


<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># Calculate %, K LUT</span>
<span class="c1">#------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="get_tcs4">
<a class="viewcode-back" href="../../../../../color.html#luxpy.color.cct.robertson1968.get_tcs4">[docs]</a>
<span class="k">def</span> <span class="nf">get_tcs4</span><span class="p">(</span><span class="n">tc4</span><span class="p">,</span> <span class="n">cct_min</span> <span class="o">=</span> <span class="n">_CCT_MIN</span><span class="p">,</span> <span class="n">cct_max</span> <span class="o">=</span> <span class="n">_CCT_MAX</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Generate list of Tc of Planckians from (Tmin, Tmax inclusive, Tincrement, unit) </span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :tc4:</span>
<span class="sd">            | 4-element list or tuple</span>
<span class="sd">            | Elements are: [Tmin, Tmax inclusive, Tincrement, unit]</span>
<span class="sd">            |  Unit specifies unit of the Tc interval, i.e. it determines the</span>
<span class="sd">            |       type of scale in which the spacing of the Tc are done.</span>
<span class="sd">            |  Unit options are:</span>
<span class="sd">            |   - &#39;%&#39;: equal relative Tc spacing (in %, cfr. (Ti+1 - Ti-1)/Ti-1).</span>
<span class="sd">            |   - &#39;K&#39; equal absolute Tc spacing (in K, cfr. (Ti+1 - Ti-1).</span>
<span class="sd">            |   - &#39;%-1&#39;: equal relative reciprocal Tc (MK-1 = mired).</span>
<span class="sd">            |   - &#39;K-1&#39;: equal absolute reciprocal Tc (MK-1 = mired).</span>
<span class="sd">            |  If the &#39;increment&#39; element is negative, it actually represents</span>
<span class="sd">            |  the number of intervals between Tmin, Tmax (included).</span>
<span class="sd">        :cct_min:</span>
<span class="sd">            | _CCT_MIN, optional        </span>
<span class="sd">            | Limit Tc&#39;s to a minimum value of cct_min</span>
<span class="sd">        :cct_max:</span>
<span class="sd">            | _CCT_MAX, optional</span>
<span class="sd">            | Limit Tc&#39;s to a maximum value of cct_max</span>

<span class="sd">    Returns:</span>
<span class="sd">        :Tcs:</span>
<span class="sd">            | ndarray [N,1] of ccts. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="p">(</span><span class="n">T0</span><span class="p">,</span><span class="n">Tn</span><span class="p">,</span><span class="n">dT</span><span class="p">),</span><span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">tc4_i</span><span class="p">)</span> <span class="k">for</span> <span class="n">tc4_i</span> <span class="ow">in</span> <span class="n">tc4</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">tc4</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># min, max, interval, unit</span>
    
    <span class="c1"># Get n from third element of input 4-vector:</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">dT</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dT</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;3e element [dT,n] in 4-vector tc4 contains negatives AND positives! Should be only 1 type.&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dT</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">dT</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="k">else</span> <span class="kc">None</span> <span class="c1"># dT contains number of tcs between T0 and Tn, not dT</span>
         
    <span class="c1"># calculate Ts for different unit types:</span>
    <span class="k">if</span> <span class="s1">&#39;K&#39;</span> <span class="ow">in</span> <span class="n">u</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="p">(((</span><span class="n">Tn</span><span class="o">-</span><span class="n">T0</span><span class="p">)</span><span class="o">//</span><span class="n">dT</span><span class="p">)</span> <span class="o">+</span> <span class="p">(((</span><span class="n">Tn</span><span class="o">-</span><span class="n">T0</span><span class="p">)</span><span class="o">%</span><span class="n">dT</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="c1"># get n from dT</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">dT</span> <span class="o">=</span> <span class="p">(</span><span class="n">Tn</span> <span class="o">-</span> <span class="n">T0</span><span class="p">)</span><span class="o">/</span><span class="n">n</span> <span class="c1"># get dT from n</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> 
            
        <span class="n">Ts</span> <span class="o">=</span> <span class="p">(</span><span class="n">T0</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dT</span><span class="p">[:,</span><span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">T</span> <span class="c1"># to include Tn</span>
    
    <span class="k">elif</span> <span class="s1">&#39;%&#39;</span> <span class="ow">in</span> <span class="n">u</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">dT</span><span class="o">/</span><span class="mi">100</span>
            <span class="n">n</span> <span class="o">=</span> <span class="p">(((</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">Tn</span><span class="o">/</span><span class="n">T0</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span><span class="o">.</span><span class="n">max</span><span class="p">())</span> <span class="c1"># get n from dT</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">Tn</span><span class="o">/</span><span class="n">T0</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">n</span><span class="p">)</span> <span class="c1"># get p = (1+dT/100) from n</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">Ts</span> <span class="o">=</span> <span class="n">T0</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="s1">&#39;-1&#39;</span> <span class="ow">in</span> <span class="n">u</span><span class="p">:</span>
        <span class="n">Ts</span><span class="p">[</span><span class="n">Ts</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">_CCT_AVOID_ZERO_DIV</span>
        <span class="n">Ts</span> <span class="o">=</span> <span class="mf">1e6</span><span class="o">/</span><span class="n">Ts</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># scale was in mireds, so flip it</span>
        
    <span class="n">Ts</span><span class="p">[(</span><span class="n">Ts</span><span class="o">&lt;</span><span class="n">cct_min</span><span class="p">)]</span> <span class="o">=</span> <span class="n">cct_min</span>
    <span class="n">Ts</span><span class="p">[(</span><span class="n">Ts</span><span class="o">&gt;</span><span class="n">cct_max</span><span class="p">)]</span> <span class="o">=</span> <span class="n">cct_max</span> <span class="c1"># limit to a maximum cct to avoid overflow/error and/or increase speed.    </span>

    <span class="k">return</span> <span class="n">Ts</span> </div>




<div class="viewcode-block" id="calculate_lut">
<a class="viewcode-back" href="../../../../../color.html#luxpy.color.cct.robertson1968.calculate_lut">[docs]</a>
<span class="k">def</span> <span class="nf">calculate_lut</span><span class="p">(</span><span class="n">ccts</span><span class="p">,</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">lut_vars</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;uv&#39;</span><span class="p">,</span><span class="s1">&#39;uvp&#39;</span><span class="p">,</span><span class="s1">&#39;uvpp&#39;</span><span class="p">,</span><span class="s1">&#39;iso-T-slope&#39;</span><span class="p">],</span>
                  <span class="n">cct_min</span> <span class="o">=</span> <span class="n">_CCT_MIN</span><span class="p">,</span> <span class="n">cct_max</span> <span class="o">=</span> <span class="n">_CCT_MAX</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function that calculates a LUT for the specified calculation method </span>
<span class="sd">    for the input ccts. Calculation is performed for CMF set specified in </span>
<span class="sd">    cieobs and in the chromaticity diagram in cspace. </span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :ccts: </span>
<span class="sd">            | ndarray [Nx1] or str or 4-element tuple</span>
<span class="sd">            | If ndarray: list of ccts for which to (re-)calculate the LUTs.</span>
<span class="sd">            | If str: path to file containing CCTs (no header; sep = &#39;,&#39;)</span>
<span class="sd">            | If 4-element tuple: generate ccts from (Tmin, Tmax, increment, unit) specifier </span>
<span class="sd">        :cieobs: </span>
<span class="sd">            | None or str, optional</span>
<span class="sd">            | str specifying cmf set.</span>
<span class="sd">        :lut_vars:</span>
<span class="sd">            | [&#39;T&#39;,&#39;uv&#39;,&#39;uvp&#39;,&#39;uvpp&#39;,&#39;iso-T-slope&#39;], optional</span>
<span class="sd">            | Data the lut should contain. Must follow this order </span>
<span class="sd">            | and minimum should be [&#39;T&#39;]</span>
<span class="sd">        :cct_min:</span>
<span class="sd">            | _CCT_MIN, optional        </span>
<span class="sd">            | Limit Tc&#39;s to a minimum value of cct_min</span>
<span class="sd">        :cct_max:</span>
<span class="sd">            | _CCT_MAX, optional</span>
<span class="sd">            | Limit Tc&#39;s to a maximum value of cct_max</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            :lut:</span>
<span class="sd">                | ndarray with T, u, v, u&#39;, v&#39;, u&quot;, v&quot;, slope (note &#39;:1st deriv., &quot;:2nd deriv.).</span>
<span class="sd">                                            </span>
<span class="sd">    &quot;&quot;&quot;</span>   
    <span class="c1"># Get ndarray with Planckian temperatures, Ts:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ccts</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="c1">#ccts = pandas.read_csv(ccts, names = None, index_col = None, header = None, sep = &#39;,&#39;).values</span>
        <span class="n">ccts</span> <span class="o">=</span> <span class="n">loadtxt</span><span class="p">(</span><span class="n">ccts</span><span class="p">,</span> <span class="n">header</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">sep</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ccts</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ccts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">ccts</span> <span class="o">=</span> <span class="n">get_tcs4</span><span class="p">(</span><span class="n">ccts</span><span class="p">,</span> <span class="n">cct_min</span> <span class="o">=</span> <span class="n">cct_min</span><span class="p">,</span> <span class="n">cct_max</span> <span class="o">=</span> <span class="n">cct_max</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;uv&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;uvp&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;uvpp&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;iso-T-slope&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">):</span>
        <span class="c1"># no need to calculate anything, only Tcs needed</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">ccts</span><span class="p">)</span>
    
    <span class="c1"># Determine what to calculate:</span>
    <span class="n">outBB</span> <span class="o">=</span> <span class="s1">&#39;BB&#39;</span>
    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;uvp&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="s1">&#39;iso-T-slope&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">):</span> 
        <span class="n">outBB</span> <span class="o">=</span> <span class="n">outBB</span> <span class="o">+</span> <span class="s1">&#39;uvp&#39;</span>
    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;uvpp&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">):</span> <span class="n">outBB</span> <span class="o">=</span> <span class="n">outBB</span> <span class="o">+</span> <span class="s1">&#39;uvpp&#39;</span>
 
    <span class="c1"># get requested cmf set:</span>
    <span class="n">xyzbar</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">_get_xyzbar_wl_dl</span><span class="p">(</span><span class="n">cieobs</span><span class="p">)</span>
        
    <span class="c1"># convert to cspace based cmfs (Eq.6-7):</span>
    <span class="n">uvwbar</span> <span class="o">=</span> <span class="n">_convert_xyzbar_to_uvwbar</span><span class="p">(</span><span class="n">xyzbar</span><span class="p">)</span> 
    
    <span class="c1"># calculate U,V,W (Eq. 6) and U&#39;,V&#39;,W&#39; (Eq.10) [Robertson,1986] and U&quot;,V&quot;,W&quot; [Li,2016; started from XYZ, but this is equivalent]:</span>
    <span class="c1">#Ti, UVW, UVWp, UVWpp = _get_tristim_of_BB_BBp_BBpp(ccts, uvwbar, wl, dl, out = &#39;BB,BBp,BBpp&#39;)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">up</span><span class="p">,</span> <span class="n">vp</span><span class="p">,</span> <span class="n">upp</span><span class="p">,</span> <span class="n">vpp</span><span class="p">,</span> <span class="p">(</span><span class="n">UVW</span><span class="p">,</span> <span class="n">UVWp</span><span class="p">,</span> <span class="n">UVWpp</span><span class="p">)</span> <span class="o">=</span> <span class="n">_get_uv_uvp_uvpp</span><span class="p">(</span><span class="n">ccts</span><span class="p">,</span> <span class="n">uvwbar</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;BB,BBp,BBpp&#39;</span><span class="p">)</span>
    <span class="n">Ti</span> <span class="o">=</span> <span class="n">ccts</span>
    <span class="k">if</span> <span class="s1">&#39;uv&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">:</span> <span class="n">uvi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">))</span>
    <span class="k">if</span> <span class="s1">&#39;uvp&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">:</span> <span class="n">uvpi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">up</span><span class="p">,</span><span class="n">vp</span><span class="p">))</span>
    <span class="k">if</span> <span class="s1">&#39;uvpp&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">:</span> <span class="n">uvppi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">upp</span><span class="p">,</span><span class="n">vpp</span><span class="p">))</span>
    
    
    <span class="c1"># calculate li, mi (= slope of iso-T-lines):</span>
    <span class="k">if</span> <span class="s1">&#39;iso-T-slope&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">:</span>
        
        <span class="n">R</span> <span class="o">=</span> <span class="n">UVW</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="c1"># for Ohno, 2014 &amp; Robertson, 1968 &amp; Li, 2016</span>
        <span class="k">if</span> <span class="n">UVWp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">Rp</span> <span class="o">=</span> <span class="n">UVWp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="c1"># for Robertson, 1968 &amp; Li, 2016</span>
        <span class="c1"># if UVWpp is not None: Rpp = UVWpp.sum(axis=-1, keepdims = True) # for Li, 2016</span>

        <span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="n">UVWp</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">R</span> <span class="o">-</span> <span class="n">UVW</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">Rp</span><span class="p">)</span> 
        <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span><span class="n">UVWp</span><span class="p">[:,:</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">R</span> <span class="o">-</span> <span class="n">UVW</span><span class="p">[:,:</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">Rp</span><span class="p">)</span>
        
        <span class="c1"># avoid div by zero:</span>
        <span class="n">num</span><span class="p">[(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">_CCT_AVOID_ZERO_DIV</span>
        <span class="n">denom</span><span class="p">[(</span><span class="n">denom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">_CCT_AVOID_ZERO_DIV</span>
    
        <span class="n">li</span> <span class="o">=</span> <span class="n">num</span><span class="o">/</span><span class="n">denom</span>  
        <span class="n">li</span> <span class="o">=</span> <span class="n">li</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">li</span><span class="p">)</span><span class="o">*</span><span class="n">_CCT_AVOID_ZERO_DIV</span> <span class="c1"># avoid division by zero</span>
        <span class="n">mi</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="n">li</span> <span class="c1"># slope of isotemperature lines</span>
        
        <span class="n">sq1pmi2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">mi</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
        <span class="n">sign_mimip1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">mi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">mi</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">mi</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:])))</span> <span class="c1"># use same value for last one</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mi</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="c1"># # get u,v &amp; u&#39;,v&#39; and u&quot;,v&quot;:</span>
    <span class="c1"># uvi = UVW[:,:2]/R</span>
    <span class="c1"># if UVWp is not None: uvpi = UVWp[:,:2]/Rp</span>
    <span class="c1"># if UVWpp is not None: uvppi = UVWpp[:,:2]/Rpp</span>
    
    <span class="c1"># construct output (use comple if structure to avoid creating intermediate arrays for optimal speed):</span>
    <span class="k">if</span>  <span class="p">(</span><span class="s1">&#39;uvp&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;uvpp&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;iso-T-slope&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">):</span>
        <span class="k">if</span>  <span class="p">(</span><span class="s1">&#39;sqrt(1+iso-T-slope**2)&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;sign(iso-T-slope_i*i+1)&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">):</span>
            <span class="n">lut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Ti</span><span class="p">,</span><span class="n">uvi</span><span class="p">,</span><span class="n">uvpi</span><span class="p">,</span><span class="n">uvppi</span><span class="p">,</span><span class="n">mi</span><span class="p">,</span><span class="n">sq1pmi2</span><span class="p">,</span><span class="n">sign_mimip1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Ti</span><span class="p">,</span><span class="n">uvi</span><span class="p">,</span><span class="n">uvpi</span><span class="p">,</span><span class="n">uvppi</span><span class="p">,</span><span class="n">mi</span><span class="p">))</span>
        
    <span class="k">elif</span> <span class="p">(</span><span class="s1">&#39;uvp&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;uvpp&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;iso-T-slope&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">):</span>
        <span class="n">lut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Ti</span><span class="p">,</span><span class="n">uvi</span><span class="p">))</span>
        
    <span class="k">elif</span> <span class="p">(</span><span class="s1">&#39;uvp&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;uvpp&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;iso-T-slope&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">):</span>
        <span class="k">if</span>  <span class="p">(</span><span class="s1">&#39;sqrt(1+iso-T-slope**2)&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;sign(iso-T-slope_i*i+1)&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">):</span>
            <span class="n">lut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Ti</span><span class="p">,</span><span class="n">uvi</span><span class="p">,</span> <span class="n">uvpi</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">sq1pmi2</span><span class="p">,</span> <span class="n">sign_mimip1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Ti</span><span class="p">,</span><span class="n">uvi</span><span class="p">,</span> <span class="n">uvpi</span><span class="p">,</span> <span class="n">mi</span><span class="p">))</span>
        
    <span class="k">elif</span> <span class="p">(</span><span class="s1">&#39;uvp&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;uvpp&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;iso-T-slope&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">):</span>
        <span class="n">lut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Ti</span><span class="p">,</span><span class="n">uvi</span><span class="p">,</span> <span class="n">uvpi</span><span class="p">))</span>
    <span class="k">elif</span> <span class="p">(</span><span class="s1">&#39;uvp&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;uvpp&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;iso-T-slope&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">):</span>
        <span class="n">lut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Ti</span><span class="p">,</span><span class="n">uvi</span><span class="p">,</span> <span class="n">uvpi</span><span class="p">,</span> <span class="n">uvppi</span><span class="p">))</span>
        
    <span class="k">elif</span> <span class="p">(</span><span class="s1">&#39;uvp&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;uvpp&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;iso-T-slope&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">):</span>
        <span class="k">if</span>  <span class="p">(</span><span class="s1">&#39;sqrt(1+iso-T-slope**2)&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;sign(iso-T-slope_i*i+1)&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">):</span>
            <span class="n">lut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Ti</span><span class="p">,</span><span class="n">uvi</span><span class="p">,</span> <span class="n">uvppi</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">sq1pmi2</span><span class="p">,</span> <span class="n">sign_mimip1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Ti</span><span class="p">,</span><span class="n">uvi</span><span class="p">,</span> <span class="n">uvppi</span><span class="p">,</span> <span class="n">mi</span><span class="p">))</span>

    <span class="k">elif</span> <span class="p">(</span><span class="s1">&#39;uvp&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;uvpp&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;iso-T-slope&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">):</span>
        <span class="n">lut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Ti</span><span class="p">,</span><span class="n">uvi</span><span class="p">,</span> <span class="n">uvppi</span><span class="p">))</span>
           
    <span class="k">elif</span> <span class="p">(</span><span class="s1">&#39;uvp&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;uvpp&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;iso-T-slope&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">):</span>

        <span class="k">if</span>  <span class="p">(</span><span class="s1">&#39;sqrt(1+iso-T-slope**2)&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;sign(iso-T-slope_i*i+1)&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">):</span>
            <span class="n">lut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Ti</span><span class="p">,</span><span class="n">uvi</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">sq1pmi2</span><span class="p">,</span> <span class="n">sign_mimip1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Ti</span><span class="p">,</span><span class="n">uvi</span><span class="p">,</span> <span class="n">mi</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">lut</span> </div>


<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># Duv calculation</span>
<span class="c1">#------------------------------------------------------------------------------</span>

<span class="k">def</span> <span class="nf">_get_Duv_for_T_from_uvBB</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span> <span class="n">uBB0</span><span class="p">,</span> <span class="n">vBB0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Calculate Duv from (u,v) coordinates of estimated Tc.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get duv: </span>
    <span class="n">du</span><span class="p">,</span> <span class="n">dv</span> <span class="o">=</span> <span class="n">u</span> <span class="o">-</span> <span class="n">uBB0</span><span class="p">,</span> <span class="n">v</span> <span class="o">-</span> <span class="n">vBB0</span>
    <span class="n">Duv</span> <span class="o">=</span> <span class="p">(</span><span class="n">du</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">dv</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> 

    <span class="c1"># find sign of duv:</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">positive_arctan</span><span class="p">(</span><span class="n">du</span><span class="p">,</span><span class="n">dv</span><span class="p">,</span><span class="n">htype</span><span class="o">=</span><span class="s1">&#39;deg&#39;</span><span class="p">)</span>
    <span class="n">theta</span><span class="p">[</span><span class="n">theta</span><span class="o">&gt;</span><span class="mi">180</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="n">theta</span><span class="o">&gt;</span><span class="mi">180</span><span class="p">]</span> <span class="o">-</span> <span class="mi">360</span>
    <span class="n">Duv</span> <span class="o">*=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">Duv</span>

<span class="k">def</span> <span class="nf">_get_Duv_for_T</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">uvwbar</span><span class="p">,</span>  <span class="n">dl</span><span class="p">,</span>
                   <span class="n">uBB</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">vBB</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Calculate Duv from T by generating a planckian and</span>
<span class="sd">    calculating the Euclidean distance to the point (u,v) and</span>
<span class="sd">    determing the sign as the v coordinate difference between </span>
<span class="sd">    the test point and the planckian.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">uBB</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>  <span class="o">&amp;</span> <span class="p">(</span><span class="n">vBB</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">_</span><span class="p">,</span><span class="n">UVWBB</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">_get_tristim_of_BB_BBp_BBpp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">uvwbar</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="s1">&#39;BB&#39;</span><span class="p">)</span>
        <span class="n">uvBB</span> <span class="o">=</span> <span class="n">xyz_to_Yxy</span><span class="p">(</span><span class="n">UVWBB</span><span class="p">)</span><span class="c1">#[...,1:]</span>
        <span class="n">uBB</span><span class="p">,</span> <span class="n">vBB</span> <span class="o">=</span> <span class="n">uvBB</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="kc">None</span><span class="p">],</span> <span class="n">uvBB</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
    
    <span class="c1"># Get duv: </span>
    <span class="k">return</span> <span class="n">_get_Duv_for_T_from_uvBB</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">uBB</span><span class="p">,</span> <span class="n">vBB</span><span class="p">)</span>

<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># Helper functions</span>
<span class="c1">#------------------------------------------------------------------------------</span>
    

<span class="c1">#------------------------------------------------------------------------------</span>
<span class="k">def</span> <span class="nf">_get_pns_from_x</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">m0p</span> <span class="o">=</span> <span class="s1">&#39;m0p&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Get idx-1, idx and idx +1 from array. </span>
<span class="sd">    Returns [Nx1] ndarray with N = len(idx).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s1">&#39;m&#39;</span> <span class="ow">in</span> <span class="n">m0p</span><span class="p">:</span> 
        <span class="n">idx_m1</span> <span class="o">=</span> <span class="n">idx</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">idx_m1</span><span class="p">[</span><span class="n">idx_m1</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># otherwise wraparound error happens</span>
    
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">m0p</span> <span class="o">==</span> <span class="s1">&#39;m0p&#39;</span><span class="p">:</span> 
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">idx_m1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">m0p</span> <span class="o">==</span> <span class="s1">&#39;0p&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">m0p</span> <span class="o">==</span> <span class="s1">&#39;mp&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">idx_m1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">m0p</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">m0p</span> <span class="o">==</span> <span class="s1">&#39;m0&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">idx_m1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;p&#39;</span> <span class="ow">in</span> <span class="n">m0p</span><span class="p">:</span> 
            <span class="n">idx_p1</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">m0p</span> <span class="o">==</span> <span class="s1">&#39;m0p&#39;</span><span class="p">:</span> 
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">idx_m1</span><span class="p">,</span><span class="n">i</span><span class="p">][:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="n">i</span><span class="p">][:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">idx_p1</span><span class="p">,</span><span class="n">i</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">m0p</span> <span class="o">==</span> <span class="s1">&#39;0p&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="n">i</span><span class="p">][:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">idx_p1</span><span class="p">,</span><span class="n">i</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">m0p</span> <span class="o">==</span> <span class="s1">&#39;mp&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">idx_m1</span><span class="p">,</span><span class="n">i</span><span class="p">][:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">idx_p1</span><span class="p">,</span><span class="n">i</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">m0p</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="n">i</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">m0p</span> <span class="o">==</span> <span class="s1">&#39;m0&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">idx_m1</span><span class="p">,</span><span class="n">i</span><span class="p">][:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="n">i</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span>
   
    
<span class="k">def</span> <span class="nf">_deal_with_lut_end_points</span><span class="p">(</span><span class="n">pn</span><span class="p">,</span> <span class="n">TBB</span><span class="p">,</span> <span class="n">out_of_lut</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="n">ce</span> <span class="o">=</span> <span class="n">pn</span> <span class="o">==</span> <span class="p">(</span><span class="n">TBB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># end point</span>
    <span class="n">cb</span> <span class="o">=</span> <span class="n">pn</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="c1"># begin point</span>
    <span class="k">if</span> <span class="n">out_of_lut</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">out_of_lut</span> <span class="o">=</span> <span class="p">(</span><span class="n">cb</span> <span class="o">|</span> <span class="n">ce</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">pn</span><span class="p">[</span><span class="n">cb</span><span class="p">]</span> <span class="o">=</span>  <span class="mi">1</span> <span class="c1"># begin point </span>
    <span class="n">ce</span> <span class="o">=</span> <span class="n">pn</span> <span class="o">==</span> <span class="p">(</span><span class="n">TBB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># end point double-check !!</span>
    <span class="n">pn</span><span class="p">[</span><span class="n">ce</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">TBB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># end of lut (results in TBB_0==TBB_p1 -&gt; (1/TBB_0)-(1/TBB_p1)) == 0 !</span>

    <span class="k">return</span> <span class="n">pn</span><span class="p">,</span> <span class="n">out_of_lut</span>

<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># Newton-Raphson estimator (cfr. Li, 2016):</span>
<span class="c1">#------------------------------------------------------------------------------       </span>
<span class="k">def</span> <span class="nf">_get_newton_raphson_estimated_Tc</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">T0</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">,</span>
                                     <span class="n">cieobs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">xyzbar</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">uvwbar</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                     <span class="n">max_iter</span> <span class="o">=</span> <span class="n">_CCT_MAX_ITER</span><span class="p">,</span> <span class="n">fast_duv</span> <span class="o">=</span> <span class="n">_CCT_FAST_DUV</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get an estimate of the CCT using the Newton-Raphson method (as specified in </span>
<span class="sd">    Li et al., 2016). (u,v) are the test coordinates. T0 is a first estimate of the Tc.</span>
<span class="sd">    atol and rtol are the absolute and relative tolerance values that are aimed at (if</span>
<span class="sd">    possible the error on the estimation should smaller than or close to these values,</span>
<span class="sd">    once one is achieved the algorithm stops). wl contains the wavelengths of the </span>
<span class="sd">    Planckians, cieobs is the CIE cmfs set to be used (or use xyzbar; at least one</span>
<span class="sd">    must be given). uvwbar the already converted cmf set. If this one is not None</span>
<span class="sd">    then any input in cieobs or xyzbar is ignored. Max-iter specifies</span>
<span class="sd">    the maximum number of iterations (avoid potential infinite loops or cut the</span>
<span class="sd">    optimization short). When fast_duv is True (default) a faster method is used, but this</span>
<span class="sd">    only sufficiently accurate when the estimated CCT is 1 K or less than the</span>
<span class="sd">    true value. </span>
<span class="sd">    </span>
<span class="sd">    Reference:</span>
<span class="sd">        1. `Li, C., Cui, G., Melgosa, M., Ruan,X., Zhang, Y., Ma, L., Xiao, K., &amp; Luo, M. R. (2016).</span>
<span class="sd">        Accurate method for computing correlated color temperature. </span>
<span class="sd">        Optics Express, 24(13), 14066â€“14078. </span>
<span class="sd">        &lt;https://doi.org/10.1364/OE.24.014066&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># process NR input:</span>
    <span class="k">if</span> <span class="n">uvwbar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">xyzbar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cieobs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">xyzbar</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">_get_xyzbar_wl_dl</span><span class="p">(</span><span class="n">cieobs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">xyzbar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cieobs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Must supply xyzbar or cieobs or uvwbar !!!&#39;</span><span class="p">)</span>
        <span class="n">uvwbar</span> <span class="o">=</span> <span class="n">_convert_xyzbar_to_uvwbar</span><span class="p">(</span><span class="n">xyzbar</span><span class="p">)</span>
       
    <span class="k">if</span> <span class="n">uvwbar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">wl</span> <span class="o">=</span> <span class="n">uvwbar</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dl</span> <span class="o">=</span> <span class="n">getwld</span><span class="p">(</span><span class="n">wl</span><span class="p">)</span>
        <span class="n">uvwbar</span> <span class="o">=</span> <span class="n">uvwbar</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">wl</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dl</span> <span class="o">=</span> <span class="n">getwld</span><span class="p">(</span><span class="n">wl</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Must supply wl for uvwbar !!!&#39;</span><span class="p">)</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">T0</span>
    <span class="k">while</span> <span class="kc">True</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">max_iter</span><span class="p">):</span>
        
        <span class="n">T</span><span class="p">[</span><span class="n">T</span> <span class="o">&lt;</span> <span class="n">_CCT_MIN</span><span class="p">]</span> <span class="o">=</span> <span class="n">_CCT_MIN</span> <span class="c1"># avoid infinities &amp; convergence problems</span>
        
        <span class="c1"># Get (u,v), (u&#39;,v&#39;), (u&quot;,v&quot;):</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">uBB</span><span class="p">,</span> <span class="n">vBB</span><span class="p">,</span> <span class="n">upBB</span><span class="p">,</span> <span class="n">vpBB</span><span class="p">,</span> <span class="n">uppBB</span><span class="p">,</span> <span class="n">vppBB</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_get_uv_uvp_uvpp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">uvwbar</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;BB,BBp,BBpp&#39;</span><span class="p">)</span>

        <span class="c1"># Calculate DT (ratio of f&#39; and abs(f&quot;):</span>
        <span class="n">du</span><span class="p">,</span> <span class="n">dv</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">uBB</span><span class="p">),</span> <span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">vBB</span><span class="p">)</span> <span class="c1"># pre-calculate for speed</span>
        <span class="n">DT</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">du</span><span class="o">*</span><span class="n">upBB</span> <span class="o">+</span> <span class="n">dv</span><span class="o">*</span><span class="n">vpBB</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">upBB</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="n">du</span><span class="o">*</span><span class="n">uppBB</span> <span class="o">+</span> <span class="p">(</span><span class="n">vpBB</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="n">dv</span><span class="o">*</span><span class="n">vppBB</span><span class="p">)</span>

        <span class="c1"># DT[DT&gt;T] = _CCT_MIN # avoid convergence problems</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">T</span> <span class="o">-</span> <span class="n">DT</span> 

        <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">DT</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">atol</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="o">|</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">DT</span><span class="p">)</span><span class="o">/</span><span class="n">T</span> <span class="o">&lt;</span> <span class="n">rtol</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="k">break</span>
        <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
        
    <span class="c1"># get Duv:</span>
    <span class="k">if</span> <span class="o">~</span><span class="p">(</span><span class="n">fast_duv</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">DT</span><span class="p">)</span><span class="o">&lt;=</span><span class="mf">1.0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()):</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">uBB</span><span class="p">,</span> <span class="n">vBB</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_get_uv_uvp_uvpp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">uvwbar</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;BB&#39;</span><span class="p">)</span> <span class="c1"># update one last time</span>
    
    <span class="n">Duv</span> <span class="o">=</span> <span class="n">_get_Duv_for_T_from_uvBB</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span> <span class="n">uBB</span><span class="p">,</span> <span class="n">vBB</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">T</span><span class="p">,</span> <span class="n">Duv</span>


<span class="c1">#==============================================================================</span>
<span class="c1"># Robertson 1968:</span>
<span class="c1">#==============================================================================</span>

<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># Load or calculate LUTs: </span>
<span class="c1">#------------------------------------------------------------------------------</span>
<span class="n">_CCT_LUT_PATH_FILE</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_CCT_LUT_PATH</span><span class="p">,</span> <span class="s1">&#39;robertson1968.pkl&#39;</span><span class="p">)</span>
<span class="k">if</span> <span class="n">_CCT_LUT_CALC</span><span class="p">:</span>
    <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;lut_type_def&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1000.0</span><span class="p">,</span> <span class="mf">41000.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;%&#39;</span><span class="p">)</span> <span class="c1"># default LUT</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_CCT_USE_EXTENDED_LUT</span><span class="p">:</span> 
        <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;lut_vars&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;uv&#39;</span><span class="p">,</span><span class="s1">&#39;iso-T-slope&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;lut_vars&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;uv&#39;</span><span class="p">,</span><span class="s1">&#39;iso-T-slope&#39;</span><span class="p">,</span><span class="s1">&#39;sqrt(1+iso-T-slope**2)&#39;</span><span class="p">,</span><span class="s1">&#39;sign(iso-T-slope_i*i+1)&#39;</span><span class="p">]</span>

    <span class="c1"># Calculate:</span>
    <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;luts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">cieobs</span> <span class="ow">in</span> <span class="n">_CCT_LIST_OF_CIEOBS_LUTS</span><span class="p">:</span>
        <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;luts&#39;</span><span class="p">][</span><span class="n">cieobs</span><span class="p">]</span> <span class="o">=</span> <span class="n">calculate_lut</span><span class="p">(</span><span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;lut_type_def&#39;</span><span class="p">],</span> 
                                                 <span class="n">cieobs</span><span class="p">,</span> 
                                                 <span class="n">lut_vars</span> <span class="o">=</span> <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;lut_vars&#39;</span><span class="p">],</span>
                                                 <span class="n">cct_min</span> <span class="o">=</span> <span class="n">_CCT_MIN</span><span class="p">,</span> <span class="n">cct_max</span> <span class="o">=</span> <span class="n">_CCT_MAX</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">_CCT_LUT_PATH</span><span class="p">):</span> <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">_CCT_LUT_PATH</span><span class="p">,</span> <span class="n">exist_ok</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">save_pkl</span><span class="p">(</span><span class="n">_CCT_LUT_PATH_FILE</span><span class="p">,</span> <span class="n">_CCT_LUT</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># load:</span>
    <span class="n">_CCT_LUT</span> <span class="o">=</span> <span class="n">load_pkl</span><span class="p">(</span><span class="n">_CCT_LUT_PATH_FILE</span><span class="p">)</span>


<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># Robertson1968 base (core) method</span>
<span class="c1">#------------------------------------------------------------------------------</span>
<span class="k">def</span> <span class="nf">_uv_to_Tx_robertson1968</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">lut</span><span class="p">,</span> <span class="n">lut_n_cols</span><span class="p">,</span> <span class="n">ns</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">out_of_lut</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">fast_duv</span> <span class="o">=</span> <span class="n">_CCT_FAST_DUV</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Calculate Tx from u,v and lut using Robertson 1968.</span>
<span class="sd">    (lut_n_cols specifies the number of columns in the lut for &#39;robertson1968&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Duvx</span> <span class="o">=</span> <span class="kc">None</span> 
    <span class="n">idx_sources</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> <span class="c1"># source/conversion index</span>
    
    <span class="c1"># get uBB, vBB, mBB from lut:</span>
    <span class="n">TBB</span><span class="p">,</span> <span class="n">uBB</span><span class="p">,</span> <span class="n">vBB</span><span class="p">,</span> <span class="n">mBB</span>  <span class="o">=</span> <span class="n">lut</span><span class="p">[:,</span><span class="mi">0</span><span class="p">::</span><span class="n">lut_n_cols</span><span class="p">],</span> <span class="n">lut</span><span class="p">[:,</span><span class="mi">1</span><span class="p">::</span><span class="n">lut_n_cols</span><span class="p">],</span> <span class="n">lut</span><span class="p">[:,</span><span class="mi">2</span><span class="p">::</span><span class="n">lut_n_cols</span><span class="p">],</span> <span class="n">lut</span><span class="p">[:,</span><span class="mi">3</span><span class="p">::</span><span class="n">lut_n_cols</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_CCT_USE_EXTENDED_LUT</span><span class="p">:</span> 
        <span class="c1"># calculate distances to coordinates in lut (Eq. 4 in Robertson, 1968):</span>
        <span class="n">di</span> <span class="o">=</span> <span class="p">((</span><span class="n">v</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">vBB</span><span class="p">)</span> <span class="o">-</span> <span class="n">mBB</span> <span class="o">*</span> <span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">uBB</span><span class="p">))</span> <span class="o">/</span> <span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">mBB</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mf">0.5</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sqrt1pm2</span><span class="p">,</span><span class="n">sign_mimip1</span> <span class="o">=</span> <span class="n">lut</span><span class="p">[:,</span><span class="mi">4</span><span class="p">::</span><span class="n">lut_n_cols</span><span class="p">],</span> <span class="n">lut</span><span class="p">[:,</span><span class="mi">5</span><span class="p">::</span><span class="n">lut_n_cols</span><span class="p">]</span>
        <span class="n">di</span> <span class="o">=</span> <span class="p">((</span><span class="n">v</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">vBB</span><span class="p">)</span> <span class="o">-</span> <span class="n">mBB</span> <span class="o">*</span> <span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">uBB</span><span class="p">))</span> <span class="o">/</span> <span class="n">sqrt1pm2</span>
        
    <span class="n">pn</span> <span class="o">=</span> <span class="p">(((</span><span class="n">v</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">vBB</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">uBB</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
    <span class="c1"># Get di_0, mBB_0 values to check sign of di_0 * mBB_0 -&gt; if positive (right of apex): [j,j+1] -&gt; [j-1,j]</span>
    <span class="n">di_0</span> <span class="o">=</span> <span class="n">_get_pns_from_x</span><span class="p">(</span><span class="n">di</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx_sources</span><span class="p">,</span> <span class="n">m0p</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>
    <span class="n">mBB_0</span> <span class="o">=</span> <span class="n">_get_pns_from_x</span><span class="p">(</span><span class="n">mBB</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx_sources</span><span class="p">,</span> <span class="n">m0p</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>

    <span class="c1"># Deal with positive slopes of iso-T lines</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">di_0</span><span class="o">*</span><span class="n">mBB_0</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">pn</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">pn</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
    
    <span class="c1"># Deal with endpoints of lut + create intermediate variables to save memory:</span>
    <span class="n">pn</span><span class="p">,</span> <span class="n">out_of_lut</span> <span class="o">=</span> <span class="n">_deal_with_lut_end_points</span><span class="p">(</span><span class="n">pn</span><span class="p">,</span> <span class="n">TBB</span><span class="p">,</span> <span class="n">out_of_lut</span><span class="p">)</span>

    <span class="c1"># Get final values required for T calculation:</span>
    <span class="n">mBB_0</span><span class="p">,</span> <span class="n">mBB_p1</span> <span class="o">=</span> <span class="n">_get_pns_from_x</span><span class="p">(</span><span class="n">mBB</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx_sources</span><span class="p">,</span> <span class="n">m0p</span> <span class="o">=</span> <span class="s1">&#39;0p&#39;</span><span class="p">)</span>
    <span class="n">TBB_0</span><span class="p">,</span> <span class="n">TBB_p1</span> <span class="o">=</span> <span class="n">_get_pns_from_x</span><span class="p">(</span><span class="n">TBB</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx_sources</span><span class="p">,</span> <span class="n">m0p</span> <span class="o">=</span> <span class="s1">&#39;0p&#39;</span><span class="p">)</span>
    <span class="n">di_0</span><span class="p">,</span> <span class="n">di_p1</span> <span class="o">=</span> <span class="n">_get_pns_from_x</span><span class="p">(</span><span class="n">di</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx_sources</span><span class="p">,</span> <span class="n">m0p</span> <span class="o">=</span> <span class="s1">&#39;0p&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_CCT_USE_EXTENDED_LUT</span><span class="p">:</span> <span class="n">sign_mimip1_0</span> <span class="o">=</span> <span class="n">_get_pns_from_x</span><span class="p">(</span><span class="n">sign_mimip1</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx_sources</span><span class="p">,</span> <span class="n">m0p</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>

    
    <span class="c1"># Estimate Tc (Robertson, 1968): </span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_CCT_USE_EXTENDED_LUT</span><span class="p">:</span> 
        <span class="n">sign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">mBB_0</span><span class="o">*</span><span class="n">mBB_p1</span><span class="p">)</span> <span class="c1"># Solve issue of zero-crossing of slope of planckian locus:</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="n">sign</span> <span class="o">=</span> <span class="n">sign_mimip1_0</span>
    <span class="n">slope</span> <span class="o">=</span> <span class="p">(</span><span class="n">di_0</span><span class="o">/</span><span class="p">((</span><span class="n">di_0</span> <span class="o">-</span> <span class="n">sign</span><span class="o">*</span><span class="n">di_p1</span><span class="p">)</span> <span class="o">+</span> <span class="n">_CCT_AVOID_ZERO_DIV</span><span class="p">))</span>
    <span class="n">Tx</span> <span class="o">=</span> <span class="p">(((</span><span class="mi">1</span><span class="o">/</span><span class="n">TBB_0</span><span class="p">)</span> <span class="o">+</span> <span class="n">slope</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span><span class="o">/</span><span class="n">TBB_p1</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">TBB_0</span><span class="p">)))</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="c1">#&quot;.copy()</span>

    <span class="c1"># Estimate Duv from approximation of u,v coordinates of Tx:</span>
    <span class="k">if</span> <span class="n">fast_duv</span><span class="p">:</span>
        <span class="n">uBB_0</span><span class="p">,</span> <span class="n">uBB_p1</span> <span class="o">=</span> <span class="n">_get_pns_from_x</span><span class="p">(</span><span class="n">uBB</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx_sources</span><span class="p">,</span> <span class="n">m0p</span> <span class="o">=</span> <span class="s1">&#39;0p&#39;</span><span class="p">)</span>
        <span class="n">vBB_0</span><span class="p">,</span> <span class="n">vBB_p1</span> <span class="o">=</span> <span class="n">_get_pns_from_x</span><span class="p">(</span><span class="n">vBB</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx_sources</span><span class="p">,</span> <span class="n">m0p</span> <span class="o">=</span> <span class="s1">&#39;0p&#39;</span><span class="p">)</span>
        <span class="n">ux</span><span class="p">,</span> <span class="n">vx</span> <span class="o">=</span> <span class="p">(</span><span class="n">uBB_0</span> <span class="o">+</span> <span class="n">slope</span> <span class="o">*</span> <span class="p">(</span><span class="n">uBB_p1</span> <span class="o">-</span> <span class="n">uBB_0</span><span class="p">)),</span> <span class="p">(</span><span class="n">vBB_0</span> <span class="o">+</span> <span class="n">slope</span> <span class="o">*</span> <span class="p">(</span><span class="n">vBB_p1</span> <span class="o">-</span> <span class="n">vBB_0</span><span class="p">))</span>
        <span class="n">Duvx</span> <span class="o">=</span> <span class="n">_get_Duv_for_T_from_uvBB</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">ux</span><span class="p">,</span> <span class="n">vx</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">Tx</span><span class="p">,</span> <span class="n">Duvx</span><span class="p">,</span> <span class="n">out_of_lut</span>


<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># xyz_to_cct wrapper function:</span>
<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="xyz_to_cct">
<a class="viewcode-back" href="../../../../../color.html#luxpy.color.cct.robertson1968.xyz_to_cct">[docs]</a>
<span class="k">def</span> <span class="nf">xyz_to_cct</span><span class="p">(</span><span class="n">xyzw</span><span class="p">,</span> <span class="n">is_uv_input</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">_CCT_CIEOBS</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;cct&#39;</span><span class="p">,</span>
               <span class="n">lut</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">apply_newton_raphson</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
               <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>  <span class="n">max_iter</span> <span class="o">=</span> <span class="n">_CCT_MAX_ITER</span><span class="p">,</span> 
               <span class="n">split_calculation_at_N</span> <span class="o">=</span> <span class="n">_CCT_SPLIT_CALC_AT_N</span><span class="p">,</span> <span class="n">use_fast_duv</span> <span class="o">=</span> <span class="n">_CCT_FAST_DUV</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert XYZ tristimulus values to correlated color temperature (CCT) and </span>
<span class="sd">    Duv(distance above (&gt; 0) or below ( &lt; 0) the Planckian locus) using  </span>
<span class="sd">    Robertson&#39;s 1968 search method.</span>
<span class="sd">        </span>
<span class="sd">    Args:</span>
<span class="sd">        :xyzw: </span>
<span class="sd">            | ndarray of tristimulus values</span>
<span class="sd">        :is_uv_input:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | If True: xyzw contain uv input data, not xyz data!</span>
<span class="sd">        :cieobs: </span>
<span class="sd">            | _CCT_CIEOBS, optional</span>
<span class="sd">            | CMF set used to calculated xyzw.</span>
<span class="sd">        :out: </span>
<span class="sd">            | &#39;cct&#39; (or 1), optional</span>
<span class="sd">            | Determines what to return.</span>
<span class="sd">            | Other options: &#39;duv&#39; (or -1), &#39;cct,duv&#39;(or 2), &quot;[cct,duv]&quot; (or -2)</span>
<span class="sd">        :rtol: </span>
<span class="sd">            | 1e-10, float, optional</span>
<span class="sd">            | Stop search when cct a relative tolerance is reached.</span>
<span class="sd">            | The relative tolerance is calculated as dCCT/CCT_est, </span>
<span class="sd">            | with CCT_est the current intermediate estimate in the </span>
<span class="sd">            | search and with dCCT the difference between</span>
<span class="sd">            | the present and former estimates.</span>
<span class="sd">        :atol: </span>
<span class="sd">            | 0.1, optional</span>
<span class="sd">            | Stop search when cct a absolute tolerance (K) is reached.</span>
<span class="sd">        :lut:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Look-Up-Table with Ti, u,v,u&#39;,v&#39;,u&quot;,v&quot;,slope values of Planckians. </span>
<span class="sd">            | Options:</span>
<span class="sd">            |  - None: defaults to the lut specified in _CCT_LUT[&#39;lut_type_def&#39;].</span>
<span class="sd">            |  - tuple: new lut will be generated from scratch using the info in the tuple.</span>
<span class="sd">            |  - ndarray [Nx1]: list of luts for which to generate a lut</span>
<span class="sd">            |  - ndarray [Nxn] with n&gt;3: pre-calculated lut (last col must contain slope of the isotemperature lines).</span>
<span class="sd">        :apply_newton_raphson:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | If False: use only the Robertson1968 base method. </span>
<span class="sd">            |           Accuracy depends on CCT of test source and the location</span>
<span class="sd">            |           and spacing of the CCTs in the list.</span>
<span class="sd">            | If True:  improve estimate of base method using a follow-up </span>
<span class="sd">            |           newton-raphson method.</span>
<span class="sd">            |           When the CCT for multiple source is calculated in one go,</span>
<span class="sd">            |           then the atol and rtol values have to be met for all! </span>
<span class="sd">        :max_iter:</span>
<span class="sd">            | _CCT_MAX_ITER, optional</span>
<span class="sd">            | Maximum number of iterations used by the cascading-lut or newton-raphson methods.</span>
<span class="sd">        :split_calculation_at_N:</span>
<span class="sd">            | _CCT_SPLIT_CALC_AT_N, optional</span>
<span class="sd">            | Split calculation when xyzw.shape[0] &gt; split_calculation_at_N. </span>
<span class="sd">            | Splitting speeds up the calculation. If None: no splitting is done.</span>
<span class="sd">        :use_fast_duv:</span>
<span class="sd">            | _CCT_FAST_DUV, optional</span>
<span class="sd">            | If True: use a fast estimator of the Duv </span>
<span class="sd">            |   (one that avoids calculation of Planckians and uses the former</span>
<span class="sd">            |    best estimate&#39;s u,v coordinates. This method is accurate enough</span>
<span class="sd">            |    when the atol is small enough -&gt; as long as abs(T-T_former)&lt;=1K</span>
<span class="sd">            |    the Duv estimate should be ok.)</span>

<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | ndarray with:</span>
<span class="sd">            |    cct: out == &#39;cct&#39; (or 1)</span>
<span class="sd">            |    duv: out == &#39;duv&#39; (or -1)</span>
<span class="sd">            |    cct, duv: out == &#39;cct,duv&#39; (or 2)</span>
<span class="sd">            |    [cct,duv]: out == &quot;[cct,duv]&quot; (or -2) </span>
<span class="sd">            </span>
<span class="sd">    Note: </span>
<span class="sd">        1. Out-of-lut CCTs are encoded as negative CCTs (with as absolute value</span>
<span class="sd">        the value of the closest CCT from the lut.)</span>
<span class="sd">    </span>
<span class="sd">    References:</span>
<span class="sd">        1.  `Robertson, A. R. (1968). </span>
<span class="sd">        Computation of Correlated Color Temperature and Distribution Temperature. </span>
<span class="sd">        Journal of the Optical Society of America,  58(11), 1528â€“1535. </span>
<span class="sd">        &lt;https://doi.org/10.1364/JOSA.58.001528&gt;`_</span>
<span class="sd">        </span>
<span class="sd">        2. Baxter D., Royer M., Smet K.A.G. (2022)</span>
<span class="sd">        Modifications of the Robertson Method for Calculating Correlated Color Temperature to Improve Accuracy and Speed</span>
<span class="sd">        (in preparation, LEUKOS?)</span>
<span class="sd">         </span>
<span class="sd">        3. `Li, C., Cui, G., Melgosa, M., Ruan, X., Zhang, Y., Ma, L., Xiao, K., &amp; Luo, M. R. (2016).</span>
<span class="sd">        Accurate method for computing correlated color temperature. </span>
<span class="sd">        Optics Express, 24(13), 14066â€“14078. </span>
<span class="sd">        &lt;https://doi.org/10.1364/OE.24.014066&gt;`_</span>

<span class="sd">    &quot;&quot;&quot;</span>      
    <span class="c1"># Get chromaticity coordinates u,v from xyzw:</span>
    <span class="n">uvw</span> <span class="o">=</span> <span class="n">xyz_to_Yuv60</span><span class="p">(</span><span class="n">xyzw</span><span class="p">)[:,</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>  <span class="k">if</span> <span class="n">is_uv_input</span> <span class="o">==</span> <span class="kc">False</span> <span class="k">else</span> <span class="n">xyzw</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># xyz contained uv !!! (needed to efficiently determine f_corr)</span>
    
    <span class="c1"># pre-calculate wl, dl, uvwbar for later use (will also determine wl if None !):</span>
    <span class="n">xyzbar</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">_get_xyzbar_wl_dl</span><span class="p">(</span><span class="n">cieobs</span><span class="p">)</span>
    <span class="n">uvwbar</span> <span class="o">=</span> <span class="n">_convert_xyzbar_to_uvwbar</span><span class="p">(</span><span class="n">xyzbar</span><span class="p">)</span> <span class="k">if</span> <span class="n">apply_newton_raphson</span> <span class="k">else</span> <span class="kc">None</span> <span class="c1"># might not be needed (only required in Duv calculation)</span>
    
    <span class="c1"># Get or generate requested lut:</span>
    <span class="k">if</span> <span class="n">lut</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lut</span> <span class="o">=</span> <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;luts&#39;</span><span class="p">][</span><span class="n">cieobs</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lut</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lut</span><span class="p">,</span><span class="nb">tuple</span><span class="p">):</span> <span class="c1"># only list of ccts! or tuple -&gt; generate new lut!</span>
            <span class="n">new_lut</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">lut</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">new_lut</span> <span class="o">=</span> <span class="kc">True</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_lut</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">new_lut</span><span class="p">:</span>
            <span class="n">lut</span> <span class="o">=</span> <span class="n">calculate_lut</span><span class="p">(</span><span class="n">lut</span><span class="p">,</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">lut_vars</span> <span class="o">=</span> <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;lut_vars&#39;</span><span class="p">],</span>
                                <span class="n">cct_min</span> <span class="o">=</span> <span class="n">_CCT_MIN</span><span class="p">,</span> <span class="n">cct_max</span> <span class="o">=</span> <span class="n">_CCT_MAX</span><span class="p">)</span>
            
    <span class="n">lut_n_cols</span> <span class="o">=</span> <span class="n">lut</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># store now, as this will change later</span>
    
    <span class="c1"># prepare split of input data to speed up calculation:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">xyzw</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># number of conversions</span>
    <span class="n">ccts</span><span class="p">,</span> <span class="n">duvs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">n_ii</span> <span class="o">=</span> <span class="n">split_calculation_at_N</span> <span class="k">if</span> <span class="n">split_calculation_at_N</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">n</span>
    <span class="n">N_ii</span> <span class="o">=</span> <span class="n">n</span><span class="o">//</span><span class="n">n_ii</span> <span class="o">+</span> <span class="mi">1</span><span class="o">*</span><span class="p">((</span><span class="n">n</span><span class="o">%</span><span class="n">n_ii</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="c1"># loop of splitted data:</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_ii</span><span class="p">):</span>
        <span class="n">out_of_lut</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># get data for split ii:</span>
        <span class="n">uv</span> <span class="o">=</span> <span class="n">uvw</span><span class="p">[</span><span class="n">n_ii</span><span class="o">*</span><span class="n">ii</span><span class="p">:</span><span class="n">n_ii</span><span class="o">*</span><span class="n">ii</span><span class="o">+</span><span class="n">n_ii</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">ii</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">N_ii</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="k">else</span> <span class="n">uvw</span><span class="p">[</span><span class="n">n_ii</span><span class="o">*</span><span class="n">ii</span><span class="p">:]</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">uv</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="kc">None</span><span class="p">],</span> <span class="n">uv</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
        
    
        <span class="c1"># get Tx estimate, out_of_lut boolean array using Robertson1968:</span>
        <span class="n">Tx</span><span class="p">,</span> <span class="n">Duvx</span><span class="p">,</span> <span class="n">out_of_lut</span> <span class="o">=</span> <span class="n">_uv_to_Tx_robertson1968</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">lut</span><span class="p">,</span> <span class="n">lut_n_cols</span><span class="p">,</span> 
                                                       <span class="n">ns</span> <span class="o">=</span> <span class="n">lut_n_cols</span><span class="p">,</span> 
                                                       <span class="n">out_of_lut</span> <span class="o">=</span> <span class="n">out_of_lut</span><span class="p">)</span>  

        
        <span class="k">if</span> <span class="n">apply_newton_raphson</span><span class="p">:</span>
            <span class="n">Tx</span><span class="p">,</span> <span class="n">Duvx</span> <span class="o">=</span> <span class="n">_get_newton_raphson_estimated_Tc</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">Tx</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> <span class="n">uvwbar</span> <span class="o">=</span> <span class="n">uvwbar</span><span class="p">,</span>
                                                        <span class="n">atol</span> <span class="o">=</span> <span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="n">rtol</span><span class="p">,</span> 
                                                        <span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span><span class="p">,</span>
                                                        <span class="n">fast_duv</span> <span class="o">=</span> <span class="n">use_fast_duv</span><span class="p">)</span>           

        <span class="c1"># Calculate Duvx if not already done:</span>
        <span class="k">if</span> <span class="n">Duvx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">uvwbar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">uvwbar</span> <span class="o">=</span> <span class="n">_convert_xyzbar_to_uvwbar</span><span class="p">(</span><span class="n">xyzbar</span><span class="p">)</span> <span class="c1"># only done once!</span>
            <span class="n">Duvx</span> <span class="o">=</span> <span class="n">_get_Duv_for_T</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span> <span class="n">Tx</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">uvwbar</span><span class="p">,</span> <span class="n">dl</span><span class="p">)</span>

        <span class="c1"># signal out-of-lut CCTs with a negative sign:</span>
        <span class="k">if</span> <span class="n">out_of_lut</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">Tx</span> <span class="o">=</span> <span class="n">Tx</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">out_of_lut</span>

        <span class="c1"># Add freshly calculated Tx, Duvx to storage array:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ii</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">N_ii</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span> 
            <span class="n">ccts</span><span class="p">[</span><span class="n">n_ii</span><span class="o">*</span><span class="n">ii</span><span class="p">:</span><span class="n">n_ii</span><span class="o">*</span><span class="n">ii</span><span class="o">+</span><span class="n">n_ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">Tx</span>
            <span class="n">duvs</span><span class="p">[</span><span class="n">n_ii</span><span class="o">*</span><span class="n">ii</span><span class="p">:</span><span class="n">n_ii</span><span class="o">*</span><span class="n">ii</span><span class="o">+</span><span class="n">n_ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">Duvx</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">ccts</span><span class="p">[</span><span class="n">n_ii</span><span class="o">*</span><span class="n">ii</span><span class="p">:]</span> <span class="o">=</span> <span class="n">Tx</span>
            <span class="n">duvs</span><span class="p">[</span><span class="n">n_ii</span><span class="o">*</span><span class="n">ii</span><span class="p">:]</span> <span class="o">=</span> <span class="n">Duvx</span>

    <span class="c1"># Regulate output:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;cct&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ccts</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;duv&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">duvs</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;cct,duv&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ccts</span><span class="p">,</span> <span class="n">duvs</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s2">&quot;[cct,duv]&quot;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">ccts</span><span class="p">,</span><span class="n">duvs</span><span class="p">))</span>   
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Unknown output requested&#39;</span><span class="p">)</span></div>


<span class="c1">#---------------------------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="xyz_to_duv">
<a class="viewcode-back" href="../../../../../color.html#luxpy.color.cct.robertson1968.xyz_to_duv">[docs]</a>
<span class="k">def</span> <span class="nf">xyz_to_duv</span><span class="p">(</span><span class="n">xyzw</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;duv&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wraps xyz_to_cct, but with duv output. For kwargs info, see xyz_to_cct.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">xyz_to_cct</span><span class="p">(</span><span class="n">xyzw</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

        
<span class="c1">#---------------------------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="cct_to_xyz">
<a class="viewcode-back" href="../../../../../color.html#luxpy.color.cct.robertson1968.cct_to_xyz">[docs]</a>
<span class="k">def</span> <span class="nf">cct_to_xyz</span><span class="p">(</span><span class="n">ccts</span><span class="p">,</span> <span class="n">duv</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">cct_offset</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">_CCT_CIEOBS</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert correlated color temperature (550 K &lt;= CCT &lt;= 1e11 K) and </span>
<span class="sd">    Duv (distance above (&gt;0) or below (&lt;0) the Planckian locus) to </span>
<span class="sd">    XYZ tristimulus values.</span>
<span class="sd">    </span>
<span class="sd">    | Finds xyzw_estimated by determining the iso-temperature line </span>
<span class="sd">    |   (= line perpendicular to the Planckian locus): </span>
<span class="sd">    |   Option 1 (fastest):</span>
<span class="sd">    |       First, the angle between the coordinates corresponding to ccts </span>
<span class="sd">    |       and ccts-cct_offset are calculated, then 90Â° is added, and finally</span>
<span class="sd">    |       the new coordinates are determined, while taking sign of duv into account.</span>
<span class="sd">    |   Option 2 (slowest, about 55% slower):</span>
<span class="sd">    |       Calculate the slope of the iso-T-line directly using the Planckian</span>
<span class="sd">    |       spectrum and its derivative.</span>
<span class="sd">     </span>
<span class="sd">    Args:</span>
<span class="sd">        :ccts: </span>
<span class="sd">            | ndarray [N,1] of cct values</span>
<span class="sd">        :duv: </span>
<span class="sd">            | None or ndarray [N,1] of duv values, optional</span>
<span class="sd">            | Note that duv can be supplied together with cct values in :ccts: </span>
<span class="sd">            | as ndarray with shape [N,2].</span>
<span class="sd">        :cct_offset:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | If None: use option 2 (direct iso-T slope calculation, more accurate,</span>
<span class="sd">            |                        but slower: about 1.55 slower)</span>
<span class="sd">            | else: use option 1 (estimate slope from 90Â° + angle of small cct_offset)</span>
<span class="sd">        :cieobs: </span>
<span class="sd">            | _CCT_CIEOBS, optional</span>
<span class="sd">            | CMF set used to calculated xyzw.</span>
<span class="sd">        :wl: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Wavelengths used when calculating Planckian radiators.</span>
<span class="sd">            | If None: use same wavelengths as CMFs in :cieobs:.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | ndarray with estimated XYZ tristimulus values</span>
<span class="sd">    </span>
<span class="sd">    Note:</span>
<span class="sd">        1. If duv is not supplied (:ccts:.shape is (N,1) and :duv: is None), </span>
<span class="sd">        source is assumed to be on the Planckian locus.</span>
<span class="sd">        2. Minimum CCT is 550 K (lower than 550 K, some negative Duv values</span>
<span class="sd">        will result in coordinates outside of the Spectrum Locus !!!)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># make ccts a min. 2d np.array:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ccts</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
        <span class="n">ccts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ccts</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ccts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">ccts</span><span class="p">)</span> 
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ccts</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;cct_to_xyz(): Input ccts.shape must be &lt;= 2 !&#39;</span><span class="p">)</span>
    
    <span class="c1"># get cct and duv arrays from :ccts:</span>
    <span class="n">cct</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">ccts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="kc">None</span><span class="p">])</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">duv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ccts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">duv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">ccts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="kc">None</span><span class="p">])</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">duv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ccts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">duv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">ccts</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">duv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">duv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">duv</span><span class="p">)</span>

    <span class="n">xyzbar</span><span class="p">,</span><span class="n">wl</span><span class="p">,</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">_get_xyzbar_wl_dl</span><span class="p">(</span><span class="n">cieobs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cct_offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># estimate iso-T-line from estimated slope using small cct offset:</span>
        <span class="c1">#-----------------------------------------------------------------</span>
        <span class="n">_</span><span class="p">,</span><span class="n">xyzBB</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">_get_tristim_of_BB_BBp_BBpp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">cct</span><span class="p">,</span> <span class="n">cct</span><span class="o">-</span><span class="n">cct_offset</span><span class="p">,</span><span class="n">cct</span><span class="o">+</span><span class="n">cct_offset</span><span class="p">)),</span><span class="n">xyzbar</span><span class="p">,</span><span class="n">wl</span><span class="p">,</span><span class="n">dl</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="s1">&#39;BB&#39;</span><span class="p">)</span> 
        <span class="n">YuvBB</span> <span class="o">=</span> <span class="n">xyz_to_Yuv60</span><span class="p">(</span><span class="n">xyzBB</span><span class="p">)</span>

        <span class="n">N</span> <span class="o">=</span> <span class="p">(</span><span class="n">xyzBB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">//</span><span class="mi">3</span>
        <span class="n">YuvBB_centered</span> <span class="o">=</span> <span class="p">(</span><span class="n">YuvBB</span><span class="p">[</span><span class="n">N</span><span class="p">:]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">YuvBB</span><span class="p">[:</span><span class="n">N</span><span class="p">],</span><span class="n">YuvBB</span><span class="p">[:</span><span class="n">N</span><span class="p">])))</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">YuvBB_centered</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span><span class="n">YuvBB_centered</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="p">(</span><span class="n">theta</span><span class="p">[:</span><span class="n">N</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="n">N</span><span class="p">:]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="n">N</span><span class="p">:])))</span><span class="o">/</span><span class="mi">2</span> <span class="c1"># take average for increased accuracy</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">duv</span><span class="p">)</span> <span class="c1"># add 90Â° to obtain the direction perpendicular to the blackbody locus</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">YuvBB</span><span class="p">[:</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">duv</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">YuvBB</span><span class="p">[:</span><span class="n">N</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">duv</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># estimate iso-T-line from calculated slope:</span>
        <span class="c1">#-------------------------------------------</span>
        <span class="n">uvwbar</span> <span class="o">=</span> <span class="n">_convert_xyzbar_to_uvwbar</span><span class="p">(</span><span class="n">xyzbar</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span><span class="n">UVW</span><span class="p">,</span><span class="n">UVWp</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">_get_tristim_of_BB_BBp_BBpp</span><span class="p">(</span><span class="n">cct</span><span class="p">,</span><span class="n">uvwbar</span><span class="p">,</span><span class="n">wl</span><span class="p">,</span><span class="n">dl</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="s1">&#39;BB,BBp&#39;</span><span class="p">)</span> 
        
        <span class="n">R</span> <span class="o">=</span> <span class="n">UVW</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> 
        <span class="n">Rp</span> <span class="o">=</span> <span class="n">UVWp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> 
        <span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="n">UVWp</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">R</span> <span class="o">-</span> <span class="n">UVW</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">Rp</span><span class="p">)</span> 
        <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span><span class="n">UVWp</span><span class="p">[:,:</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">R</span> <span class="o">-</span> <span class="n">UVW</span><span class="p">[:,:</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">Rp</span><span class="p">)</span>
        <span class="n">num</span><span class="p">[(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">_CCT_AVOID_ZERO_DIV</span>
        <span class="n">denom</span><span class="p">[(</span><span class="n">denom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">_CCT_AVOID_ZERO_DIV</span>
        <span class="n">li</span> <span class="o">=</span> <span class="n">num</span><span class="o">/</span><span class="n">denom</span>  
        <span class="n">li</span> <span class="o">=</span> <span class="n">li</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">li</span><span class="p">)</span><span class="o">*</span><span class="n">_CCT_AVOID_ZERO_DIV</span> <span class="c1"># avoid division by zero</span>
        <span class="n">mi</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="n">li</span> <span class="c1"># slope of isotemperature lines</span>

        <span class="n">YuvBB</span> <span class="o">=</span> <span class="n">xyz_to_Yxy</span><span class="p">(</span><span class="n">UVW</span><span class="p">)</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">YuvBB</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">mi</span><span class="p">)</span> <span class="o">*</span> <span class="n">duv</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">((</span><span class="mi">1</span><span class="o">+</span><span class="n">mi</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)),</span> <span class="n">YuvBB</span><span class="p">[:,</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">mi</span><span class="p">)</span><span class="o">*</span> <span class="n">duv</span><span class="o">*</span><span class="p">((</span><span class="n">mi</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">mi</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>    
        
    <span class="n">Yuv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="mi">100</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">u</span><span class="p">),</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">Yuv60_to_xyz</span><span class="p">(</span><span class="n">Yuv</span><span class="p">)</span></div>


<span class="c1">#==============================================================================</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">luxpy</span> <span class="k">as</span> <span class="nn">lx</span> 
    
    <span class="n">cieobs</span> <span class="o">=</span> <span class="s1">&#39;1931_2&#39;</span>
    
    <span class="c1"># cieobs = &#39;2015_10&#39;</span>

    <span class="c1"># ------------------------------</span>
    <span class="c1"># Setup some tests:</span>
    
    <span class="c1"># test 1:</span>
    <span class="n">cct</span> <span class="o">=</span> <span class="mi">5000</span>   
    <span class="n">duvs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.05</span><span class="p">,</span><span class="o">-</span><span class="mf">0.025</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.025</span><span class="p">,</span><span class="mf">0.05</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
    <span class="c1"># duvs = np.array([[-0.03]]).T</span>
    <span class="n">ccts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">cct</span><span class="p">]</span><span class="o">*</span><span class="n">duvs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
    
    <span class="c1"># test 2:</span>
    <span class="c1"># duv = -0.04</span>
    <span class="c1"># duvs = np.array([[0,*[duv]*(ccts.shape[0]-1)]]).T</span>
    <span class="c1"># ccts = np.array([[1000,1050,1100,1150,1200,1250,1300,1350,1400,1450,1500,1550,1600,1650,1700,1750,1800,1850,1900,1950,2000, 3500, 4500.0, 5500, 6500, 15500,25500,35500,45500,50500]]).T</span>

    <span class="c1"># test 3:</span>
    <span class="c1"># ccts = np.array([[1625.92608972303,1626.26, 3500, 4500.0, 5500, 6500, 15500,25500,35500,45500,50500]]).T</span>
    <span class="c1"># duvs = np.array([[duv]*ccts.shape[0]]).T</span>
    <span class="c1"># duvs[0] = 0.0037117089512229</span>
    
    <span class="n">cctsduvs_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">ccts</span><span class="p">,</span><span class="n">duvs</span><span class="p">))</span>

    <span class="c1"># # # Test 4 (from disk):</span>
    <span class="c1"># # Test 4 (from disk): &#39;ref_cct_duv_1500-40000K.csv&#39; or &#39;test_rob_error.csv&#39;</span>
    <span class="c1"># cctsduvs_t = pandas.read_csv(&#39;../ref_cct_duv_1500-40000K.csv&#39;,header=&#39;infer&#39;,index_col=None).values</span>
    <span class="c1"># cctsduvs_t = cctsduvs_t[cctsduvs_t[:,0] &lt;= 40000,:2]</span>
    <span class="c1"># # cctsduvs_t = cctsduvs_t[(cctsduvs_t[:,0] &gt;= 2000) &amp; (cctsduvs_t[:,0] &lt;= 20000),:2]</span>
    <span class="c1"># # cctsduvs_t = cctsduvs_t[(cctsduvs_t[:,1] &gt;= -0.03) &amp; (cctsduvs_t[:,1] &lt;= 0.03),:2]</span>
    <span class="c1"># ccts, duvs = cctsduvs_t[:,:1], cctsduvs_t[:,1:]</span>
    
    
    <span class="c1">#--------------------------------</span>
    <span class="c1"># Backward transform from CCT,Duv to xyz to generate test xyz for forward tf:</span>
    <span class="n">cct_offset</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cct_to_xyz:&#39;</span><span class="p">)</span>
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">cct_to_xyz</span><span class="p">(</span><span class="n">ccts</span> <span class="o">=</span> <span class="n">ccts</span><span class="p">,</span> <span class="n">duv</span> <span class="o">=</span> <span class="n">duvs</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">cct_offset</span> <span class="o">=</span> <span class="n">cct_offset</span><span class="p">)</span>
    
    
    <span class="c1">#--------------------------------</span>
    <span class="c1"># Forward transform from xyz to CCT,Duv using Robertson 1968:</span>
    <span class="n">modes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;robertson1968&#39;</span><span class="p">]</span>
    <span class="n">lut</span> <span class="o">=</span> <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;luts&#39;</span><span class="p">][</span><span class="s1">&#39;1931_2&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1">#lut_ = lx._CCT_LUT[&#39;robertson1968&#39;][&#39;luts&#39;][&#39;Yuv60&#39;][&#39;1931_2&#39;][((1000.0,51000.0,0.5,&#39;%&#39;),)][0]</span>
    <span class="n">lut</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1000.0</span><span class="p">,</span><span class="mf">40000.0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;%&#39;</span><span class="p">)</span>
    <span class="c1"># lut = None</span>
    <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">modes</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;mode:&#39;</span><span class="p">,</span><span class="n">mode</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;xyz_to_cct&#39;</span><span class="p">)</span>
        <span class="n">cctsduvs</span> <span class="o">=</span> <span class="n">xyz_to_cct</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">,</span><span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;[cct,duv]&#39;</span><span class="p">,</span> 
                              <span class="n">apply_newton_raphson</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">lut</span> <span class="o">=</span> <span class="n">lut</span><span class="p">,</span><span class="n">split_calculation_at_N</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    
    <span class="c1"># Out of LUT conversions are coded with a negative CCT, so make positive again before calculating error:</span>
    <span class="n">cctsduvs_</span> <span class="o">=</span> <span class="n">cctsduvs</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span><span class="n">cctsduvs_</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cctsduvs_</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># outof gamut ccts are encoded as negative!!</span>
    
    <span class="c1">#--------------------------------</span>
    <span class="c1"># Close loop: Backward transform from CCT,Duv (obtained from forward tf) to xyz</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cct_to_xyz2&#39;</span><span class="p">)</span>
    <span class="n">xyz_</span> <span class="o">=</span> <span class="n">cct_to_xyz</span><span class="p">(</span><span class="n">cctsduvs_</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">cct_offset</span> <span class="o">=</span> <span class="n">cct_offset</span><span class="p">)</span>
    
    <span class="c1">#--------------------------------</span>
    <span class="c1"># Calculate CCT,Duv and XYZ errors:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cctsduvs_t:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">cctsduvs_t</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cctsduvs:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">cctsduvs</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Dcctsduvs:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">cctsduvs_</span> <span class="o">-</span> <span class="n">cctsduvs_t</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Dxyz:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">xyz</span> <span class="o">-</span> <span class="n">xyz_</span><span class="p">)</span>
    
    <span class="c1">#---------------------------------</span>
    <span class="c1"># Make a plot of the errors:    </span>
    <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cctsduvs_</span> <span class="o">-</span> <span class="n">cctsduvs_t</span><span class="p">)</span> <span class="c1"># error array</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ccts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">[:,</span><span class="n">i</span><span class="p">],</span><span class="s1">&#39;o&#39;</span><span class="p">)</span>
        <span class="c1">#ax[i].plot(lut[:,0], np.zeros_like(lut),&#39;r.&#39;)</span>
        <span class="c1">#ax[i].plot(lut[:,0], lut[:,-1],&#39;g.-&#39;)</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="n">d</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">*</span><span class="mf">1.1</span><span class="p">,</span><span class="n">d</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">*</span><span class="mf">1.1</span><span class="p">])</span>
    
    <span class="c1"># plt.close(&#39;all&#39;)</span>
    <span class="n">xyz_to_cct_r</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">xyz</span><span class="p">:</span> <span class="n">xyz_to_cct</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">,</span><span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;[cct,duv]&#39;</span><span class="p">,</span> 
                          <span class="n">apply_newton_raphson</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">lut</span> <span class="o">=</span> <span class="n">lut</span><span class="p">,</span><span class="n">split_calculation_at_N</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Kevin A.G. Smet.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>