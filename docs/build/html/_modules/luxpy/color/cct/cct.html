<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>luxpy.color.cct.cct &mdash; LuxPy 1.11.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=b76e3c8a" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../../_static/documentation_options.js?v=6cf1fb80"></script>
        <script src="../../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            LuxPy
          </a>
              <div class="version">
                1.11.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../license.html">License: GPLv3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../required_packages.html">Imported (required) packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../luxpy_structure.html">Luxpy package structure</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">LuxPy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">luxpy.color.cct.cct</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for luxpy.color.cct.cct</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">########################################################################</span>
<span class="c1"># &lt;LUXPY: a Python package for lighting and color science.&gt;</span>
<span class="c1"># Copyright (C) &lt;2017&gt;  &lt;Kevin A.G. Smet&gt; (ksmet1977 at gmail.com)</span>
<span class="c1">#</span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#########################################################################</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">cct: Module with functions related to correlated color temperature calculations</span>
<span class="sd">===============================================================================</span>
<span class="sd"> These methods supersede earlier methods in cct_legacy.y (prior to Nov 2021)</span>

<span class="sd"> :_CCT_MAX: (= 1e11 K), max. value that does not cause overflow problems. </span>
<span class="sd"> </span>
<span class="sd"> :_CCT_MIN: (= 550 K), min. value that does not cause underflow problems.</span>
<span class="sd"> </span>
<span class="sd"> :_CCT_FALLBACK_N: Number of intervals to divide an ndarray with CCTs.</span>
<span class="sd"> </span>
<span class="sd"> :_CCT_FALLBACK_UNIT: Type of scale (units) an ndarray will be subdivided.</span>

<span class="sd"> :_CCT_LUT_PATH: Folder with Look-Up-Tables (LUT) for correlated color </span>
<span class="sd">                 temperature calculations. </span>

<span class="sd"> :_CCT_LUT: Dict with pre-calculated LUTs with structure LUT[mode][cspace][cieobs][lut i].</span>
<span class="sd"> </span>
<span class="sd"> :_CCT_LUT_CALC: Boolean determining whether to force LUT calculation, even if</span>
<span class="sd">                 the LUT.pkl files can be found in ./data/cctluts/.</span>
<span class="sd"> </span>
<span class="sd"> :_CCT_LUT_RESOLUTION_REDUCTION_FACTOR: number of subdivisions when performing</span>
<span class="sd">                                        a cascading lut calculation to zoom-in </span>
<span class="sd">                                        progressively on the CCT (until a certain </span>
<span class="sd">                                        tolerance is met)</span>
<span class="sd">                 </span>
<span class="sd"> :_CCT_CSPACE: default chromaticity space to calculate CCT and Duv in.</span>
<span class="sd"> </span>
<span class="sd"> :_CCT_CSPACE_KWARGS: nested dict with cspace parameters for forward and backward modes. </span>
<span class="sd"> </span>
<span class="sd"> :get_tcs4(): Get an ndarray of Tc&#39;s obtained from a list or tuple of tc4 4-vectors.</span>
<span class="sd"> </span>
<span class="sd"> :calculate_lut(): Function that calculates the LUT for the input ccts.</span>
<span class="sd"> </span>
<span class="sd"> :generate_luts(): Generate a number of luts and store them in a nested dictionary.</span>
<span class="sd">                    (Structure: lut[cspace][cieobs][lut type])</span>

<span class="sd"> :xyz_to_cct(): Calculates CCT, Duv from XYZ (wraps a variety of methods)</span>

<span class="sd"> :xyz_to_duv(): Calculates Duv, (CCT) from XYZ (wrapper around xyz_to_cct, but with Duv output.)</span>
<span class="sd">                </span>
<span class="sd"> :cct_to_xyz(): Calculates xyz from CCT, Duv by estimating the line perpendicular to the planckian locus (=iso-T line).</span>

<span class="sd"> :cct_to_xyz(): Calculates xyz from CCT, Duv [_CCT_MIN &lt; CCT &lt; _CCT_MAX]</span>

<span class="sd"> :xyz_to_cct_mcamy1992(): | Calculates CCT from XYZ using Mcamy model:</span>
<span class="sd">                          | `McCamy, Calvin S. (April 1992). </span>
<span class="sd">                            Correlated color temperature as an explicit function of </span>
<span class="sd">                            chromaticity coordinates. </span>
<span class="sd">                            Color Research &amp; Application. 17 (2): 142–144. </span>
<span class="sd">                            &lt;http://onlinelibrary.wiley.com/doi/10.1002/col.5080170211/abstract&gt;`_</span>

<span class="sd"> :xyz_to_cct_hernandez1999(): | Calculate CCT from XYZ using Hernández-Andrés et al. model.</span>
<span class="sd">                              | `Hernández-Andrés, Javier; Lee, RL; Romero, J (September 20, 1999). </span>
<span class="sd">                                Calculating Correlated Color Temperatures Across the </span>
<span class="sd">                                Entire Gamut of Daylight and Skylight Chromaticities. </span>
<span class="sd">                                Applied Optics. 38 (27): 5703–5709. PMID 18324081. </span>
<span class="sd">                                &lt;https://www.osapublishing.org/ao/abstract.cfm?uri=ao-38-27-5703&gt;`_</span>

<span class="sd"> :xyz_to_cct_ohno2014(): | Calculates CCT, Duv from XYZ using a Ohno&#39;s 2014 LUT method.</span>
<span class="sd">                         | `Ohno Y. (2014)</span>
<span class="sd">                           Practical use and calculation of CCT and Duv. </span>
<span class="sd">                           Leukos. 2014 Jan 2;10(1):47-55.</span>
<span class="sd">                           &lt;http://www.tandfonline.com/doi/abs/10.1080/15502724.2014.839020&gt;`_</span>
<span class="sd">                       </span>
<span class="sd"> :xyz_to_cct_zhang2019():  | Calculates CCT, Duv from XYZ using Zhang&#39;s 2019 golden-ratio search algorithm</span>
<span class="sd">                           | `Zhang, F. (2019). </span>
<span class="sd">                              High-accuracy method for calculating correlated color temperature with </span>
<span class="sd">                              a lookup table based on golden section search. </span>
<span class="sd">                              Optik, 193, 163018. </span>
<span class="sd">                              &lt;https://doi.org/https://doi.org/10.1016/j.ijleo.2019.163018&gt;`_</span>
<span class="sd">                 </span>
<span class="sd"> :xyz_to_cct_robertson1968(): | Calculates CCT, Duv from XYZ using a Robertson&#39;s 1968 search method.</span>
<span class="sd">                              | `Robertson, A. R. (1968). </span>
<span class="sd">                                Computation of Correlated Color Temperature and Distribution Temperature. </span>
<span class="sd">                                Journal of the Optical Society of America,  58(11), 1528–1535. </span>
<span class="sd">                                &lt;https://doi.org/10.1364/JOSA.58.001528&gt;`_</span>
<span class="sd">                              | Baxter D., Royer M., Smet K.A.G. (2022)</span>
<span class="sd">                                Modifications of the Robertson Method for Calculating Correlated Color Temperature to Improve Accuracy and Speed</span>
<span class="sd">                                (in preparation, LEUKOS?)</span>
<span class="sd">  </span>
<span class="sd"> :xyz_to_cct_li2016(): | Calculates CCT, Duv from XYZ using Li&#39;s 2016 Newton-Raphson method.</span>
<span class="sd">                       | `Li, C., Cui, G., Melgosa, M., Ruan, X., Zhang, Y., Ma, L., Xiao, K., &amp; Luo, M. R. (2016).</span>
<span class="sd">                         Accurate method for computing correlated color temperature. </span>
<span class="sd">                         Optics Express, 24(13), 14066–14078. </span>
<span class="sd">                         &lt;https://doi.org/10.1364/OE.24.014066&gt;`_   </span>
<span class="sd">                         </span>
<span class="sd"> :xyz_to_cct_li2022(): | Calculates CCT, Duv from XYZ using Li&#39;s 2022 update of Ohno&#39;s 2014 method.</span>
<span class="sd">                       | `Li, Y., Gao, C.,  Melgosa, M. and Li, C. (2022).</span>
<span class="sd">                          Improved methods for computing CCT and Duv. </span>
<span class="sd">                          LEUKOS, (in press). &lt;email://794962485@qq.com&gt;`_   </span>
<span class="sd">                                </span>
<span class="sd"> :xyz_to_cct_fibonacci(): | Calculates CCT, Duv from XYZ using a Fibonacci search method.</span>
<span class="sd">                  </span>
<span class="sd"> :cct_to_mired(): Converts from CCT to Mired scale (or back).</span>

<span class="sd">===============================================================================</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">copy</span> 
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># load some methods already programmed in luxpy:</span>
<span class="kn">from</span> <span class="nn">luxpy</span> <span class="kn">import</span> <span class="p">(</span><span class="n">math</span><span class="p">,</span> <span class="n">_BB</span><span class="p">,</span> <span class="n">_WL3</span><span class="p">,</span> <span class="n">_CIEOBS</span><span class="p">,</span> <span class="n">_CMF</span><span class="p">,</span> 
                   <span class="n">cie_interp</span><span class="p">,</span> <span class="n">spd_to_xyz</span><span class="p">,</span> 
                   <span class="n">getwlr</span><span class="p">,</span> <span class="n">getwld</span><span class="p">,</span>
                   <span class="n">xyz_to_Yxy</span><span class="p">,</span> <span class="n">Yxy_to_xyz</span><span class="p">,</span> <span class="n">xyz_to_Yuv60</span><span class="p">,</span> <span class="n">Yuv60_to_xyz</span><span class="p">,</span> 
                   <span class="n">xyz_to_Yuv</span><span class="p">,</span> <span class="n">Yuv_to_xyz</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">luxpy.utils</span> <span class="kn">import</span> <span class="n">_PKG_PATH</span><span class="p">,</span> <span class="n">_SEP</span><span class="p">,</span> <span class="n">np2d</span><span class="p">,</span> <span class="n">np2dT</span><span class="p">,</span> <span class="n">getdata</span><span class="p">,</span> <span class="n">save_pkl</span><span class="p">,</span> <span class="n">load_pkl</span>
<span class="kn">from</span> <span class="nn">luxpy.color.ctf.colortf</span> <span class="kn">import</span> <span class="n">colortf</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;_CCT_MAX&#39;</span><span class="p">,</span><span class="s1">&#39;_CCT_MIN&#39;</span><span class="p">,</span><span class="s1">&#39;_CCT_CSPACE&#39;</span><span class="p">,</span><span class="s1">&#39;_CCT_CSPACE_KWARGS&#39;</span><span class="p">,</span>
           <span class="s1">&#39;_CCT_LUT_PATH&#39;</span><span class="p">,</span><span class="s1">&#39;_CCT_LUT&#39;</span><span class="p">,</span> <span class="s1">&#39;_CCT_LUT_RESOLUTION_REDUCTION_FACTOR&#39;</span><span class="p">,</span>
           <span class="s1">&#39;_CCT_FALLBACK_N&#39;</span><span class="p">,</span> <span class="s1">&#39;_CCT_FALLBACK_UNIT&#39;</span><span class="p">,</span><span class="s1">&#39;_CCT_PKL_COMPRESSLEVEL&#39;</span><span class="p">,</span>
           <span class="s1">&#39;cct_to_mired&#39;</span><span class="p">,</span><span class="s1">&#39;xyz_to_cct_mcamy1992&#39;</span><span class="p">,</span> <span class="s1">&#39;xyz_to_cct_hernandez1999&#39;</span><span class="p">,</span>
           <span class="s1">&#39;xyz_to_cct_robertson1968&#39;</span><span class="p">,</span><span class="s1">&#39;xyz_to_cct_ohno2014&#39;</span><span class="p">,</span>
           <span class="s1">&#39;xyz_to_cct_li2016&#39;</span><span class="p">,</span> <span class="s1">&#39;xyz_to_cct_li2022&#39;</span><span class="p">,</span>
           <span class="s1">&#39;xyz_to_cct_zhang2019&#39;</span><span class="p">,</span> <span class="s1">&#39;xyz_to_cct_fibonacci&#39;</span><span class="p">,</span>
           <span class="s1">&#39;xyz_to_cct&#39;</span><span class="p">,</span><span class="s1">&#39;cct_to_xyz&#39;</span><span class="p">,</span> <span class="s1">&#39;calculate_lut&#39;</span><span class="p">,</span> <span class="s1">&#39;generate_luts&#39;</span><span class="p">,</span> <span class="s1">&#39;get_tcs4&#39;</span><span class="p">,</span>
           <span class="s1">&#39;_get_lut&#39;</span><span class="p">,</span> <span class="s1">&#39;_generate_tcs&#39;</span><span class="p">,</span> <span class="s1">&#39;_generate_lut&#39;</span><span class="p">,</span>
           <span class="s1">&#39;_generate_lut_ohno2014&#39;</span><span class="p">,</span><span class="s1">&#39;_generate_lut_li2022&#39;</span><span class="p">]</span>


<span class="c1">#==============================================================================</span>
<span class="c1"># define global variables:</span>
<span class="c1">#==============================================================================</span>
<span class="n">_CCT_AVOID_ZERO_DIV</span> <span class="o">=</span> <span class="mf">1e-100</span>
<span class="n">_CCT_AVOID_INF</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">_CCT_AVOID_ZERO_DIV</span>
<span class="c1"># _CCT_T_ROUNDING = 12</span>

<span class="n">_CCT_MAX</span> <span class="o">=</span> <span class="mf">1e11</span> <span class="c1"># don&#39;t set to higher value to avoid overflow and errors</span>
<span class="n">_CCT_MIN</span> <span class="o">=</span> <span class="mi">450</span>

<span class="n">_CCT_CSPACE</span> <span class="o">=</span> <span class="s1">&#39;Yuv60&#39;</span>
<span class="n">_CCT_CSPACE_KWARGS</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fwtf&#39;</span><span class="p">:{},</span> <span class="s1">&#39;bwtf&#39;</span><span class="p">:{}}</span>

<span class="n">_CCT_FALLBACK_N</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">_CCT_FALLBACK_UNIT</span> <span class="o">=</span> <span class="s1">&#39;K-1&#39;</span>
<span class="n">_CCT_MAX_ITER</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">_CCT_SPLIT_CALC_AT_N</span> <span class="o">=</span> <span class="mi">25</span> <span class="c1"># some tests show that this seems to be the fastest (for 1000 conversions)</span>

<span class="n">_CCT_LUT_PATH</span> <span class="o">=</span> <span class="n">_PKG_PATH</span> <span class="o">+</span> <span class="n">_SEP</span> <span class="o">+</span> <span class="s1">&#39;data&#39;</span><span class="o">+</span> <span class="n">_SEP</span> <span class="o">+</span> <span class="s1">&#39;cctluts&#39;</span> <span class="o">+</span> <span class="n">_SEP</span> <span class="c1">#folder with cct lut data</span>

<span class="n">_CCT_LUT_PATH_LX_REPO</span> <span class="o">=</span> <span class="s1">&#39;https://raw.github.com/ksmet1977/luxpy/master/luxpy/data/cctluts/&#39;</span> <span class="c1"># luxpy repo url where cctluts are stored </span>
<span class="n">_CCT_LUT_CALC</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">_CCT_LUT</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">_CCT_UV_TO_TX_FCNS</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">_CCT_LUT_RESOLUTION_REDUCTION_FACTOR</span> <span class="o">=</span> <span class="mi">4</span> <span class="c1"># for when cascading luts are used (d(Tm1,Tp1)--&gt;divide in _CCT_LUT_RESOLUTION_REDUCTION_FACTOR segments)</span>

<span class="n">_CCT_FAST_DUV</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># use a fast, but slightly less accurate Duv calculation with Newton-Raphson</span>
<span class="n">_CCT_VERBOSITY_LUT_GENERATION</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c1"># flow control parameters:</span>
<span class="c1">#-------------------------</span>
<span class="n">_CCT_LIST_OF_MODE_LUTS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;robertson1968&#39;</span><span class="p">,</span><span class="s1">&#39;ohno2014&#39;</span><span class="p">,</span><span class="s1">&#39;zhang2019&#39;</span><span class="p">,</span><span class="s1">&#39;fibonacci&#39;</span><span class="p">,</span><span class="s1">&#39;li2022&#39;</span><span class="p">]</span> <span class="c1"># only for the ones in this list are LUTS pre-generated (-&gt;_CCT_LUT)</span>
<span class="n">_CCT_LIST_OF_CIEOBS_LUTS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;1931_2&#39;</span><span class="p">,</span> <span class="s1">&#39;1964_10&#39;</span><span class="p">,</span> <span class="s1">&#39;2015_2&#39;</span><span class="p">,</span> <span class="s1">&#39;2015_10&#39;</span><span class="p">]</span> <span class="c1"># only for the ones in this list are LUTS pre-generated (-&gt;_CCT_LUT)</span>

<span class="n">_CCT_LUT_MIN</span><span class="p">,</span> <span class="n">_CCT_LUT_MAX</span> <span class="o">=</span> <span class="mf">1000.0</span><span class="p">,</span> <span class="mi">41000</span>

<span class="n">_CCT_SHARED_LUT_TYPES</span> <span class="o">=</span> <span class="p">[((</span><span class="n">_CCT_LUT_MIN</span><span class="p">,</span> <span class="n">_CCT_LUT_MAX</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;%&#39;</span><span class="p">),)]</span> <span class="c1"># shared among all modes</span>

<span class="n">_CCT_LUT_ONE_NPY_PER_MODE</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># switch between generating one npy file per mode (3-.. columns) vs one for all modes (8 columns)</span>

<span class="n">_CCT_PKL_COMPRESSLEVEL</span> <span class="o">=</span> <span class="mi">9</span>

<span class="c1">#==============================================================================</span>
<span class="c1"># define general helper functions:</span>
<span class="c1">#==============================================================================</span>


<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># cspace related functions:</span>
<span class="c1">#------------------------------------------------------------------------------</span>

<span class="k">def</span> <span class="nf">_process_cspace</span><span class="p">(</span><span class="n">cspace</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">cust_str</span> <span class="o">=</span> <span class="s1">&#39;cspace&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Process cspace and cspace_kwargs input. </span>
<span class="sd">    </span>
<span class="sd">    Returns dict with keys:</span>
<span class="sd">        - &#39;str&#39;: cspace string</span>
<span class="sd">        - &#39;fwtf&#39;: lambda function for xyz_to_cspace forward transform (cspace_kwargs are already processed).</span>
<span class="sd">        - &#39;bwtf&#39;: lambda function for cspace_to_xyz backward transform (cspace_kwargs are already processed).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">cspace_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fwtf&#39;</span><span class="p">:{},</span><span class="s1">&#39;bwtf&#39;</span><span class="p">:{}}</span>
    <span class="k">if</span> <span class="s1">&#39;fwtf&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cspace_kwargs</span><span class="p">:</span> <span class="n">cspace_kwargs</span><span class="p">[</span><span class="s1">&#39;fwtf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="s1">&#39;bwtf&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cspace_kwargs</span><span class="p">:</span> <span class="n">cspace_kwargs</span><span class="p">[</span><span class="s1">&#39;bwtf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cspace</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span> 
        <span class="n">cspace_str</span> <span class="o">=</span> <span class="n">cspace</span>
        <span class="k">if</span> <span class="n">cspace</span> <span class="o">==</span> <span class="s1">&#39;Yuv60&#39;</span><span class="p">:</span>
            <span class="n">cspace_fw</span> <span class="o">=</span> <span class="n">xyz_to_Yuv60</span> <span class="c1"># don&#39;t use lambda function for speed</span>
            <span class="n">cspace_bw</span> <span class="o">=</span> <span class="n">Yuv60_to_xyz</span> 
        <span class="k">elif</span> <span class="p">(</span><span class="n">cspace</span> <span class="o">==</span> <span class="s1">&#39;Yuv&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">cspace</span> <span class="o">==</span> <span class="s1">&#39;Yuv76&#39;</span><span class="p">):</span>
            <span class="n">cspace_fw</span> <span class="o">=</span> <span class="n">xyz_to_Yuv</span> <span class="c1"># don&#39;t use lambda function for speed</span>
            <span class="n">cspace_bw</span> <span class="o">=</span> <span class="n">Yuv_to_xyz</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cspace_fw</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">xyz</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">colortf</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span><span class="n">tf</span> <span class="o">=</span> <span class="s1">&#39;xyz&gt;&#39;</span> <span class="o">+</span> <span class="n">cspace_str</span><span class="p">,</span> <span class="n">fwtf</span> <span class="o">=</span> <span class="n">cspace_kwargs</span><span class="p">[</span><span class="s1">&#39;fwtf&#39;</span><span class="p">]))</span>
            <span class="n">cspace_bw</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">Yuv</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">colortf</span><span class="p">(</span><span class="n">Yuv</span><span class="p">,</span><span class="n">tf</span> <span class="o">=</span> <span class="n">cspace_str</span> <span class="o">+</span> <span class="s1">&#39;&gt;xyz&#39;</span><span class="p">,</span> <span class="n">bwtf</span> <span class="o">=</span> <span class="n">cspace_kwargs</span><span class="p">[</span><span class="s1">&#39;bwtf&#39;</span><span class="p">]))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cspace</span><span class="p">,</span><span class="nb">tuple</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cspace</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span> 
            <span class="n">cspace_str</span> <span class="o">=</span> <span class="n">cspace</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">cspace_fw</span> <span class="o">=</span> <span class="n">cspace</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">cspace_bw</span> <span class="o">=</span> <span class="n">cspace</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">cspace</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cspace</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="nb">str</span><span class="p">):</span>
                <span class="n">cspace_str</span> <span class="o">=</span> <span class="n">cspace</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">cspace_fw</span> <span class="o">=</span> <span class="n">cspace</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">cspace_bw</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cspace_str</span> <span class="o">=</span> <span class="n">cust_str</span>
                <span class="n">cspace_fw</span> <span class="o">=</span> <span class="n">cspace</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">cspace_bw</span> <span class="o">=</span> <span class="n">cspace</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cspace_str</span> <span class="o">=</span> <span class="n">cust_str</span>
            <span class="n">cspace_fw</span> <span class="o">=</span> <span class="n">cspace</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">cspace_bw</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cspace</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
        <span class="n">cspace_str</span> <span class="o">=</span> <span class="n">cspace</span><span class="p">[</span><span class="s1">&#39;str&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;str&#39;</span> <span class="ow">in</span> <span class="n">cspace</span><span class="p">)</span> <span class="k">else</span> <span class="n">cust_str</span>
        <span class="k">if</span> <span class="s1">&#39;fwtf&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cspace</span><span class="p">:</span> 
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&#39;fwtf&#39; key with forward xyz_to_cspace function must be supplied !!!&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cspace_fw</span> <span class="o">=</span> <span class="n">cspace</span><span class="p">[</span><span class="s1">&#39;fwtf&#39;</span><span class="p">]</span> 
        <span class="n">cspace_bw</span> <span class="o">=</span> <span class="n">cspace</span><span class="p">[</span><span class="s1">&#39;bwtf&#39;</span><span class="p">]</span>  <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;bwtf&#39;</span> <span class="ow">in</span> <span class="n">cspace</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cspace_str</span> <span class="o">=</span> <span class="n">cust_str</span>
        <span class="n">cspace_fw</span> <span class="o">=</span> <span class="n">cspace</span>
        <span class="n">cspace_bw</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="c1"># create cspace dict:</span>
    <span class="n">cspace_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;str&#39;</span><span class="p">:</span> <span class="n">cspace_str</span><span class="p">}</span> 
    <span class="n">cspace_dict</span><span class="p">[</span><span class="s1">&#39;fwtf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cspace_fw</span> <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cspace_kwargs</span><span class="p">[</span><span class="s1">&#39;fwtf&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">xyz</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">cspace_fw</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span><span class="o">**</span><span class="n">cspace_kwargs</span><span class="p">[</span><span class="s1">&#39;fwtf&#39;</span><span class="p">]))</span>
    <span class="n">cspace_dict</span><span class="p">[</span><span class="s1">&#39;bwtf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cspace_bw</span> <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cspace_kwargs</span><span class="p">[</span><span class="s1">&#39;bwtf&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">xyz</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">cspace_fw</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span><span class="o">**</span><span class="n">cspace_kwargs</span><span class="p">[</span><span class="s1">&#39;fwtf&#39;</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">cspace_dict</span><span class="p">,</span> <span class="n">cspace_str</span>

<span class="k">def</span> <span class="nf">_get_xyzbar_wl_dl</span><span class="p">(</span><span class="n">cieobs</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the interpolated (to wl) xyzbar CMF set corresponding to cieobs.</span>
<span class="sd">    Returns an ndarray with the cmfs (stripped of wavelengths), ndarray with</span>
<span class="sd">    wavelengths and an ndarray with the wavelength differences.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get requested cmf set:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cieobs</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
        <span class="n">cmf</span> <span class="o">=</span> <span class="n">_CMF</span><span class="p">[</span><span class="n">cieobs</span><span class="p">][</span><span class="s1">&#39;bar&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cmf</span> <span class="o">=</span> <span class="n">cieobs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">wl</span> <span class="o">=</span> <span class="n">cmf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">wl</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">getwlr</span><span class="p">(</span><span class="n">wl</span><span class="p">)</span>
    <span class="n">dl</span> <span class="o">=</span> <span class="n">getwld</span><span class="p">(</span><span class="n">wl</span><span class="p">)</span><span class="o">*</span><span class="mf">1.0</span>
    <span class="n">cmf</span> <span class="o">=</span>  <span class="n">cie_interp</span><span class="p">(</span><span class="n">cmf</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;cmf&#39;</span><span class="p">,</span> <span class="n">negative_values_allowed</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">c</span> <span class="o">=</span> <span class="o">~</span><span class="p">(((</span><span class="n">cmf</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">cmf</span><span class="p">[:,</span><span class="n">c</span><span class="p">]</span> <span class="o">+=</span> <span class="n">_CCT_AVOID_ZERO_DIV</span> <span class="c1"># avoid nan&#39;s in uvwvbar</span>
    <span class="k">return</span> <span class="n">cmf</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">dl</span>



<span class="k">def</span> <span class="nf">_convert_xyzbar_to_uvwbar</span><span class="p">(</span><span class="n">xyzbar</span><span class="p">,</span> <span class="n">cspace_dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert the xyzbar (no wl on row 0!) CMF set to a CMF set representing a different </span>
<span class="sd">    color space/ chromaticity diagram (integration leads to new tristimulus values)</span>
<span class="sd">    Returns an ndarray (no wl on row 0!) of new CMFs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># convert to cspace based cmfs (Eq.6-7):</span>
    <span class="n">Yuvbar</span> <span class="o">=</span> <span class="n">cspace_dict</span><span class="p">[</span><span class="s1">&#39;fwtf&#39;</span><span class="p">](</span><span class="n">xyzbar</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span> <span class="c1"># convert to chromaticity format from xyz (cfr. cmf) format</span>
    <span class="n">uvwbar</span> <span class="o">=</span> <span class="n">Yxy_to_xyz</span><span class="p">(</span><span class="n">Yuvbar</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="c1"># convert from chromaticity format (Vuv) to tristimulus (UVW) format and take transpose (=spectra)</span>
    <span class="k">return</span> <span class="n">uvwbar</span>


<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># Planckian spectrum and colorimetric calculations:</span>
<span class="c1">#------------------------------------------------------------------------------</span>
  
<span class="k">def</span> <span class="nf">_get_BB_BBp_BBpp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;BB,BBp,BBpp&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Get the blackbody radiatior spectrum, and the spectra corresponding to </span>
<span class="sd">    the first and second derivatives to Tc of the blackbody radiator.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">BBp</span><span class="p">,</span><span class="n">BBpp</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="kc">None</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="o">*</span><span class="mf">1.0</span> <span class="c1"># force float</span>
    <span class="n">wlt</span> <span class="o">=</span> <span class="n">wl</span><span class="o">*</span><span class="mf">1.0e-9</span>
    <span class="n">c_wl_T</span> <span class="o">=</span> <span class="n">_BB</span><span class="p">[</span><span class="s1">&#39;c2&#39;</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">wlt</span><span class="o">*</span><span class="n">T</span><span class="p">)</span>
    <span class="n">exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">c_wl_T</span><span class="p">)</span>
    <span class="n">exp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">exp</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_CCT_AVOID_INF</span>
    
    <span class="c1"># avoid div by inf or zero:</span>
    <span class="n">exp_min_1</span> <span class="o">=</span> <span class="n">exp</span> <span class="o">-</span> <span class="mf">1.0</span>
    <span class="n">exp_min_1</span><span class="p">[</span><span class="n">exp_min_1</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">_CCT_AVOID_ZERO_DIV</span>
    <span class="n">exp_min_1</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">exp_min_1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_CCT_AVOID_INF</span>
        
    <span class="n">BB</span> <span class="o">=</span> <span class="n">_BB</span><span class="p">[</span><span class="s1">&#39;c1&#39;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">wlt</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">exp_min_1</span><span class="p">))</span>
    <span class="n">BB</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">BB</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_CCT_AVOID_INF</span>
        
    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;BBp&#39;</span> <span class="ow">in</span> <span class="n">out</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="s1">&#39;BBpp&#39;</span> <span class="ow">in</span> <span class="n">out</span><span class="p">):</span> 
        
        <span class="n">exp_min_1_squared</span> <span class="o">=</span> <span class="n">exp_min_1</span><span class="o">**</span><span class="mi">2</span>
        
        <span class="c1"># avoid div by inf or zero:</span>
        <span class="n">exp_min_1_squared</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">exp_min_1_squared</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_CCT_AVOID_INF</span> <span class="c1"># avoid warning &quot;invalid value encountered in true_divide&quot;</span>
        <span class="n">exp_min_1_squared</span><span class="p">[</span><span class="n">exp_min_1_squared</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="n">_CCT_AVOID_ZERO_DIV</span>
        
        <span class="n">exp_frac</span> <span class="o">=</span> <span class="n">exp</span><span class="o">/</span><span class="n">exp_min_1_squared</span>

        <span class="n">BBp</span> <span class="o">=</span> <span class="p">(</span><span class="n">_BB</span><span class="p">[</span><span class="s1">&#39;c1&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">_BB</span><span class="p">[</span><span class="s1">&#39;c2&#39;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">T</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">wlt</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">)))</span><span class="o">*</span><span class="n">exp_frac</span>

        
    <span class="k">if</span> <span class="s1">&#39;BBpp&#39;</span> <span class="ow">in</span> <span class="n">out</span><span class="p">:</span>
        <span class="n">exp_plus_1</span> <span class="o">=</span> <span class="n">exp</span> <span class="o">+</span> <span class="mf">1.0</span>
        <span class="n">BBpp</span> <span class="o">=</span> <span class="p">(</span><span class="n">BBp</span><span class="o">/</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_wl_T</span> <span class="o">*</span> <span class="p">(</span><span class="n">exp_plus_1</span> <span class="o">/</span> <span class="n">exp_min_1</span><span class="p">)</span>  <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> 
        
        
    <span class="k">return</span> <span class="n">BB</span><span class="p">,</span> <span class="n">BBp</span><span class="p">,</span> <span class="n">BBpp</span>


<span class="k">def</span> <span class="nf">_get_tristim_of_BB_BBp_BBpp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">xyzbar</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;BB,BBp,BBpp&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Get the tristimulus values for CMF set xyzbar of the blackbody radiatior spectra</span>
<span class="sd">    and the spectra corresponding to the first and second derivatives to Tc </span>
<span class="sd">    of the blackbody radiator.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xyzp</span><span class="p">,</span><span class="n">xyzpp</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="n">BB</span><span class="p">,</span> <span class="n">BBp</span><span class="p">,</span> <span class="n">BBpp</span> <span class="o">=</span>  <span class="n">_get_BB_BBp_BBpp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">)</span>
    <span class="c1">#cnd = np.ones((BB.shape[-1],),dtype=bool)#((xyzbar&gt;0).sum(0)&gt;0).T # keep only wavelengths where not all 3 cmfs are equal (to avoid nan&#39;s for 2015 cmfs which are defined only between 390 and 830 nm)</span>
    <span class="n">xyz</span> <span class="o">=</span> <span class="p">((</span><span class="n">BB</span> <span class="o">*</span> <span class="n">dl</span><span class="p">)</span> <span class="o">@</span> <span class="n">xyzbar</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;BBp&#39;</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">):</span> 
        <span class="n">xyzp</span> <span class="o">=</span> <span class="p">((</span><span class="n">BBp</span> <span class="o">*</span> <span class="n">dl</span><span class="p">)</span> <span class="o">@</span> <span class="n">xyzbar</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">xyzp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">xyzp</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_CCT_AVOID_INF</span> <span class="c1"># # avoid warning &quot;invalid value encountered in subtract&quot; when calculating li</span>

    <span class="k">if</span> <span class="s1">&#39;BBpp&#39;</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">):</span> 
        <span class="n">xyzpp</span> <span class="o">=</span> <span class="p">((</span><span class="n">BBpp</span> <span class="o">*</span> <span class="n">dl</span><span class="p">)</span> <span class="o">@</span> <span class="n">xyzbar</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">xyzpp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">xyzpp</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_CCT_AVOID_INF</span>

    <span class="k">return</span> <span class="n">T</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">xyzp</span><span class="p">,</span> <span class="n">xyzpp</span>


<span class="k">def</span> <span class="nf">_get_uv_uvp_uvpp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">uvwbar</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;BB,BBp,BBpp&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Get the (u,v), (u&#39;,v&#39;) and (u&quot;,v&quot;) coordinates of one or more Planckians</span>
<span class="sd">    with specified Tc. uvwbar (no wavelengths on row0, these are supplied seperately</span>
<span class="sd">    in wl, with wavelength spacing in dl) is the cmf set corresponding to the tristimulus values</span>
<span class="sd">    of the chosen chromaticity diagram or color space to do the CCT calculations in.</span>
<span class="sd">    See: Li et al. (2016). Accurate method for computing correlated color temperature. Optics Express, 24(13), 14066–14078.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># calculate U,V,W (Eq. 6) and U&#39;,V&#39;,W&#39; (Eq.10) [Robertson,1986] and U&quot;,V&quot;,W&quot; [Li,2016; started from XYZ, but this is equivalent]:</span>
    <span class="n">T</span><span class="p">,</span> <span class="n">UVW</span><span class="p">,</span> <span class="n">UVWp</span><span class="p">,</span> <span class="n">UVWpp</span> <span class="o">=</span> <span class="n">_get_tristim_of_BB_BBp_BBpp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">uvwbar</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">)</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">T</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span>
    
    <span class="c1"># get u,v &amp; u&#39;,v&#39; and u&quot;,v&quot;:</span>
    <span class="n">S</span> <span class="o">=</span> <span class="p">(</span><span class="n">UVW</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">UVW</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">UVW</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">])[:,</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">uv</span> <span class="o">=</span> <span class="p">(</span><span class="n">UVW</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">S</span> <span class="o">+</span> <span class="n">_CCT_AVOID_ZERO_DIV</span><span class="p">))</span>
    <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="o">=</span> <span class="n">uv</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span> <span class="n">uv</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">UVWp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Sp</span> <span class="o">=</span> <span class="p">(</span><span class="n">UVWp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">UVWp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">UVWp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">])[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">PQ</span> <span class="o">=</span> <span class="p">(</span><span class="n">UVWp</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">S</span> <span class="o">-</span> <span class="n">UVW</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">Sp</span><span class="p">)</span>
        <span class="n">uvp</span> <span class="o">=</span> <span class="p">(</span><span class="n">PQ</span> <span class="o">/</span> <span class="p">((</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">_CCT_AVOID_ZERO_DIV</span><span class="p">))</span>
        <span class="n">up</span><span class="p">,</span><span class="n">vp</span> <span class="o">=</span> <span class="n">uvp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span> <span class="n">uvp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">up</span><span class="p">,</span><span class="n">vp</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        
    <span class="k">if</span> <span class="p">(</span><span class="n">UVWpp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UVWp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">Spp</span> <span class="o">=</span> <span class="p">(</span><span class="n">UVWpp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">UVWpp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">UVWpp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">])[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">PQp</span> <span class="o">=</span> <span class="p">(</span><span class="n">UVWpp</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">S</span> <span class="o">-</span> <span class="n">UVW</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">Spp</span><span class="p">)</span>
        <span class="n">uvpp</span> <span class="o">=</span> <span class="p">((</span><span class="n">PQp</span> <span class="o">*</span> <span class="n">S</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">PQ</span> <span class="o">*</span><span class="n">Sp</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="n">S</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">_CCT_AVOID_ZERO_DIV</span><span class="p">))</span>
        <span class="n">upp</span><span class="p">,</span><span class="n">vpp</span> <span class="o">=</span> <span class="n">uvpp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span> <span class="n">uvpp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">upp</span><span class="p">,</span> <span class="n">vpp</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    
    <span class="k">return</span> <span class="n">T</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">up</span><span class="p">,</span> <span class="n">vp</span><span class="p">,</span> <span class="n">upp</span><span class="p">,</span> <span class="n">vpp</span><span class="p">,</span> <span class="p">(</span><span class="n">UVW</span><span class="p">,</span> <span class="n">UVWp</span><span class="p">,</span> <span class="n">UVWpp</span><span class="p">)</span>


<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># Tc list generation functions:</span>
<span class="c1">#------------------------------------------------------------------------------</span>

<span class="k">def</span> <span class="nf">_get_tcs4</span><span class="p">(</span><span class="n">tc4</span><span class="p">,</span> <span class="n">uin</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;Ts&#39;</span><span class="p">,</span>
              <span class="n">fallback_unit</span> <span class="o">=</span> <span class="n">_CCT_FALLBACK_UNIT</span><span class="p">,</span> 
              <span class="n">fallback_n</span> <span class="o">=</span> <span class="n">_CCT_FALLBACK_N</span><span class="p">):</span>

    <span class="p">(</span><span class="n">T0</span><span class="p">,</span><span class="n">Tn</span><span class="p">,</span><span class="n">dT</span><span class="p">),</span><span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">tc4_i</span><span class="p">)</span> <span class="k">for</span> <span class="n">tc4_i</span> <span class="ow">in</span> <span class="n">tc4</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">tc4</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># min, max, interval, unit</span>
    
    <span class="c1"># Get n from third element:</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">dT</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dT</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;3e element [dT,n] in 4-vector tc4 contains negatives AND positives! Should be only 1 type.&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dT</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">dT</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="k">else</span> <span class="kc">None</span> <span class="c1"># dT contains number of tcs between T0 and Tn, not dT</span>
 
    <span class="c1"># special &#39;au&#39; case</span>
    <span class="k">if</span> <span class="s1">&#39;au&#39;</span> <span class="ow">in</span> <span class="n">u</span><span class="p">:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">fallback_unit</span> 
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">n</span> <span class="o">=</span> <span class="n">fallback_n</span> <span class="c1"># not-None n force the use of n in what follows !!</span>
    
    <span class="c1"># Tmin, Tmax input different from unit u:</span>
    <span class="k">if</span> <span class="n">uin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">uin</span> <span class="o">!=</span> <span class="n">u</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">((</span><span class="s1">&#39;-1&#39;</span> <span class="ow">in</span> <span class="n">uin</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;-1&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">u</span><span class="p">))</span> <span class="o">|</span> <span class="p">((</span><span class="s1">&#39;-1&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">uin</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;-1&#39;</span> <span class="ow">in</span> <span class="n">u</span><span class="p">)):</span>
                <span class="n">T0</span><span class="p">,</span> <span class="n">Tn</span> <span class="o">=</span> <span class="mf">1e6</span><span class="o">/</span><span class="n">Tn</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1e6</span><span class="o">/</span><span class="n">T0</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># generate scale in mireds (input was always in Tc)</span>
    
    <span class="c1"># calculate Ts for different unit types:</span>
    <span class="k">if</span> <span class="s1">&#39;K&#39;</span> <span class="ow">in</span> <span class="n">u</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="p">(((</span><span class="n">Tn</span><span class="o">-</span><span class="n">T0</span><span class="p">)</span><span class="o">//</span><span class="n">dT</span><span class="p">)</span> <span class="o">+</span> <span class="p">(((</span><span class="n">Tn</span><span class="o">-</span><span class="n">T0</span><span class="p">)</span><span class="o">%</span><span class="n">dT</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="c1"># get n from dT</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">dT</span> <span class="o">=</span> <span class="p">(</span><span class="n">Tn</span> <span class="o">-</span> <span class="n">T0</span><span class="p">)</span><span class="o">/</span><span class="n">n</span> <span class="c1"># get dT from n</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> 
            
        <span class="n">Ts</span> <span class="o">=</span> <span class="p">(</span><span class="n">T0</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dT</span><span class="p">[:,</span><span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">T</span> <span class="c1"># to include Tn</span>
    
    <span class="k">elif</span> <span class="s1">&#39;%&#39;</span> <span class="ow">in</span> <span class="n">u</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">dT</span><span class="o">/</span><span class="mi">100</span>
            <span class="n">n</span> <span class="o">=</span> <span class="p">(((</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">Tn</span><span class="o">/</span><span class="n">T0</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span><span class="o">.</span><span class="n">max</span><span class="p">())</span> <span class="c1"># get n from dT</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">Tn</span><span class="o">/</span><span class="n">T0</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">n</span><span class="p">)</span> <span class="c1"># get p = (1+dT/100) from n</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">Ts</span> <span class="o">=</span> <span class="n">T0</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>
    
        
    
    <span class="k">if</span> <span class="s1">&#39;-1&#39;</span> <span class="ow">in</span> <span class="n">u</span><span class="p">:</span>
        <span class="n">Ts</span><span class="p">[</span><span class="n">Ts</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">_CCT_AVOID_ZERO_DIV</span>
        <span class="n">Ts</span> <span class="o">=</span> <span class="mf">1e6</span><span class="o">/</span><span class="n">Ts</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># scale was in mireds </span>
    
    <span class="c1">#Ts = np.round(Ts,_CCT_T_ROUNDING)</span>
    
    <span class="k">if</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;Ts&#39;</span><span class="p">:</span> 
        <span class="k">return</span> <span class="n">Ts</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;Ts,T0,Tn,dT,u,n&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Ts</span><span class="p">,</span><span class="n">T0</span><span class="p">,</span><span class="n">Tn</span><span class="p">,</span><span class="n">dT</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">n</span>

<div class="viewcode-block" id="get_tcs4">
<a class="viewcode-back" href="../../../../color.html#luxpy.color.cct.get_tcs4">[docs]</a>
<span class="k">def</span> <span class="nf">get_tcs4</span><span class="p">(</span><span class="n">tc4</span><span class="p">,</span> <span class="n">uin</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">seamless_stitch</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
             <span class="n">fallback_unit</span> <span class="o">=</span> <span class="n">_CCT_FALLBACK_UNIT</span><span class="p">,</span> 
             <span class="n">fallback_n</span> <span class="o">=</span> <span class="n">_CCT_FALLBACK_N</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Get an ndarray of Tc&#39;s obtained from a list or tuple of tc4 4-vectors.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :tc4:</span>
<span class="sd">            | list or tuple of 4-vectors.</span>
<span class="sd">            |  e.g. (tc4_1, tc4_2, tc4_3,...) or (tc4_1, tc4_2, tc4_3,..., bool::seamless_stitch)</span>
<span class="sd">            | When the last element of the list/tuple is a bool, then this specifies</span>
<span class="sd">            |  how the Tc arrays generated for each of the 4-vector elements need to be</span>
<span class="sd">            |  stitched together. This overrides the seamless_stitch input argument.</span>
<span class="sd">            | Vector elements are: </span>
<span class="sd">            |    [Tmin, Tmax inclusive, Tinterval(or number of intervals), unit]</span>
<span class="sd">            |  Unit specifies unit of the Tc interval, i.e. it determines the</span>
<span class="sd">            |       type of scale in which the spacing of the Tc are done.</span>
<span class="sd">            |  Unit options are:</span>
<span class="sd">            |   - &#39;%&#39;: equal relative Tc spacing (in %, cfr. (Ti+1 - Ti-1)/Ti-1).</span>
<span class="sd">            |   - &#39;K&#39; equal absolute Tc spacing (in K, cfr. (Ti+1 - Ti-1).</span>
<span class="sd">            |   - &#39;%-1&#39;: equal relative reciprocal Tc (MK-1 = mired).</span>
<span class="sd">            |   - &#39;K-1&#39;: equal absolute reciprocal Tc (MK-1 = mired).</span>
<span class="sd">            |  If the &#39;interval&#39; element is negative, it actually represents</span>
<span class="sd">            |  the number of intervals between Tmin, Tmax (included).</span>
<span class="sd">        :uin:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Unit of input Tmin, Tmax (by default it is assumed to be the same</span>
<span class="sd">            | as the scale &#39;unit&#39;).</span>
<span class="sd">        :seamless_stitch:</span>
<span class="sd">            | True, optional</span>
<span class="sd">            | Determines how the Tc arrays generated for each of the 4-vector </span>
<span class="sd">            | elements are stitched together. Is overriden by the presence of a </span>
<span class="sd">            | bool as last list/tuple element in :tc4:.</span>
<span class="sd">            | For a seamless stitch, all units for all 4-vectors should be the same!!</span>
<span class="sd">        :fallback_unit:</span>
<span class="sd">            | _CCT_FALLBACK_UNIT, optional</span>
<span class="sd">            | Unit to fall back on when the input unit in tc4 (of first list) is &#39;au&#39;.</span>
<span class="sd">            | As there is no common distancing of the unit types [&#39;K&#39;,&#39;%&#39;,&#39;%-1&#39;,&#39;K-1&#39;]</span>
<span class="sd">            | the Tc&#39;s are generated by dividing the min-max range into </span>
<span class="sd">            | a number of divisions, specified by the negative 3 element (or when</span>
<span class="sd">            | positive or NaN, the number of divisions is set by :fallback_divisions:)</span>
<span class="sd">        :fallback_n:</span>
<span class="sd">            | _CCT_FALLBACK_N, optional</span>
<span class="sd">            | Number of divisions the min-max range is divided into, in the </span>
<span class="sd">            | fallback case in which unit==&#39;au&#39; and the 3e 4-vector element </span>
<span class="sd">            | is NaN or positive.</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :tcs:</span>
<span class="sd">            | ndarray with Tcs</span>
<span class="sd">            </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># make tupleof depth 2 if not already:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tc4</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="nb">str</span><span class="p">):</span> 
         <span class="n">tc4</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">tc4</span><span class="p">])</span>
    
    <span class="c1"># use seamless stitch from tuple/list of tc4s:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tc4</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="nb">bool</span><span class="p">):</span> 
        <span class="n">seamless_stitch</span> <span class="o">=</span> <span class="n">tc4</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">tc4</span> <span class="o">=</span> <span class="n">tc4</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="c1"># check all units (should be the same!!):</span>
    <span class="k">if</span> <span class="n">seamless_stitch</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tc4</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">units</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">tc4_i</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">==</span><span class="n">tc4</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span> <span class="k">for</span> <span class="n">tc4_i</span> <span class="ow">in</span> <span class="n">tc4</span><span class="p">])</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">units</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Seamless stitching for unequal units not supported.&#39;</span><span class="p">)</span>
    
    <span class="c1"># loop over all tc4s and &#39;stitch&#39; them together.</span>
    <span class="n">Ts</span> <span class="o">=</span> <span class="kc">None</span>    
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">tc4_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tc4</span><span class="p">):</span>
        <span class="n">tc4_i</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tc4_i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">seamless_stitch</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">):</span> 
            <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;-1&#39;</span> <span class="ow">in</span> <span class="n">tc4_i</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">tc4_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e6</span><span class="o">/</span><span class="n">Ts</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># change T0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tc4_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># change T0</span>

        <span class="n">Ts_i</span> <span class="o">=</span> <span class="n">_get_tcs4</span><span class="p">(</span><span class="n">tc4_i</span><span class="p">,</span> <span class="n">uin</span> <span class="o">=</span> <span class="n">uin</span><span class="p">,</span> 
                         <span class="n">fallback_unit</span> <span class="o">=</span> <span class="n">fallback_unit</span><span class="p">,</span>
                         <span class="n">fallback_n</span> <span class="o">=</span> <span class="n">fallback_n</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">Ts</span> <span class="o">=</span> <span class="n">Ts_i</span>  
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;-1&#39;</span> <span class="ow">in</span> <span class="n">tc4_i</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span> <span class="c1"># avoid overlap</span>
                <span class="n">Ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">Ts_i</span><span class="p">[</span><span class="n">Ts_i</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],:],</span><span class="n">Ts</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">Ts</span><span class="p">,</span><span class="n">Ts_i</span><span class="p">[</span><span class="n">Ts_i</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="n">Ts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],:]))</span>
    <span class="k">return</span> <span class="n">Ts</span></div>

          

<div class="viewcode-block" id="_generate_tcs">
<a class="viewcode-back" href="../../../../color.html#luxpy.color.cct._generate_tcs">[docs]</a>
<span class="k">def</span> <span class="nf">_generate_tcs</span><span class="p">(</span><span class="n">tc4</span><span class="p">,</span> <span class="n">uin</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">seamless_stitch</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">cct_max</span> <span class="o">=</span> <span class="n">_CCT_MAX</span><span class="p">,</span> <span class="n">cct_min</span> <span class="o">=</span> <span class="n">_CCT_MIN</span><span class="p">,</span> 
                  <span class="n">fallback_unit</span> <span class="o">=</span> <span class="n">_CCT_FALLBACK_UNIT</span><span class="p">,</span> 
                  <span class="n">fallback_n</span> <span class="o">=</span> <span class="n">_CCT_FALLBACK_N</span><span class="p">,</span>
                  <span class="n">resample_ndarray</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Get an ndarray of Tc&#39;s obtained from a list or tuple of tc4 4-vectors (or ndarray).</span>
<span class="sd">        </span>
<span class="sd">    Args:</span>
<span class="sd">        :tc4:</span>
<span class="sd">            | list or tuple of 4-vectors or ndarray.</span>
<span class="sd">            | If ndarray: return tc4 limited to a cct_min-cct_max range (do nothing else).</span>
<span class="sd">            | If list/tuple: e.g. (tc4_1, tc4_2, tc4_3,...) or (tc4_1, tc4_2, tc4_3,..., bool::seamless_stitch)</span>
<span class="sd">            | When the last element of the list/tuple is a bool, then this specifies</span>
<span class="sd">            |  how the Tc arrays generated for each of the 4-vector elements need to be</span>
<span class="sd">            |  stitched together. This overrides the seamless_stitch input argument.</span>
<span class="sd">            | Vector elements are: </span>
<span class="sd">            |    [Tmin, Tmax inclusive, Tinterval(or number of intervals), unit]</span>
<span class="sd">            |  Unit specifies unit of the Tc interval, i.e. it determines the</span>
<span class="sd">            |       type of scale in which the spacing of the Tc are done.</span>
<span class="sd">            |  Unit options are:</span>
<span class="sd">            |   - &#39;%&#39;: equal relative Tc spacing (in %, cfr. (Ti+1 - Ti-1)/Ti-1).</span>
<span class="sd">            |   - &#39;K&#39; equal absolute Tc spacing (in K, cfr. (Ti+1 - Ti-1).</span>
<span class="sd">            |   - &#39;%-1&#39;: equal relative reciprocal Tc (MK-1 = mired).</span>
<span class="sd">            |   - &#39;K-1&#39;: equal absolute reciprocal Tc (MK-1 = mired).</span>
<span class="sd">            |  If the &#39;interval&#39; element is negative, it actually represents</span>
<span class="sd">            |   the number of intervals between Tmin, Tmax (included).</span>
<span class="sd">        :uin:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Unit of input Tmin, Tmax (by default it is assumed to be the same</span>
<span class="sd">            | as the scale &#39;unit&#39;).</span>
<span class="sd">        :seamless_stitch:</span>
<span class="sd">            | True, optional</span>
<span class="sd">            | Determines how the Tc arrays generated for each of the 4-vector </span>
<span class="sd">            | elements are stitched together. Is overriden by the presence of a </span>
<span class="sd">            | bool as last list/tuple element in :tc4:.</span>
<span class="sd">            | For a seamless stitch, all units for all 4-vectors should be the same!!</span>
<span class="sd">        :cct_max:</span>
<span class="sd">            | _CCT_MAX, optional</span>
<span class="sd">            | Limit Tc&#39;s to a maximum value of cct_max</span>
<span class="sd">        :cct_min:</span>
<span class="sd">            | _CCT_MIN, optional</span>
<span class="sd">            | Limit Tc&#39;s to a minimum value of cct_max</span>
<span class="sd">        :fallback_unit:</span>
<span class="sd">            | _CCT_FALLBACK_UNIT, optional</span>
<span class="sd">            | Unit to fall back on when the input unit in tc4 (of first list) is &#39;au&#39;.</span>
<span class="sd">            | As there is no common distancing of the unit types [&#39;K&#39;,&#39;%&#39;,&#39;%-1&#39;,&#39;K-1&#39;]</span>
<span class="sd">            | the Tc&#39;s are generated by dividing the min-max range into </span>
<span class="sd">            | a number of divisions, specified by the negative 3 element (or when</span>
<span class="sd">            | positive or NaN, the number of divisions is set by :fallback_divisions:)</span>
<span class="sd">        :fallback_n:</span>
<span class="sd">            | _CCT_FALLBACK_N, optional</span>
<span class="sd">            | Number of divisions the min-max range is divided into, in the </span>
<span class="sd">            | fallback case in which unit==&#39;au&#39; and the 3e 4-vector element </span>
<span class="sd">            | is NaN or positive.</span>
<span class="sd">        :resample_ndarray:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | If False: do not resample Tc&#39;s of an ndarray input for tc4</span>
<span class="sd">            | else: divide min-max range in fallback_n intervals. Uses fallback_unit</span>
<span class="sd">            | to determine the scale for the resampling.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :tcs:</span>
<span class="sd">            | ndarray with Tcs</span>
<span class="sd">            </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Get ccts for lut generation:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tc4</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>

        <span class="n">Ts</span> <span class="o">=</span> <span class="n">get_tcs4</span><span class="p">(</span><span class="n">tc4</span><span class="p">,</span> <span class="n">uin</span> <span class="o">=</span> <span class="n">uin</span><span class="p">,</span> <span class="n">seamless_stitch</span> <span class="o">=</span> <span class="n">seamless_stitch</span><span class="p">,</span>
                      <span class="n">fallback_unit</span> <span class="o">=</span> <span class="n">fallback_unit</span><span class="p">,</span> 
                      <span class="n">fallback_n</span> <span class="o">=</span> <span class="n">fallback_n</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">resample_ndarray</span><span class="p">:</span>
            <span class="n">T0</span> <span class="o">=</span> <span class="n">tc4</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">T1</span> <span class="o">=</span> <span class="n">tc4</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="n">fallback_n</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">fallback_unit</span>
            <span class="n">tc4_a</span> <span class="o">=</span> <span class="p">(</span><span class="n">T0</span><span class="p">,</span><span class="n">T1</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">u</span><span class="p">)</span>
            
            <span class="n">Ts</span> <span class="o">=</span> <span class="n">get_tcs4</span><span class="p">(</span><span class="n">tc4_a</span><span class="p">,</span> <span class="n">uin</span> <span class="o">=</span> <span class="s1">&#39;K&#39;</span><span class="p">)</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Ts</span> <span class="o">=</span> <span class="n">tc4</span><span class="p">[:,:</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># actually stores ccts already! [Nx1] with N&gt;2 !</span>

    <span class="n">Ts</span><span class="p">[(</span><span class="n">Ts</span><span class="o">&lt;</span><span class="n">cct_min</span><span class="p">)]</span> <span class="o">=</span> <span class="n">cct_min</span>
    <span class="n">Ts</span><span class="p">[(</span><span class="n">Ts</span><span class="o">&gt;</span><span class="n">cct_max</span><span class="p">)]</span> <span class="o">=</span> <span class="n">cct_max</span> <span class="c1"># limit to a maximum cct to avoid overflow/error and/or increase speed.    </span>
    <span class="k">return</span> <span class="n">Ts</span>              </div>

 
    
<span class="k">def</span> <span class="nf">_get_lut_characteristics</span><span class="p">(</span><span class="n">lut</span><span class="p">,</span> <span class="n">force_au</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">tuple_depth_2</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Guesses the interval, unit and wavelength range from lut array.</span>
<span class="sd">     (slow, so avoid use: set force_au to True !!)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">force_au</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">tuple_depth_2</span><span class="p">:</span> 
            <span class="k">return</span> <span class="p">((</span><span class="n">lut</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span><span class="n">lut</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s1">&#39;au&#39;</span><span class="p">),)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">lut</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span><span class="n">lut</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s1">&#39;au&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        
        <span class="n">lut_units</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;K&#39;</span><span class="p">,</span><span class="s1">&#39;%&#39;</span><span class="p">,</span><span class="s1">&#39;K-1&#39;</span><span class="p">,</span><span class="s1">&#39;%-1&#39;</span><span class="p">])</span>
        
        <span class="n">T</span> <span class="o">=</span> <span class="n">lut</span><span class="p">[:,:</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">T01</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">T11</span> <span class="o">=</span> <span class="n">T1</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        
        <span class="c1"># cfr. &#39;K&#39;</span>
        <span class="n">dT</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">T</span> <span class="o">-</span> <span class="n">T1</span><span class="p">),</span><span class="mi">8</span><span class="p">)[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">intsT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">dT</span><span class="p">)</span>
        <span class="n">minmaxT</span> <span class="o">=</span> <span class="p">[[</span><span class="n">T01</span><span class="p">[(</span><span class="n">dT</span><span class="o">==</span><span class="n">intsT</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span><span class="n">T01</span><span class="p">[(</span><span class="n">dT</span><span class="o">==</span><span class="n">intsT</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span><span class="o">.</span><span class="n">max</span><span class="p">()]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">intsT</span><span class="p">))]</span>
        <span class="n">minmaxT</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># cfr &#39;%:</span>
        <span class="n">dTr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="n">T01</span><span class="o">-</span><span class="n">T11</span><span class="p">)</span><span class="o">/</span><span class="n">T11</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span>
        <span class="n">intsTr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">dTr</span><span class="p">)</span>
        <span class="n">minmaxTr</span> <span class="o">=</span> <span class="p">[[</span><span class="n">T01</span><span class="p">[(</span><span class="n">dTr</span><span class="o">==</span><span class="n">intsTr</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span><span class="n">T01</span><span class="p">[(</span><span class="n">dTr</span><span class="o">==</span><span class="n">intsTr</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span><span class="o">.</span><span class="n">max</span><span class="p">()]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">intsTr</span><span class="p">))]</span>
        <span class="n">minmaxTr</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># cfr. &#39;K-1&#39;:</span>
        <span class="n">dRD</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="mf">1e6</span><span class="o">/</span><span class="n">T01</span> <span class="o">-</span> <span class="mf">1e6</span><span class="o">/</span><span class="n">T11</span><span class="p">),</span><span class="mi">8</span><span class="p">))</span>
        <span class="n">intsRD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">dRD</span><span class="p">)</span>
        <span class="n">minmaxRD</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1e6</span><span class="o">/</span><span class="n">T01</span><span class="p">[(</span><span class="n">dRD</span><span class="o">==</span><span class="n">intsRD</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span><span class="mf">1e6</span><span class="o">/</span><span class="n">T01</span><span class="p">[(</span><span class="n">dRD</span><span class="o">==</span><span class="n">intsRD</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span><span class="o">.</span><span class="n">min</span><span class="p">()]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">intsRD</span><span class="p">))]</span>
        <span class="n">minmaxRD</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e6</span><span class="o">/</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
          
        <span class="c1"># cfr. &#39;%-1&#39;:</span>
        <span class="n">dRDr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="n">T01</span><span class="o">-</span><span class="n">T11</span><span class="p">)</span><span class="o">/</span><span class="n">T11</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span>
        <span class="n">intsRDr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">dRDr</span><span class="p">)</span>
        <span class="n">minmaxRDr</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1e6</span><span class="o">/</span><span class="n">T01</span><span class="p">[(</span><span class="n">dRDr</span><span class="o">==</span><span class="n">intsRDr</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span><span class="mf">1e6</span><span class="o">/</span><span class="n">T01</span><span class="p">[(</span><span class="n">dRDr</span><span class="o">==</span><span class="n">intsRDr</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span><span class="o">.</span><span class="n">min</span><span class="p">()]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">intsRDr</span><span class="p">))]</span>
        <span class="n">minmaxRDr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e6</span><span class="o">/</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># find minimum lengths &amp; units for which the min max order is ok: </span>
        <span class="n">len_ints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">intsT</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">intsTr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">intsRD</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">intsRDr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="k">if</span> <span class="n">len_ints</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span> 
            <span class="n">minmax_order_ok</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">minmaxT</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">minmaxT</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                    <span class="n">minmaxTr</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">minmaxTr</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                    <span class="n">minmaxRD</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">minmaxRD</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                    <span class="n">minmaxRDr</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">minmaxRDr</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">minmax_order_ok</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">4</span><span class="p">,),</span><span class="n">dtype</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">)</span>
        
        <span class="c1"># determine unit:</span>
        <span class="n">len_order_ok</span> <span class="o">=</span> <span class="p">((</span><span class="n">len_ints</span> <span class="o">==</span> <span class="n">len_ints</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">&amp;</span> <span class="n">minmax_order_ok</span><span class="p">)</span>
        <span class="n">lut_unit</span> <span class="o">=</span> <span class="n">lut_units</span><span class="p">[</span><span class="n">len_order_ok</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lut_unit</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">lut_unit</span> <span class="o">=</span> <span class="s1">&#39;au&#39;</span>
        <span class="c1"># for code testing:</span>
        <span class="c1"># return {&#39;K&#39;:(dT,intsT,minmaxT),</span>
        <span class="c1">#         &#39;%&#39;:(dTr,intsTr,minmaxTr),</span>
        <span class="c1">#         &#39;K-1&#39;:(dRD,intsRD,minmaxRD),</span>
        <span class="c1">#         &#39;%-1&#39;:(dRDr,intsRDr,minmaxRDr),</span>
        <span class="c1">#         &#39;len_ints&#39;:len_ints,</span>
        <span class="c1">#         &#39;minmax_order_ok&#39;:minmax_order_ok,</span>
        <span class="c1">#         &#39;len_order_ok&#39; : len_order_ok,</span>
        <span class="c1">#         &#39;lut_unit&#39;:lut_unit}</span>
        
        <span class="k">if</span> <span class="n">lut_unit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;K&#39;</span><span class="p">:</span>
            <span class="n">dT</span><span class="p">,</span> <span class="n">lut_unit</span><span class="p">,</span> <span class="n">Tminmax</span> <span class="o">=</span> <span class="n">intsT</span><span class="p">,</span><span class="n">lut_unit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">minmaxT</span>
        <span class="k">elif</span> <span class="n">lut_unit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;%&#39;</span><span class="p">:</span>
            <span class="n">dT</span><span class="p">,</span> <span class="n">lut_unit</span><span class="p">,</span> <span class="n">Tminmax</span> <span class="o">=</span> <span class="n">intsTr</span><span class="p">,</span><span class="n">lut_unit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">minmaxTr</span> 
        <span class="k">elif</span> <span class="n">lut_unit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;K-1&#39;</span><span class="p">:</span>
            <span class="n">dT</span><span class="p">,</span> <span class="n">lut_unit</span><span class="p">,</span> <span class="n">Tminmax</span> <span class="o">=</span> <span class="n">intsRD</span><span class="p">,</span><span class="n">lut_unit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">minmaxRD</span>
        <span class="k">elif</span> <span class="n">lut_unit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;%-1&#39;</span><span class="p">:</span>
            <span class="n">dT</span><span class="p">,</span> <span class="n">lut_unit</span><span class="p">,</span> <span class="n">Tminmax</span> <span class="o">=</span> <span class="n">intsRDr</span><span class="p">,</span><span class="n">lut_unit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">minmaxRDr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dT</span><span class="p">,</span> <span class="n">lut_unit</span><span class="p">,</span> <span class="n">Tminmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="p">[[</span><span class="n">T</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span><span class="n">T</span><span class="o">.</span><span class="n">max</span><span class="p">()]]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dT</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span> <span class="n">dT</span> <span class="o">=</span> <span class="n">dT</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">dT</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dT</span><span class="p">)</span>
        <span class="n">Tminmax</span> <span class="o">=</span> <span class="n">Tminmax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Tminmax</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="n">Tminmax</span> 
        
        <span class="c1"># format output:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dT</span><span class="p">,(</span><span class="nb">float</span><span class="p">,</span><span class="nb">int</span><span class="p">)):</span> 
            <span class="k">if</span> <span class="n">tuple_depth_2</span><span class="p">:</span> 
                <span class="k">return</span> <span class="p">((</span><span class="o">*</span><span class="n">Tminmax</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">lut_unit</span><span class="p">),)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">Tminmax</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">lut_unit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Tminmax</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="p">(</span><span class="n">lut_unit</span><span class="p">,)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">dT</span><span class="p">))</span> 
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="nb">tuple</span><span class="p">((</span><span class="nb">tuple</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))),</span><span class="n">lut_unit</span><span class="o">!=</span><span class="s1">&#39;au&#39;</span><span class="p">)</span>
        
 
<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># LUT generation functions:</span>
<span class="c1">#------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="calculate_lut">
<a class="viewcode-back" href="../../../../color.html#luxpy.color.cct.calculate_lut">[docs]</a>
<span class="k">def</span> <span class="nf">calculate_lut</span><span class="p">(</span><span class="n">ccts</span><span class="p">,</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">lut_vars</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;uv&#39;</span><span class="p">,</span><span class="s1">&#39;uvp&#39;</span><span class="p">,</span><span class="s1">&#39;uvpp&#39;</span><span class="p">,</span><span class="s1">&#39;iso-T-slope&#39;</span><span class="p">],</span>
                  <span class="n">cspace</span> <span class="o">=</span> <span class="n">_CCT_CSPACE</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">_CCT_CSPACE_KWARGS</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function that calculates a LUT for the specified calculation method </span>
<span class="sd">    for the input ccts. Calculation is performed for CMF set specified in </span>
<span class="sd">    cieobs and in the chromaticity diagram in cspace. </span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :ccts: </span>
<span class="sd">            | ndarray [Nx1] or str</span>
<span class="sd">            | list of ccts for which to (re-)calculate the LUTs.</span>
<span class="sd">            | If str, ccts contains path/filename.dat to list.</span>
<span class="sd">        :cieobs: </span>
<span class="sd">            | None or str, optional</span>
<span class="sd">            | str specifying cmf set.</span>
<span class="sd">        :wl: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Generate luts based on Planckians with wavelengths (range). </span>
<span class="sd">            | If None: use same wavelengths as CMFs in :cieobs:.</span>
<span class="sd">        :lut_vars:</span>
<span class="sd">            | [&#39;T&#39;,&#39;uv&#39;,&#39;uvp&#39;,&#39;uvpp&#39;,&#39;iso-T-slope&#39;], optional</span>
<span class="sd">            | Data the lut should contain. Must follow this order </span>
<span class="sd">            | and minimum should be [&#39;T&#39;]</span>
<span class="sd">        :cspace:</span>
<span class="sd">            | _CCT_SPACE, optional</span>
<span class="sd">            | Color space to do calculations in. </span>
<span class="sd">            | Options: </span>
<span class="sd">            |    - cspace string: </span>
<span class="sd">            |        e.g. &#39;Yuv60&#39; for use with luxpy.colortf()</span>
<span class="sd">            |    - tuple with forward (i.e. xyz_to..) [and backward (i.e. ..to_xyz)] functions </span>
<span class="sd">            |      (and an optional string describing the cspace): </span>
<span class="sd">            |        e.g. (forward, backward) or (forward, backward, cspace string) or (forward, cspace string) </span>
<span class="sd">            |    - dict with keys: &#39;fwtf&#39; (foward), &#39;bwtf&#39; (backward) [, optional: &#39;str&#39; (cspace string)]</span>
<span class="sd">            |  Note: if the backward tf is not supplied, optimization in cct_to_xyz() is done in the CIE 1976 u&#39;v&#39; diagram</span>
<span class="sd">        :cspace_kwargs:</span>
<span class="sd">            | _CCT_CSPACE_KWARGS, optional</span>
<span class="sd">            | Parameter nested dictionary for the forward and backward transforms.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            :lut:</span>
<span class="sd">                | ndarray with T, u, v, u&#39;, v&#39;, u&quot;, v&quot;, slope (note &#39;:1st deriv., &quot;:2nd deriv.).</span>
<span class="sd">                                            </span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ccts</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">ccts</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">ccts</span><span class="p">)</span>
    
        
    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;uv&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;uvp&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;uvpp&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;iso-T-slope&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">):</span>
        <span class="c1"># no need to calculate anything, only Tcs needed</span>
        <span class="k">return</span> <span class="n">np2d</span><span class="p">(</span><span class="n">ccts</span><span class="p">)</span>


    <span class="c1"># get requested cmf set:</span>
    <span class="n">xyzbar</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">_get_xyzbar_wl_dl</span><span class="p">(</span><span class="n">cieobs</span><span class="p">,</span> <span class="n">wl</span><span class="p">)</span>
    
    <span class="c1"># process cspace input:</span>
    <span class="n">cspace_dict</span><span class="p">,</span> <span class="n">cspace_str</span> <span class="o">=</span> <span class="n">_process_cspace</span><span class="p">(</span><span class="n">cspace</span><span class="p">,</span> <span class="n">cspace_kwargs</span><span class="p">)</span>
    
    <span class="c1"># convert to cspace based cmfs (Eq.6-7):</span>
    <span class="n">uvwbar</span> <span class="o">=</span> <span class="n">_convert_xyzbar_to_uvwbar</span><span class="p">(</span><span class="n">xyzbar</span><span class="p">,</span> <span class="n">cspace_dict</span><span class="p">)</span> 
    
    <span class="c1"># calculate U,V,W (Eq. 6) and U&#39;,V&#39;,W&#39; (Eq.10) [Robertson,1986] and U&quot;,V&quot;,W&quot; [Li,2016; started from XYZ, but this is equivalent]:</span>
    <span class="c1">#Ti, UVW, UVWp, UVWpp = _get_tristim_of_BB_BBp_BBpp(ccts, uvwbar, wl, dl, out = &#39;BB,BBp,BBpp&#39;)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">up</span><span class="p">,</span> <span class="n">vp</span><span class="p">,</span> <span class="n">upp</span><span class="p">,</span> <span class="n">vpp</span><span class="p">,</span> <span class="p">(</span><span class="n">UVW</span><span class="p">,</span> <span class="n">UVWp</span><span class="p">,</span> <span class="n">UVWpp</span><span class="p">)</span> <span class="o">=</span> <span class="n">_get_uv_uvp_uvpp</span><span class="p">(</span><span class="n">ccts</span><span class="p">,</span> <span class="n">uvwbar</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;BB,BBp,BBpp&#39;</span><span class="p">)</span>
    <span class="n">Ti</span> <span class="o">=</span> <span class="n">ccts</span>
    <span class="k">if</span> <span class="s1">&#39;uv&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">:</span> <span class="n">uvi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">))</span>
    <span class="k">if</span> <span class="s1">&#39;uvp&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">:</span> <span class="n">uvpi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">up</span><span class="p">,</span><span class="n">vp</span><span class="p">))</span>
    <span class="k">if</span> <span class="s1">&#39;uvpp&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">:</span> <span class="n">uvppi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">upp</span><span class="p">,</span><span class="n">vpp</span><span class="p">))</span>


    <span class="c1"># calculate li, mi (= slope of iso-T-lines):</span>
    <span class="k">if</span> <span class="s1">&#39;iso-T-slope&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">:</span>
        
        <span class="n">R</span> <span class="o">=</span> <span class="n">UVW</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="c1"># for Ohno, 2014 &amp; Robertson, 1968 &amp; Li, 2016</span>
        <span class="k">if</span> <span class="n">UVWp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">Rp</span> <span class="o">=</span> <span class="n">UVWp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="c1"># for Robertson, 1968 &amp; Li, 2016</span>
        <span class="c1"># if UVWpp is not None: Rpp = UVWpp.sum(axis=-1, keepdims = True) # for Li, 2016</span>

        <span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="n">UVWp</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">R</span> <span class="o">-</span> <span class="n">UVW</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">Rp</span><span class="p">)</span> 
        <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span><span class="n">UVWp</span><span class="p">[:,:</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">R</span> <span class="o">-</span> <span class="n">UVW</span><span class="p">[:,:</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">Rp</span><span class="p">)</span>
        
        <span class="c1"># avoid div by zero:</span>
        <span class="n">num</span><span class="p">[(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">_CCT_AVOID_ZERO_DIV</span>
        <span class="n">denom</span><span class="p">[(</span><span class="n">denom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">_CCT_AVOID_ZERO_DIV</span>
    
        <span class="n">li</span> <span class="o">=</span> <span class="n">num</span><span class="o">/</span><span class="n">denom</span>  
        <span class="n">li</span> <span class="o">=</span> <span class="n">li</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">li</span><span class="p">)</span><span class="o">*</span><span class="n">_CCT_AVOID_ZERO_DIV</span> <span class="c1"># avoid division by zero</span>
        <span class="n">mi</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="n">li</span> <span class="c1"># slope of isotemperature lines</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mi</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="c1"># get u,v &amp; u&#39;,v&#39; and u&quot;,v&quot;:</span>
    <span class="c1"># uvi = UVW[:,:2]/R</span>
    <span class="c1"># if UVWp is not None: uvpi = UVWp[:,:2]/Rp</span>
    <span class="c1"># if UVWpp is not None: uvppi = UVWpp[:,:2]/Rpp</span>

    
    <span class="c1"># construct output (use comple if structure to avoid creating intermediate arrays for optimal speed):</span>
    <span class="k">if</span>   <span class="p">(</span><span class="s1">&#39;uvp&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;uvpp&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;iso-T-slope&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">):</span>
        <span class="n">lut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Ti</span><span class="p">,</span><span class="n">uvi</span><span class="p">,</span><span class="n">uvpi</span><span class="p">,</span><span class="n">uvppi</span><span class="p">,</span><span class="n">mi</span><span class="p">))</span>
    <span class="k">elif</span> <span class="p">(</span><span class="s1">&#39;uvp&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;uvpp&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;iso-T-slope&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">):</span>
        <span class="n">lut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Ti</span><span class="p">,</span><span class="n">uvi</span><span class="p">))</span>
        
    <span class="k">elif</span> <span class="p">(</span><span class="s1">&#39;uvp&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;uvpp&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;iso-T-slope&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">):</span>
        <span class="n">lut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Ti</span><span class="p">,</span><span class="n">uvi</span><span class="p">,</span> <span class="n">uvpi</span><span class="p">,</span> <span class="n">mi</span><span class="p">))</span>
    <span class="k">elif</span> <span class="p">(</span><span class="s1">&#39;uvp&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;uvpp&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;iso-T-slope&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">):</span>
        <span class="n">lut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Ti</span><span class="p">,</span><span class="n">uvi</span><span class="p">,</span> <span class="n">uvpi</span><span class="p">))</span>
    <span class="k">elif</span> <span class="p">(</span><span class="s1">&#39;uvp&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;uvpp&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;iso-T-slope&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">):</span>
        <span class="n">lut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Ti</span><span class="p">,</span><span class="n">uvi</span><span class="p">,</span> <span class="n">uvpi</span><span class="p">,</span> <span class="n">uvppi</span><span class="p">))</span>
        
    <span class="k">elif</span> <span class="p">(</span><span class="s1">&#39;uvp&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;uvpp&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;iso-T-slope&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">):</span>
        <span class="n">lut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Ti</span><span class="p">,</span><span class="n">uvi</span><span class="p">,</span> <span class="n">uvppi</span><span class="p">,</span> <span class="n">mi</span><span class="p">))</span>
    <span class="k">elif</span> <span class="p">(</span><span class="s1">&#39;uvp&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;uvpp&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;iso-T-slope&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">):</span>
        <span class="n">lut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Ti</span><span class="p">,</span><span class="n">uvi</span><span class="p">,</span> <span class="n">uvppi</span><span class="p">))</span>
           
    <span class="k">elif</span> <span class="p">(</span><span class="s1">&#39;uvp&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;uvpp&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;iso-T-slope&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">):</span>
        <span class="n">lut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Ti</span><span class="p">,</span><span class="n">uvi</span><span class="p">,</span><span class="n">mi</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">lut</span> </div>



    
<div class="viewcode-block" id="_generate_lut">
<a class="viewcode-back" href="../../../../color.html#luxpy.color.cct._generate_lut">[docs]</a>
<span class="k">def</span> <span class="nf">_generate_lut</span><span class="p">(</span><span class="n">tc4</span><span class="p">,</span> <span class="n">uin</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">seamless_stitch</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
                  <span class="n">fallback_unit</span> <span class="o">=</span> <span class="n">_CCT_FALLBACK_UNIT</span><span class="p">,</span> <span class="n">fallback_n</span> <span class="o">=</span> <span class="n">_CCT_FALLBACK_UNIT</span><span class="p">,</span>
                  <span class="n">resample_ndarray</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                  <span class="n">cct_max</span> <span class="o">=</span> <span class="n">_CCT_MAX</span><span class="p">,</span> <span class="n">cct_min</span> <span class="o">=</span> <span class="n">_CCT_MIN</span><span class="p">,</span>
                  <span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">_CIEOBS</span><span class="p">,</span> <span class="n">lut_vars</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;uv&#39;</span><span class="p">,</span><span class="s1">&#39;uvp&#39;</span><span class="p">,</span><span class="s1">&#39;uvpp&#39;</span><span class="p">,</span><span class="s1">&#39;iso-T-slope&#39;</span><span class="p">],</span>
                  <span class="n">cspace</span> <span class="o">=</span> <span class="n">_CCT_CSPACE</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">_CCT_CSPACE_KWARGS</span><span class="p">,</span>
                  <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Get an ndarray LUT for Tc&#39;s obtained from a list or tuple of tc4 4-vectors (or ndarray).</span>
<span class="sd">        </span>
<span class="sd">    Args:</span>
<span class="sd">        :tc4:</span>
<span class="sd">            | list or tuple of 4-vectors or ndarray.</span>
<span class="sd">            | If ndarray: return tc4 limited to a cct_min-cct_max range (do nothing else).</span>
<span class="sd">            | If list/tuple: e.g. (tc4_1, tc4_2, tc4_3,...) or (tc4_1, tc4_2, tc4_3,..., bool::seamless_stitch)</span>
<span class="sd">            | When the last element of the list/tuple is a bool, then this specifies</span>
<span class="sd">            |  how the Tc arrays generated for each of the 4-vector elements need to be</span>
<span class="sd">            |  stitched together. This overrides the seamless_stitch input argument.</span>
<span class="sd">            | Vector elements are: </span>
<span class="sd">            |    [Tmin, Tmax inclusive, Tinterval(or number of intervals), unit]</span>
<span class="sd">            |  Unit specifies unit of the Tc interval, i.e. it determines the</span>
<span class="sd">            |       type of scale in which the spacing of the Tc are done.</span>
<span class="sd">            |  Unit options are:</span>
<span class="sd">            |   - &#39;%&#39;: equal relative Tc spacing (in %, cfr. (Ti+1 - Ti-1)/Ti-1).</span>
<span class="sd">            |   - &#39;K&#39; equal absolute Tc spacing (in K, cfr. (Ti+1 - Ti-1).</span>
<span class="sd">            |   - &#39;%-1&#39;: equal relative reciprocal Tc (MK-1 = mired).</span>
<span class="sd">            |   - &#39;K-1&#39;: equal absolute reciprocal Tc (MK-1 = mired).</span>
<span class="sd">            |  If the &#39;interval&#39; element is negative, it actually represents</span>
<span class="sd">            |   the number of intervals between Tmin, Tmax (included).</span>
<span class="sd">        :uin:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Unit of input Tmin, Tmax (by default it is assumed to be the same</span>
<span class="sd">            | as the scale &#39;unit&#39;).</span>
<span class="sd">        :seamless_stitch:</span>
<span class="sd">            | True, optional</span>
<span class="sd">            | Determines how the Tc arrays generated for each of the 4-vector </span>
<span class="sd">            | elements are stitched together. Is overriden by the presence of a </span>
<span class="sd">            | bool as last list/tuple element in :tc4:.</span>
<span class="sd">            | For a seamless stitch, all units for all 4-vectors should be the same!!</span>
<span class="sd">        :cct_max:</span>
<span class="sd">            | _CCT_MAX, optional</span>
<span class="sd">            | Limit Tc&#39;s to a maximum value of cct_max</span>
<span class="sd">        :cct_min:</span>
<span class="sd">            | _CCT_MIN, optional</span>
<span class="sd">            | Limit Tc&#39;s to a minimum value of cct_max</span>
<span class="sd">        :fallback_unit:</span>
<span class="sd">            | _CCT_FALLBACK_UNIT, optional</span>
<span class="sd">            | Unit to fall back on when the input unit in tc4 (of first list) is &#39;au&#39;.</span>
<span class="sd">            | As there is no common distancing of the unit types [&#39;K&#39;,&#39;%&#39;,&#39;%-1&#39;,&#39;K-1&#39;]</span>
<span class="sd">            | the Tc&#39;s are generated by dividing the min-max range into </span>
<span class="sd">            | a number of divisions, specified by the negative 3 element (or when</span>
<span class="sd">            | positive or NaN, the number of divisions is set by :fallback_divisions:)</span>
<span class="sd">        :fallback_n:</span>
<span class="sd">            | _CCT_FALLBACK_N, optional</span>
<span class="sd">            | Number of divisions the min-max range is divided into, in the </span>
<span class="sd">            | fallback case in which unit==&#39;au&#39; and the 3e 4-vector element </span>
<span class="sd">            | is NaN or positive.</span>
<span class="sd">        :resample_tc4_array:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | If False: do not resample Tc&#39;s of an ndarray input for tc4</span>
<span class="sd">            | else: divide min-max range in fallback_n intervals. Uses fallback_unit</span>
<span class="sd">            | to determine the scale for the resampling.</span>
<span class="sd">        :wl:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Wavelength for Planckian spectrum generation.</span>
<span class="sd">            | If None: use same wavelengths as CMFs in :cieobs:.</span>
<span class="sd">        :cieobs:</span>
<span class="sd">            | [_CIEOBS] or list, optional</span>
<span class="sd">            | Generate a LUT for each one in the list.</span>
<span class="sd">            | If None: generate for all cmfs in _CMF.</span>
<span class="sd">        :lut_vars:</span>
<span class="sd">            | [&#39;T&#39;,&#39;uv&#39;,&#39;uvp&#39;,&#39;uvpp&#39;,&#39;iso-T-slope&#39;], optional</span>
<span class="sd">            | Data the lut should contain. Must follow this order </span>
<span class="sd">            | and minimum should be [&#39;T&#39;]</span>
<span class="sd">        :cspace,cspace_kwargs:</span>
<span class="sd">            | Lists with the cspace and cspace_kwargs for which luts will be generated.</span>
<span class="sd">            | Default is single chromaticity diagram in _CCT_CSPACE.</span>

<span class="sd">    Returns:</span>
<span class="sd">        :lut:</span>
<span class="sd">            | List with an ndarray with in the columns whatever is specified in </span>
<span class="sd">            | lut_vars (Tc and uv are always present!).</span>
<span class="sd">            | Default lut_vars =  [&#39;T&#39;,&#39;uv&#39;,&#39;uvp&#39;,&#39;uvpp&#39;,&#39;iso-T-slope&#39;]</span>
<span class="sd">            | - Tc: (in K)</span>
<span class="sd">            | - u,v: chromaticity coordinates of planckians</span>
<span class="sd">            | - u&#39;v&#39;: chromaticity coordinates of 1st derivative of the planckians.</span>
<span class="sd">            | - u&quot;,v&quot;: chromaticity coordinates of 2nd derivative of the planckians.</span>
<span class="sd">            | - slope of isotemperature lines (calculated as in Robertson, 1968).</span>
<span class="sd">        :lut_kwargs:</span>
<span class="sd">            | {},</span>
<span class="sd">            | Dictionary with additional parameters related to the generation of the</span>
<span class="sd">            | lut.</span>
<span class="sd">            </span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="c1"># get tcs:</span>
    <span class="n">Ts</span> <span class="o">=</span> <span class="n">_generate_tcs</span><span class="p">(</span><span class="n">tc4</span><span class="p">,</span> <span class="n">uin</span> <span class="o">=</span> <span class="n">uin</span><span class="p">,</span> <span class="n">seamless_stitch</span> <span class="o">=</span> <span class="n">seamless_stitch</span><span class="p">,</span>
                       <span class="n">fallback_unit</span> <span class="o">=</span> <span class="n">fallback_unit</span><span class="p">,</span> 
                       <span class="n">fallback_n</span> <span class="o">=</span> <span class="n">fallback_n</span><span class="p">,</span>
                       <span class="n">cct_min</span> <span class="o">=</span> <span class="n">cct_min</span><span class="p">,</span> <span class="n">cct_max</span> <span class="o">=</span> <span class="n">cct_max</span><span class="p">,</span>
                       <span class="n">resample_ndarray</span> <span class="o">=</span> <span class="n">resample_ndarray</span><span class="p">)</span>
     
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lut_vars</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">lut_vars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;T&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">([</span><span class="n">Ts</span><span class="p">,{}])</span> <span class="c1">#no need to do anythin, except output lut containining Tcs only</span>
    <span class="k">else</span><span class="p">:</span>
        
        <span class="c1"># reshape for input in calculate_luts:</span>
        <span class="n">n_sources</span> <span class="o">=</span> <span class="n">Ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">n_sources</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">Ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Ts</span><span class="p">,(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    
        <span class="c1"># calculate lut:</span>
        <span class="n">lut</span> <span class="o">=</span> <span class="n">calculate_lut</span><span class="p">(</span><span class="n">ccts</span> <span class="o">=</span> <span class="n">Ts</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">lut_vars</span> <span class="o">=</span> <span class="n">lut_vars</span><span class="p">,</span>
                            <span class="n">cspace</span> <span class="o">=</span> <span class="n">cspace</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">cspace_kwargs</span><span class="p">)</span>
    
        
        <span class="c1"># reshape lut back:</span>
        <span class="k">if</span> <span class="n">n_sources</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">lut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">lut</span><span class="p">,(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">lut</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">n_sources</span><span class="p">))</span>
          
        
        <span class="k">return</span> <span class="nb">list</span><span class="p">([</span><span class="n">lut</span><span class="p">,</span> <span class="p">{}])</span></div>


    
<div class="viewcode-block" id="_get_lut">
<a class="viewcode-back" href="../../../../color.html#luxpy.color.cct._get_lut">[docs]</a>
<span class="k">def</span> <span class="nf">_get_lut</span><span class="p">(</span><span class="n">lut</span><span class="p">,</span> 
             <span class="n">uin</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">seamless_stitch</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
             <span class="n">fallback_unit</span> <span class="o">=</span> <span class="n">_CCT_FALLBACK_UNIT</span><span class="p">,</span> <span class="n">fallback_n</span> <span class="o">=</span> <span class="n">_CCT_FALLBACK_N</span><span class="p">,</span>
             <span class="n">resample_ndarray</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">cct_max</span> <span class="o">=</span> <span class="n">_CCT_MAX</span><span class="p">,</span> <span class="n">cct_min</span> <span class="o">=</span> <span class="n">_CCT_MIN</span><span class="p">,</span>
             <span class="n">luts_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">lut_type_def</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">lut_vars</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;uv&#39;</span><span class="p">,</span><span class="s1">&#39;uvp&#39;</span><span class="p">,</span><span class="s1">&#39;uvpp&#39;</span><span class="p">,</span><span class="s1">&#39;iso-T-slope&#39;</span><span class="p">],</span>
             <span class="n">cieobs</span> <span class="o">=</span>  <span class="n">_CIEOBS</span><span class="p">,</span> <span class="n">cspace_str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ignore_unequal_wl</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
             <span class="n">lut_generator_fcn</span> <span class="o">=</span> <span class="n">_generate_lut</span><span class="p">,</span> <span class="n">lut_generator_kwargs</span> <span class="o">=</span> <span class="p">{},</span>
             <span class="n">cspace</span> <span class="o">=</span> <span class="n">_CCT_CSPACE</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">_CCT_CSPACE_KWARGS</span><span class="p">,</span>
             <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Get an ndarray LUT from various sources.</span>
<span class="sd">        </span>
<span class="sd">    Args:</span>
<span class="sd">        :lut:</span>
<span class="sd">            | Look-Up-Table with Ti, u,v,u&#39;,v&#39;,u&quot;,v&quot;,slope values of Planckians, or</span>
<span class="sd">            | whatever quantities are specified in lut_vars (&#39;T&#39;,&#39;uv&#39; is always part of the lut).</span>
<span class="sd">            | Options: </span>
<span class="sd">            | - list: must have two elements: [lut,lut_kwargs]</span>
<span class="sd">            | - None: lut from luts_dict with lut_type_def as key</span>
<span class="sd">            | - str: lut from luts_dict at key :lut:</span>
<span class="sd">            | - ndarray [Nxn, with n&gt;1]: precalculated lut (only processing will be to keep it with cct_min-cct_max range)</span>
<span class="sd">            | - ndarray [Nx1]: list of Tc&#39;s from which a new lut will be calculated.</span>
<span class="sd">            | - tuple of 4-vectors: used as key in luts_dict or to generate new lut from scratch</span>
<span class="sd">            |    4-vector info: </span>
<span class="sd">            |       + format: e.g. (tc4_1, tc4_2, tc4_3,...) or (tc4_1, tc4_2, tc4_3,..., bool::seamless_stitch)</span>
<span class="sd">            |       + When the last element of the list/tuple is a bool, then this specifies</span>
<span class="sd">            |         how the Tc arrays generated for each of the 4-vector elements need to be</span>
<span class="sd">            |         stitched together. This overrides the seamless_stitch input argument.</span>
<span class="sd">            |       + Vector elements are: </span>
<span class="sd">            |           [Tmin, Tmax inclusive, Tinterval(or number of intervals), unit]</span>
<span class="sd">            |         Unit specifies unit of the Tc interval, i.e. it determines the</span>
<span class="sd">            |         type of scale in which the spacing of the Tc are done.</span>
<span class="sd">            |         Unit options are:</span>
<span class="sd">            |           - &#39;%&#39;: equal relative Tc spacing (in %, cfr. (Ti+1 - Ti-1)/Ti-1).</span>
<span class="sd">            |           - &#39;K&#39; equal absolute Tc spacing (in K, cfr. (Ti+1 - Ti-1).</span>
<span class="sd">            |           - &#39;%-1&#39;: equal relative reciprocal Tc (MK-1 = mired).</span>
<span class="sd">            |           - &#39;K-1&#39;: equal absolute reciprocal Tc (MK-1 = mired).</span>
<span class="sd">            |         If the &#39;interval&#39; element is negative, it actually represents</span>
<span class="sd">            |         the number of intervals between Tmin, Tmax (included).</span>
<span class="sd">        :uin:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Unit of input Tmin, Tmax (by default it is assumed to be the same</span>
<span class="sd">            | as the scale &#39;unit&#39;) in Tc generation from tuple.</span>
<span class="sd">        :seamless_stitch:</span>
<span class="sd">            | True, optional</span>
<span class="sd">            | Determines how the Tc arrays generated for each of the 4-vector </span>
<span class="sd">            | elements are stitched together. Is overriden by the presence of a </span>
<span class="sd">            | bool as last list/tuple element in :tc4:.</span>
<span class="sd">            | For a seamless stitch, all units for all 4-vectors should be the same!!</span>
<span class="sd">        :cct_max:</span>
<span class="sd">            | _CCT_MAX, optional</span>
<span class="sd">            | Limit Tc&#39;s to a maximum value of cct_max</span>
<span class="sd">        :cct_min:</span>
<span class="sd">            | _CCT_MIN, optional</span>
<span class="sd">            | Limit Tc&#39;s to a minimum value of cct_max</span>
<span class="sd">        :fallback_unit:</span>
<span class="sd">            | _CCT_FALLBACK_UNIT, optional</span>
<span class="sd">            | Unit to fall back on when the input unit in tc4 (of first list) is &#39;au&#39;.</span>
<span class="sd">            | As there is no common distancing of the unit types [&#39;K&#39;,&#39;%&#39;,&#39;%-1&#39;,&#39;K-1&#39;]</span>
<span class="sd">            | the Tc&#39;s are generated by dividing the min-max range into </span>
<span class="sd">            | a number of divisions, specified by the negative 3 element (or when</span>
<span class="sd">            | positive or NaN, the number of divisions is set by :fallback_divisions:)</span>
<span class="sd">        :fallback_n:</span>
<span class="sd">            | _CCT_FALLBACK_N, optional</span>
<span class="sd">            | Number of divisions the min-max range is divided into, in the </span>
<span class="sd">            | fallback case in which unit==&#39;au&#39; and the 3e 4-vector element </span>
<span class="sd">            | is NaN or positive.</span>
<span class="sd">        :resample_tc4_array:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | If False: do not resample Tc&#39;s of an ndarray input for tc4</span>
<span class="sd">            | else: divide min-max range in fallback_n intervals. Uses fallback_unit</span>
<span class="sd">            | to determine the scale for the resampling.</span>
<span class="sd">        :wl:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Wavelength for Planckian spectrum generation.</span>
<span class="sd">            | If None: use same wavelengths as CMFs in :cieobs:.</span>
<span class="sd">        :cieobs:</span>
<span class="sd">            | _CIEOBS, optional</span>
<span class="sd">            | CMF set used to convert Planckian spectra to chromaticity coordinates</span>
<span class="sd">        :lut_type_def:</span>
<span class="sd">            | None, placeholder</span>
<span class="sd">            | Default lut (tuple key) to read from luts_dict.</span>
<span class="sd">        :luts_dict:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Dictionary of pre-calculated luts for various cspaces and cmf sets.</span>
<span class="sd">            |  Must have structure luts_dict[cspace][cieobs][lut_label] with the</span>
<span class="sd">            |   lut part of a two-element list [lut, lut_kwargs]. It must contain</span>
<span class="sd">            |   at the top-level a key &#39;wl&#39; containing the wavelengths of the </span>
<span class="sd">            |   Planckians used to generate the luts in this dictionary.</span>
<span class="sd">            | If None: the default dict for the mode is used </span>
<span class="sd">            |   (e.g. _CCT_LUT[&#39;ohno2014&#39;][&#39;lut_type_def&#39;], for mode==&#39;ohno2014&#39;).    </span>
<span class="sd">        :lut_vars:</span>
<span class="sd">            | [&#39;T&#39;,&#39;uv&#39;,&#39;uvp&#39;,&#39;uvpp&#39;,&#39;iso-T-slope&#39;], optional</span>
<span class="sd">            | Data the lut should contain. Must follow this order </span>
<span class="sd">            | and minimum should be [&#39;T&#39;]</span>
<span class="sd">        :cspace,cspace_kwargs:</span>
<span class="sd">            | Lists with the cspace and cspace_kwargs for which luts will be generated.</span>
<span class="sd">            | Default is single chromaticity diagram in _CCT_CSPACE.</span>
<span class="sd">        :ignore_unequal_wl:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | If True: ignore any differences in the wavelengths used to calculate</span>
<span class="sd">            |   the lut (cfr. Planckians) from the luts_dict and the requested </span>
<span class="sd">            |   wavelengths in :wl:</span>
<span class="sd">        :lut_generator_fcn:</span>
<span class="sd">            | _generate_lut, optional</span>
<span class="sd">            | Lets a user specify his own lut generation function (must output a list of 1 lut). </span>
<span class="sd">            | Default is the general function. There is a specific one for</span>
<span class="sd">            | Ohno&#39;s 2014 method as that one requires a different correction factor</span>
<span class="sd">            | for each lut for the parabolic solutions. This optimized value is specified in the </span>
<span class="sd">            | second list index. (see _generate_lut_ohno2014()).</span>
<span class="sd">        :lut_generator_kwargs:</span>
<span class="sd">            | {}, optional</span>
<span class="sd">            | Dict with keyword arguments specific to the (user) lut_generator_fcn.</span>
<span class="sd">            |  (e.g. {&#39;f_corr&#39;:0.9991} for _generate_lut_ohno2014())  </span>

<span class="sd">    Returns:</span>
<span class="sd">        :lut:</span>
<span class="sd">            | List with an ndarray with in the columns whatever is specified in </span>
<span class="sd">            | lut_vars (Tc and uv are always present!).</span>
<span class="sd">            | Default lut_vars =  [&#39;T&#39;,&#39;uv&#39;,&#39;uvp&#39;,&#39;uvpp&#39;,&#39;iso-T-slope&#39;]</span>
<span class="sd">            | - Tc: (in K)</span>
<span class="sd">            | - u,v: chromaticity coordinates of planckians</span>
<span class="sd">            | - u&#39;v&#39;: chromaticity coordinates of 1st derivative of the planckians.</span>
<span class="sd">            | - u&quot;,v&quot;: chromaticity coordinates of 2nd derivative of the planckians.</span>
<span class="sd">            | - slope of isotemperature lines (calculated as in Robertson, 1968).</span>
<span class="sd">        :lut_kwargs:</span>
<span class="sd">            | {}</span>
<span class="sd">            | Dictionary with additional parameters related to the generation of the</span>
<span class="sd">            | lut.</span>
<span class="sd">            </span>
<span class="sd">    &quot;&quot;&quot;</span>  
    <span class="c1"># get cspace info:</span>
    <span class="n">cspace_dict</span><span class="p">,</span> <span class="n">cspace_str</span> <span class="o">=</span> <span class="n">_process_cspace</span><span class="p">(</span><span class="n">cspace</span><span class="p">,</span> <span class="n">cspace_kwargs</span><span class="p">)</span>

    <span class="n">lut_kwargs</span> <span class="o">=</span> <span class="n">lut_generator_kwargs</span> <span class="c1"># default settings, but can be overriden later depending on the lut input argument</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lut</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span> <span class="c1"># should contain [(tuple,list,ndarray)::lut,dict::lut_kwargs]</span>
        <span class="n">lut_list_error</span> <span class="o">=</span> <span class="kc">True</span> 
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lut</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">lut</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="nb">dict</span><span class="p">)):</span> <span class="c1"># test for lut_kwargs presence </span>
                <span class="n">lut_kwargs</span> <span class="o">=</span> <span class="n">lut</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">lut</span> <span class="o">=</span> <span class="n">lut</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">lut_list_error</span> <span class="o">=</span> <span class="kc">False</span>
 
        <span class="k">if</span> <span class="n">lut_list_error</span><span class="p">:</span> 
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;When lut input is a list, the first element </span>
<span class="s2">contains the lut as a tuple/list, tuple/list of </span>
<span class="s2">tuples/lists or as an ndarray; the second element</span>
<span class="s2">should be a dictionary &#39;lut_kwargs&#39;.&quot;&quot;&quot;</span><span class="p">)</span>
    
    
    <span class="n">luts_dict_empty</span> <span class="o">=</span> <span class="kc">False</span> 
    <span class="c1"># lut_from_dict = False</span>
    <span class="n">lut_from_tuple</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># lut_from_str = False</span>
    <span class="n">lut_from_Tcs</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">lut_from_array</span> <span class="o">=</span> <span class="kc">False</span> 
    <span class="n">unequal_wl</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">lut_tuple</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># print(luts_dict[cspace_str][cieobs].keys(),lut)</span>
    <span class="k">if</span> <span class="n">lut</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">lut</span> <span class="o">=</span> <span class="n">lut_type_def</span> <span class="c1"># use default type in luts_dict</span>
 
    <span class="c1"># further process lut (1st element of input lut): </span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lut</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span><span class="nb">str</span><span class="p">)):</span> <span class="c1"># lut is key in luts_dict, if not generate new lut from scratch</span>
        <span class="n">lut_from_tuple</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">lut_tuple</span> <span class="o">=</span> <span class="n">lut</span> <span class="c1"># keep copy to use later as key</span>

        <span class="k">if</span> <span class="n">luts_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># luts_dict is None: generate a new lut from scratch</span>
            <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;wl&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">luts_dict</span><span class="p">):</span> 
                <span class="n">luts_dict_empty</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># if not present luts_dict must be empty </span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cieobs</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">luts_dict</span><span class="p">[</span><span class="s1">&#39;wl&#39;</span><span class="p">]:</span>
                    <span class="n">luts_dict_empty</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># is empty for this cieobs</span>
                    
            <span class="k">if</span> <span class="n">cieobs</span> <span class="ow">in</span> <span class="n">luts_dict</span><span class="p">[</span><span class="n">cspace_str</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">lut</span> <span class="ow">in</span> <span class="n">luts_dict</span><span class="p">[</span><span class="n">cspace_str</span><span class="p">][</span><span class="n">cieobs</span><span class="p">]:</span> <span class="c1"># read from luts_dict</span>
                    <span class="n">lut</span><span class="p">,</span> <span class="n">lut_kwargs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">luts_dict</span><span class="p">[</span><span class="n">cspace_str</span><span class="p">][</span><span class="n">cieobs</span><span class="p">][</span><span class="n">lut</span><span class="p">])</span>
                    <span class="n">lut_from_tuple</span> <span class="o">=</span> <span class="kc">False</span>
    
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lut</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span> <span class="c1"># lut is either pre-calculated lut or a list with Tcs for which a lut needs to be generated</span>
        <span class="n">lut_from_array</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">lut</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">lut</span> <span class="o">=</span> <span class="n">lut</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> <span class="c1"># make 2D</span>
        <span class="k">if</span> <span class="n">lut</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">lut_from_Tcs</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">lut_from_array</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># signal that the lut doesn&#39;t exist yet!</span>

    <span class="c1"># If pre-calculated from luts_dict, check if wavelengths agree.</span>
    <span class="c1"># When directly entered as ndarray there is no way to check, </span>
    <span class="c1"># so assume unequal_wl==False:</span>
    <span class="k">if</span> <span class="n">ignore_unequal_wl</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">luts_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">luts_dict_empty</span> <span class="o">==</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">luts_dict</span><span class="p">[</span><span class="s1">&#39;wl&#39;</span><span class="p">][</span><span class="n">cieobs</span><span class="p">],</span> <span class="n">wl</span><span class="p">):</span>
                <span class="n">unequal_wl</span> <span class="o">=</span> <span class="kc">True</span>    

    <span class="k">if</span> <span class="p">(</span><span class="n">unequal_wl</span>  <span class="o">|</span> <span class="n">luts_dict_empty</span><span class="o">|</span> <span class="n">lut_from_tuple</span> <span class="o">|</span> <span class="n">lut_from_Tcs</span> <span class="o">|</span> <span class="n">resample_ndarray</span><span class="p">):</span>
    
        <span class="k">if</span> <span class="n">cspace_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;No cspace dict or other given !&#39;</span><span class="p">)</span>
    
    
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">lut_from_array</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">resample_ndarray</span><span class="p">):</span>

            <span class="n">lut</span><span class="p">,</span> <span class="n">lut_kwargs</span> <span class="o">=</span> <span class="n">lut_generator_fcn</span><span class="p">(</span><span class="n">lut</span><span class="p">,</span> 
                                                <span class="n">uin</span> <span class="o">=</span> <span class="n">uin</span><span class="p">,</span>
                                                <span class="n">seamless_stitch</span> <span class="o">=</span> <span class="n">seamless_stitch</span><span class="p">,</span>
                                                <span class="n">fallback_unit</span> <span class="o">=</span> <span class="n">fallback_unit</span><span class="p">,</span>
                                                <span class="n">fallback_n</span> <span class="o">=</span> <span class="n">fallback_n</span><span class="p">,</span>
                                                <span class="n">resample_ndarray</span> <span class="o">=</span> <span class="n">resample_ndarray</span><span class="p">,</span>
                                                <span class="n">cct_max</span> <span class="o">=</span> <span class="n">cct_max</span><span class="p">,</span>
                                                <span class="n">cct_min</span> <span class="o">=</span> <span class="n">cct_min</span><span class="p">,</span>
                                                <span class="n">lut_vars</span> <span class="o">=</span> <span class="n">lut_vars</span><span class="p">,</span>
                                                <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> 
                                                <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> 
                                                <span class="n">cspace</span> <span class="o">=</span> <span class="n">cspace_dict</span><span class="p">,</span>
                                                <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                                <span class="o">**</span><span class="n">lut_kwargs</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">luts_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cieobs</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">luts_dict</span><span class="p">[</span><span class="s1">&#39;wl&#39;</span><span class="p">]:</span>
                    <span class="n">luts_dict</span><span class="p">[</span><span class="s1">&#39;wl&#39;</span><span class="p">][</span><span class="n">cieobs</span><span class="p">]</span> <span class="o">=</span> <span class="n">wl</span>
                <span class="k">if</span> <span class="n">cieobs</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">luts_dict</span><span class="p">[</span><span class="n">cspace_str</span><span class="p">]:</span>
                    <span class="n">luts_dict</span><span class="p">[</span><span class="n">cspace_str</span><span class="p">][</span><span class="n">cieobs</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># create empty dict for new cieobs</span>
                <span class="k">if</span> <span class="n">lut_tuple</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
                    <span class="n">luts_dict</span><span class="p">[</span><span class="n">cspace_str</span><span class="p">][</span><span class="n">cieobs</span><span class="p">][</span><span class="n">lut_tuple</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">lut</span><span class="p">,</span> <span class="n">lut_kwargs</span><span class="p">]</span> <span class="c1"># store for later use</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">lut</span> <span class="o">=</span> <span class="n">lut</span><span class="p">[(</span><span class="n">lut</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">cct_min</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">lut</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">cct_max</span><span class="p">),:]</span>
            

    <span class="k">return</span> <span class="nb">list</span><span class="p">([</span><span class="n">lut</span><span class="p">,</span> <span class="n">lut_kwargs</span><span class="p">])</span></div>

  

<div class="viewcode-block" id="generate_luts">
<a class="viewcode-back" href="../../../../color.html#luxpy.color.cct.generate_luts">[docs]</a>
<span class="k">def</span> <span class="nf">generate_luts</span><span class="p">(</span><span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">],</span> <span class="n">seamless_stitch</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                  <span class="n">fallback_unit</span> <span class="o">=</span> <span class="n">_CCT_FALLBACK_UNIT</span><span class="p">,</span> <span class="n">fallback_n</span> <span class="o">=</span> <span class="n">_CCT_FALLBACK_N</span><span class="p">,</span>
                  <span class="n">cct_min</span> <span class="o">=</span> <span class="n">_CCT_MIN</span><span class="p">,</span> <span class="n">cct_max</span> <span class="o">=</span> <span class="n">_CCT_MAX</span><span class="p">,</span>
                  <span class="n">lut_file</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">load</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">lut_path</span> <span class="o">=</span> <span class="n">_CCT_LUT_PATH</span><span class="p">,</span> <span class="n">save_luts</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
                  <span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="p">[</span><span class="n">_CIEOBS</span><span class="p">],</span> 
                  <span class="n">lut_vars</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;uv&#39;</span><span class="p">,</span><span class="s1">&#39;uvp&#39;</span><span class="p">,</span><span class="s1">&#39;uvpp&#39;</span><span class="p">,</span><span class="s1">&#39;iso-T-slope&#39;</span><span class="p">],</span>
                  <span class="n">cspace</span> <span class="o">=</span> <span class="p">[</span><span class="n">_CCT_CSPACE</span><span class="p">],</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="p">[</span><span class="n">_CCT_CSPACE_KWARGS</span><span class="p">],</span>
                  <span class="n">verbosity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lut_generator_fcn</span> <span class="o">=</span> <span class="n">_generate_lut</span><span class="p">,</span> 
                  <span class="n">lut_generator_kwargs</span> <span class="o">=</span> <span class="p">{}):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a number of luts and store them in a nested dictionary.</span>
<span class="sd">    Structure: lut[cspace][cieobs][lut type].</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :lut_file:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | string specifying the filename to save the lut (as .pkl) to.</span>
<span class="sd">            | If None: don&#39;t save anything when generated (i.e. load==False).</span>
<span class="sd">        :load:</span>
<span class="sd">            | True, optional</span>
<span class="sd">            | If True: load previously generated dictionary.</span>
<span class="sd">            | If False: generate from scratch.</span>
<span class="sd">        :lut_path:</span>
<span class="sd">            | _CCT_LUT_PATH, optional</span>
<span class="sd">            | Path to file.</span>
<span class="sd">        :wl:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Wavelength for Planckian spectrum generation.</span>
<span class="sd">            | If None: use same wavelengths as CMFs in :cieobs:.</span>
<span class="sd">        :cieobs:</span>
<span class="sd">            | [_CIEOBS] or list, optional</span>
<span class="sd">            | Generate a LUT for each one in the list.</span>
<span class="sd">            | If None: generate for all cmfs in _CMF.</span>
<span class="sd">        :types:</span>
<span class="sd">            | [None], optional</span>
<span class="sd">            | List of lut specifiers of format [(Tmin,Tmax,Tinterval,unit),...]</span>
<span class="sd">            | If units are in MK-1 then the range is also!</span>
<span class="sd">            |  Unit options are:</span>
<span class="sd">            |  - &#39;%&#39;: equal relative Tc spacing (in %, cfr. (Ti+1 - Ti-1)/Ti-1).</span>
<span class="sd">            |  - &#39;K&#39; equal absolute Tc spacing (in K, cfr. (Ti+1 - Ti-1).</span>
<span class="sd">            |  - &#39;%-1&#39;: equal relative reciprocal Tc (MK-1 = mired).</span>
<span class="sd">            |  - &#39;K-1&#39;: equal absolute reciprocal Tc (MK-1 = mired).</span>
<span class="sd">            | If the last element of the list is a bool, then the way the different</span>
<span class="sd">            | lists of Tcs generated by each list element can be set. If True:</span>
<span class="sd">            | the Tcs will be &#39;seamlessly&#39; stitched together (this does have an</span>
<span class="sd">            | an impact on the min-max range of each Tc set) so that there are no</span>
<span class="sd">            | discontinuities in terms of the intervals.</span>
<span class="sd">        :seamless_stitch:</span>
<span class="sd">            | True, optional</span>
<span class="sd">            | When stitching (creating) LUTs composed of several CCT ranges with different</span>
<span class="sd">            | intervals, these do not always &#39;match&#39; well, in the sense that discontinuities</span>
<span class="sd">            | might be generated. This can be avoided (at the expense of possibly slightly changed ranges)</span>
<span class="sd">            | by setting the :seamless_stitch: argument to True. Is overriden when</span>
<span class="sd">            | the last element in the lut list is a boolean.</span>
<span class="sd">        :cct_max:</span>
<span class="sd">            | _CCT_MAX, optional</span>
<span class="sd">            | Limit Tc&#39;s to a maximum value of cct_max</span>
<span class="sd">        :cct_min:</span>
<span class="sd">            | _CCT_MIN, optional</span>
<span class="sd">            | Limit Tc&#39;s to a minimum value of cct_max</span>
<span class="sd">        :fallback_unit:</span>
<span class="sd">            | _CCT_FALLBACK_UNIT, optional</span>
<span class="sd">            | Unit to fall back on when the input unit in tc4 (of first list) is &#39;au&#39;.</span>
<span class="sd">            | As there is no common distancing of the unit types [&#39;K&#39;,&#39;%&#39;,&#39;%-1&#39;,&#39;K-1&#39;]</span>
<span class="sd">            | the Tc&#39;s are generated by dividing the min-max range into </span>
<span class="sd">            | a number of divisions, specified by the negative 3 element (or when</span>
<span class="sd">            | positive or NaN, the number of divisions is set by :fallback_divisions:)</span>
<span class="sd">        :fallback_n:</span>
<span class="sd">            | _CCT_FALLBACK_N, optional</span>
<span class="sd">            | Number of divisions the min-max range is divided into, in the </span>
<span class="sd">            | fallback case in which unit==&#39;au&#39; and the 3e 4-vector element </span>
<span class="sd">            | is NaN or positive.</span>
<span class="sd">        :lut_vars:</span>
<span class="sd">            | [&#39;T&#39;,&#39;uv&#39;,&#39;uvp&#39;,&#39;uvpp&#39;,&#39;iso-T-slope&#39;], optional</span>
<span class="sd">            | Data the lut should contain. Must follow this order </span>
<span class="sd">            | and minimum should be [&#39;T&#39;]</span>
<span class="sd">        :cspace,cspace_kwargs:</span>
<span class="sd">            | Lists with the cspace and cspace_kwargs for which luts will be generated.</span>
<span class="sd">            | Default is single chromaticity diagram in _CCT_CSPACE.</span>
<span class="sd">        :verbosity:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | If &gt; 0: give some intermediate feedback while generating luts.</span>
<span class="sd">        :lut_generator_fcn:</span>
<span class="sd">            | _generate_lut, optional</span>
<span class="sd">            | Lets a user specify his own lut generation function (must output a list of 1 lut). </span>
<span class="sd">            | Default is the general function. There is a specific one for</span>
<span class="sd">            | Ohno&#39;s 2014 method as that one requires a different correction factor</span>
<span class="sd">            | for each lut for the parabolic solutions. This optimized value is specified in the </span>
<span class="sd">            | second list index. (see _generate_lut_ohno2014()).</span>
<span class="sd">        :lut_generator_kwargs:</span>
<span class="sd">            | {}, optional</span>
<span class="sd">            | Dict with keyword arguments specific to the (user) lut_generator_fcn.</span>
<span class="sd">            |  (e.g. {&#39;f_corr&#39;:0.9991} for _generate_lut_ohno2014())</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            :dict:</span>
<span class="sd">                | Dictionary with luts for the specified mode, cieobs(s) and cspace(s).</span>
<span class="sd">                | Structure: lut[cspace][cieobs][lut type]</span>
<span class="sd">                | At the upper dict level there is also a key &#39;wl&#39; which contains a dict with keys </span>
<span class="sd">                | the cieobs and with values the wavelengths used to calculate the Planckians for</span>
<span class="sd">                | each lut for the specified cieobs; as well as a key with the lut_vars</span>
<span class="sd">                | The luts contains as data the variables as specified in lut_vars:</span>
<span class="sd">                | - T: (in K)</span>
<span class="sd">                | - uv: chromaticity coordinates of planckians</span>
<span class="sd">                | - uvp: chromaticity coordinates of 1st derivative of the planckians.</span>
<span class="sd">                | - uvpp: chromaticity coordinates of 2nd derivative of the planckians.</span>
<span class="sd">                | - iso-T-slope: slope of isotemperature lines (calculated as in Robertson, 1968).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">luts</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lut_vars&#39;</span> <span class="p">:</span> <span class="n">lut_vars</span><span class="p">}</span> 
    <span class="c1"># lut_units = [&#39;%&#39;,&#39;K&#39;,&#39;%-1&#39;,&#39;K-1&#39;,&#39;au&#39;]</span>

    <span class="c1"># Calculate luts:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">load</span> <span class="o">==</span> <span class="kc">False</span><span class="p">):</span>
        <span class="c1">#luts[&#39;wl&#39;] = wl</span>
        <span class="n">luts</span><span class="p">[</span><span class="s1">&#39;wl&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># store wavelengths of the cieobs</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">cspace_i</span><span class="p">,</span><span class="n">cspace_kwargs_i</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">cspace</span><span class="p">,</span><span class="n">cspace_kwargs</span><span class="p">)):</span>
            
            <span class="n">cspace_dict_i</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">_process_cspace</span><span class="p">(</span><span class="n">cspace_i</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">cspace_kwargs_i</span><span class="p">)</span>
            <span class="n">cspace_str_i</span> <span class="o">=</span> <span class="n">cspace_dict_i</span><span class="p">[</span><span class="s1">&#39;str&#39;</span><span class="p">]</span>
            <span class="n">luts</span><span class="p">[</span><span class="n">cspace_i</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;cspace&#39;</span> <span class="p">:</span> <span class="n">cspace_i</span><span class="p">,</span> <span class="s1">&#39;cspace_kwargs&#39;</span> <span class="p">:</span> <span class="n">cspace_kwargs_i</span><span class="p">,</span> <span class="s1">&#39;cspace_dict&#39;</span><span class="p">:</span> <span class="n">cspace_dict_i</span><span class="p">}</span>
            
            <span class="k">if</span> <span class="n">cieobs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">_CMF</span><span class="p">[</span><span class="s1">&#39;types&#39;</span><span class="p">]</span>
            
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">cieobs_j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cieobs</span><span class="p">):</span>
                
                <span class="n">luts</span><span class="p">[</span><span class="s1">&#39;wl&#39;</span><span class="p">][</span><span class="n">cieobs_j</span><span class="p">]</span> <span class="o">=</span> <span class="n">_CMF</span><span class="p">[</span><span class="n">cieobs_j</span><span class="p">][</span><span class="s1">&#39;bar&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">wl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="n">getwlr</span><span class="p">(</span><span class="n">wl</span><span class="p">)</span> <span class="c1"># store wavelengths</span>
                
                <span class="n">ftmp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">lut</span><span class="p">:</span> <span class="n">lut_generator_fcn</span><span class="p">(</span><span class="n">lut</span><span class="p">,</span> 
                                                     <span class="n">seamless_stitch</span> <span class="o">=</span> <span class="n">seamless_stitch</span><span class="p">,</span> 
                                                     <span class="n">fallback_unit</span> <span class="o">=</span> <span class="n">fallback_unit</span><span class="p">,</span> 
                                                     <span class="n">fallback_n</span> <span class="o">=</span> <span class="n">fallback_n</span><span class="p">,</span>
                                                     <span class="n">cct_max</span> <span class="o">=</span> <span class="n">cct_max</span><span class="p">,</span> 
                                                     <span class="n">cct_min</span> <span class="o">=</span> <span class="n">cct_min</span><span class="p">,</span>
                                                     <span class="n">wl</span> <span class="o">=</span> <span class="n">luts</span><span class="p">[</span><span class="s1">&#39;wl&#39;</span><span class="p">][</span><span class="n">cieobs_j</span><span class="p">],</span> 
                                                     <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs_j</span><span class="p">,</span> 
                                                     <span class="n">cspace</span> <span class="o">=</span>  <span class="n">cspace_dict_i</span><span class="p">,</span> 
                                                     <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                                     <span class="n">lut_vars</span> <span class="o">=</span> <span class="n">lut_vars</span><span class="p">,</span>
                                                     <span class="o">**</span><span class="n">lut_generator_kwargs</span><span class="p">)</span>
                <span class="n">luts</span><span class="p">[</span><span class="n">cspace_i</span><span class="p">][</span><span class="n">cieobs_j</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                
                <span class="k">for</span> <span class="n">type_k</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
                    <span class="c1"># ensure full tuple depth for use as key:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">type_k</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="nb">str</span><span class="p">):</span> <span class="c1"># at least depth 2 (&lt;--last element is str for depth 1)</span>
                        <span class="n">tmp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">((</span><span class="nb">tuple</span><span class="p">(</span><span class="n">type_kl</span><span class="p">)</span> <span class="k">for</span> <span class="n">type_kl</span> <span class="ow">in</span> <span class="n">type_k</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">type_kl</span><span class="p">,</span><span class="nb">bool</span><span class="p">)))</span>
                        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">type_k</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="nb">bool</span><span class="p">)):</span> <span class="n">seamless_stitch</span> <span class="o">=</span> <span class="n">type_k</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">):</span> <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">tmp</span><span class="p">,</span><span class="n">seamless_stitch</span><span class="p">)</span> <span class="c1"># </span>

                    <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Generating lut with type = </span><span class="si">{}</span><span class="s1"> in cspace = </span><span class="si">{:s}</span><span class="s1"> for cieobs = </span><span class="si">{:s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">type_k</span><span class="p">,</span><span class="n">cspace_str_i</span><span class="p">,</span><span class="n">cieobs_j</span><span class="p">))</span>
                    
                    <span class="k">if</span> <span class="p">(</span><span class="n">cieobs_j</span> <span class="o">!=</span> <span class="s1">&#39;cie_std_dev_obs_f1&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cieobs_j</span> <span class="o">!=</span> <span class="s1">&#39;1951_20_scotopic&#39;</span><span class="p">):</span>
                        <span class="n">luts</span><span class="p">[</span><span class="n">cspace_i</span><span class="p">][</span><span class="n">cieobs_j</span><span class="p">][</span><span class="n">tmp</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ftmp</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">luts</span><span class="p">[</span><span class="n">cspace_i</span><span class="p">][</span><span class="n">cieobs_j</span><span class="p">][</span><span class="n">tmp</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    

                <span class="c1"># save to disk (do intermediate saves):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">lut_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">save_luts</span> <span class="o">==</span> <span class="kc">True</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span> 
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">lut_path</span><span class="p">):</span>
                            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">lut_path</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lut_path</span><span class="p">,</span><span class="n">lut_file</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Saving dict with luts in </span><span class="si">{:s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">file_path</span><span class="p">))</span>                                                 
                    <span class="n">save_pkl</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span><span class="n">luts</span><span class="p">,</span> <span class="n">compresslevel</span> <span class="o">=</span> <span class="n">_CCT_PKL_COMPRESSLEVEL</span><span class="p">)</span>
        <span class="n">luts</span> <span class="o">=</span> <span class="n">load_pkl</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">gzipped</span> <span class="o">=</span> <span class="n">_CCT_PKL_COMPRESSLEVEL</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">lut_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lut_path</span><span class="p">,</span> <span class="n">lut_file</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Loading dict with luts in </span><span class="si">{:s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">file_path</span><span class="p">))</span>                                                 
            <span class="n">luts</span> <span class="o">=</span> <span class="n">load_pkl</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">gzipped</span> <span class="o">=</span> <span class="n">_CCT_PKL_COMPRESSLEVEL</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Trying to load lut file but no lut_file has been supplied.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">luts</span></div>


<span class="k">def</span> <span class="nf">_copy_luts</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">cspace</span> <span class="o">=</span> <span class="n">_CCT_CSPACE</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;2006_2&#39;</span><span class="p">,</span><span class="s1">&#39;2006_10&#39;</span><span class="p">],</span> 
               <span class="n">cieobs_src</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;2015_2&#39;</span><span class="p">,</span> <span class="s1">&#39;2015_10&#39;</span><span class="p">],</span> <span class="n">lut</span> <span class="o">=</span> <span class="n">_CCT_LUT</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Copy luts for specific cieobs keys to equivalent cieobs keys&quot;&quot;&quot;</span>
    <span class="n">cieobs_in_lut</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">lut</span><span class="p">[</span><span class="n">mode</span><span class="p">][</span><span class="s1">&#39;luts&#39;</span><span class="p">][</span><span class="n">cspace</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">cieobs_i</span><span class="p">,</span> <span class="n">cieobs_src_i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cieobs</span><span class="p">,</span> <span class="n">cieobs_src</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cieobs_src_i</span> <span class="ow">in</span> <span class="n">cieobs_in_lut</span><span class="p">:</span>
            <span class="n">lut</span><span class="p">[</span><span class="n">mode</span><span class="p">][</span><span class="s1">&#39;luts&#39;</span><span class="p">][</span><span class="s1">&#39;wl&#39;</span><span class="p">][</span><span class="n">cieobs_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lut</span><span class="p">[</span><span class="n">mode</span><span class="p">][</span><span class="s1">&#39;luts&#39;</span><span class="p">][</span><span class="s1">&#39;wl&#39;</span><span class="p">][</span><span class="n">cieobs_src_i</span><span class="p">]</span>
            <span class="n">lut</span><span class="p">[</span><span class="n">mode</span><span class="p">][</span><span class="s1">&#39;luts&#39;</span><span class="p">][</span><span class="n">cspace</span><span class="p">][</span><span class="n">cieobs_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lut</span><span class="p">[</span><span class="n">mode</span><span class="p">][</span><span class="s1">&#39;luts&#39;</span><span class="p">][</span><span class="n">cspace</span><span class="p">][</span><span class="n">cieobs_src_i</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">_unique_types</span><span class="p">(</span><span class="n">lut_types</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Get list of unique tuple lut_type specifiers&quot;&quot;&quot;</span>
    <span class="n">utypes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">type_lut</span> <span class="ow">in</span> <span class="n">lut_types</span><span class="p">:</span>
         <span class="k">if</span> <span class="n">type_lut</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">utypes</span><span class="p">:</span>
             <span class="n">utypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">type_lut</span><span class="p">)</span> 
    <span class="k">return</span> <span class="n">utypes</span>

<span class="k">def</span> <span class="nf">_sample_lut_vars</span><span class="p">(</span><span class="n">lut_vars</span><span class="p">,</span> <span class="n">all_modes_luts</span><span class="p">,</span> <span class="n">is_lut_kwargs_empty_mode</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; From a full set of lut_vars (8 columns in lut), select only those required by a mode&quot;&quot;&quot;</span>
    <span class="n">lut</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lut_vars&#39;</span> <span class="p">:</span> <span class="n">lut_vars</span><span class="p">,</span>
           <span class="s1">&#39;wl&#39;</span> <span class="p">:</span> <span class="n">all_modes_luts</span><span class="p">[</span><span class="s1">&#39;wl&#39;</span><span class="p">],</span>
           <span class="p">}</span>
    
    <span class="c1"># get lut_vars indices:</span>
    <span class="n">lut_vars_n</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;uv&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;uvp&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;uvpp&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;iso-T-slope&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span>
    <span class="n">lut_vars_indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">lut_vars_i</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">:</span> 
        <span class="n">lut_vars_indices</span> <span class="o">=</span> <span class="n">lut_vars_indices</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">cnt</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">lut_vars_n</span><span class="p">[</span><span class="n">lut_vars_i</span><span class="p">]))</span>
        <span class="n">cnt</span><span class="o">+=</span><span class="n">lut_vars_n</span><span class="p">[</span><span class="n">lut_vars_i</span><span class="p">]</span>
    
    <span class="c1"># sample request lut_vars:</span>
    <span class="k">for</span> <span class="n">cspace_i</span> <span class="ow">in</span> <span class="n">all_modes_luts</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cspace_i</span> <span class="o">==</span> <span class="s1">&#39;wl&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">cspace_i</span> <span class="o">==</span> <span class="s1">&#39;lut_vars&#39;</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lut</span><span class="p">[</span><span class="n">cspace_i</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">cieobs_j</span> <span class="ow">in</span> <span class="n">all_modes_luts</span><span class="p">[</span><span class="n">cspace_i</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="s1">&#39;cspace&#39;</span> <span class="ow">in</span> <span class="n">cieobs_j</span><span class="p">:</span>
                    <span class="n">lut</span><span class="p">[</span><span class="n">cspace_i</span><span class="p">][</span><span class="n">cieobs_j</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_modes_luts</span><span class="p">[</span><span class="n">cspace_i</span><span class="p">][</span><span class="n">cieobs_j</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lut</span><span class="p">[</span><span class="n">cspace_i</span><span class="p">][</span><span class="n">cieobs_j</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">for</span> <span class="n">lut_k</span> <span class="ow">in</span>  <span class="n">all_modes_luts</span><span class="p">[</span><span class="n">cspace_i</span><span class="p">][</span><span class="n">cieobs_j</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">lut_array</span> <span class="o">=</span> <span class="n">all_modes_luts</span><span class="p">[</span><span class="n">cspace_i</span><span class="p">][</span><span class="n">cieobs_j</span><span class="p">][</span><span class="n">lut_k</span><span class="p">][</span><span class="mi">0</span><span class="p">][:,</span><span class="n">lut_vars_indices</span><span class="p">]</span>
                        <span class="n">lut_kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">is_lut_kwargs_empty_mode</span> <span class="k">else</span> <span class="n">all_modes_luts</span><span class="p">[</span><span class="n">cspace_i</span><span class="p">][</span><span class="n">cieobs_j</span><span class="p">][</span><span class="n">lut_k</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">lut</span><span class="p">[</span><span class="n">cspace_i</span><span class="p">][</span><span class="n">cieobs_j</span><span class="p">][</span><span class="n">lut_k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">lut_array</span><span class="p">,</span> <span class="n">lut_kwargs</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">lut</span>

<span class="k">def</span> <span class="nf">_lut_to_float64</span><span class="p">(</span><span class="n">luts</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; undo *1000 for storage as float32 &quot;&quot;&quot;</span>
    
    <span class="c1"># get lut_vars indices:</span>
    <span class="k">for</span> <span class="n">cspace_i</span> <span class="ow">in</span> <span class="n">luts</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">cspace_i</span> <span class="o">==</span> <span class="s1">&#39;wl&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">cspace_i</span> <span class="o">==</span> <span class="s1">&#39;lut_vars&#39;</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">cieobs_j</span> <span class="ow">in</span> <span class="n">luts</span><span class="p">[</span><span class="n">cspace_i</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="s1">&#39;cspace&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cieobs_j</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">lut_k</span> <span class="ow">in</span>  <span class="n">luts</span><span class="p">[</span><span class="n">cspace_i</span><span class="p">][</span><span class="n">cieobs_j</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">lut_array</span> <span class="o">=</span> <span class="n">luts</span><span class="p">[</span><span class="n">cspace_i</span><span class="p">][</span><span class="n">cieobs_j</span><span class="p">][</span><span class="n">lut_k</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">lut_kwargs</span> <span class="o">=</span> <span class="n">luts</span><span class="p">[</span><span class="n">cspace_i</span><span class="p">][</span><span class="n">cieobs_j</span><span class="p">][</span><span class="n">lut_k</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">luts</span><span class="p">[</span><span class="n">cspace_i</span><span class="p">][</span><span class="n">cieobs_j</span><span class="p">][</span><span class="n">lut_k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">lut_array</span><span class="p">,</span> <span class="n">lut_kwargs</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">luts</span>


<span class="k">def</span> <span class="nf">_download_luts_from_github</span><span class="p">(</span><span class="n">modes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">url</span> <span class="o">=</span> <span class="n">_CCT_LUT_PATH_LX_REPO</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Download lut(s) from the luxpy github repo &quot;&quot;&quot;</span>
    
    <span class="kn">import</span> <span class="nn">requests</span> <span class="c1"># lazy import</span>
    <span class="kn">import</span> <span class="nn">pickle</span> <span class="c1"># lazy import</span>
    <span class="kn">import</span> <span class="nn">gzip</span> <span class="c1"># lazy import</span>
    <span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">BytesIO</span> <span class="c1"># lazy import</span>
    
    <span class="k">if</span> <span class="n">modes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">modes</span> <span class="o">=</span> <span class="n">_CCT_LIST_OF_MODE_LUTS</span>
    <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">modes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">_CCT_PKL_COMPRESSLEVEL</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> 
            <span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">url</span><span class="p">,</span><span class="n">mode</span><span class="o">+</span><span class="s1">&#39;_luts.pkl&#39;</span><span class="p">))</span>
            <span class="n">lut</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">content</span><span class="p">))</span>
            <span class="n">save_pkl</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_CCT_LUT_PATH</span><span class="p">,</span><span class="n">mode</span><span class="o">+</span><span class="s1">&#39;_luts.pkl&#39;</span><span class="p">),</span> <span class="n">lut</span><span class="p">,</span> <span class="n">compresslevel</span> <span class="o">=</span> <span class="n">_CCT_PKL_COMPRESSLEVEL</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">url</span><span class="p">,</span><span class="n">mode</span><span class="o">+</span><span class="s1">&#39;_luts.pkl.gz&#39;</span><span class="p">))</span>
            <span class="k">with</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">content</span><span class="p">),</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fobj</span><span class="p">:</span>
                <span class="n">lut</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fobj</span><span class="p">)</span>
            <span class="n">save_pkl</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_CCT_LUT_PATH</span><span class="p">,</span><span class="n">mode</span><span class="o">+</span><span class="s1">&#39;_luts.pkl&#39;</span><span class="p">),</span> <span class="n">lut</span><span class="p">,</span> <span class="n">compresslevel</span> <span class="o">=</span> <span class="n">_CCT_PKL_COMPRESSLEVEL</span><span class="p">)</span>

        
<span class="k">def</span> <span class="nf">_initialize_lut</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">lut_types</span><span class="p">,</span> <span class="n">force_calc</span> <span class="o">=</span> <span class="n">_CCT_LUT_CALC</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">lut_generator_kwargs</span> <span class="o">=</span> <span class="p">{}):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Pre-generate / load from disk / download from github some LUTs for a specific mode &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="ow">in</span> <span class="n">_CCT_LIST_OF_MODE_LUTS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_CCT_LUT_ONE_NPY_PER_MODE</span><span class="p">:</span>
        <span class="n">lut_exists</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_CCT_LUT_PATH</span><span class="p">,</span><span class="s1">&#39;</span><span class="si">{:s}</span><span class="s1">_luts.pkl&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">)))</span> <span class="o">|</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_CCT_LUT_PATH</span><span class="p">,</span><span class="s1">&#39;</span><span class="si">{:s}</span><span class="s1">_luts.pkl.gz&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">)))</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">lut_exists</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">force_calc</span> <span class="o">==</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;LUT pickle file for mode &#39;</span><span class="si">{:s}</span><span class="s2">&#39; doesn&#39;t exist. Trying download from luxpy github repo.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
                <span class="n">_download_luts_from_github</span><span class="p">(</span><span class="n">modes</span><span class="o">=</span><span class="p">[</span><span class="n">mode</span><span class="p">])</span>
                <span class="n">lut_exists</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">lut_exists</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Couldn&#39;t download LUTs from luxpy github repo. Will generate from scratch. This might take a while.&quot;</span><span class="p">)</span>
        <span class="n">_CCT_LUT</span><span class="p">[</span><span class="n">mode</span><span class="p">][</span><span class="s1">&#39;luts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">generate_luts</span><span class="p">(</span><span class="n">types</span> <span class="o">=</span> <span class="n">lut_types</span><span class="p">,</span>
                                                <span class="n">lut_file</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{:s}</span><span class="s1">_luts.pkl&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">),</span> 
                                                <span class="n">load</span> <span class="o">=</span>  <span class="p">(</span><span class="n">lut_exists</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">force_calc</span><span class="o">==</span><span class="kc">False</span><span class="p">)),</span> 
                                                <span class="n">lut_path</span> <span class="o">=</span> <span class="n">_CCT_LUT_PATH</span><span class="p">,</span> 
                                                <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">_CCT_LIST_OF_CIEOBS_LUTS</span><span class="p">,</span>
                                                <span class="n">cspace</span> <span class="o">=</span> <span class="p">[</span><span class="n">_CCT_CSPACE</span><span class="p">],</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="p">[</span><span class="n">_CCT_CSPACE_KWARGS</span><span class="p">],</span>
                                                <span class="n">lut_vars</span> <span class="o">=</span> <span class="n">_CCT_LUT</span><span class="p">[</span><span class="n">mode</span><span class="p">][</span><span class="s1">&#39;lut_vars&#39;</span><span class="p">],</span>
                                                <span class="n">verbosity</span> <span class="o">=</span> <span class="n">_CCT_VERBOSITY_LUT_GENERATION</span><span class="p">,</span>
                                                <span class="n">lut_generator_fcn</span> <span class="o">=</span> <span class="n">_CCT_LUT</span><span class="p">[</span><span class="n">mode</span><span class="p">][</span><span class="s1">&#39;_generate_lut&#39;</span><span class="p">],</span>
                                                <span class="n">lut_generator_kwargs</span> <span class="o">=</span> <span class="n">lut_generator_kwargs</span><span class="p">)</span>
        <span class="c1"># _CCT_LUT[mode][&#39;luts&#39;] = _lut_to_float64(_CCT_LUT[mode][&#39;luts&#39;])</span>
        <span class="n">_copy_luts</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">lut</span> <span class="o">=</span> <span class="n">_CCT_LUT</span><span class="p">)</span> <span class="c1"># 2015_2 -&gt; 2006_2, 2015_10 -&gt; 2006_10</span>


<span class="k">def</span> <span class="nf">_add_lut_endpoints</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Replicates endpoints of lut to avoid out-of-bounds issues &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]))</span>


    

<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># Other helper functions</span>
<span class="c1">#------------------------------------------------------------------------------</span>

<span class="k">def</span> <span class="nf">_get_Duv_for_T_from_uvBB</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span> <span class="n">uBB0</span><span class="p">,</span> <span class="n">vBB0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Calculate Duv from uv coordinates of estimated Tc.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get duv: </span>
    <span class="n">du</span><span class="p">,</span> <span class="n">dv</span> <span class="o">=</span> <span class="n">u</span> <span class="o">-</span> <span class="n">uBB0</span><span class="p">,</span> <span class="n">v</span> <span class="o">-</span> <span class="n">vBB0</span>
    <span class="n">Duv</span> <span class="o">=</span> <span class="p">(</span><span class="n">du</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">dv</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> 

    <span class="c1"># find sign of duv:</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">positive_arctan</span><span class="p">(</span><span class="n">du</span><span class="p">,</span><span class="n">dv</span><span class="p">,</span><span class="n">htype</span><span class="o">=</span><span class="s1">&#39;deg&#39;</span><span class="p">)</span>
    <span class="n">theta</span><span class="p">[</span><span class="n">theta</span><span class="o">&gt;</span><span class="mi">180</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="n">theta</span><span class="o">&gt;</span><span class="mi">180</span><span class="p">]</span> <span class="o">-</span> <span class="mi">360</span>
    <span class="n">Duv</span> <span class="o">*=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">Duv</span>

<span class="k">def</span> <span class="nf">_get_Duv_for_T</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">cspace_dict</span><span class="p">,</span> <span class="n">uvwbar</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">uBB</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">vBB</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Calculate Duv from T by generating a planckian and</span>
<span class="sd">    calculating the Euclidean distance to the point (u,v) and</span>
<span class="sd">    determing the sign as the v coordinate difference between </span>
<span class="sd">    the test point and the planckian.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">uBB</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>  <span class="o">&amp;</span> <span class="p">(</span><span class="n">vBB</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">uvwbar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dl</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">_</span><span class="p">,</span><span class="n">UVWBB</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">_get_tristim_of_BB_BBp_BBpp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">uvwbar</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="s1">&#39;BB&#39;</span><span class="p">)</span>
            <span class="n">uvBB</span> <span class="o">=</span> <span class="n">xyz_to_Yxy</span><span class="p">(</span><span class="n">UVWBB</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">BB</span> <span class="o">=</span> <span class="n">_get_BB_BBp_BBpp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;BB&#39;</span><span class="p">)</span>
            <span class="c1"># BB = cri_ref(T, ref_type = [&#39;BB&#39;], wl3 = wl)</span>
            <span class="n">xyzBB</span> <span class="o">=</span> <span class="n">spd_to_xyz</span><span class="p">(</span><span class="n">BB</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">relative</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">uvBB</span> <span class="o">=</span> <span class="n">cspace_dict</span><span class="p">[</span><span class="s1">&#39;fwtf&#39;</span><span class="p">](</span><span class="n">xyzBB</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">uBB</span><span class="p">,</span> <span class="n">vBB</span> <span class="o">=</span> <span class="n">uvBB</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span> <span class="n">uvBB</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    
    <span class="c1"># Get duv: </span>
    <span class="k">return</span> <span class="n">_get_Duv_for_T_from_uvBB</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">uBB</span><span class="p">,</span> <span class="n">vBB</span><span class="p">)</span>
        

<span class="c1"># def _plot_triangular_solution(u,v,uBB,vBB,TBB,pn):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Make a plot of the geometry of the test (u,v) and the</span>
<span class="c1">#     3 points i-1, i, i+1. Helps for testing and understanding coded algorithms.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     import matplotlib.pyplot as plt # lazy import</span>
<span class="c1">#     import luxpy as lx</span>
    
<span class="c1">#     plt.plot(u,v,&#39;ro&#39;)</span>
<span class="c1">#     # pnl = np.hstack((pn-2,pn-1,pn,pn+1,pn+2))</span>
<span class="c1">#     # plt.plot(uBB[pnl],vBB[pnl],&#39;k.-&#39;)</span>
<span class="c1">#     plt.plot(uBB[pn-1],vBB[pn-1],&#39;cv&#39;)</span>
<span class="c1">#     plt.plot(uBB[pn+1],vBB[pn+1],&#39;m^&#39;)</span>
<span class="c1">#     plt.plot(np.vstack((u,uBB[pn-1])), np.vstack((v,vBB[pn-1])), &#39;c&#39;)</span>
<span class="c1">#     plt.plot(np.vstack((u,uBB[pn+1])), np.vstack((v,vBB[pn+1])), &#39;m&#39;)</span>
<span class="c1">#     plt.plot(np.vstack((uBB[pn-1],uBB[pn+1])), np.vstack((vBB[pn-1],vBB[pn+1])), &#39;g&#39;)</span>
<span class="c1">#     # for i in range(TBB.shape[0]):</span>
<span class="c1">#     #     plt.text(uBB[i],vBB[i],&#39;{:1.0f}K&#39;.format(TBB[i,0]))</span>
<span class="c1">#     lx.plotSL(axh=plt.gca(),cspace=&#39;Yuv60&#39;)</span>

<span class="k">def</span> <span class="nf">_get_pns_from_x</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">m0p</span> <span class="o">=</span> <span class="s1">&#39;m0p&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Get idx-1, idx and idx +1 from array. </span>
<span class="sd">    Returns [Nx1] ndarray with N = len(idx).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s1">&#39;m&#39;</span> <span class="ow">in</span> <span class="n">m0p</span><span class="p">:</span> 
        <span class="n">idx_m1</span> <span class="o">=</span> <span class="n">idx</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">idx_m1</span><span class="p">[</span><span class="n">idx_m1</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># otherwise wraparound error happens</span>
    
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">m0p</span> <span class="o">==</span> <span class="s1">&#39;m0p&#39;</span><span class="p">:</span> 
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">idx_m1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">m0p</span> <span class="o">==</span> <span class="s1">&#39;0p&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">m0p</span> <span class="o">==</span> <span class="s1">&#39;mp&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">idx_m1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">m0p</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">m0p</span> <span class="o">==</span> <span class="s1">&#39;m0&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">idx_m1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;p&#39;</span> <span class="ow">in</span> <span class="n">m0p</span><span class="p">:</span> 
            <span class="n">idx_p1</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">m0p</span> <span class="o">==</span> <span class="s1">&#39;m0p&#39;</span><span class="p">:</span> 
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">idx_m1</span><span class="p">,</span><span class="n">i</span><span class="p">][:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="n">i</span><span class="p">][:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">idx_p1</span><span class="p">,</span><span class="n">i</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">m0p</span> <span class="o">==</span> <span class="s1">&#39;0p&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="n">i</span><span class="p">][:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">idx_p1</span><span class="p">,</span><span class="n">i</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">m0p</span> <span class="o">==</span> <span class="s1">&#39;mp&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">idx_m1</span><span class="p">,</span><span class="n">i</span><span class="p">][:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">idx_p1</span><span class="p">,</span><span class="n">i</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">m0p</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="n">i</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">m0p</span> <span class="o">==</span> <span class="s1">&#39;m0&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">idx_m1</span><span class="p">,</span><span class="n">i</span><span class="p">][:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="n">i</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span>
   
    
<span class="k">def</span> <span class="nf">_deal_with_lut_end_points</span><span class="p">(</span><span class="n">pn</span><span class="p">,</span> <span class="n">TBB</span><span class="p">,</span> <span class="n">out_of_lut</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="n">ce</span> <span class="o">=</span> <span class="n">pn</span> <span class="o">==</span> <span class="p">(</span><span class="n">TBB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># end point</span>
    <span class="n">cb</span> <span class="o">=</span> <span class="n">pn</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="c1"># begin point</span>
    <span class="k">if</span> <span class="n">out_of_lut</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">out_of_lut</span> <span class="o">=</span> <span class="p">(</span><span class="n">cb</span> <span class="o">|</span> <span class="n">ce</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">pn</span><span class="p">[</span><span class="n">cb</span><span class="p">]</span> <span class="o">=</span>  <span class="mi">1</span> <span class="c1"># begin point </span>
    <span class="n">ce</span> <span class="o">=</span> <span class="n">pn</span> <span class="o">==</span> <span class="p">(</span><span class="n">TBB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># end point double-check !!</span>
    <span class="n">pn</span><span class="p">[</span><span class="n">ce</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">TBB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># end of lut (results in TBB_0==TBB_p1 -&gt; (1/TBB_0)-(1/TBB_p1)) == 0 !</span>

    <span class="k">return</span> <span class="n">pn</span><span class="p">,</span> <span class="n">out_of_lut</span>

<span class="c1">#==============================================================================</span>
<span class="c1"># Define cct, duv to xyz conversion function:</span>
<span class="c1">#==============================================================================</span>

<span class="c1">#---------------------------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="cct_to_xyz">
<a class="viewcode-back" href="../../../../color.html#luxpy.color.cct.cct_to_xyz">[docs]</a>
<span class="k">def</span> <span class="nf">cct_to_xyz</span><span class="p">(</span><span class="n">ccts</span><span class="p">,</span> <span class="n">duv</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">cct_offset</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">_CIEOBS</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
               <span class="n">cspace</span> <span class="o">=</span> <span class="n">_CCT_CSPACE</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">_CCT_CSPACE_KWARGS</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert correlated color temperature (550 K &lt;= CCT &lt;= 1e11 K) and </span>
<span class="sd">    Duv (distance above (&gt;0) or below (&lt;0) the Planckian locus) to </span>
<span class="sd">    XYZ tristimulus values.</span>
<span class="sd">    </span>
<span class="sd">    | Finds xyzw_estimated by determining the iso-temperature line </span>
<span class="sd">    |   (= line perpendicular to the Planckian locus): </span>
<span class="sd">    |   Option 1 (fastest):</span>
<span class="sd">    |       First, the angle between the coordinates corresponding to ccts </span>
<span class="sd">    |       and ccts-cct_offset are calculated, then 90° is added, and finally</span>
<span class="sd">    |       the new coordinates are determined, while taking sign of duv into account.</span>
<span class="sd">    |   Option 2 (slowest, about 55% slower):</span>
<span class="sd">    |       Calculate the slope of the iso-T-line directly using the Planckian</span>
<span class="sd">    |       spectrum and its derivative.</span>
<span class="sd">     </span>
<span class="sd">    Args:</span>
<span class="sd">        :ccts: </span>
<span class="sd">            | ndarray [N,1] of cct values</span>
<span class="sd">        :duv: </span>
<span class="sd">            | None or ndarray [N,1] of duv values, optional</span>
<span class="sd">            | Note that duv can be supplied together with cct values in :ccts: </span>
<span class="sd">            | as ndarray with shape [N,2].</span>
<span class="sd">        :cct_offset:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | If None: use option 2 (direct iso-T slope calculation, more accurate,</span>
<span class="sd">            |                        but slower: about 1.55 slower)</span>
<span class="sd">            | else: use option 1 (estimate slope from 90° + angle of small cct_offset)</span>
<span class="sd">        :cieobs: </span>
<span class="sd">            | luxpy._CIEOBS, optional</span>
<span class="sd">            | CMF set used to calculated xyzw.</span>
<span class="sd">        :wl: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Wavelengths used when calculating Planckian radiators.</span>
<span class="sd">            | If None: use same wavelengths as CMFs in :cieobs:.</span>
<span class="sd">        :cspace:</span>
<span class="sd">            | _CCT_SPACE, optional</span>
<span class="sd">            | Color space to do calculations in. </span>
<span class="sd">            | Options: </span>
<span class="sd">            |    - cspace string: </span>
<span class="sd">            |        e.g. &#39;Yuv60&#39; for use with luxpy.colortf()</span>
<span class="sd">            |    - tuple with forward (i.e. xyz_to..) [and backward (i.e. ..to_xyz)] functions </span>
<span class="sd">            |      (and an optional string describing the cspace): </span>
<span class="sd">            |        e.g. (forward, backward) or (forward, backward, cspace string) or (forward, cspace string) </span>
<span class="sd">            |    - dict with keys: &#39;fwtf&#39; (foward), &#39;bwtf&#39; (backward) [, optional: &#39;str&#39; (cspace string)]</span>
<span class="sd">            |  Note: if the backward tf is not supplied, optimization in cct_to_xyz() is done in the CIE 1976 u&#39;v&#39; diagram</span>
<span class="sd">        :cspace_kwargs:</span>
<span class="sd">            | _CCT_CSPACE_KWARGS, optional</span>
<span class="sd">            | Parameter nested dictionary for the forward and backward transforms.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | ndarray with estimated XYZ tristimulus values</span>
<span class="sd">    </span>
<span class="sd">    Note:</span>
<span class="sd">        1. If duv is not supplied (:ccts:.shape is (N,1) and :duv: is None), </span>
<span class="sd">        source is assumed to be on the Planckian locus.</span>
<span class="sd">        2. Minimum CCT is 550 K (lower than 550 K, some negative Duv values</span>
<span class="sd">        will result in coordinates outside of the Spectrum Locus !!!)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># make ccts a min. 2d np.array:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ccts</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
        <span class="n">ccts</span> <span class="o">=</span> <span class="n">np2dT</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ccts</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ccts</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">(</span><span class="n">ccts</span><span class="p">)</span> 
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ccts</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;cct_to_xyz(): Input ccts.shape must be &lt;= 2 !&#39;</span><span class="p">)</span>
    
    <span class="c1"># get cct and duv arrays from :ccts:</span>
    <span class="n">cct</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">(</span><span class="n">ccts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="kc">None</span><span class="p">])</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">duv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ccts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">duv</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">(</span><span class="n">ccts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="kc">None</span><span class="p">])</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">duv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ccts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">duv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">ccts</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">duv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">duv</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">(</span><span class="n">duv</span><span class="p">)</span>

    <span class="n">cspace_dict</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">_process_cspace</span><span class="p">(</span><span class="n">cspace</span><span class="p">,</span> <span class="n">cspace_kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cspace_dict</span><span class="p">[</span><span class="s1">&#39;bwtf&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;cct_to_xyz_fast requires the backward cspace transform to be defined !!!&#39;</span><span class="p">)</span>

    <span class="n">xyzbar</span><span class="p">,</span><span class="n">wl</span><span class="p">,</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">_get_xyzbar_wl_dl</span><span class="p">(</span><span class="n">cieobs</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cct_offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># estimate iso-T-line from estimated slope using small cct offset:</span>
        <span class="c1">#-----------------------------------------------------------------</span>
        <span class="n">_</span><span class="p">,</span><span class="n">xyzBB</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">_get_tristim_of_BB_BBp_BBpp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">cct</span><span class="p">,</span> <span class="n">cct</span><span class="o">-</span><span class="n">cct_offset</span><span class="p">,</span><span class="n">cct</span><span class="o">+</span><span class="n">cct_offset</span><span class="p">)),</span><span class="n">xyzbar</span><span class="p">,</span><span class="n">wl</span><span class="p">,</span><span class="n">dl</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="s1">&#39;BB&#39;</span><span class="p">)</span> 
        <span class="n">YuvBB</span> <span class="o">=</span> <span class="n">cspace_dict</span><span class="p">[</span><span class="s1">&#39;fwtf&#39;</span><span class="p">](</span><span class="n">xyzBB</span><span class="p">)</span>

        <span class="n">N</span> <span class="o">=</span> <span class="p">(</span><span class="n">xyzBB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">//</span><span class="mi">3</span>
        <span class="n">YuvBB_centered</span> <span class="o">=</span> <span class="p">(</span><span class="n">YuvBB</span><span class="p">[</span><span class="n">N</span><span class="p">:]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">YuvBB</span><span class="p">[:</span><span class="n">N</span><span class="p">],</span><span class="n">YuvBB</span><span class="p">[:</span><span class="n">N</span><span class="p">])))</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">YuvBB_centered</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span><span class="n">YuvBB_centered</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="p">(</span><span class="n">theta</span><span class="p">[:</span><span class="n">N</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="n">N</span><span class="p">:]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="n">N</span><span class="p">:])))</span><span class="o">/</span><span class="mi">2</span> <span class="c1"># take average for increased accuracy</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">duv</span><span class="p">)</span> <span class="c1"># add 90° to obtain the direction perpendicular to the blackbody locus</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">YuvBB</span><span class="p">[:</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">duv</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">YuvBB</span><span class="p">[:</span><span class="n">N</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">duv</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># estimate iso-T-line from calculated slope:</span>
        <span class="c1">#-------------------------------------------</span>
        <span class="n">uvwbar</span> <span class="o">=</span> <span class="n">_convert_xyzbar_to_uvwbar</span><span class="p">(</span><span class="n">xyzbar</span><span class="p">,</span><span class="n">cspace_dict</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span><span class="n">UVW</span><span class="p">,</span><span class="n">UVWp</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">_get_tristim_of_BB_BBp_BBpp</span><span class="p">(</span><span class="n">cct</span><span class="p">,</span><span class="n">uvwbar</span><span class="p">,</span><span class="n">wl</span><span class="p">,</span><span class="n">dl</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="s1">&#39;BB,BBp&#39;</span><span class="p">)</span> 
        
        <span class="n">R</span> <span class="o">=</span> <span class="n">UVW</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> 
        <span class="n">Rp</span> <span class="o">=</span> <span class="n">UVWp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> 
        <span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="n">UVWp</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">R</span> <span class="o">-</span> <span class="n">UVW</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">Rp</span><span class="p">)</span> 
        <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span><span class="n">UVWp</span><span class="p">[:,:</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">R</span> <span class="o">-</span> <span class="n">UVW</span><span class="p">[:,:</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">Rp</span><span class="p">)</span>
        <span class="n">num</span><span class="p">[(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">_CCT_AVOID_ZERO_DIV</span>
        <span class="n">denom</span><span class="p">[(</span><span class="n">denom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">_CCT_AVOID_ZERO_DIV</span>
        <span class="n">li</span> <span class="o">=</span> <span class="n">num</span><span class="o">/</span><span class="n">denom</span>  
        <span class="n">li</span> <span class="o">=</span> <span class="n">li</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">li</span><span class="p">)</span><span class="o">*</span><span class="n">_CCT_AVOID_ZERO_DIV</span> <span class="c1"># avoid division by zero</span>
        <span class="n">mi</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="n">li</span> <span class="c1"># slope of isotemperature lines</span>

        <span class="n">YuvBB</span> <span class="o">=</span> <span class="n">xyz_to_Yxy</span><span class="p">(</span><span class="n">UVW</span><span class="p">)</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">YuvBB</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">mi</span><span class="p">)</span> <span class="o">*</span> <span class="n">duv</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">((</span><span class="mi">1</span><span class="o">+</span><span class="n">mi</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)),</span> <span class="n">YuvBB</span><span class="p">[:,</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">mi</span><span class="p">)</span><span class="o">*</span> <span class="n">duv</span><span class="o">*</span><span class="p">((</span><span class="n">mi</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">mi</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
        
    <span class="c1"># plt.plot(YuvBB[...,1],YuvBB[...,2],&#39;gx&#39;)</span>
    <span class="c1"># lx.plotSL(cspace=&#39;Yuv60&#39;,axh=plt.gca())</span>
    <span class="c1"># plt.plot(u,v,&#39;b+&#39;)    </span>
    
    <span class="n">Yuv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="mi">100</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">u</span><span class="p">),</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">cspace_dict</span><span class="p">[</span><span class="s1">&#39;bwtf&#39;</span><span class="p">](</span><span class="n">Yuv</span><span class="p">)</span></div>





<span class="c1">#==============================================================================</span>
<span class="c1"># define original versions of various cct methods:</span>
<span class="c1">#==============================================================================</span>

<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># Mcamy, 1992:</span>
<span class="c1">#------------------------------------------------------------------------------</span>
<span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;mcamy1992&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lut_vars&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;lut_type_def&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;luts&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;_generate_lut&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">}</span>
<span class="k">def</span> <span class="nf">_xyz_to_cct_mcamy</span><span class="p">(</span><span class="n">xyzw</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert XYZ tristimulus values to correlated color temperature (CCT) using </span>
<span class="sd">    the mccamy approximation.</span>
<span class="sd">    </span>
<span class="sd">    | Only valid for approx. 3000 &lt; T &lt; 9000, if &lt; 6500, error &lt; 2 K.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :xyzw: </span>
<span class="sd">            | ndarray of tristimulus values</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        :cct: </span>
<span class="sd">            | ndarray of correlated color temperatures estimates</span>
<span class="sd">            </span>
<span class="sd">    References:</span>
<span class="sd">        1. `McCamy, Calvin S. (April 1992). </span>
<span class="sd">        &quot;Correlated color temperature as an explicit function of </span>
<span class="sd">        chromaticity coordinates&quot;.</span>
<span class="sd">        Color Research &amp; Application. 17 (2): 142–144.</span>
<span class="sd">        &lt;http://onlinelibrary.wiley.com/doi/10.1002/col.5080170211/abstract&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Yxy</span> <span class="o">=</span> <span class="n">xyz_to_Yxy</span><span class="p">(</span><span class="n">xyzw</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">Yxy</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mf">0.3320</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">Yxy</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mf">0.1858</span><span class="p">)</span>
    <span class="k">return</span>  <span class="n">np2d</span><span class="p">(</span><span class="o">-</span><span class="mf">449.0</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mf">3525.0</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mf">6823.3</span><span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="mf">5520.33</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

<div class="viewcode-block" id="xyz_to_cct_mcamy1992">
<a class="viewcode-back" href="../../../../color.html#luxpy.color.cct.xyz_to_cct_mcamy1992">[docs]</a>
<span class="k">def</span> <span class="nf">xyz_to_cct_mcamy1992</span><span class="p">(</span><span class="n">xyzw</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="s1">&#39;1931_2&#39;</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;cct&#39;</span><span class="p">,</span>
                         <span class="n">cspace</span> <span class="o">=</span> <span class="n">_CCT_CSPACE</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">_CCT_CSPACE_KWARGS</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert XYZ tristimulus values to correlated color temperature (CCT) using </span>
<span class="sd">    the mccamy approximation (!!! only valid for CIE 1931 2° input !!!).</span>
<span class="sd">    </span>
<span class="sd">    | Only valid for approx. 3000 &lt; T &lt; 9000, if &lt; 6500, error &lt; 2 K </span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :xyzw: </span>
<span class="sd">            | ndarray of tristimulus values</span>
<span class="sd">        :cieobs: </span>
<span class="sd">            | &#39;1931_2&#39;, optional</span>
<span class="sd">            | CMF set used to calculated xyzw. </span>
<span class="sd">            | Note: since the parameter values in Mcamy&#39;s equation were optimized,</span>
<span class="sd">            |   using the 1931 2° CMFs, this is only valid for that CMF set.</span>
<span class="sd">            |   It can be changed, but will only impact the calculation of Duv and</span>
<span class="sd">            |   thereby causing a potential mismatch/error. Change at own discretion.</span>
<span class="sd">        :out: </span>
<span class="sd">            | &#39;cct&#39; (or 1), optional</span>
<span class="sd">            | Determines what to return.</span>
<span class="sd">            | Other options: &#39;duv&#39; (or -1), &#39;cct,duv&#39;(or 2), &quot;[cct,duv]&quot; (or -2)</span>
<span class="sd">        :wl: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Wavelengths used when calculating Planckian radiators when determining Duv.</span>
<span class="sd">            |  (!!CCT is determined using a fixed set of equations optimized for the 1931 2° CMFS!!)</span>
<span class="sd">        :cspace:</span>
<span class="sd">            | _CCT_SPACE, optional</span>
<span class="sd">            | Color space to do calculations in. </span>
<span class="sd">            | Options: </span>
<span class="sd">            |    - cspace string: </span>
<span class="sd">            |        e.g. &#39;Yuv60&#39; for use with luxpy.colortf()</span>
<span class="sd">            |    - tuple with forward (i.e. xyz_to..) [and backward (i.e. ..to_xyz)] functions </span>
<span class="sd">            |      (and an optional string describing the cspace): </span>
<span class="sd">            |        e.g. (forward, backward) or (forward, backward, cspace string) or (forward, cspace string) </span>
<span class="sd">            |    - dict with keys: &#39;fwtf&#39; (foward), &#39;bwtf&#39; (backward) [, optional: &#39;str&#39; (cspace string)]</span>
<span class="sd">            |  Note: if the backward tf is not supplied, optimization in cct_to_xyz() is done in the CIE 1976 u&#39;v&#39; diagram</span>
<span class="sd">        :cspace_kwargs:</span>
<span class="sd">            | _CCT_CSPACE_KWARGS, optional</span>
<span class="sd">            | Parameter nested dictionary for the forward and backward transforms.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        :cct: </span>
<span class="sd">            | ndarray of correlated color temperatures estimates</span>
<span class="sd">            </span>
<span class="sd">    References:</span>
<span class="sd">        1. `McCamy, Calvin S. (April 1992). </span>
<span class="sd">        &quot;Correlated color temperature as an explicit function of </span>
<span class="sd">        chromaticity coordinates&quot;.</span>
<span class="sd">        Color Research &amp; Application. 17 (2): 142–144.</span>
<span class="sd">        &lt;http://onlinelibrary.wiley.com/doi/10.1002/col.5080170211/abstract&gt;`_</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ccts</span> <span class="o">=</span> <span class="n">_xyz_to_cct_mcamy</span><span class="p">(</span><span class="n">xyzw</span><span class="p">)</span>
    <span class="n">cspace_dict</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">_process_cspace</span><span class="p">(</span><span class="n">cspace</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">cspace_kwargs</span><span class="p">)</span>
    <span class="n">uv</span> <span class="o">=</span> <span class="n">cspace_dict</span><span class="p">[</span><span class="s1">&#39;fwtf&#39;</span><span class="p">](</span><span class="n">xyzw</span><span class="p">)[:,</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="o">=</span> <span class="n">uv</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="kc">None</span><span class="p">],</span> <span class="n">uv</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">duvs</span> <span class="o">=</span> <span class="n">_get_Duv_for_T</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">ccts</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">cspace_dict</span><span class="p">)</span>
    
    <span class="c1"># Regulate output:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;cct&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ccts</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;duv&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">duvs</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;cct,duv&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ccts</span><span class="p">,</span> <span class="n">duvs</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s2">&quot;[cct,duv]&quot;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">ccts</span><span class="p">,</span><span class="n">duvs</span><span class="p">))</span>   
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Unknown output requested&#39;</span><span class="p">)</span></div>



<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># Hernandez-Andres, 1999:</span>
<span class="c1">#------------------------------------------------------------------------------</span>
<span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;hernandez1999&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lut_vars&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;lut_type_def&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;luts&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;_generate_lut&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">}</span>
<span class="k">def</span> <span class="nf">_xyz_to_cct_HA</span><span class="p">(</span><span class="n">xyzw</span><span class="p">,</span> <span class="n">verbosity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert XYZ tristimulus values to correlated color temperature (CCT). </span>
<span class="sd">       </span>
<span class="sd">    | According to paper small error from 3000 - 800 000 K</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :xyzw: </span>
<span class="sd">            | ndarray of tristimulus values</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        :cct: </span>
<span class="sd">            | ndarray of correlated color temperatures estimates</span>
<span class="sd">    </span>
<span class="sd">    References:</span>
<span class="sd">        1. `Hernández-Andrés, Javier; Lee, RL; Romero, J (September 20, 1999). </span>
<span class="sd">        Calculating Correlated Color Temperatures Across the Entire Gamut </span>
<span class="sd">        of Daylight and Skylight Chromaticities.</span>
<span class="sd">        Applied Optics. 38 (27), 5703–5709. P</span>
<span class="sd">        &lt;https://www.osapublishing.org/ao/abstract.cfm?uri=ao-38-27-5703&gt;`_</span>
<span class="sd">            </span>
<span class="sd">    Notes: </span>
<span class="sd">        According to paper small error from 3000 - 800 000 K, but a test with </span>
<span class="sd">        Planckians showed errors up to 20% around 500 000 K; </span>
<span class="sd">        e&gt;0.05 for T&gt;200 000, e&gt;0.1 for T&gt;300 000, ...</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xyzw</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;xyz_to_cct_HA(): Input xyzw.ndim must be &lt;= 2 !&#39;</span><span class="p">)</span>
        
    <span class="n">out_of_range_code</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">xe</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.3366</span><span class="p">,</span> <span class="mf">0.3356</span><span class="p">]</span>
    <span class="n">ye</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1735</span><span class="p">,</span> <span class="mf">0.1691</span><span class="p">]</span>
    <span class="n">A0</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">949.86315</span><span class="p">,</span> <span class="mf">36284.48953</span><span class="p">]</span>
    <span class="n">A1</span> <span class="o">=</span> <span class="p">[</span><span class="mf">6253.80338</span><span class="p">,</span> <span class="mf">0.00228</span><span class="p">]</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.92159</span><span class="p">,</span> <span class="mf">0.07861</span><span class="p">]</span>
    <span class="n">A2</span> <span class="o">=</span> <span class="p">[</span><span class="mf">28.70599</span><span class="p">,</span> <span class="mf">5.4535</span><span class="o">*</span><span class="mf">1e-36</span><span class="p">]</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.20039</span><span class="p">,</span> <span class="mf">0.01543</span><span class="p">]</span>
    <span class="n">A3</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.00004</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
    <span class="n">t3</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.07125</span><span class="p">,</span><span class="mf">1.0</span><span class="p">]</span>
    <span class="n">cct_ranges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">3000.0</span><span class="p">,</span><span class="mf">50000.0</span><span class="p">],[</span><span class="mf">50000.0</span><span class="p">,</span><span class="mf">800000.0</span><span class="p">]])</span>
    
    <span class="n">Yxy</span> <span class="o">=</span> <span class="n">xyz_to_Yxy</span><span class="p">(</span><span class="n">xyzw</span><span class="p">)</span>
    <span class="n">CCT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">Yxy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">*</span><span class="n">out_of_range_code</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">Yxy</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xe</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">Yxy</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">ye</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">CCT_i</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">A1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">,</span><span class="n">t1</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">+</span> <span class="n">A2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">,</span><span class="n">t2</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">+</span> <span class="n">A3</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">,</span><span class="n">t3</span><span class="p">[</span><span class="n">i</span><span class="p">]))))</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">CCT_i</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="mf">0.05</span><span class="o">*</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span><span class="o">*</span><span class="n">cct_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CCT_i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="mf">0.05</span><span class="o">*</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span><span class="o">*</span><span class="n">cct_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">CCT</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">CCT_i</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">CCT_i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="mf">0.05</span><span class="p">)</span><span class="o">*</span><span class="n">cct_ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="c1">#smaller than smallest valid CCT value</span>
        <span class="n">CCT</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
   
    <span class="k">if</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">CCT</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">CCT</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">verbosity</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: xyz_to_cct_HA(): one or more CCTs out of range! --&gt; (CCT &lt; 3 kK,  CCT &gt;800 kK) coded as (-1, NaN) &#39;s&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">CCT</span><span class="o">.</span><span class="n">T</span>

<div class="viewcode-block" id="xyz_to_cct_hernandez1999">
<a class="viewcode-back" href="../../../../color.html#luxpy.color.cct.xyz_to_cct_hernandez1999">[docs]</a>
<span class="k">def</span> <span class="nf">xyz_to_cct_hernandez1999</span><span class="p">(</span><span class="n">xyzw</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="s1">&#39;1931_2&#39;</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;cct&#39;</span><span class="p">,</span>
                             <span class="n">cspace</span> <span class="o">=</span> <span class="n">_CCT_CSPACE</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">_CCT_CSPACE_KWARGS</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert XYZ tristimulus values to correlated color temperature (CCT) using </span>
<span class="sd">    the mccamy approximation (!!! only valid for CIE 1931 2° input !!!).</span>
<span class="sd">    </span>
<span class="sd">    | According to paper small error from 3000 - 800 000 K</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :xyzw: </span>
<span class="sd">            | ndarray of tristimulus values</span>
<span class="sd">        :cieobs: </span>
<span class="sd">            | &#39;1931_2&#39;, optional</span>
<span class="sd">            | CMF set used to calculated xyzw. </span>
<span class="sd">            | Note: since the parameter values in the HA equations were optimized,</span>
<span class="sd">            |   using the 1931 2° CMFs, this is only valid for that CMF set.</span>
<span class="sd">            |   It can be changed, but will only impact the calculation of Duv and</span>
<span class="sd">            |   thereby causing a potential mismatch/error. Change at own discretion.</span>
<span class="sd">        :out: </span>
<span class="sd">            | &#39;cct&#39; (or 1), optional</span>
<span class="sd">            | Determines what to return.</span>
<span class="sd">            | Other options: &#39;duv&#39; (or -1), &#39;cct,duv&#39;(or 2), &quot;[cct,duv]&quot; (or -2)</span>
<span class="sd">        :wl: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Wavelengths used when calculating Planckian radiators when determining Duv.</span>
<span class="sd">            |  (!!CCT is determined using a fixed set of equations optimized for the 1931 2° CMFS!!)</span>
<span class="sd">        :cspace:</span>
<span class="sd">            | _CCT_SPACE, optional</span>
<span class="sd">            | Color space to do calculations in. </span>
<span class="sd">            | Options: </span>
<span class="sd">            |    - cspace string: </span>
<span class="sd">            |        e.g. &#39;Yuv60&#39; for use with luxpy.colortf()</span>
<span class="sd">            |    - tuple with forward (i.e. xyz_to..) [and backward (i.e. ..to_xyz)] functions </span>
<span class="sd">            |      (and an optional string describing the cspace): </span>
<span class="sd">            |        e.g. (forward, backward) or (forward, backward, cspace string) or (forward, cspace string) </span>
<span class="sd">            |    - dict with keys: &#39;fwtf&#39; (foward), &#39;bwtf&#39; (backward) [, optional: &#39;str&#39; (cspace string)]</span>
<span class="sd">            |  Note: if the backward tf is not supplied, optimization in cct_to_xyz() is done in the CIE 1976 u&#39;v&#39; diagram</span>
<span class="sd">        :cspace_kwargs:</span>
<span class="sd">            | _CCT_CSPACE_KWARGS, optional</span>
<span class="sd">            | Parameter nested dictionary for the forward and backward transforms.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        :cct: </span>
<span class="sd">            | ndarray of correlated color temperatures estimates</span>
<span class="sd">            </span>
<span class="sd">    References:</span>
<span class="sd">        1. `Hernández-Andrés, Javier; Lee, RL; Romero, J (September 20, 1999). </span>
<span class="sd">        Calculating Correlated Color Temperatures Across the Entire Gamut </span>
<span class="sd">        of Daylight and Skylight Chromaticities.</span>
<span class="sd">        Applied Optics. 38 (27), 5703–5709. P</span>
<span class="sd">        &lt;https://www.osapublishing.org/ao/abstract.cfm?uri=ao-38-27-5703&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ccts</span> <span class="o">=</span> <span class="n">_xyz_to_cct_HA</span><span class="p">(</span><span class="n">xyzw</span><span class="p">)</span>
    <span class="n">cspace_dict</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">_process_cspace</span><span class="p">(</span><span class="n">cspace</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">cspace_kwargs</span><span class="p">)</span>
    <span class="n">uv</span> <span class="o">=</span> <span class="n">cspace_dict</span><span class="p">[</span><span class="s1">&#39;fwtf&#39;</span><span class="p">](</span><span class="n">xyzw</span><span class="p">)[:,</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="o">=</span> <span class="n">uv</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="kc">None</span><span class="p">],</span> <span class="n">uv</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">duvs</span> <span class="o">=</span> <span class="n">_get_Duv_for_T</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">ccts</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">cspace_dict</span><span class="p">)</span>
    
    <span class="c1"># Regulate output:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;cct&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ccts</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;duv&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">duvs</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;cct,duv&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ccts</span><span class="p">,</span> <span class="n">duvs</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s2">&quot;[cct,duv]&quot;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">ccts</span><span class="p">,</span><span class="n">duvs</span><span class="p">))</span>   
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Unknown output requested&#39;</span><span class="p">)</span></div>


<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># Newton-Raphson estimator (cfr. Li, 2016):</span>
<span class="c1">#------------------------------------------------------------------------------       </span>
<span class="k">def</span> <span class="nf">_get_newton_raphson_estimated_Tc</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">T0</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">,</span>
                                     <span class="n">cieobs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">xyzbar</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">uvwbar</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                     <span class="n">cspace_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="n">_CCT_MAX_ITER</span><span class="p">,</span>
                                     <span class="n">fast_duv</span> <span class="o">=</span> <span class="n">_CCT_FAST_DUV</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get an estimate of the CCT using the Newton-Raphson method (as specified in </span>
<span class="sd">    Li et al., 2016). (u,v) are the test coordinates. T0 is a first estimate of the Tc.</span>
<span class="sd">    atol and rtol are the absolute and relative tolerance values that are aimed at (if</span>
<span class="sd">    possible the error on the estimation should smaller than or close to these values,</span>
<span class="sd">    once one is achieved the algorithm stops). wl contains the wavelengths of the </span>
<span class="sd">    Planckians, cieobs is the CIE cmfs set to be used (or use xyzbar; at least one</span>
<span class="sd">    must be given). uvwbar the already converted cmf set. If this one is not none</span>
<span class="sd">    than any input in cieobs or xyzbar is ignored. cspace_dict must be supplied</span>
<span class="sd">    when uvwbar is None (needed for color space conversion!). Max-iter specifies</span>
<span class="sd">    the maximum number of iterations (avoid potential infinite loops or cut the</span>
<span class="sd">    optimization short). When fast_duv is True (default) a faster method is used, but this</span>
<span class="sd">    only sufficiently accurate when the estimated CCT is 1 K or less than the</span>
<span class="sd">    true value. </span>
<span class="sd">    </span>
<span class="sd">    Reference:</span>
<span class="sd">        1. `Li, C., Cui, G., Melgosa, M., Ruan,X., Zhang, Y., Ma, L., Xiao, K., &amp; Luo, M. R. (2016).</span>
<span class="sd">        Accurate method for computing correlated color temperature. </span>
<span class="sd">        Optics Express, 24(13), 14066–14078. </span>
<span class="sd">        &lt;https://doi.org/10.1364/OE.24.014066&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># process NR input:</span>
    <span class="k">if</span> <span class="n">uvwbar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cspace_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">xyzbar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cieobs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">xyzbar</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">_get_xyzbar_wl_dl</span><span class="p">(</span><span class="n">cieobs</span><span class="p">,</span> <span class="n">wl</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">xyzbar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cieobs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Must supply xyzbar or cieobs or uvwbar !!!&#39;</span><span class="p">)</span>
            <span class="n">uvwbar</span> <span class="o">=</span> <span class="n">_convert_xyzbar_to_uvwbar</span><span class="p">(</span><span class="n">xyzbar</span><span class="p">,</span> <span class="n">cspace_dict</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Must supply cspace_dict if uvwbar is None. How to convert xyzbar if not supplied ?&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">uvwbar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">wl</span> <span class="o">=</span> <span class="n">uvwbar</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dl</span> <span class="o">=</span> <span class="n">getwld</span><span class="p">(</span><span class="n">wl</span><span class="p">)</span>
        <span class="n">uvwbar</span> <span class="o">=</span> <span class="n">uvwbar</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dl</span> <span class="o">=</span> <span class="n">getwld</span><span class="p">(</span><span class="n">wl</span><span class="p">)</span>

    
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">T0</span>
    <span class="k">while</span> <span class="kc">True</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">max_iter</span><span class="p">):</span>
           
        <span class="n">T</span><span class="p">[</span><span class="n">T</span> <span class="o">&lt;</span> <span class="n">_CCT_MIN</span><span class="p">]</span> <span class="o">=</span> <span class="n">_CCT_MIN</span> <span class="c1"># avoid infinities and convergence problems </span>
        
        <span class="c1"># Get (u,v), (u&#39;,v&#39;), (u&quot;,v&quot;):</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">uBB</span><span class="p">,</span> <span class="n">vBB</span><span class="p">,</span> <span class="n">upBB</span><span class="p">,</span> <span class="n">vpBB</span><span class="p">,</span> <span class="n">uppBB</span><span class="p">,</span> <span class="n">vppBB</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_get_uv_uvp_uvpp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">uvwbar</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;BB,BBp,BBpp&#39;</span><span class="p">)</span>

        <span class="c1"># Calculate DT (ratio of f&#39; and abs(f&quot;):</span>
        <span class="n">du</span><span class="p">,</span> <span class="n">dv</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">uBB</span><span class="p">),</span> <span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">vBB</span><span class="p">)</span> <span class="c1"># pre-calculate for speed</span>

        <span class="c1"># print(&#39;\n&#39;,((vpBB**2)-dv*vppBB).shape)</span>
        <span class="n">DT</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">du</span><span class="o">*</span><span class="n">upBB</span> <span class="o">+</span> <span class="n">dv</span><span class="o">*</span><span class="n">vpBB</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">upBB</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="n">du</span><span class="o">*</span><span class="n">uppBB</span> <span class="o">+</span> <span class="p">(</span><span class="n">vpBB</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="n">dv</span><span class="o">*</span><span class="n">vppBB</span><span class="p">)</span>

        <span class="c1"># DT[DT&gt;T] = _CCT_MIN # avoid convergence problems</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">T</span> <span class="o">-</span> <span class="n">DT</span> 

        <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">DT</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">atol</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="o">|</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">DT</span><span class="p">)</span><span class="o">/</span><span class="n">T</span> <span class="o">&lt;</span> <span class="n">rtol</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="k">break</span>
        <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
        
    <span class="c1"># get Duv:</span>
    <span class="k">if</span> <span class="o">~</span><span class="p">(</span><span class="n">fast_duv</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">DT</span><span class="p">)</span><span class="o">&lt;=</span><span class="mf">1.0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()):</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">uBB</span><span class="p">,</span> <span class="n">vBB</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_get_uv_uvp_uvpp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">uvwbar</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;BB&#39;</span><span class="p">)</span> <span class="c1"># update one last time</span>
    
    <span class="n">Duv</span> <span class="o">=</span> <span class="n">_get_Duv_for_T_from_uvBB</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span> <span class="n">uBB</span><span class="p">,</span> <span class="n">vBB</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">T</span><span class="p">,</span> <span class="n">Duv</span>

<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># Cascade lut estimator:</span>
<span class="c1">#------------------------------------------------------------------------------       </span>
<span class="k">def</span> <span class="nf">_get_loop_i_lut_for_cascading_lut</span><span class="p">(</span><span class="n">Tx</span><span class="p">,</span> <span class="n">TBB_m1</span><span class="p">,</span> <span class="n">TBB_p1</span><span class="p">,</span> <span class="n">out_of_lut</span><span class="p">,</span>
                                      <span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span><span class="p">,</span> 
                                      <span class="n">cascade_idx</span><span class="p">,</span> <span class="n">lut_char</span><span class="p">,</span> <span class="n">lut_resolution_reduction_factor</span><span class="p">,</span>
                                      <span class="n">mode</span><span class="p">,</span> <span class="n">luts_dict</span><span class="p">,</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">cspace_str</span><span class="p">,</span> <span class="n">cspace_dict</span><span class="p">,</span>
                                      <span class="n">ignore_wl_diff</span><span class="p">,</span>
                                      <span class="n">lut_generator_fcn</span> <span class="o">=</span> <span class="n">_generate_lut</span><span class="p">,</span>
                                      <span class="n">lut_generator_kwargs</span> <span class="o">=</span> <span class="p">{},</span>
                                      <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get a new updated lut with reduced min-max range for a cascading lut calculation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># cl cannot recover from out-of-lut, so if all are out-of-lut, no use continuing!</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">out_of_lut</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">out_of_lut</span><span class="o">.</span><span class="n">all</span><span class="p">()):</span> 
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span> <span class="c1"># ,None because expected output (from _generate_lut is 2):</span>

    <span class="c1"># get overall min, max Ts over all xyzw test points:</span>
    <span class="n">Ts_m1p1</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">TBB_m1</span><span class="p">,</span><span class="n">TBB_p1</span><span class="p">))</span>  
    <span class="n">Ts_min</span><span class="p">,</span> <span class="n">Ts_max</span> <span class="o">=</span> <span class="n">Ts_m1p1</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span><span class="n">Ts_m1p1</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="n">dTs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Ts_max</span> <span class="o">-</span> <span class="n">Ts_min</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">dTs</span><span class="o">&lt;=</span> <span class="n">atol</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="o">|</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dTs</span><span class="o">/</span><span class="n">Tx</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">rtol</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="n">Tx</span> <span class="o">=</span>  <span class="p">((</span><span class="n">Ts_min</span> <span class="o">+</span> <span class="n">Ts_max</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span> 
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">Tx</span> 
    <span class="k">else</span><span class="p">:</span>
        
        <span class="n">lut_int</span> <span class="o">=</span> <span class="n">lut_char</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">lut_int</span><span class="p">):</span> 
            <span class="n">lut_cl</span> <span class="o">=</span> <span class="mf">1e6</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">1e6</span><span class="o">/</span><span class="n">Ts_max</span><span class="p">,</span><span class="mf">1e6</span><span class="o">/</span><span class="n">Ts_min</span><span class="p">,</span><span class="n">lut_resolution_reduction_factor</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lut_unit</span> <span class="o">=</span> <span class="n">lut_char</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">lut_int</span> <span class="o">=</span> <span class="n">lut_int</span><span class="o">/</span><span class="n">lut_resolution_reduction_factor</span><span class="o">**</span><span class="p">(</span><span class="n">cascade_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            
            <span class="c1"># dTs = np.abs((Ts_max-Ts_min)) if (&#39;-1&#39; not in lut_unit) else np.abs((1e6/Ts_max - 1e6/Ts_min))</span>
            <span class="c1"># if (dTs &lt; lut_int).any(): </span>
            <span class="c1">#     lut_int = lut_int*np.ones_like(dTs) </span>
            <span class="c1">#     lut_int[dTs &lt; lut_int] = dTs[dTs&lt; lut_int]/lut_resolution_reduction_factor</span>

            <span class="n">lut_cl</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ts_min</span><span class="p">,</span><span class="n">Ts_max</span><span class="p">,</span><span class="n">lut_int</span><span class="p">,</span><span class="n">lut_unit</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;-1&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lut_unit</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="mf">1e6</span><span class="o">/</span><span class="n">Ts_max</span><span class="p">,</span><span class="mf">1e6</span><span class="o">/</span><span class="n">Ts_min</span><span class="p">,</span><span class="n">lut_int</span><span class="p">,</span><span class="n">lut_unit</span><span class="p">]</span>
            
        
        <span class="c1">#return (lut, lut_kwargs) tuple:</span>
        <span class="n">lut_vars</span> <span class="o">=</span> <span class="n">lut_generator_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;lut_vars&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="s1">&#39;lut_vars&#39;</span> <span class="ow">in</span> <span class="n">lut_generator_kwargs</span> <span class="k">else</span> <span class="n">_CCT_LUT</span><span class="p">[</span><span class="n">mode</span><span class="p">][</span><span class="s1">&#39;lut_vars&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">lut_generator_fcn</span><span class="p">(</span><span class="n">lut_cl</span><span class="p">,</span> <span class="n">seamless_stitch</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
                                 <span class="n">fallback_unit</span> <span class="o">=</span> <span class="n">_CCT_FALLBACK_UNIT</span><span class="p">,</span> 
                                 <span class="n">fallback_n</span> <span class="o">=</span> <span class="n">_CCT_FALLBACK_N</span><span class="p">,</span>
                                 <span class="n">resample_ndarray</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                                 <span class="n">luts_dict</span> <span class="o">=</span> <span class="n">luts_dict</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> 
                                 <span class="n">lut_type_def</span> <span class="o">=</span> <span class="n">_CCT_LUT</span><span class="p">[</span><span class="n">mode</span><span class="p">][</span><span class="s1">&#39;lut_type_def&#39;</span><span class="p">],</span>
                                 <span class="n">cspace_str</span> <span class="o">=</span> <span class="n">cspace_str</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> <span class="n">cspace</span> <span class="o">=</span> <span class="n">cspace_dict</span><span class="p">,</span> 
                                 <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ignore_unequal_wl</span> <span class="o">=</span> <span class="n">ignore_wl_diff</span><span class="p">,</span> 
                                 <span class="n">lut_vars</span> <span class="o">=</span> <span class="n">lut_vars</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">lut_generator_kwargs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_get_cascading_lut_Tx</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">lut</span><span class="p">,</span> <span class="n">lut_n_cols</span><span class="p">,</span> <span class="n">lut_char</span><span class="p">,</span> <span class="n">lut_resolution_reduction_factor</span><span class="p">,</span>
                          <span class="n">luts_dict</span><span class="p">,</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">cspace_str</span><span class="p">,</span> <span class="n">cspace_dict</span><span class="p">,</span> <span class="n">ignore_wl_diff</span><span class="p">,</span>
                          <span class="n">max_iter</span> <span class="o">=</span> <span class="n">_CCT_MAX_ITER</span><span class="p">,</span> <span class="n">mode_kwargs</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">,</span> 
                          <span class="n">Tx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">Duvx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out_of_lut</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">TBB_l</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">TBB_r</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="n">fast_duv</span> <span class="o">=</span> <span class="n">_CCT_FAST_DUV</span><span class="p">,</span>
                          <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine Tx using a specified mode from u,v input using a cascading lut, </span>
<span class="sd">    i.e. lut progressively decreasing in min-max range, zooming-in on the </span>
<span class="sd">    &#39;true&#39; Tx value. lut_n_cols should specify the number of columns in the lut</span>
<span class="sd">    for the specified mode. _uv_to_Tx_mode is a function that calculates the Tx</span>
<span class="sd">    for the specific mode from u,v. It should have the following interface:</span>
<span class="sd">    _uv_to_Tx_mode(u,v,lut,lut_n_cols, ns = 0, out_of_lut = None, </span>
<span class="sd">                   Tx = None, out_of_lut = None, TBB_l = None, TBB_r = None)</span>
<span class="sd">    and return the Tx,Duvx, out_of_lut and a tuple with Tleft (TBB_m1), Tright (TBB_p1). </span>
<span class="sd">    Duvx can be None if method doesn&#39;t naturally provide an estimate.</span>
<span class="sd">    Skips first calculation of Tx when (Tx0, out_of_lut, TBB_l, TBB_r) are None</span>
<span class="sd">    (i.e. already calculated).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># cascading lut:</span>
    <span class="n">cascade_i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">lut_i</span> <span class="o">=</span> <span class="n">lut</span> <span class="c1"># cascading lut will be updated later in the while loop</span>
    <span class="n">_uv_to_Tx_mode</span> <span class="o">=</span> <span class="n">_CCT_UV_TO_TX_FCNS</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
    <span class="n">lut_generator_fcn</span> <span class="o">=</span> <span class="n">_CCT_LUT</span><span class="p">[</span><span class="n">mode</span><span class="p">][</span><span class="s1">&#39;_generate_lut&#39;</span><span class="p">]</span>
    <span class="n">lut_generator_kwargs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">mode_kwargs</span><span class="p">[</span><span class="n">mode</span><span class="p">])</span>
    
    <span class="c1"># some mode specific processing to prepare lut_generator_kwargs:</span>
    <span class="n">lut_generator_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;f_corr&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">})</span> <span class="c1"># only required when mode = &#39;ohno2014&#39;</span>
    <span class="k">if</span> <span class="s1">&#39;wl&#39;</span> <span class="ow">in</span> <span class="n">lut_generator_kwargs</span><span class="p">:</span> <span class="n">lut_generator_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;wl&#39;</span><span class="p">)</span> <span class="c1"># for mode == &#39;zhang2019&#39;: &#39;wl&#39; is also part of this dict!</span>
    <span class="c1"># if &#39;lut_vars&#39; in lut_generator_kwargs: lut_generator_kwargs.pop(&#39;lut_vars&#39;) # for mode == &#39;zhang2019&#39;: &#39;wl&#39; is also part of this dict!</span>
    
    <span class="k">while</span> <span class="kc">True</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cascade_i</span> <span class="o">&lt;</span> <span class="n">max_iter</span><span class="p">):</span>
        
        <span class="c1"># needed to get correct columns from updated lut_i:</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">lut_i</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="n">lut_n_cols</span>
        <span class="n">ns</span> <span class="o">=</span> <span class="n">lut_n_cols</span> <span class="c1">#np.arange(0,N*lut_n_cols,lut_n_cols,dtype= np.int32)</span>

        <span class="c1"># get Tx estimate, out_of_lut boolean array, and (TBB_m1, TBB_p1 or equivalent):</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">Tx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">out_of_lut</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TBB_l</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TBB_r</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="n">cascade_i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">Tx</span><span class="p">,</span> <span class="n">Duvx</span><span class="p">,</span> <span class="n">out_of_lut</span><span class="p">,</span> <span class="p">(</span><span class="n">TBB_l</span><span class="p">,</span><span class="n">TBB_r</span><span class="p">)</span> <span class="o">=</span> <span class="n">_uv_to_Tx_mode</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">lut_i</span><span class="p">,</span> <span class="n">lut_n_cols</span><span class="p">,</span> 
                                                                 <span class="n">ns</span> <span class="o">=</span> <span class="n">ns</span><span class="p">,</span> <span class="n">out_of_lut</span> <span class="o">=</span> <span class="n">out_of_lut</span><span class="p">,</span>
                                                                 <span class="n">fast_duv</span> <span class="o">=</span> <span class="n">fast_duv</span><span class="p">,</span>
                                                                 <span class="o">**</span><span class="p">{</span><span class="o">**</span><span class="n">mode_kwargs</span><span class="p">[</span><span class="n">mode</span><span class="p">],</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;max_iter&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}})</span> <span class="c1"># cl takes over, so max_iter should be 1</span>

        <span class="k">if</span> <span class="n">cascade_i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">Tx0</span> <span class="o">=</span> <span class="n">Tx</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># keep copy of first estimate</span>

        <span class="c1"># Update lut for next cascade (ie decrease min-max range):</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">_get_loop_i_lut_for_cascading_lut</span><span class="p">(</span><span class="n">Tx</span><span class="p">,</span> <span class="n">TBB_l</span><span class="p">,</span> <span class="n">TBB_r</span><span class="p">,</span> <span class="n">out_of_lut</span><span class="p">,</span>
                                                <span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span><span class="p">,</span> 
                                                <span class="n">cascade_i</span><span class="p">,</span> <span class="n">lut_char</span><span class="p">,</span> <span class="n">lut_resolution_reduction_factor</span><span class="p">,</span>
                                                <span class="n">mode</span><span class="p">,</span> <span class="n">luts_dict</span><span class="p">,</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">cspace_str</span><span class="p">,</span> <span class="n">cspace_dict</span><span class="p">,</span>
                                                <span class="n">ignore_wl_diff</span><span class="p">,</span>
                                                <span class="n">lut_generator_fcn</span> <span class="o">=</span> <span class="n">lut_generator_fcn</span><span class="p">,</span>
                                                <span class="n">lut_generator_kwargs</span> <span class="o">=</span> <span class="n">lut_generator_kwargs</span><span class="p">,</span>
                                                <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span> 
            <span class="k">if</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">Tx</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lut_i</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">lut_kwargs</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">cascade_i</span><span class="o">+=</span><span class="mi">1</span> <span class="c1"># to stop cascade loop after max_iter iterations</span>
    
    <span class="n">Tx</span><span class="p">[</span><span class="n">out_of_lut</span><span class="p">]</span> <span class="o">=</span> <span class="n">Tx0</span><span class="p">[</span><span class="n">out_of_lut</span><span class="p">]</span> <span class="c1"># restore originals as cl_lut might have messed up these Tx   </span>

    <span class="k">return</span> <span class="n">Tx</span><span class="p">,</span> <span class="n">Duvx</span>


<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># General _xyz_to_cct structure:</span>
<span class="c1">#------------------------------------------------------------------------------</span>
<span class="k">def</span> <span class="nf">_xyz_to_cct</span><span class="p">(</span><span class="n">xyzw</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">is_uv_input</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">_CIEOBS</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;cct&#39;</span><span class="p">,</span>
                <span class="n">lut</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">luts_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ignore_wl_diff</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                <span class="n">force_tolerance</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">tol_method</span> <span class="o">=</span> <span class="s1">&#39;newton-raphson&#39;</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">,</span> 
                <span class="n">max_iter</span> <span class="o">=</span> <span class="n">_CCT_MAX_ITER</span><span class="p">,</span> <span class="n">force_au</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                <span class="n">split_calculation_at_N</span> <span class="o">=</span> <span class="n">_CCT_SPLIT_CALC_AT_N</span><span class="p">,</span> <span class="n">lut_resolution_reduction_factor</span> <span class="o">=</span> <span class="n">_CCT_LUT_RESOLUTION_REDUCTION_FACTOR</span><span class="p">,</span>
                <span class="n">cspace</span> <span class="o">=</span> <span class="n">_CCT_CSPACE</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">_CCT_CSPACE_KWARGS</span><span class="p">,</span>
                <span class="n">duv_triangular_threshold</span> <span class="o">=</span> <span class="mf">0.002</span><span class="p">,</span> 
                <span class="n">first_guess_mode</span> <span class="o">=</span> <span class="s1">&#39;robertson1968&#39;</span><span class="p">,</span>
                <span class="n">use_fast_duv</span> <span class="o">=</span> <span class="n">_CCT_FAST_DUV</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Convert XYZ tristimulus values to correlated color temperature (CCT) and </span>
<span class="sd">    Duv (distance above (&gt;0) or below (&lt;0) the Planckian locus) using a number</span>
<span class="sd">    of modes (methods). </span>
<span class="sd">    </span>
<span class="sd">    General fucntion for calculation of &#39;robertson1968&#39;, &#39;ohno2014&#39;, &#39;li2016&#39; and &#39;zhang2019&#39;</span>
<span class="sd">    (for info on arguments, see docstring of xyz_to_cct)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># allow for seperate max_iter for mode and follow-up tol_method:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_iter</span><span class="p">,(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">max_iter</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_iter</span><span class="p">,</span><span class="n">max_iter</span><span class="p">)</span> <span class="c1">#(mode, tol_method)</span>
    
    <span class="c1"># Deal with mode == &#39;li2016&#39;: </span>
    <span class="k">if</span> <span class="s1">&#39;li2016&#39;</span> <span class="ow">in</span> <span class="n">mode</span><span class="p">:</span> 
        <span class="k">if</span> <span class="s1">&#39;:&#39;</span> <span class="ow">in</span> <span class="n">mode</span><span class="p">:</span> <span class="c1"># for &#39;li2016:first_guess_mode&#39; format</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">mode</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
            <span class="n">first_guess_mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="n">first_guess_mode</span> <span class="c1"># overwrite mode with first_guess_mode as this is the one to use together with LUTs</span>
        <span class="n">force_tolerance</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># must be True, otherwise li2016 == first_guess_mode output!</span>
        <span class="n">tol_method</span> <span class="o">=</span> <span class="s1">&#39;newton-raphson&#39;</span> <span class="c1"># by default, no need for addditional lut cascading   </span>
    
    <span class="c1"># Process cspace-parameters:</span>
    <span class="n">cspace_dict</span><span class="p">,</span> <span class="n">cspace_str</span> <span class="o">=</span> <span class="n">_process_cspace</span><span class="p">(</span><span class="n">cspace</span><span class="p">,</span> <span class="n">cspace_kwargs</span><span class="p">)</span>
    
    <span class="c1"># Get chromaticity coordinates u,v from xyzw:</span>
    <span class="n">uvw</span> <span class="o">=</span> <span class="n">cspace_dict</span><span class="p">[</span><span class="s1">&#39;fwtf&#39;</span><span class="p">](</span><span class="n">xyzw</span><span class="p">)[:,</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>  <span class="k">if</span> <span class="n">is_uv_input</span> <span class="o">==</span> <span class="kc">False</span> <span class="k">else</span> <span class="n">xyzw</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># xyz contained uv !!! (needed to efficiently determine f_corr)</span>
    
    <span class="c1"># pre-calculate wl,dl,uvwbar for later use (will also determine wl if None !):</span>
    <span class="n">xyzbar</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">_get_xyzbar_wl_dl</span><span class="p">(</span><span class="n">cieobs</span><span class="p">,</span> <span class="n">wl</span><span class="p">)</span>
    <span class="n">uvwbar</span> <span class="o">=</span> <span class="n">_convert_xyzbar_to_uvwbar</span><span class="p">(</span><span class="n">xyzbar</span><span class="p">,</span> <span class="n">cspace_dict</span><span class="p">)</span>
    
    <span class="c1"># Get or generate requested lut</span>
    <span class="c1"># (if wl doesn&#39;t match those in _CCT_LUT[mode] , </span>
    <span class="c1"># a new recalculated lut will be generated):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">luts_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span> 
        <span class="n">luts_dict</span> <span class="o">=</span> <span class="n">_CCT_LUT</span><span class="p">[</span><span class="n">mode</span><span class="p">][</span><span class="s1">&#39;luts&#39;</span><span class="p">]</span>

    <span class="n">lut</span><span class="p">,</span> <span class="n">lut_kwargs</span> <span class="o">=</span> <span class="n">_get_lut</span><span class="p">(</span><span class="n">lut</span><span class="p">,</span> 
                               <span class="n">fallback_unit</span> <span class="o">=</span> <span class="n">_CCT_FALLBACK_UNIT</span><span class="p">,</span> 
                               <span class="n">fallback_n</span> <span class="o">=</span> <span class="n">_CCT_FALLBACK_N</span><span class="p">,</span>
                               <span class="n">resample_ndarray</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                               <span class="n">luts_dict</span> <span class="o">=</span> <span class="n">luts_dict</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> 
                               <span class="n">lut_type_def</span> <span class="o">=</span> <span class="n">_CCT_LUT</span><span class="p">[</span><span class="n">mode</span><span class="p">][</span><span class="s1">&#39;lut_type_def&#39;</span><span class="p">],</span>
                               <span class="n">cspace_str</span> <span class="o">=</span> <span class="n">cspace_str</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> <span class="n">cspace</span> <span class="o">=</span> <span class="n">cspace_dict</span><span class="p">,</span> 
                               <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ignore_unequal_wl</span> <span class="o">=</span> <span class="n">ignore_wl_diff</span><span class="p">,</span> 
                               <span class="n">lut_generator_fcn</span> <span class="o">=</span> <span class="n">_CCT_LUT</span><span class="p">[</span><span class="n">mode</span><span class="p">][</span><span class="s1">&#39;_generate_lut&#39;</span><span class="p">],</span>
                               <span class="n">lut_vars</span> <span class="o">=</span> <span class="n">_CCT_LUT</span><span class="p">[</span><span class="n">mode</span><span class="p">][</span><span class="s1">&#39;lut_vars&#39;</span><span class="p">])</span>
    
    <span class="c1"># Prepare some parameters for forced tolerance:</span>
    <span class="k">if</span> <span class="n">force_tolerance</span><span class="p">:</span> 
        <span class="k">if</span> <span class="p">(</span><span class="n">tol_method</span> <span class="o">==</span> <span class="s1">&#39;newton-raphson&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">tol_method</span> <span class="o">==</span> <span class="s1">&#39;nr&#39;</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">tol_method</span> <span class="o">==</span> <span class="s1">&#39;cascading-lut&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">tol_method</span> <span class="o">==</span> <span class="s1">&#39;cl&#39;</span><span class="p">):</span> 
            <span class="n">lut_char</span> <span class="o">=</span> <span class="n">_get_lut_characteristics</span><span class="p">(</span><span class="n">lut</span><span class="p">,</span> <span class="n">force_au</span> <span class="o">=</span> <span class="n">force_au</span><span class="p">)</span>
            <span class="n">use_fast_duv</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># True can generate large errors !!!</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Tolerance method = </span><span class="si">{:s}</span><span class="s1"> not implemented.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tol_method</span><span class="p">))</span>
    
    <span class="n">lut_n_cols</span> <span class="o">=</span> <span class="n">lut</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># store now, as this will change later</span>
    
    <span class="c1"># prepare split of input data to speed up calculation:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">xyzw</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ccts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">duvs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">n_ii</span> <span class="o">=</span> <span class="n">split_calculation_at_N</span> <span class="k">if</span> <span class="n">split_calculation_at_N</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">n</span>
    <span class="n">N_ii</span> <span class="o">=</span> <span class="n">n</span><span class="o">//</span><span class="n">n_ii</span> <span class="o">+</span> <span class="mi">1</span><span class="o">*</span><span class="p">((</span><span class="n">n</span><span class="o">%</span><span class="n">n_ii</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">lut_vars</span> <span class="o">=</span> <span class="n">_CCT_LUT</span><span class="p">[</span><span class="n">mode</span><span class="p">][</span><span class="s1">&#39;lut_vars&#39;</span><span class="p">]</span>  <span class="k">if</span> <span class="s1">&#39;lut_vars&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;lut_vars&#39;</span><span class="p">]</span> 
    <span class="c1"># prepare mode_kwargs (i.e. extra kwargs for _uv_to_Tx_mode() required by specific modes):</span>
    <span class="n">mode_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;robertson1968&#39;</span><span class="p">:</span> <span class="p">{},</span>
                   <span class="s1">&#39;zhang2019&#39;</span> <span class="p">:</span> <span class="p">{</span><span class="s1">&#39;uvwbar&#39;</span> <span class="p">:</span> <span class="n">uvwbar</span><span class="p">,</span> <span class="s1">&#39;wl&#39;</span> <span class="p">:</span> <span class="n">wl</span><span class="p">,</span> <span class="s1">&#39;dl&#39;</span> <span class="p">:</span> <span class="n">dl</span><span class="p">,</span> <span class="s1">&#39;lut_vars&#39;</span> <span class="p">:</span> <span class="n">lut_vars</span><span class="p">,</span>
                                  <span class="s1">&#39;max_iter&#39;</span> <span class="p">:</span> <span class="n">max_iter</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;atol&#39;</span> <span class="p">:</span> <span class="n">atol</span><span class="p">,</span> <span class="s1">&#39;rtol&#39;</span> <span class="p">:</span> <span class="n">rtol</span><span class="p">},</span>
                   <span class="s1">&#39;ohno2014&#39;</span> <span class="p">:</span> <span class="p">{</span><span class="o">**</span><span class="n">lut_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="s1">&#39;duv_triangular_threshold&#39;</span> <span class="p">:</span> <span class="n">duv_triangular_threshold</span><span class="p">}},</span>
                   <span class="s1">&#39;li2022&#39;</span> <span class="p">:</span>   <span class="p">{</span><span class="o">**</span><span class="n">lut_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="s1">&#39;duv_triangular_threshold&#39;</span> <span class="p">:</span> <span class="n">duv_triangular_threshold</span><span class="p">,</span><span class="s1">&#39;uvwbar&#39;</span> <span class="p">:</span> <span class="n">uvwbar</span><span class="p">,</span> <span class="s1">&#39;wl&#39;</span> <span class="p">:</span> <span class="n">wl</span><span class="p">,</span> <span class="s1">&#39;dl&#39;</span> <span class="p">:</span> <span class="n">dl</span><span class="p">}},</span>
                   <span class="s1">&#39;fibonacci&#39;</span> <span class="p">:</span> <span class="p">{</span><span class="s1">&#39;uvwbar&#39;</span> <span class="p">:</span> <span class="n">uvwbar</span><span class="p">,</span> <span class="s1">&#39;wl&#39;</span> <span class="p">:</span> <span class="n">wl</span><span class="p">,</span> <span class="s1">&#39;dl&#39;</span> <span class="p">:</span> <span class="n">dl</span><span class="p">,</span> <span class="s1">&#39;lut_vars&#39;</span> <span class="p">:</span> <span class="n">lut_vars</span><span class="p">,</span>
                                  <span class="s1">&#39;max_iter&#39;</span> <span class="p">:</span> <span class="n">max_iter</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;atol&#39;</span> <span class="p">:</span> <span class="n">atol</span><span class="p">,</span> <span class="s1">&#39;rtol&#39;</span> <span class="p">:</span> <span class="n">rtol</span><span class="p">},</span>
                   <span class="s1">&#39;none&#39;</span> <span class="p">:</span> <span class="p">{</span><span class="s1">&#39;uvwbar&#39;</span> <span class="p">:</span> <span class="n">uvwbar</span><span class="p">,</span> <span class="s1">&#39;wl&#39;</span> <span class="p">:</span> <span class="n">wl</span><span class="p">,</span> <span class="s1">&#39;dl&#39;</span> <span class="p">:</span> <span class="n">dl</span><span class="p">,</span> <span class="s1">&#39;lut_vars&#39;</span> <span class="p">:</span> <span class="n">lut_vars</span><span class="p">,</span>
                             <span class="s1">&#39;max_iter&#39;</span> <span class="p">:</span> <span class="n">max_iter</span><span class="p">,</span> <span class="s1">&#39;atol&#39;</span> <span class="p">:</span> <span class="n">atol</span><span class="p">,</span> <span class="s1">&#39;rtol&#39;</span> <span class="p">:</span> <span class="n">rtol</span><span class="p">}</span>
                   <span class="p">}</span> 

    <span class="c1"># loop of splitted data:</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_ii</span><span class="p">):</span>
        <span class="n">out_of_lut</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># get data for split ii:</span>
        <span class="n">uv</span> <span class="o">=</span> <span class="n">uvw</span><span class="p">[</span><span class="n">n_ii</span><span class="o">*</span><span class="n">ii</span><span class="p">:</span><span class="n">n_ii</span><span class="o">*</span><span class="n">ii</span><span class="o">+</span><span class="n">n_ii</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">ii</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">N_ii</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="k">else</span> <span class="n">uvw</span><span class="p">[</span><span class="n">n_ii</span><span class="o">*</span><span class="n">ii</span><span class="p">:]</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">uv</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="kc">None</span><span class="p">],</span> <span class="n">uv</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
        
        <span class="c1"># get Tx estimate, out_of_lut boolean array, and (TBB_m1, TBB_p1 or equivalent):</span>
        <span class="n">Tx</span><span class="p">,</span> <span class="n">Duvx</span><span class="p">,</span> <span class="n">out_of_lut</span><span class="p">,</span> <span class="p">(</span><span class="n">TBB_l</span><span class="p">,</span> <span class="n">TBB_r</span><span class="p">)</span> <span class="o">=</span> <span class="n">_CCT_UV_TO_TX_FCNS</span><span class="p">[</span><span class="n">mode</span><span class="p">](</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">lut</span><span class="p">,</span> <span class="n">lut_n_cols</span><span class="p">,</span> 
                                                                        <span class="n">ns</span> <span class="o">=</span> <span class="n">lut_n_cols</span><span class="p">,</span> 
                                                                        <span class="n">out_of_lut</span> <span class="o">=</span> <span class="n">out_of_lut</span><span class="p">,</span>
                                                                        <span class="n">fast_duv</span> <span class="o">=</span> <span class="n">use_fast_duv</span><span class="p">,</span>
                                                                        <span class="o">**</span><span class="n">mode_kwargs</span><span class="p">[</span><span class="n">mode</span><span class="p">])</span>  

        <span class="k">if</span> <span class="n">force_tolerance</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">tol_method</span> <span class="o">==</span> <span class="s1">&#39;cascading-lut&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">tol_method</span> <span class="o">==</span> <span class="s1">&#39;cl&#39;</span><span class="p">):</span> 

                <span class="n">Tx</span><span class="p">,</span><span class="n">Duvx</span> <span class="o">=</span> <span class="n">_get_cascading_lut_Tx</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">lut</span><span class="p">,</span> <span class="n">lut_n_cols</span><span class="p">,</span> <span class="n">lut_char</span><span class="p">,</span> <span class="n">lut_resolution_reduction_factor</span><span class="p">,</span>
                                                <span class="n">luts_dict</span><span class="p">,</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">cspace_str</span><span class="p">,</span> <span class="n">cspace_dict</span><span class="p">,</span> <span class="n">ignore_wl_diff</span><span class="p">,</span> 
                                                <span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mode_kwargs</span> <span class="o">=</span> <span class="n">mode_kwargs</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="n">rtol</span><span class="p">,</span>
                                                <span class="n">Tx</span> <span class="o">=</span> <span class="n">Tx</span><span class="p">,</span> <span class="n">Duvx</span> <span class="o">=</span> <span class="n">Duvx</span><span class="p">,</span> <span class="n">out_of_lut</span> <span class="o">=</span> <span class="n">out_of_lut</span><span class="p">,</span> <span class="n">TBB_l</span> <span class="o">=</span> <span class="n">TBB_l</span><span class="p">,</span> <span class="n">TBB_r</span> <span class="o">=</span> <span class="n">TBB_r</span><span class="p">,</span>
                                                <span class="n">fast_duv</span> <span class="o">=</span> <span class="n">use_fast_duv</span>
                                                <span class="p">)</span>

   
            <span class="k">elif</span> <span class="p">(</span><span class="n">tol_method</span> <span class="o">==</span> <span class="s1">&#39;newton-raphson&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">tol_method</span> <span class="o">==</span> <span class="s1">&#39;nr&#39;</span><span class="p">):</span>

                <span class="n">Tx</span><span class="p">,</span> <span class="n">Duvx</span> <span class="o">=</span> <span class="n">_get_newton_raphson_estimated_Tc</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">Tx</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> <span class="n">uvwbar</span> <span class="o">=</span> <span class="n">uvwbar</span><span class="p">,</span>
                                                            <span class="n">atol</span> <span class="o">=</span> <span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="n">rtol</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                            <span class="n">fast_duv</span> <span class="o">=</span> <span class="n">use_fast_duv</span><span class="p">)</span>           

        <span class="k">if</span> <span class="n">Duvx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Duvx</span> <span class="o">=</span> <span class="n">_get_Duv_for_T</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span> <span class="n">Tx</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">cspace_dict</span><span class="p">,</span> 
                                  <span class="n">uvwbar</span> <span class="o">=</span> <span class="n">uvwbar</span><span class="p">,</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">dl</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">out_of_lut</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">Tx</span> <span class="o">=</span> <span class="n">Tx</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">out_of_lut</span>

        <span class="c1"># Add freshly calculated Tx, Duvx to storage array:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ii</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">N_ii</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span> 
            <span class="n">ccts</span><span class="p">[</span><span class="n">n_ii</span><span class="o">*</span><span class="n">ii</span><span class="p">:</span><span class="n">n_ii</span><span class="o">*</span><span class="n">ii</span><span class="o">+</span><span class="n">n_ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">Tx</span>
            <span class="n">duvs</span><span class="p">[</span><span class="n">n_ii</span><span class="o">*</span><span class="n">ii</span><span class="p">:</span><span class="n">n_ii</span><span class="o">*</span><span class="n">ii</span><span class="o">+</span><span class="n">n_ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">Duvx</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">ccts</span><span class="p">[</span><span class="n">n_ii</span><span class="o">*</span><span class="n">ii</span><span class="p">:]</span> <span class="o">=</span> <span class="n">Tx</span>
            <span class="n">duvs</span><span class="p">[</span><span class="n">n_ii</span><span class="o">*</span><span class="n">ii</span><span class="p">:]</span> <span class="o">=</span> <span class="n">Duvx</span>
   
    <span class="c1"># Regulate output:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;cct&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ccts</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;duv&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">duvs</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;cct,duv&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ccts</span><span class="p">,</span> <span class="n">duvs</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s2">&quot;[cct,duv]&quot;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">ccts</span><span class="p">,</span><span class="n">duvs</span><span class="p">))</span>   
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Unknown output requested&#39;</span><span class="p">)</span>



<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># Robertson 1968:</span>
<span class="c1">#------------------------------------------------------------------------------</span>
<span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;robertson1968&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;robertson1968&#39;</span><span class="p">][</span><span class="s1">&#39;lut_type_def&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">_CCT_LUT_MIN</span><span class="p">,</span> <span class="n">_CCT_LUT_MAX</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;%&#39;</span><span class="p">),)</span> <span class="c1"># default LUT, must be in all_modes</span>
<span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;robertson1968&#39;</span><span class="p">][</span><span class="s1">&#39;lut_vars&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;uv&#39;</span><span class="p">,</span><span class="s1">&#39;iso-T-slope&#39;</span><span class="p">]</span>
<span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;robertson1968&#39;</span><span class="p">][</span><span class="s1">&#39;_generate_lut&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_generate_lut</span> 

<span class="k">def</span> <span class="nf">_uv_to_Tx_robertson1968</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">lut</span><span class="p">,</span> <span class="n">lut_n_cols</span><span class="p">,</span> <span class="n">ns</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">out_of_lut</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">fast_duv</span> <span class="o">=</span> <span class="n">_CCT_FAST_DUV</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Calculate Tx from u,v and lut using Robertson 1968.</span>
<span class="sd">    (lut_n_cols specifies the number of columns in the lut for &#39;robertson1968&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Duvx</span> <span class="o">=</span> <span class="kc">None</span> 
    <span class="n">idx_sources</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> <span class="c1"># source/conversion index</span>
    
    <span class="c1"># get uBB, vBB, mBB from lut:</span>
    <span class="n">TBB</span><span class="p">,</span> <span class="n">uBB</span><span class="p">,</span> <span class="n">vBB</span><span class="p">,</span> <span class="n">mBB</span>  <span class="o">=</span> <span class="n">lut</span><span class="p">[:,</span><span class="mi">0</span><span class="p">::</span><span class="n">lut_n_cols</span><span class="p">],</span> <span class="n">lut</span><span class="p">[:,</span><span class="mi">1</span><span class="p">::</span><span class="n">lut_n_cols</span><span class="p">],</span> <span class="n">lut</span><span class="p">[:,</span><span class="mi">2</span><span class="p">::</span><span class="n">lut_n_cols</span><span class="p">],</span> <span class="n">lut</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">::</span><span class="n">lut_n_cols</span><span class="p">]</span>
    
    <span class="c1"># calculate distances to coordinates in lut (Eq. 4 in Robertson, 1968):</span>
    <span class="n">di</span> <span class="o">=</span> <span class="p">((</span><span class="n">v</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">vBB</span><span class="p">)</span> <span class="o">-</span> <span class="n">mBB</span> <span class="o">*</span> <span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">uBB</span><span class="p">))</span> <span class="o">/</span> <span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">mBB</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mf">0.5</span><span class="p">))</span>
    <span class="n">pn</span> <span class="o">=</span> <span class="p">(((</span><span class="n">v</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">vBB</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">uBB</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
    <span class="c1"># Get di_0, mBB_0 values to check sign of di_0 * mBB_0 -&gt; if positive (right of apex): [j,j+1] -&gt; [j-1,j]</span>
    <span class="n">di_0</span> <span class="o">=</span> <span class="n">_get_pns_from_x</span><span class="p">(</span><span class="n">di</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx_sources</span><span class="p">,</span> <span class="n">m0p</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>
    <span class="n">mBB_0</span> <span class="o">=</span> <span class="n">_get_pns_from_x</span><span class="p">(</span><span class="n">mBB</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx_sources</span><span class="p">,</span> <span class="n">m0p</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>
    
    <span class="c1"># Deal with positive slopes of iso-T lines</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">di_0</span><span class="o">*</span><span class="n">mBB_0</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">pn</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">pn</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> 
    
    <span class="c1"># Deal with endpoints of lut + create intermediate variables to save memory:</span>
    <span class="n">pn</span><span class="p">,</span> <span class="n">out_of_lut</span> <span class="o">=</span> <span class="n">_deal_with_lut_end_points</span><span class="p">(</span><span class="n">pn</span><span class="p">,</span> <span class="n">TBB</span><span class="p">,</span> <span class="n">out_of_lut</span><span class="p">)</span>
    
    <span class="c1"># Get final values required for T calculation:</span>
    <span class="n">mBB_0</span><span class="p">,</span> <span class="n">mBB_p1</span> <span class="o">=</span> <span class="n">_get_pns_from_x</span><span class="p">(</span><span class="n">mBB</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx_sources</span><span class="p">,</span> <span class="n">m0p</span> <span class="o">=</span> <span class="s1">&#39;0p&#39;</span><span class="p">)</span>
    <span class="n">TBB_m1</span><span class="p">,</span> <span class="n">TBB_0</span><span class="p">,</span> <span class="n">TBB_p1</span> <span class="o">=</span> <span class="n">_get_pns_from_x</span><span class="p">(</span><span class="n">TBB</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx_sources</span><span class="p">,</span> <span class="n">m0p</span> <span class="o">=</span> <span class="s1">&#39;m0p&#39;</span><span class="p">)</span>
    <span class="n">di_0</span><span class="p">,</span> <span class="n">di_p1</span> <span class="o">=</span> <span class="n">_get_pns_from_x</span><span class="p">(</span><span class="n">di</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx_sources</span><span class="p">,</span> <span class="n">m0p</span> <span class="o">=</span> <span class="s1">&#39;0p&#39;</span><span class="p">)</span>


    <span class="c1"># Estimate Tc (Robertson, 1968): </span>
    <span class="n">sign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">mBB_0</span><span class="o">*</span><span class="n">mBB_p1</span><span class="p">)</span> <span class="c1"># Solve issue of zero-crossing of slope of planckian locus:</span>
    <span class="n">slope</span> <span class="o">=</span> <span class="p">(</span><span class="n">di_0</span><span class="o">/</span><span class="p">((</span><span class="n">di_0</span> <span class="o">-</span> <span class="n">sign</span><span class="o">*</span><span class="n">di_p1</span><span class="p">)</span> <span class="o">+</span> <span class="n">_CCT_AVOID_ZERO_DIV</span><span class="p">))</span>
    <span class="n">Tx</span> <span class="o">=</span> <span class="p">((((</span><span class="mi">1</span><span class="o">/</span><span class="n">TBB_0</span><span class="p">)</span> <span class="o">+</span> <span class="n">slope</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span><span class="o">/</span><span class="n">TBB_p1</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">TBB_0</span><span class="p">)))</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">fast_duv</span><span class="p">:</span>
        <span class="n">uBB_0</span><span class="p">,</span> <span class="n">uBB_p1</span> <span class="o">=</span> <span class="n">_get_pns_from_x</span><span class="p">(</span><span class="n">uBB</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx_sources</span><span class="p">,</span> <span class="n">m0p</span> <span class="o">=</span> <span class="s1">&#39;0p&#39;</span><span class="p">)</span>
        <span class="n">vBB_0</span><span class="p">,</span> <span class="n">vBB_p1</span> <span class="o">=</span> <span class="n">_get_pns_from_x</span><span class="p">(</span><span class="n">vBB</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx_sources</span><span class="p">,</span> <span class="n">m0p</span> <span class="o">=</span> <span class="s1">&#39;0p&#39;</span><span class="p">)</span>
        <span class="n">ux</span><span class="p">,</span> <span class="n">vx</span> <span class="o">=</span> <span class="p">(</span><span class="n">uBB_0</span> <span class="o">+</span> <span class="n">slope</span> <span class="o">*</span> <span class="p">(</span><span class="n">uBB_p1</span> <span class="o">-</span> <span class="n">uBB_0</span><span class="p">)),</span> <span class="p">(</span><span class="n">vBB_0</span> <span class="o">+</span> <span class="n">slope</span> <span class="o">*</span> <span class="p">(</span><span class="n">vBB_p1</span> <span class="o">-</span> <span class="n">vBB_0</span><span class="p">))</span>
        <span class="n">Duvx</span> <span class="o">=</span> <span class="n">_get_Duv_for_T_from_uvBB</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">ux</span><span class="p">,</span> <span class="n">vx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Tx</span><span class="p">,</span> <span class="n">Duvx</span><span class="p">,</span> <span class="n">out_of_lut</span><span class="p">,</span> <span class="p">(</span><span class="n">TBB_m1</span><span class="p">,</span> <span class="n">TBB_p1</span><span class="p">)</span>

<span class="n">_CCT_UV_TO_TX_FCNS</span><span class="p">[</span><span class="s1">&#39;robertson1968&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_uv_to_Tx_robertson1968</span>

<div class="viewcode-block" id="xyz_to_cct_robertson1968">
<a class="viewcode-back" href="../../../../color.html#luxpy.color.cct.xyz_to_cct_robertson1968">[docs]</a>
<span class="k">def</span> <span class="nf">xyz_to_cct_robertson1968</span><span class="p">(</span><span class="n">xyzw</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">_CIEOBS</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;cct&#39;</span><span class="p">,</span> <span class="n">is_uv_input</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                            <span class="n">atol</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="n">force_tolerance</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">tol_method</span> <span class="o">=</span> <span class="s1">&#39;newton-raphson&#39;</span><span class="p">,</span> 
                            <span class="n">lut_resolution_reduction_factor</span> <span class="o">=</span> <span class="n">_CCT_LUT_RESOLUTION_REDUCTION_FACTOR</span><span class="p">,</span>
                            <span class="n">split_calculation_at_N</span> <span class="o">=</span> <span class="n">_CCT_SPLIT_CALC_AT_N</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="n">_CCT_MAX_ITER</span><span class="p">,</span>
                            <span class="n">cspace</span> <span class="o">=</span> <span class="n">_CCT_CSPACE</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">_CCT_CSPACE_KWARGS</span><span class="p">,</span>
                            <span class="n">lut</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">luts_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ignore_wl_diff</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="n">use_fast_duv</span> <span class="o">=</span> <span class="n">_CCT_FAST_DUV</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert XYZ tristimulus values to correlated color temperature (CCT) and </span>
<span class="sd">    Duv(distance above (&gt; 0) or below ( &lt; 0) the Planckian locus) using  </span>
<span class="sd">    Robertson&#39;s 1968 search method.</span>
<span class="sd">        </span>
<span class="sd">    Args:</span>
<span class="sd">        :xyzw: </span>
<span class="sd">            | ndarray of tristimulus values</span>
<span class="sd">        :cieobs: </span>
<span class="sd">            | luxpy._CIEOBS, optional</span>
<span class="sd">            | CMF set used to calculated xyzw.</span>
<span class="sd">        :out: </span>
<span class="sd">            | &#39;cct&#39; (or 1), optional</span>
<span class="sd">            | Determines what to return.</span>
<span class="sd">            | Other options: &#39;duv&#39; (or -1), &#39;cct,duv&#39;(or 2), &quot;[cct,duv]&quot; (or -2)</span>
<span class="sd">        :is_uv_input:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | If True: xyzw contain uv input data, not xyz data!</span>
<span class="sd">        :wl: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Wavelengths used when calculating Planckian radiators.</span>
<span class="sd">            | If None: use same wavelengths as CMFs in :cieobs:.</span>
<span class="sd">        :rtol: </span>
<span class="sd">            | 1e-5, float, optional</span>
<span class="sd">            | Stop search when cct a relative tolerance is reached.</span>
<span class="sd">            | The relative tolerance is calculated as dCCT/CCT_est, </span>
<span class="sd">            | with CCT_est the current intermediate estimate in the </span>
<span class="sd">            | search and with dCCT the difference between</span>
<span class="sd">            | the present and former estimates.</span>
<span class="sd">        :atol: </span>
<span class="sd">            | 0.1, optional</span>
<span class="sd">            | Stop search when cct a absolute tolerance (K) is reached.</span>
<span class="sd">        :force_tolerance:</span>
<span class="sd">            | True, optional</span>
<span class="sd">            | If False: search only using the list of CCTs in the used lut. </span>
<span class="sd">            |           Only one loop of the full algorithm is performed. </span>
<span class="sd">            |           Accuracy depends on CCT of test source and the location</span>
<span class="sd">            |           and spacing of the CCTs in the list.</span>
<span class="sd">            | If True:  search will use adjacent CCTs to test source to create a new LUT,</span>
<span class="sd">            |           (repeat the algoritm at higher resolution, progessively zooming in</span>
<span class="sd">            |            toward the ground-truth) for tol_method == &#39;cl&#39;; when </span>
<span class="sd">            |           tol_method == &#39;nr&#39; a newton-raphson method is used.</span>
<span class="sd">            |           Because the CCT for multiple source is calculated in one go,</span>
<span class="sd">            |           the atol and rtol values have to be met for all! </span>
<span class="sd">        :tol_method:</span>
<span class="sd">            | &#39;newton-raphson&#39;, optional</span>
<span class="sd">            | (Additional) method to try and achieve set tolerances. </span>
<span class="sd">            | Options: </span>
<span class="sd">            | - &#39;cl&#39;, &#39;cascading-lut&#39;: use increasingly higher CCT-resolution</span>
<span class="sd">            |       to &#39;zoom-in&#39; on the ground-truth.</span>
<span class="sd">            | - &#39;nr&#39;, &#39;newton-raphson&#39;: use the method as described in Li, 2016.</span>
<span class="sd">        :lut_resolution_reduction_factor:</span>
<span class="sd">            | _CCT_LUT_RESOLUTION_REDUCTION_FACTOR, optional</span>
<span class="sd">            | Number of times the interval spanned by the adjacent Tc in a search or lut</span>
<span class="sd">            | method is downsampled (the search process will then start again)</span>
<span class="sd">        :max_iter:</span>
<span class="sd">            | _CCT_MAX_ITER, optional</span>
<span class="sd">            | Maximum number of iterations used by the cascading-lut or newton-raphson methods.</span>
<span class="sd">        :split_calculation_at_N:</span>
<span class="sd">            | _CCT_SPLIT_CALC_AT_N, optional</span>
<span class="sd">            | Split calculation when xyzw.shape[0] &gt; split_calculation_at_N. </span>
<span class="sd">            | Splitting speeds up the calculation. If None: no splitting is done.</span>
<span class="sd">        :lut:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Look-Up-Table with Ti, u,v,u&#39;,v&#39;,u&quot;,v&quot;,slope values of Planckians. </span>
<span class="sd">            | Options:</span>
<span class="sd">            |  - None: defaults to the lut specified in _CCT_LUT[&#39;robertson1968&#39;][&#39;lut_type_def&#39;].</span>
<span class="sd">            |  - list (lut,lut_kwargs): use this pre-calculated lut </span>
<span class="sd">            |       (add additional kwargs for the lut_generator_fcn(), defaults to None if omitted)</span>
<span class="sd">            |  - tuple: must be key (label) in :luts_dict: (pre-calculated dict of luts),</span>
<span class="sd">            |           if not: then a new lut will be generated from scratch using the info in the tuple.</span>
<span class="sd">            |  - str: must be key (label) in :luts_dict: (pre-calculated dict of luts)</span>
<span class="sd">            |  - ndarray [Nx1]: list of luts for which to generate a lut</span>
<span class="sd">            |  - ndarray [Nxn] with n&gt;3: pre-calculated lut (last col must contain slope of the isotemperature lines).</span>
<span class="sd">        :luts_dict:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Dictionary of pre-calculated luts for various cspaces and cmf sets.</span>
<span class="sd">            |  Must have structure luts_dict[cspace][cieobs][lut_label] with the</span>
<span class="sd">            |   lut part of a two-element list [lut, lut_kwargs]. It must contain</span>
<span class="sd">            |   at the top-level a key &#39;wl&#39; containing the wavelengths of the </span>
<span class="sd">            |   Planckians used to generate the luts in this dictionary.</span>
<span class="sd">            | If None: luts_dict defaults to _CCT_LUT[&#39;robertson1968&#39;][&#39;luts&#39;]   </span>
<span class="sd">        :cspace:</span>
<span class="sd">            | _CCT_SPACE, optional</span>
<span class="sd">            | Color space to do calculations in. </span>
<span class="sd">            | Options: </span>
<span class="sd">            |    - cspace string: </span>
<span class="sd">            |        e.g. &#39;Yuv60&#39; for use with luxpy.colortf()</span>
<span class="sd">            |    - tuple with forward (i.e. xyz_to..) [and backward (i.e. ..to_xyz)] functions </span>
<span class="sd">            |      (and an optional string describing the cspace): </span>
<span class="sd">            |        e.g. (forward, backward) or (forward, backward, cspace string) or (forward, cspace string) </span>
<span class="sd">            |    - dict with keys: &#39;fwtf&#39; (foward), &#39;bwtf&#39; (backward) [, optional: &#39;str&#39; (cspace string)]</span>
<span class="sd">            |  Note: if the backward tf is not supplied, optimization in cct_to_xyz() is done in the CIE 1976 u&#39;v&#39; diagram</span>
<span class="sd">        :cspace_kwargs:</span>
<span class="sd">            | _CCT_CSPACE_KWARGS, optional</span>
<span class="sd">            | Parameter nested dictionary for the forward and backward transforms.</span>
<span class="sd">        :ignore_wl_diff:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | When getting a lut from the dictionary, if differences are</span>
<span class="sd">            | detected in the wavelengts of the lut and the ones used to calculate any</span>
<span class="sd">            | plankcians then a new lut should be generated. Seting this to True ignores</span>
<span class="sd">            | these differences and proceeds anyway.</span>
<span class="sd">        :use_fast_duv:</span>
<span class="sd">            | _CCT_FAST_DUV, optional</span>
<span class="sd">            | If True: use a fast estimator of the Duv </span>
<span class="sd">            |   (one that avoids calculation of Planckians and uses the former</span>
<span class="sd">            |    best estimate&#39;s u,v coordinates. This method is accurate enough</span>
<span class="sd">            |    when the atol is small enough -&gt; as long as abs(T-T_former)&lt;=1K</span>
<span class="sd">            |    the Duv estimate should be ok.)</span>

<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | ndarray with:</span>
<span class="sd">            |    cct: out == &#39;cct&#39; (or 1)</span>
<span class="sd">            |    duv: out == &#39;duv&#39; (or -1)</span>
<span class="sd">            |    cct, duv: out == &#39;cct,duv&#39; (or 2)</span>
<span class="sd">            |    [cct,duv]: out == &quot;[cct,duv]&quot; (or -2) </span>
<span class="sd">            </span>
<span class="sd">    Note: </span>
<span class="sd">        1. Out-of-lut CCTs are encoded as negative CCTs (with as absolute value</span>
<span class="sd">        the value of the closest CCT from the lut.)</span>
<span class="sd">    </span>
<span class="sd">    References:</span>
<span class="sd">        1.  `Robertson, A. R. (1968). </span>
<span class="sd">        Computation of Correlated Color Temperature and Distribution Temperature. </span>
<span class="sd">        Journal of the Optical Society of America,  58(11), 1528–1535. </span>
<span class="sd">        &lt;https://doi.org/10.1364/JOSA.58.001528&gt;` </span>
<span class="sd">        </span>
<span class="sd">        2. Smet K.A.G., Royer M., Baxter D., Bretschneider E., Esposito E., Houser K., Luedtke W., Man K., Ohno Y. (2022),</span>
<span class="sd">        Recommended method for determining the correlated color temperature and distance from the Planckian Locus of a light source</span>
<span class="sd">        (in preparation, LEUKOS?)</span>
<span class="sd">        </span>
<span class="sd">        3. Baxter D., Royer M., Smet K.A.G. (2022)</span>
<span class="sd">        Modifications of the Robertson Method for Calculating Correlated Color Temperature to Improve Accuracy and Speed</span>
<span class="sd">        (in preparation, LEUKOS?)</span>
<span class="sd">         </span>
<span class="sd">        4. `Li, C., Cui, G., Melgosa, M., Ruan, X., Zhang, Y., Ma, L., Xiao, K., &amp; Luo, M. R. (2016).</span>
<span class="sd">        Accurate method for computing correlated color temperature. </span>
<span class="sd">        Optics Express, 24(13), 14066–14078. </span>
<span class="sd">        &lt;https://doi.org/10.1364/OE.24.014066&gt;`_</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_xyz_to_cct</span><span class="p">(</span><span class="n">xyzw</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;robertson1968&#39;</span><span class="p">,</span>
                       <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> <span class="n">is_uv_input</span> <span class="o">=</span> <span class="n">is_uv_input</span><span class="p">,</span> 
                       <span class="n">cspace</span> <span class="o">=</span> <span class="n">cspace</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">cspace_kwargs</span><span class="p">,</span>
                       <span class="n">atol</span> <span class="o">=</span> <span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="n">rtol</span><span class="p">,</span> <span class="n">force_tolerance</span> <span class="o">=</span> <span class="n">force_tolerance</span><span class="p">,</span>
                       <span class="n">tol_method</span> <span class="o">=</span> <span class="n">tol_method</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span><span class="p">,</span>  
                       <span class="n">lut_resolution_reduction_factor</span> <span class="o">=</span> <span class="n">lut_resolution_reduction_factor</span><span class="p">,</span>
                       <span class="n">split_calculation_at_N</span> <span class="o">=</span> <span class="n">split_calculation_at_N</span><span class="p">,</span> 
                       <span class="n">lut</span> <span class="o">=</span> <span class="n">lut</span><span class="p">,</span> <span class="n">luts_dict</span> <span class="o">=</span> <span class="n">luts_dict</span><span class="p">,</span> 
                       <span class="n">ignore_wl_diff</span> <span class="o">=</span> <span class="n">ignore_wl_diff</span><span class="p">,</span> 
                       <span class="n">use_fast_duv</span> <span class="o">=</span> <span class="n">use_fast_duv</span><span class="p">,</span>
                       <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="c1"># pre-generate / load from disk / load from github some LUTs for Robertson1968:</span>
<span class="n">_initialize_lut</span><span class="p">(</span><span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;robertson1968&#39;</span><span class="p">,</span><span class="n">lut_types</span> <span class="o">=</span> <span class="n">_unique_types</span><span class="p">([</span><span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;robertson1968&#39;</span><span class="p">][</span><span class="s1">&#39;lut_type_def&#39;</span><span class="p">],((</span><span class="mi">10</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="s1">&#39;K-1&#39;</span><span class="p">),(</span><span class="mi">100</span><span class="p">,</span><span class="mi">625</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="s1">&#39;K-1&#39;</span><span class="p">),</span><span class="kc">True</span><span class="p">)]</span> <span class="o">+</span> <span class="n">_CCT_SHARED_LUT_TYPES</span><span class="p">))</span>


<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># Zhang 2019:</span>
<span class="c1">#------------------------------------------------------------------------------</span>
<span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;zhang2019&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span> 
<span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;zhang2019&#39;</span><span class="p">][</span><span class="s1">&#39;lut_type_def&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;K-1&#39;</span><span class="p">),(</span><span class="mi">25</span><span class="p">,</span><span class="mi">1025</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="s1">&#39;K-1&#39;</span><span class="p">),</span><span class="kc">False</span><span class="p">)</span>
<span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;zhang2019&#39;</span><span class="p">][</span><span class="s1">&#39;lut_vars&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;uv&#39;</span><span class="p">]</span> <span class="c1"># use a lut with &#39;uv&#39;, without it the speed is not much different and ability to more finely tuned detect out-of-luts is gone</span>
<span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;zhang2019&#39;</span><span class="p">][</span><span class="s1">&#39;_generate_lut&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_generate_lut</span> 


<span class="k">def</span> <span class="nf">_uv_to_Tx_zhang2019</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">lut</span><span class="p">,</span> <span class="n">lut_n_cols</span><span class="p">,</span> <span class="n">ns</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out_of_lut</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                        <span class="n">max_iter</span> <span class="o">=</span> <span class="n">_CCT_MAX_ITER</span><span class="p">,</span> <span class="n">uvwbar</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                        <span class="n">atol</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="n">lut_vars</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;uv&#39;</span><span class="p">],</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Calculate Tx from u,v and lut using Zhang 2019.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="mf">5.0</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
    
    <span class="c1"># get uBB, vBB from lut:</span>
    <span class="n">TBB</span> <span class="o">=</span> <span class="n">lut</span><span class="p">[:,</span><span class="mi">0</span><span class="p">::</span><span class="n">lut_n_cols</span><span class="p">]</span> 
    <span class="n">idx_sources</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;uv&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">:</span>
        <span class="n">uBB</span><span class="p">,</span> <span class="n">vBB</span> <span class="o">=</span> <span class="n">lut</span><span class="p">[:,</span><span class="mi">1</span><span class="p">::</span><span class="n">lut_n_cols</span><span class="p">],</span> <span class="n">lut</span><span class="p">[:,</span><span class="mi">2</span><span class="p">::</span><span class="n">lut_n_cols</span><span class="p">]</span>

        <span class="c1"># calculate distances to coordinates in lut and find minimum:</span>
        <span class="n">pn</span> <span class="o">=</span> <span class="p">(((</span><span class="n">v</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">vBB</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">uBB</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
        <span class="c1"># Deal with endpoints of lut + create intermediate variables </span>
        <span class="c1"># to save memory:</span>
        <span class="n">pn</span><span class="p">,</span> <span class="n">out_of_lut</span> <span class="o">=</span> <span class="n">_deal_with_lut_end_points</span><span class="p">(</span><span class="n">pn</span><span class="p">,</span> <span class="n">TBB</span><span class="p">,</span> <span class="n">out_of_lut</span> <span class="o">=</span> <span class="n">out_of_lut</span><span class="p">)</span>
      
        <span class="n">TBB_m1</span><span class="p">,</span> <span class="n">TBB_p1</span> <span class="o">=</span> <span class="n">_get_pns_from_x</span><span class="p">(</span><span class="n">TBB</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx_sources</span><span class="p">,</span> <span class="n">m0p</span> <span class="o">=</span> <span class="s1">&#39;mp&#39;</span><span class="p">)</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="n">TBB_m1</span><span class="p">,</span><span class="n">TBB_p1</span> <span class="o">=</span> <span class="n">TBB</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span><span class="n">TBB</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span>

        
    <span class="c1"># get RTm-1 (RTl) and RTm+1 (RTr):</span>
    <span class="n">RTl</span> <span class="o">=</span> <span class="mf">1e6</span><span class="o">/</span><span class="n">TBB_m1</span>
    <span class="n">RTr</span> <span class="o">=</span> <span class="mf">1e6</span><span class="o">/</span><span class="n">TBB_p1</span>

    <span class="c1"># calculate RTa, RTb:</span>
    <span class="n">RTa</span> <span class="o">=</span> <span class="n">RTl</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">RTr</span> <span class="o">-</span> <span class="n">RTl</span><span class="p">)</span>
    <span class="n">RTb</span> <span class="o">=</span> <span class="n">RTl</span> <span class="o">+</span> <span class="n">s</span> <span class="o">*</span> <span class="p">(</span><span class="n">RTr</span> <span class="o">-</span> <span class="n">RTl</span><span class="p">)</span> 
    
    <span class="n">Tx_a</span><span class="p">,</span> <span class="n">Tx_b</span> <span class="o">=</span> <span class="mf">1e6</span><span class="o">/</span><span class="n">RTa</span><span class="p">,</span> <span class="mf">1e6</span><span class="o">/</span><span class="n">RTb</span>
    <span class="c1"># # RTx = ((RTa+RTb)/2)</span>
    <span class="c1"># # _plot_triangular_solution(u,v,uBB,vBB,TBB,pn)</span>
    
      
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="kc">True</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">max_iter</span><span class="p">):</span> <span class="c1"># loop part of zhang optimization process</span>
        
        <span class="c1"># calculate BBa BBb:</span>
        <span class="c1"># BBab = cri_ref(np.vstack([cct_to_mired(RTa), cct_to_mired(RTx), cct_to_mired(RTb)]), ref_type = [&#39;BB&#39;], wl3 = wl)</span>
        <span class="c1"># BBab = cri_ref(np.vstack([cct_to_mired(RTa), cct_to_mired(RTb)]), ref_type = [&#39;BB&#39;], wl3 = wl)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">uvwbar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">wl</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dl</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">TBB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">Tx_a</span><span class="p">,</span> <span class="n">Tx_b</span><span class="p">])</span>
            <span class="n">_</span><span class="p">,</span><span class="n">UVWBBab</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">_get_tristim_of_BB_BBp_BBpp</span><span class="p">(</span><span class="n">TBB</span><span class="p">,</span> <span class="n">uvwbar</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="s1">&#39;BB&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;uvwbar, wl &amp; dl must all be not None !!!&#39;</span><span class="p">)</span>
        
        <span class="c1"># calculate xyzBBab:</span>
        <span class="c1"># xyzBBab = spd_to_xyz(BBab, cieobs = cieobs, relative = True)</span>
    
        <span class="c1"># get cspace coordinates of BB and input xyz:</span>
        <span class="c1"># uvBBab_ = cspace_dict[&#39;fwtf&#39;](XYZBBab)[...,1:]</span>
        <span class="n">uvBBab</span> <span class="o">=</span> <span class="n">xyz_to_Yxy</span><span class="p">(</span><span class="n">UVWBBab</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:]</span>

        <span class="c1"># N = uvBBab.shape[0]//3 </span>
        <span class="c1"># uBBa, vBBa = uvBBab[:N,0:1], uvBBab[:N,1:2]</span>
        <span class="c1"># uBBx, vBBx = uvBBab[N:2*N,0:1], uvBBab[N:2*N,1:2]</span>
        <span class="c1"># uBBb, vBBb = uvBBab[2*N:,0:1], uvBBab[2*N:,1:2]</span>
       
        <span class="n">N</span> <span class="o">=</span> <span class="n">uvBBab</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span> 
        <span class="c1"># uBBa, vBBa = uvBBab[:N,0:1], uvBBab[:N,1:2]</span>
        <span class="c1"># uBBb, vBBb = uvBBab[N:,0:1], uvBBab[N:,1:2]</span>
        
        <span class="c1"># find distance in UCD of BBab to input:</span>
        <span class="n">DEuv</span> <span class="o">=</span> <span class="p">((</span><span class="n">uvBBab</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">uvBBab</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># no need for **0.5</span>
        <span class="n">DEuv_a</span><span class="p">,</span> <span class="n">DEuv_b</span> <span class="o">=</span> <span class="n">DEuv</span><span class="p">[:</span><span class="n">N</span><span class="p">],</span> <span class="n">DEuv</span><span class="p">[</span><span class="n">N</span><span class="p">:]</span> 

        <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">DEuv_a</span> <span class="o">&lt;</span> <span class="n">DEuv_b</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># when DEuv_a &lt; DEuv_b:</span>
        <span class="n">RTr</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">RTb</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
        <span class="n">RTb</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">RTa</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
        <span class="c1">#DEuv_b[c] = DEuv_a[c]</span>
        <span class="n">RTa</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">RTl</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">RTr</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="n">RTl</span><span class="p">[</span><span class="n">c</span><span class="p">]))</span>
        
        <span class="c1"># when DEuv_a &gt;= DEuv_b:</span>
        <span class="n">RTl</span><span class="p">[</span><span class="o">~</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">RTa</span><span class="p">[</span><span class="o">~</span><span class="n">c</span><span class="p">]</span>
        <span class="n">RTa</span><span class="p">[</span><span class="o">~</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">RTb</span><span class="p">[</span><span class="o">~</span><span class="n">c</span><span class="p">]</span>
        <span class="c1">#DEuv_a[~c] = DEuv_b[~c]</span>
        <span class="n">RTb</span><span class="p">[</span><span class="o">~</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">RTl</span><span class="p">[</span><span class="o">~</span><span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span> <span class="o">*</span> <span class="p">(</span><span class="n">RTr</span><span class="p">[</span><span class="o">~</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="n">RTl</span><span class="p">[</span><span class="o">~</span><span class="n">c</span><span class="p">]))</span>
        
        <span class="c1"># Calculate CCTs from RTa and RTb:</span>
        <span class="n">Tx_a</span><span class="p">,</span> <span class="n">Tx_b</span> <span class="o">=</span> <span class="mf">1e6</span><span class="o">/</span><span class="n">RTa</span><span class="p">,</span> <span class="mf">1e6</span><span class="o">/</span><span class="n">RTb</span>
        <span class="n">Tx</span> <span class="o">=</span> <span class="mf">1e6</span><span class="o">/</span><span class="p">((</span><span class="n">RTa</span><span class="o">+</span><span class="n">RTb</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">dTx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Tx_a</span> <span class="o">-</span> <span class="n">Tx_b</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(((</span><span class="n">dTx</span> <span class="o">&lt;=</span> <span class="n">atol</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="o">|</span> <span class="p">((</span><span class="n">dTx</span><span class="o">/</span><span class="n">Tx</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">rtol</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">())):</span>
            <span class="k">break</span>
        <span class="n">j</span><span class="o">+=</span><span class="mi">1</span>

    <span class="c1"># uBB = np.vstack((uBBa,uBBx,uBBb))</span>
    <span class="c1"># vBB = np.vstack((vBBa,vBBx,vBBb))</span>
    <span class="c1"># TBB = np.vstack((Tx_a,Tx,Tx_b))</span>
    <span class="c1"># pn = np.array([1])</span>
    <span class="c1"># _plot_triangular_solution(u,v,uBB,vBB,TBB,pn)</span>
    
    <span class="k">return</span> <span class="n">Tx</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out_of_lut</span><span class="p">,</span> <span class="p">(</span><span class="mf">1e6</span><span class="o">/</span><span class="n">RTl</span><span class="p">,</span><span class="mf">1e6</span><span class="o">/</span><span class="n">RTr</span><span class="p">)</span>

<span class="n">_CCT_UV_TO_TX_FCNS</span><span class="p">[</span><span class="s1">&#39;zhang2019&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_uv_to_Tx_zhang2019</span>

<div class="viewcode-block" id="xyz_to_cct_zhang2019">
<a class="viewcode-back" href="../../../../color.html#luxpy.color.cct.xyz_to_cct_zhang2019">[docs]</a>
<span class="k">def</span> <span class="nf">xyz_to_cct_zhang2019</span><span class="p">(</span><span class="n">xyzw</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">_CIEOBS</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;cct&#39;</span><span class="p">,</span> <span class="n">is_uv_input</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                        <span class="n">atol</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="n">force_tolerance</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">tol_method</span> <span class="o">=</span> <span class="s1">&#39;newton-raphson&#39;</span><span class="p">,</span> 
                        <span class="n">lut_resolution_reduction_factor</span> <span class="o">=</span> <span class="n">_CCT_LUT_RESOLUTION_REDUCTION_FACTOR</span><span class="p">,</span>
                        <span class="n">split_calculation_at_N</span> <span class="o">=</span> <span class="n">_CCT_SPLIT_CALC_AT_N</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="n">_CCT_MAX_ITER</span><span class="p">,</span>
                        <span class="n">cspace</span> <span class="o">=</span> <span class="n">_CCT_CSPACE</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">_CCT_CSPACE_KWARGS</span><span class="p">,</span>
                        <span class="n">lut</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">luts_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ignore_wl_diff</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="n">use_fast_duv</span> <span class="o">=</span> <span class="n">_CCT_FAST_DUV</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert XYZ tristimulus values to correlated color temperature (CCT) and </span>
<span class="sd">    Duv(distance above (&gt; 0) or below ( &lt; 0) the Planckian locus) using the </span>
<span class="sd">    golden-ratio search method described in Zhang et al. (2019).</span>
<span class="sd">        </span>
<span class="sd">    Args:</span>
<span class="sd">        :xyzw: </span>
<span class="sd">            | ndarray of tristimulus values</span>
<span class="sd">        :cieobs: </span>
<span class="sd">            | luxpy._CIEOBS, optional</span>
<span class="sd">            | CMF set used to calculated xyzw.</span>
<span class="sd">        :out: </span>
<span class="sd">            | &#39;cct&#39; (or 1), optional</span>
<span class="sd">            | Determines what to return.</span>
<span class="sd">            | Other options: &#39;duv&#39; (or -1), &#39;cct,duv&#39;(or 2), &quot;[cct,duv]&quot; (or -2)</span>
<span class="sd">        :is_uv_input:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | If True: xyzw contain uv input data, not xyz data!</span>
<span class="sd">        :wl: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Wavelengths used when calculating Planckian radiators.</span>
<span class="sd">            | If None: use same wavelengths as CMFs in :cieobs:.</span>
<span class="sd">        :rtol: </span>
<span class="sd">            | 1e-5, float, optional</span>
<span class="sd">            | Stop search when cct a relative tolerance is reached.</span>
<span class="sd">            | The relative tolerance is calculated as dCCT/CCT_est, </span>
<span class="sd">            | with CCT_est the current intermediate estimate in the </span>
<span class="sd">            | search and with dCCT the difference between</span>
<span class="sd">            | the present and former estimates.</span>
<span class="sd">        :atol: </span>
<span class="sd">            | 0.1, optional</span>
<span class="sd">            | Stop search when cct a absolute tolerance (K) is reached.</span>
<span class="sd">        :force_tolerance:</span>
<span class="sd">            | True, optional</span>
<span class="sd">            | If False: search only using the list of CCTs in the used lut. </span>
<span class="sd">            |           Only one loop of the full algorithm is performed. </span>
<span class="sd">            |           Accuracy depends on CCT of test source and the location</span>
<span class="sd">            |           and spacing of the CCTs in the list.</span>
<span class="sd">            | If True:  search will use adjacent CCTs to test source to create a new LUT,</span>
<span class="sd">            |           (repeat the algoritm at higher resolution, progessively zooming in</span>
<span class="sd">            |            toward the ground-truth) for tol_method == &#39;cl&#39;; when </span>
<span class="sd">            |           tol_method == &#39;nr&#39; a newton-raphson method is used.</span>
<span class="sd">            |           Because the CCT for multiple source is calculated in one go,</span>
<span class="sd">            |           the atol and rtol values have to be met for all! </span>
<span class="sd">        :tol_method:</span>
<span class="sd">            | &#39;newton-raphson&#39;, optional</span>
<span class="sd">            | (Additional) method to try and achieve set tolerances. </span>
<span class="sd">            | Options: </span>
<span class="sd">            | - &#39;cl&#39;, &#39;cascading-lut&#39;: use increasingly higher CCT-resolution</span>
<span class="sd">            |       to &#39;zoom-in&#39; on the ground-truth.</span>
<span class="sd">            | - &#39;nr&#39;, &#39;newton-raphson&#39;: use the method as described in Li, 2016.</span>
<span class="sd">        :lut_resolution_reduction_factor:</span>
<span class="sd">            | _CCT_LUT_RESOLUTION_REDUCTION_FACTOR, optional</span>
<span class="sd">            | Number of times the interval spanned by the adjacent Tc in a search or lut</span>
<span class="sd">            | method is downsampled (the search process will then start again)</span>
<span class="sd">        :max_iter:</span>
<span class="sd">            | _CCT_MAX_ITER, optional</span>
<span class="sd">            | Maximum number of iterations used by the cascading-lut or newton-raphson methods.</span>
<span class="sd">        :split_calculation_at_N:</span>
<span class="sd">            | _CCT_SPLIT_CALC_AT_N, optional</span>
<span class="sd">            | Split calculation when xyzw.shape[0] &gt; split_calculation_at_N. </span>
<span class="sd">            | Splitting speeds up the calculation. If None: no splitting is done.</span>
<span class="sd">        :lut:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Look-Up-Table with Ti, u,v,u&#39;,v&#39;,u&quot;,v&quot;,slope values of Planckians. </span>
<span class="sd">            | Options:</span>
<span class="sd">            |  - None: defaults to the lut specified in _CCT_LUT[&#39;zhang2019&#39;][&#39;lut_type_def&#39;].</span>
<span class="sd">            |  - list (lut,lut_kwargs): use this pre-calculated lut </span>
<span class="sd">            |       (add additional kwargs for the lut_generator_fcn(), defaults to None if omitted)</span>
<span class="sd">            |  - tuple: must be key (label) in :luts_dict: (pre-calculated dict of luts),</span>
<span class="sd">            |           if not: then a new lut will be generated from scratch using the info in the tuple.</span>
<span class="sd">            |  - str: must be key (label) in :luts_dict: (pre-calculated dict of luts)</span>
<span class="sd">            |  - ndarray [Nx1]: list of luts for which to generate a lut</span>
<span class="sd">            |  - ndarray [Nxn] with n&gt;3: pre-calculated lut (last col must contain slope of the isotemperature lines).</span>
<span class="sd">        :luts_dict:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Dictionary of pre-calculated luts for various cspaces and cmf sets.</span>
<span class="sd">            |  Must have structure luts_dict[cspace][cieobs][lut_label] with the</span>
<span class="sd">            |   lut part of a two-element list [lut, lut_kwargs]. It must contain</span>
<span class="sd">            |   at the top-level a key &#39;wl&#39; containing the wavelengths of the </span>
<span class="sd">            |   Planckians used to generate the luts in this dictionary.</span>
<span class="sd">            | If None: luts_dict defaults to _CCT_LUT[&#39;zhang2019&#39;][&#39;luts&#39;]    </span>
<span class="sd">        :cspace:</span>
<span class="sd">            | _CCT_SPACE, optional</span>
<span class="sd">            | Color space to do calculations in. </span>
<span class="sd">            | Options: </span>
<span class="sd">            |    - cspace string: </span>
<span class="sd">            |        e.g. &#39;Yuv60&#39; for use with luxpy.colortf()</span>
<span class="sd">            |    - tuple with forward (i.e. xyz_to..) [and backward (i.e. ..to_xyz)] functions </span>
<span class="sd">            |      (and an optional string describing the cspace): </span>
<span class="sd">            |        e.g. (forward, backward) or (forward, backward, cspace string) or (forward, cspace string) </span>
<span class="sd">            |    - dict with keys: &#39;fwtf&#39; (foward), &#39;bwtf&#39; (backward) [, optional: &#39;str&#39; (cspace string)]</span>
<span class="sd">            |  Note: if the backward tf is not supplied, optimization in cct_to_xyz() is done in the CIE 1976 u&#39;v&#39; diagram</span>
<span class="sd">        :cspace_kwargs:</span>
<span class="sd">            | _CCT_CSPACE_KWARGS, optional</span>
<span class="sd">            | Parameter nested dictionary for the forward and backward transforms.</span>
<span class="sd">        :ignore_wl_diff:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | When getting a lut from the dictionary, if differences are</span>
<span class="sd">            | detected in the wavelengts of the lut and the ones used to calculate any</span>
<span class="sd">            | plankcians then a new lut should be generated. Seting this to True ignores</span>
<span class="sd">            | these differences and proceeds anyway.</span>
<span class="sd">        :use_fast_duv:</span>
<span class="sd">            | _CCT_FAST_DUV, optional</span>
<span class="sd">            | If True: use a fast estimator of the Duv </span>
<span class="sd">            |   (one that avoids calculation of Planckians and uses the former</span>
<span class="sd">            |    best estimate&#39;s u,v coordinates. This method is accurate enough</span>
<span class="sd">            |    when the atol is small enough -&gt; as long as abs(T-T_former)&lt;=1K</span>
<span class="sd">            |    the Duv estimate should be ok.)</span>

<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | ndarray with:</span>
<span class="sd">            |    cct: out == &#39;cct&#39; (or 1)</span>
<span class="sd">            |    duv: out == &#39;duv&#39; (or -1)</span>
<span class="sd">            |    cct, duv: out == &#39;cct,duv&#39; (or 2)</span>
<span class="sd">            |    [cct,duv]: out == &quot;[cct,duv]&quot; (or -2) </span>
<span class="sd">            </span>
<span class="sd">    Note: </span>
<span class="sd">        1. Out-of-lut CCTs are encoded as negative CCTs (with as absolute value</span>
<span class="sd">        the value of the closest CCT from the lut.)</span>
<span class="sd">    </span>
<span class="sd">    References:</span>
<span class="sd">        1. `Zhang, F. (2019). </span>
<span class="sd">        High-accuracy method for calculating correlated color temperature with </span>
<span class="sd">        a lookup table based on golden section search. </span>
<span class="sd">        Optik, 193, 163018. </span>
<span class="sd">        &lt;https://doi.org/https://doi.org/10.1016/j.ijleo.2019.163018&gt;`_</span>
<span class="sd">         </span>
<span class="sd">        2. `Li, C., Cui, G., Melgosa, M., Ruan, X., Zhang, Y., Ma, L., Xiao, K., &amp; Luo, M. R. (2016).</span>
<span class="sd">        Accurate method for computing correlated color temperature. </span>
<span class="sd">        Optics Express, 24(13), 14066–14078. </span>
<span class="sd">        &lt;https://doi.org/10.1364/OE.24.014066&gt;`_</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_xyz_to_cct</span><span class="p">(</span><span class="n">xyzw</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;zhang2019&#39;</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> <span class="n">is_uv_input</span> <span class="o">=</span> <span class="n">is_uv_input</span><span class="p">,</span> 
                       <span class="n">cspace</span> <span class="o">=</span> <span class="n">cspace</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">cspace_kwargs</span><span class="p">,</span>
                       <span class="n">atol</span> <span class="o">=</span> <span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="n">rtol</span><span class="p">,</span> <span class="n">force_tolerance</span> <span class="o">=</span> <span class="n">force_tolerance</span><span class="p">,</span>
                       <span class="n">tol_method</span> <span class="o">=</span> <span class="n">tol_method</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span><span class="p">,</span>  
                       <span class="n">lut_resolution_reduction_factor</span> <span class="o">=</span> <span class="n">lut_resolution_reduction_factor</span><span class="p">,</span>
                       <span class="n">split_calculation_at_N</span> <span class="o">=</span> <span class="n">split_calculation_at_N</span><span class="p">,</span> 
                       <span class="n">lut</span> <span class="o">=</span> <span class="n">lut</span><span class="p">,</span> <span class="n">luts_dict</span> <span class="o">=</span> <span class="n">luts_dict</span><span class="p">,</span> 
                       <span class="n">ignore_wl_diff</span> <span class="o">=</span> <span class="n">ignore_wl_diff</span><span class="p">,</span> 
                       <span class="n">use_fast_duv</span> <span class="o">=</span> <span class="n">use_fast_duv</span><span class="p">,</span>
                       <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<span class="c1"># pre-generate / load from disk / load from github some LUTs for Zhang2019:</span>
<span class="n">_initialize_lut</span><span class="p">(</span><span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;zhang2019&#39;</span><span class="p">,</span><span class="n">lut_types</span> <span class="o">=</span> <span class="n">_unique_types</span><span class="p">([</span><span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;zhang2019&#39;</span><span class="p">][</span><span class="s1">&#39;lut_type_def&#39;</span><span class="p">]]</span> <span class="o">+</span> <span class="n">_CCT_SHARED_LUT_TYPES</span><span class="p">))</span>


<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># Ohno 2014 related functions:</span>
<span class="c1">#------------------------------------------------------------------------------</span>
<span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;ohno2014&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;luts&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">}</span>
<span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;ohno2014&#39;</span><span class="p">][</span><span class="s1">&#39;lut_type_def&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">_CCT_LUT_MIN</span><span class="p">,</span> <span class="n">_CCT_LUT_MAX</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="s1">&#39;%&#39;</span><span class="p">),)</span>
<span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;ohno2014&#39;</span><span class="p">][</span><span class="s1">&#39;lut_vars&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;uv&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="_generate_lut_ohno2014">
<a class="viewcode-back" href="../../../../color.html#luxpy.color.cct._generate_lut_ohno2014">[docs]</a>
<span class="k">def</span> <span class="nf">_generate_lut_ohno2014</span><span class="p">(</span><span class="n">lut</span><span class="p">,</span> 
                           <span class="n">uin</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">seamless_stitch</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
                           <span class="n">fallback_unit</span> <span class="o">=</span> <span class="n">_CCT_FALLBACK_UNIT</span><span class="p">,</span> <span class="n">fallback_n</span> <span class="o">=</span> <span class="n">_CCT_FALLBACK_N</span><span class="p">,</span>
                           <span class="n">resample_ndarray</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                           <span class="n">cct_max</span> <span class="o">=</span> <span class="n">_CCT_MAX</span><span class="p">,</span> <span class="n">cct_min</span> <span class="o">=</span> <span class="n">_CCT_MIN</span><span class="p">,</span>
                           <span class="n">luts_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">lut_type_def</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">lut_vars</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;uv&#39;</span><span class="p">],</span>
                           <span class="n">cieobs</span> <span class="o">=</span>  <span class="n">_CIEOBS</span><span class="p">,</span> <span class="n">cspace_str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ignore_unequal_wl</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                           <span class="c1">#lut_generator_fcn = _generate_lut, lut_generator_kwargs = {},</span>
                           <span class="n">cspace</span> <span class="o">=</span> <span class="n">_CCT_CSPACE</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">_CCT_CSPACE_KWARGS</span><span class="p">,</span>
                           <span class="n">f_corr</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ignore_f_corr_is_None</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                           <span class="n">duv_triangular_threshold</span> <span class="o">=</span> <span class="mf">0.002</span><span class="p">,</span>
                           <span class="n">ignore_wl_diff</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Lut generator function for ohno2014. </span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :...: </span>
<span class="sd">            | see docstring for _generate_lut</span>
<span class="sd">        :f_corr:</span>
<span class="sd">            | Tc,x correction factor for the parabolic solution in Ohno2014.</span>
<span class="sd">            |   If None, it will be recalculated (note that it depends on the lut) for increased accuracy.</span>
<span class="sd">        :ignore_f_corr_is_None: </span>
<span class="sd">            |   If True, ignore f_corr is None, i.e. don&#39;t re-calculate f_corr.</span>
<span class="sd">                             </span>
<span class="sd">    Returns:</span>
<span class="sd">        :lut: </span>
<span class="sd">            | an ndarray with the lut </span>
<span class="sd">        :dict:</span>
<span class="sd">            | a dictionary with the (re-optmized) value for f_corr and for ignore_f_cor_is_None.)</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="c1"># get/estimate lut unit:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lut</span><span class="p">,</span><span class="nb">tuple</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lut</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">tuple</span><span class="p">):</span>
            <span class="n">fallback_unit_lut</span> <span class="o">=</span> <span class="n">lut</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fallback_unit_lut</span> <span class="o">=</span> <span class="n">lut</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fallback_unit_lut</span> <span class="o">=</span> <span class="n">_get_lut_characteristics</span><span class="p">(</span><span class="n">lut</span><span class="p">,</span><span class="n">force_au</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">fallback_unit_lut</span> <span class="o">==</span> <span class="s1">&#39;au&#39;</span><span class="p">:</span> <span class="n">fallback_unit_lut</span> <span class="o">=</span> <span class="n">_CCT_FALLBACK_UNIT</span>
        
    <span class="c1"># generate lut:</span>
    <span class="n">lut</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_generate_lut</span><span class="p">(</span><span class="n">lut</span><span class="p">,</span> <span class="n">uin</span> <span class="o">=</span> <span class="n">uin</span><span class="p">,</span> <span class="n">seamless_stitch</span> <span class="o">=</span> <span class="n">seamless_stitch</span><span class="p">,</span> 
                        <span class="n">fallback_unit</span> <span class="o">=</span> <span class="n">fallback_unit_lut</span><span class="p">,</span> <span class="n">fallback_n</span> <span class="o">=</span> <span class="n">fallback_n</span><span class="p">,</span>
                        <span class="n">resample_ndarray</span> <span class="o">=</span> <span class="n">resample_ndarray</span><span class="p">,</span> <span class="n">cct_max</span> <span class="o">=</span> <span class="n">cct_max</span><span class="p">,</span> <span class="n">cct_min</span> <span class="o">=</span> <span class="n">cct_min</span><span class="p">,</span>
                        <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">lut_vars</span> <span class="o">=</span> <span class="n">lut_vars</span><span class="p">,</span>
                        <span class="n">cspace</span> <span class="o">=</span>  <span class="n">cspace</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">cspace_kwargs</span><span class="p">)</span>        
    
    <span class="c1"># No f_corr needed for high resolution luts:</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">lut</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span><span class="mi">6</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">lut</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span><span class="mi">6</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">lut</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">lut</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mi">6</span><span class="p">)))</span> <span class="o">|</span> <span class="p">(</span><span class="n">fallback_unit_lut</span> <span class="o">==</span> <span class="s1">&#39;K&#39;</span><span class="p">):</span> <span class="c1"># K scale</span>
        <span class="k">if</span> <span class="n">lut</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">lut</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">f_corr</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">fallback_unit_lut</span> <span class="o">==</span> <span class="s1">&#39;%&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="n">lut</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">lut</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.2</span><span class="p">:</span>
            <span class="n">f_corr</span> <span class="o">=</span> <span class="mi">1</span>
        
    <span class="c1"># Get correction factor for Tx in parabolic solution:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">f_corr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span> 
        <span class="k">if</span> <span class="p">(</span><span class="n">ignore_f_corr_is_None</span> <span class="o">==</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">f_corr</span> <span class="o">=</span> <span class="n">get_correction_factor_for_Tx</span><span class="p">(</span><span class="n">lut</span><span class="p">,</span> 
                                                  <span class="n">uin</span> <span class="o">=</span> <span class="n">uin</span><span class="p">,</span> 
                                                  <span class="n">seamless_stitch</span> <span class="o">=</span> <span class="n">seamless_stitch</span><span class="p">,</span> 
                                                  <span class="n">fallback_unit</span> <span class="o">=</span> <span class="n">fallback_unit_lut</span><span class="p">,</span>
                                                  <span class="n">fallback_n</span> <span class="o">=</span> <span class="n">lut</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span>
                                                  <span class="n">resample_ndarray</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                                  <span class="n">cct_max</span> <span class="o">=</span> <span class="n">cct_max</span><span class="p">,</span> 
                                                  <span class="n">cct_min</span> <span class="o">=</span> <span class="n">cct_min</span><span class="p">,</span>
                                                  <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> 
                                                  <span class="n">lut_vars</span> <span class="o">=</span> <span class="n">lut_vars</span><span class="p">,</span>
                                                  <span class="n">cspace</span> <span class="o">=</span>  <span class="n">cspace</span><span class="p">,</span> 
                                                  <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">cspace_kwargs</span><span class="p">,</span>
                                                  <span class="n">ignore_wl_diff</span> <span class="o">=</span> <span class="n">ignore_wl_diff</span><span class="p">,</span>
                                                  <span class="n">duv_triangular_threshold</span> <span class="o">=</span> <span class="n">duv_triangular_threshold</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span> 
            <span class="n">f_corr</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="c1"># use this a backup value</span>


    <span class="k">return</span> <span class="nb">list</span><span class="p">([</span><span class="n">lut</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;f_corr&#39;</span><span class="p">:</span><span class="n">f_corr</span><span class="p">,</span><span class="s1">&#39;ignore_f_corr_is_None&#39;</span><span class="p">:</span><span class="n">ignore_f_corr_is_None</span><span class="p">}])</span></div>


<span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;ohno2014&#39;</span><span class="p">][</span><span class="s1">&#39;_generate_lut&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_generate_lut_ohno2014</span>

<span class="k">def</span> <span class="nf">get_correction_factor_for_Tx</span><span class="p">(</span><span class="n">lut</span><span class="p">,</span> <span class="n">lut_fine</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">cctduv</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                 <span class="n">uin</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">seamless_stitch</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
                                 <span class="n">fallback_unit</span> <span class="o">=</span> <span class="n">_CCT_FALLBACK_UNIT</span><span class="p">,</span> <span class="n">fallback_n</span> <span class="o">=</span> <span class="n">_CCT_FALLBACK_N</span><span class="p">,</span>
                                 <span class="n">resample_ndarray</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                 <span class="n">cct_max</span> <span class="o">=</span> <span class="n">_CCT_MAX</span><span class="p">,</span> <span class="n">cct_min</span> <span class="o">=</span> <span class="n">_CCT_MIN</span><span class="p">,</span>
                                 <span class="n">luts_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">lut_type_def</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">lut_vars</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;uv&#39;</span><span class="p">],</span>
                                 <span class="n">cieobs</span> <span class="o">=</span>  <span class="n">_CIEOBS</span><span class="p">,</span> <span class="n">cspace_str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ignore_unequal_wl</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                                 <span class="c1">#lut_generator_fcn = _generate_lut, lut_generator_kwargs = {},</span>
                                 <span class="n">cspace</span> <span class="o">=</span> <span class="n">_CCT_CSPACE</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">_CCT_CSPACE_KWARGS</span><span class="p">,</span>
                                 <span class="n">f_corr</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ignore_f_corr_is_None</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                                 <span class="n">duv_triangular_threshold</span> <span class="o">=</span> <span class="mf">0.002</span><span class="p">,</span>
                                 <span class="n">ignore_wl_diff</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                 <span class="n">verbosity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Ohno&#39;s 2014 parabolic solution uses a correction factor to correct the</span>
<span class="sd">    calculated CCT. However, this factor depends on the lut used. This function</span>
<span class="sd">    optimizes a new correction factor. Not using the right f_corr can lead to errors</span>
<span class="sd">    of several Kelvin. (it generates a finer resolution lut and optimizes the correction</span>
<span class="sd">                        factor such that predictions of the working lut for each of the</span>
<span class="sd">                        entries in this fine-resolution lut is minimized.)</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :lut:</span>
<span class="sd">            | ndarray with lut to optimize factor for.</span>
<span class="sd">        :...: </span>
<span class="sd">            | see docstring for _generate_lut</span>
<span class="sd">        :f_corr:</span>
<span class="sd">            | Tc,x correction factor for the parabolic solution in Ohno2014.</span>
<span class="sd">            |   If None, it will be recalculated (note that it depends on the lut) for increased accuracy.</span>
<span class="sd">        :ignore_f_corr_is_None: </span>
<span class="sd">            |   If True, ignore f_corr is None, i.e. don&#39;t re-calculate f_corr.</span>
<span class="sd">                             </span>

<span class="sd">    Returns:</span>
<span class="sd">         :f_corr:</span>
<span class="sd">             | Tc,x correction factor.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">cctduv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    
        <span class="c1"># Generate a finer resolution lut of ccts to estimate the f_corr correction factor:    </span>
        <span class="k">if</span> <span class="n">lut_fine</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lut_fine</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_generate_lut</span><span class="p">(</span><span class="n">lut</span><span class="p">,</span> <span class="n">uin</span> <span class="o">=</span> <span class="n">uin</span><span class="p">,</span> <span class="n">seamless_stitch</span> <span class="o">=</span> <span class="n">seamless_stitch</span><span class="p">,</span> 
                                        <span class="n">fallback_unit</span> <span class="o">=</span> <span class="n">fallback_unit</span><span class="p">,</span> <span class="n">fallback_n</span> <span class="o">=</span> <span class="n">fallback_n</span><span class="p">,</span>
                                        <span class="n">resample_ndarray</span> <span class="o">=</span> <span class="n">resample_ndarray</span><span class="p">,</span> <span class="n">cct_max</span> <span class="o">=</span> <span class="n">cct_max</span><span class="p">,</span> <span class="n">cct_min</span> <span class="o">=</span> <span class="n">cct_min</span><span class="p">,</span>
                                        <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> 
                                        <span class="n">cspace</span> <span class="o">=</span>  <span class="n">cspace</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">cspace_kwargs</span><span class="p">,</span>
                                        <span class="n">lut_vars</span> <span class="o">=</span> <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;ohno2014&#39;</span><span class="p">][</span><span class="s1">&#39;lut_vars&#39;</span><span class="p">])</span>

        <span class="c1"># add Duv offsets to ccts from finer lut:</span>
        <span class="n">cct</span> <span class="o">=</span> <span class="n">lut_fine</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,:</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">duv</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">cctduv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">cct</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">cct</span><span class="p">)</span><span class="o">*</span><span class="n">duv</span><span class="p">))</span>
        <span class="c1">#cctduv = np.vstack((cctduv,np.hstack((cct,-np.ones_like(cct)*duv))))</span>
        <span class="k">while</span> <span class="n">duv</span> <span class="o">&lt;=</span> <span class="mf">0.05</span><span class="p">:</span>
            <span class="n">duv</span> <span class="o">=</span> <span class="n">duv</span> <span class="o">+</span> <span class="mf">0.001</span>
            <span class="n">cctduv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">cctduv</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">cct</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">cct</span><span class="p">)</span><span class="o">*</span><span class="n">duv</span><span class="p">))))</span>
            <span class="n">cctduv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">cctduv</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">cct</span><span class="p">,</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">cct</span><span class="p">)</span><span class="o">*</span><span class="n">duv</span><span class="p">))))</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">cctduv</span><span class="p">)</span>
        <span class="n">cctduv</span> <span class="o">=</span> <span class="n">cctduv</span><span class="p">[:</span><span class="nb">min</span><span class="p">(</span><span class="n">cctduv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">max</span><span class="p">(</span><span class="n">lut_fine</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1000</span><span class="p">)),:]</span>
        
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">cct_to_xyz</span><span class="p">(</span><span class="n">cctduv</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> <span class="n">cspace</span> <span class="o">=</span> <span class="n">cspace</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">cspace_kwargs</span><span class="p">)</span>
        
    
    <span class="c1"># define shorthand lambda fcn:</span>
    <span class="n">rr</span> <span class="o">=</span> <span class="mi">10</span> <span class="c1"># rounding of f_corr</span>
    <span class="n">TxDuvx_p</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_xyz_to_cct</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;ohno2014&#39;</span><span class="p">,</span> 
                                     <span class="n">lut</span> <span class="o">=</span> <span class="p">[</span><span class="n">lut</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;f_corr&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">rr</span><span class="p">)}],</span> 
                                     <span class="n">is_uv_input</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span><span class="c1">#True, </span>
                                     <span class="n">force_tolerance</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">tol_method</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                     <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;[cct,duv]&#39;</span><span class="p">,</span>
                                     <span class="n">duv_triangular_threshold</span> <span class="o">=</span> <span class="n">duv_triangular_threshold</span><span class="p">,</span> <span class="c1"># force use of parabolic</span>
                                     <span class="n">lut_resolution_reduction_factor</span> <span class="o">=</span> <span class="n">_CCT_LUT_RESOLUTION_REDUCTION_FACTOR</span><span class="p">,</span>
                                     <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">ignore_wl_diff</span> <span class="o">=</span> <span class="n">ignore_wl_diff</span><span class="p">,</span>
                                     <span class="n">cspace</span> <span class="o">=</span> <span class="n">cspace</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">cspace_kwargs</span><span class="p">,</span>
                                     <span class="n">luts_dict</span> <span class="o">=</span> <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;ohno2014&#39;</span><span class="p">][</span><span class="s1">&#39;luts&#39;</span><span class="p">],</span>
                                     <span class="p">)</span>
 
    <span class="n">T</span> <span class="o">=</span> <span class="n">cctduv</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> 
    <span class="n">Duv</span> <span class="o">=</span> <span class="n">cctduv</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="c1">#0.0</span>
    
    <span class="c1"># define objective function:</span>
    <span class="k">def</span> <span class="nf">optfcn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Duv</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span><span class="p">):</span>
        <span class="n">f_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">f_corr</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span> <span class="n">f_corr</span> <span class="o">=</span> <span class="mi">100</span> <span class="c1"># limit search, avoid invalid values</span>
        <span class="n">TxDuvx</span> <span class="o">=</span> <span class="n">TxDuvx_p</span><span class="p">(</span><span class="n">f_corr</span><span class="p">)</span>
        <span class="n">Tx</span><span class="p">,</span><span class="n">Duvx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">TxDuvx</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span><span class="n">TxDuvx</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># abs needed as out_of_lut&#39;s are encode as negative!</span>
        <span class="n">dT2</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span><span class="o">-</span><span class="n">Tx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">dDuv2</span> <span class="o">=</span> <span class="p">(</span><span class="n">Duv</span> <span class="o">-</span> <span class="n">Duvx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">F</span> <span class="o">=</span> <span class="p">(</span><span class="n">dT2</span><span class="o">/</span><span class="mi">1000</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">dDuv2</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;F&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">F</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">eval</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        
    <span class="c1"># setup and run optimization:    </span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;maxiter&#39;</span><span class="p">:</span> <span class="mf">1e3</span><span class="p">,</span> <span class="s1">&#39;maxfev&#39;</span><span class="p">:</span> <span class="mf">1e3</span><span class="p">,</span>  <span class="s1">&#39;xatol&#39;</span><span class="p">:</span> <span class="mf">1e-6</span><span class="p">,</span> <span class="s1">&#39;fatol&#39;</span><span class="p">:</span> <span class="mf">1e-6</span><span class="p">}</span>
    <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span> <span class="c1"># lazy import</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">optfcn</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">Duv</span><span class="p">,</span><span class="s1">&#39;F&#39;</span><span class="p">),</span><span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;Nelder-Mead&#39;</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="n">options</span><span class="p">)</span>
    <span class="n">f_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">rr</span><span class="p">)</span>
    <span class="n">F</span><span class="p">,</span> <span class="n">dT2</span><span class="p">,</span> <span class="n">dDuv2</span><span class="p">,</span> <span class="n">Tx</span><span class="p">,</span> <span class="n">Duvx</span> <span class="o">=</span> <span class="n">optfcn</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">T</span><span class="p">,</span> <span class="n">Duv</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;F,dT2,dDuv2,Tx,Duvx&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> 
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span> <span class="c1"># lazy import</span>
        <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">dT2</span><span class="o">**</span><span class="mf">0.5</span><span class="p">,</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;dT (f_corr = </span><span class="si">{:1.5f}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f_corr</span><span class="p">))</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;dT&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;T (K)&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">dDuv2</span><span class="o">**</span><span class="mf">0.5</span><span class="p">,</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;dDuv (f_corr = </span><span class="si">{:1.5f}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f_corr</span><span class="p">))</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;dDuv&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;T (K)&#39;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> 
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    f_corr = </span><span class="si">{:1.12f}</span><span class="s1">: rmse dT=</span><span class="si">{:1.4f}</span><span class="s1">, dDuv=</span><span class="si">{:1.6f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f_corr</span><span class="p">,</span> <span class="n">dT2</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">**</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">dDuv2</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">**</span><span class="mf">0.5</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">f_corr</span>


<span class="k">def</span> <span class="nf">_uv_to_Tx_ohno2014</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">lut</span><span class="p">,</span> <span class="n">lut_n_cols</span><span class="p">,</span> <span class="n">ns</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out_of_lut</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                       <span class="n">f_corr</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">duv_triangular_threshold</span> <span class="o">=</span> <span class="mf">0.002</span><span class="p">,</span>
                       <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Calculate Tx from u,v and lut using Ohno2014.</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="c1"># get uBB, vBB from lut:</span>
    <span class="n">TBB</span><span class="p">,</span> <span class="n">uBB</span><span class="p">,</span> <span class="n">vBB</span>  <span class="o">=</span> <span class="n">lut</span><span class="p">[:,</span><span class="mi">0</span><span class="p">::</span><span class="n">lut_n_cols</span><span class="p">],</span> <span class="n">lut</span><span class="p">[:,</span><span class="mi">1</span><span class="p">::</span><span class="n">lut_n_cols</span><span class="p">],</span> <span class="n">lut</span><span class="p">[:,</span><span class="mi">2</span><span class="p">::</span><span class="n">lut_n_cols</span><span class="p">]</span>
    <span class="n">idx_sources</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    
    <span class="c1"># calculate distances to coordinates in lut:</span>
    <span class="n">di</span> <span class="o">=</span> <span class="p">((</span><span class="n">u</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">uBB</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">vBB</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
    <span class="n">pn</span> <span class="o">=</span> <span class="n">di</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Deal with endpoints of lut + create intermediate variables </span>
    <span class="c1"># to save memory:</span>
    <span class="n">pn</span><span class="p">,</span> <span class="n">out_of_lut</span> <span class="o">=</span> <span class="n">_deal_with_lut_end_points</span><span class="p">(</span><span class="n">pn</span><span class="p">,</span> <span class="n">TBB</span><span class="p">,</span> <span class="n">out_of_lut</span><span class="p">)</span>

    <span class="n">TBB_m1</span><span class="p">,</span> <span class="n">TBB_0</span><span class="p">,</span> <span class="n">TBB_p1</span> <span class="o">=</span> <span class="n">_get_pns_from_x</span><span class="p">(</span><span class="n">TBB</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx_sources</span><span class="p">)</span>
    <span class="n">uBB_m1</span><span class="p">,</span> <span class="n">uBB_p1</span> <span class="o">=</span> <span class="n">_get_pns_from_x</span><span class="p">(</span><span class="n">uBB</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx_sources</span><span class="p">,</span> <span class="n">m0p</span> <span class="o">=</span> <span class="s1">&#39;mp&#39;</span><span class="p">)</span>
    <span class="n">vBB_m1</span><span class="p">,</span> <span class="n">vBB_p1</span> <span class="o">=</span> <span class="n">_get_pns_from_x</span><span class="p">(</span><span class="n">vBB</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx_sources</span><span class="p">,</span> <span class="n">m0p</span> <span class="o">=</span> <span class="s1">&#39;mp&#39;</span><span class="p">)</span>
    <span class="n">di_m1</span><span class="p">,</span> <span class="n">di_0</span><span class="p">,</span> <span class="n">di_p1</span> <span class="o">=</span> <span class="n">_get_pns_from_x</span><span class="p">(</span><span class="n">di</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx_sources</span><span class="p">)</span>

    <span class="c1">#---------------------------------------------</span>
    <span class="c1"># Triangular solution:        </span>
    <span class="n">l</span> <span class="o">=</span> <span class="p">((</span><span class="n">uBB_p1</span> <span class="o">-</span> <span class="n">uBB_m1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">vBB_p1</span> <span class="o">-</span> <span class="n">vBB_m1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
    <span class="n">l</span><span class="p">[</span><span class="n">l</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="n">_CCT_AVOID_ZERO_DIV</span> 
    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">di_m1</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">di_p1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">l</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">l</span><span class="p">)</span>
    <span class="c1"># uTx = uBB_m1 + (uBB_p1 - uBB_m1)*(x/l)</span>
    <span class="n">vTx</span> <span class="o">=</span> <span class="n">vBB_m1</span> <span class="o">+</span> <span class="p">(</span><span class="n">vBB_p1</span> <span class="o">-</span> <span class="n">vBB_m1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">l</span><span class="p">)</span>
    <span class="n">Txt</span> <span class="o">=</span> <span class="n">TBB_m1</span> <span class="o">+</span> <span class="p">(</span><span class="n">TBB_p1</span> <span class="o">-</span> <span class="n">TBB_m1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">l</span><span class="p">)</span> 
    <span class="n">Duvxt</span> <span class="o">=</span> <span class="p">(</span><span class="n">di_m1</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">Duvxt</span><span class="p">[</span><span class="n">Duvxt</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">Duvxt</span> <span class="o">=</span> <span class="p">(</span><span class="n">Duvxt</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">vTx</span><span class="p">)</span>
    <span class="c1">#_plot_triangular_solution(u,v,uBB,vBB,TBB,pn)</span>


    <span class="c1">#---------------------------------------------</span>
    <span class="c1"># Parabolic solution:</span>
    <span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">TBB_p1</span> <span class="o">-</span> <span class="n">TBB_0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">TBB_m1</span> <span class="o">-</span> <span class="n">TBB_p1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">TBB_0</span><span class="o">-</span><span class="n">TBB_m1</span><span class="p">)</span>
    <span class="n">X</span><span class="p">[</span><span class="n">X</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">_CCT_AVOID_ZERO_DIV</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">TBB_m1</span> <span class="o">*</span> <span class="p">(</span><span class="n">di_p1</span> <span class="o">-</span> <span class="n">di_0</span><span class="p">)</span> <span class="o">+</span> <span class="n">TBB_0</span> <span class="o">*</span> <span class="p">(</span><span class="n">di_m1</span> <span class="o">-</span> <span class="n">di_p1</span><span class="p">)</span> <span class="o">+</span> <span class="n">TBB_p1</span> <span class="o">*</span> <span class="p">(</span><span class="n">di_0</span> <span class="o">-</span> <span class="n">di_m1</span><span class="p">))</span> <span class="o">/</span> <span class="n">X</span>
    <span class="n">a</span><span class="p">[</span><span class="n">a</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">_CCT_AVOID_ZERO_DIV</span>
    <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="p">((</span><span class="n">TBB_m1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">di_p1</span> <span class="o">-</span> <span class="n">di_0</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">TBB_0</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">di_m1</span> <span class="o">-</span> <span class="n">di_p1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">TBB_p1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">di_0</span> <span class="o">-</span> <span class="n">di_m1</span><span class="p">))</span> <span class="o">/</span> <span class="n">X</span>
    <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">di_m1</span> <span class="o">*</span> <span class="p">(</span><span class="n">TBB_p1</span> <span class="o">-</span> <span class="n">TBB_0</span><span class="p">)</span>  <span class="o">*</span> <span class="n">TBB_p1</span> <span class="o">*</span> <span class="n">TBB_0</span>  <span class="o">+</span>\
          <span class="n">di_0</span>  <span class="o">*</span> <span class="p">(</span><span class="n">TBB_m1</span> <span class="o">-</span> <span class="n">TBB_p1</span><span class="p">)</span> <span class="o">*</span> <span class="n">TBB_m1</span> <span class="o">*</span> <span class="n">TBB_p1</span> <span class="o">+</span>\
          <span class="n">di_p1</span> <span class="o">*</span> <span class="p">(</span><span class="n">TBB_0</span> <span class="o">-</span> <span class="n">TBB_m1</span><span class="p">)</span>  <span class="o">*</span> <span class="n">TBB_0</span> <span class="o">*</span> <span class="n">TBB_m1</span><span class="p">)</span> <span class="o">/</span> <span class="n">X</span>
    <span class="n">Txp</span> <span class="o">=</span> <span class="o">-</span><span class="n">b</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>

    <span class="n">Duvxp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">vTx</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">Txp</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">Txp</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span>

    <span class="c1"># Select triangular (threshold=0), parabolic (threshold=inf) or </span>
    <span class="c1"># combined solution:</span>
    <span class="n">Tx</span><span class="p">,</span> <span class="n">Duvx</span> <span class="o">=</span> <span class="n">Txt</span><span class="p">,</span> <span class="n">Duvxt</span> 
    <span class="n">cnd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Duvx</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">duv_triangular_threshold</span>
    <span class="n">Tx</span><span class="p">[</span><span class="n">cnd</span><span class="p">],</span> <span class="n">Duvx</span><span class="p">[</span><span class="n">cnd</span><span class="p">]</span><span class="o">=</span> <span class="n">Txp</span><span class="p">[</span><span class="n">cnd</span><span class="p">],</span> <span class="n">Duvxp</span><span class="p">[</span><span class="n">cnd</span><span class="p">]</span>
    
    <span class="n">Tx</span> <span class="o">=</span> <span class="n">Tx</span> <span class="o">*</span> <span class="n">f_corr</span>  <span class="c1"># correction factor depends on the LUT !!!!! (0.99991 is for 1% Table I in paper, for smaller % correction factor is not needed)</span>

            
    <span class="k">return</span> <span class="n">Tx</span><span class="p">,</span> <span class="n">Duvx</span><span class="p">,</span> <span class="n">out_of_lut</span><span class="p">,</span> <span class="p">(</span><span class="n">TBB_m1</span><span class="p">,</span><span class="n">TBB_p1</span><span class="p">)</span>

<span class="n">_CCT_UV_TO_TX_FCNS</span><span class="p">[</span><span class="s1">&#39;ohno2014&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">_uv_to_Tx_ohno2014</span>
    
<div class="viewcode-block" id="xyz_to_cct_ohno2014">
<a class="viewcode-back" href="../../../../color.html#luxpy.color.cct.xyz_to_cct_ohno2014">[docs]</a>
<span class="k">def</span> <span class="nf">xyz_to_cct_ohno2014</span><span class="p">(</span><span class="n">xyzw</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">_CIEOBS</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;cct&#39;</span><span class="p">,</span> <span class="n">is_uv_input</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                        <span class="n">atol</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="n">force_tolerance</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">tol_method</span> <span class="o">=</span> <span class="s1">&#39;newton-raphson&#39;</span><span class="p">,</span> 
                        <span class="n">lut_resolution_reduction_factor</span> <span class="o">=</span> <span class="n">_CCT_LUT_RESOLUTION_REDUCTION_FACTOR</span><span class="p">,</span>
                        <span class="n">duv_triangular_threshold</span> <span class="o">=</span> <span class="mf">0.002</span><span class="p">,</span>
                        <span class="n">split_calculation_at_N</span> <span class="o">=</span> <span class="n">_CCT_SPLIT_CALC_AT_N</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="n">_CCT_MAX_ITER</span><span class="p">,</span>
                        <span class="n">cspace</span> <span class="o">=</span> <span class="n">_CCT_CSPACE</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">_CCT_CSPACE_KWARGS</span><span class="p">,</span>
                        <span class="n">lut</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">luts_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ignore_wl_diff</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="n">use_fast_duv</span> <span class="o">=</span> <span class="n">_CCT_FAST_DUV</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert XYZ tristimulus values to correlated color temperature (CCT) and </span>
<span class="sd">    Duv (distance above (&gt;0) or below (&lt;0) the Planckian locus) </span>
<span class="sd">    using Ohno&#39;s 2014 method. </span>
<span class="sd">        </span>
<span class="sd">    Args:</span>
<span class="sd">        :xyzw: </span>
<span class="sd">            | ndarray of tristimulus values</span>
<span class="sd">        :cieobs: </span>
<span class="sd">            | luxpy._CIEOBS, optional</span>
<span class="sd">            | CMF set used to calculated xyzw.</span>
<span class="sd">        :out: </span>
<span class="sd">            | &#39;cct&#39; (or 1), optional</span>
<span class="sd">            | Determines what to return.</span>
<span class="sd">            | Other options: &#39;duv&#39; (or -1), &#39;cct,duv&#39;(or 2), &quot;[cct,duv]&quot; (or -2)</span>
<span class="sd">        :is_uv_input:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | If True: xyzw contain uv input data, not xyz data!</span>
<span class="sd">        :wl: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Wavelengths used when calculating Planckian radiators.</span>
<span class="sd">            | If None: use same wavelengths as CMFs in :cieobs:.</span>
<span class="sd">        :rtol: </span>
<span class="sd">            | 1e-5, float, optional</span>
<span class="sd">            | Stop search when cct a relative tolerance is reached.</span>
<span class="sd">            | The relative tolerance is calculated as dCCT/CCT_est, </span>
<span class="sd">            | with CCT_est the current intermediate estimate in the </span>
<span class="sd">            | search and with dCCT the difference between</span>
<span class="sd">            | the present and former estimates.</span>
<span class="sd">        :atol: </span>
<span class="sd">            | 0.1, optional</span>
<span class="sd">            | Stop search when cct a absolute tolerance (K) is reached.</span>
<span class="sd">        :force_tolerance:</span>
<span class="sd">            | True, optional</span>
<span class="sd">            | If False: search only using the list of CCTs in the used lut. </span>
<span class="sd">            |           Only one loop of the full algorithm is performed. </span>
<span class="sd">            |           Accuracy depends on CCT of test source and the location</span>
<span class="sd">            |           and spacing of the CCTs in the list.</span>
<span class="sd">            | If True:  search will use adjacent CCTs to test source to create a new LUT,</span>
<span class="sd">            |           (repeat the algoritm at higher resolution, progessively zooming in</span>
<span class="sd">            |            toward the ground-truth) for tol_method == &#39;cl&#39;; when </span>
<span class="sd">            |           tol_method == &#39;nr&#39; a newton-raphson method is used.</span>
<span class="sd">            |           Because the CCT for multiple source is calculated in one go,</span>
<span class="sd">            |           the atol and rtol values have to be met for all! </span>
<span class="sd">        :tol_method:</span>
<span class="sd">            | &#39;newton-raphson&#39;, optional</span>
<span class="sd">            | (Additional) method to try and achieve set tolerances. </span>
<span class="sd">            | Options: </span>
<span class="sd">            | - &#39;cl&#39;, &#39;cascading-lut&#39;: use increasingly higher CCT-resolution</span>
<span class="sd">            |       to &#39;zoom-in&#39; on the ground-truth.</span>
<span class="sd">            | - &#39;nr&#39;, &#39;newton-raphson&#39;: use the method as described in Li, 2016.</span>
<span class="sd">        :lut_resolution_reduction_factor:</span>
<span class="sd">            | _CCT_LUT_RESOLUTION_REDUCTION_FACTOR, optional</span>
<span class="sd">            | Number of times the interval spanned by the adjacent Tc in a search or lut</span>
<span class="sd">            | method is downsampled (the search process will then start again)</span>
<span class="sd">        :duv_triangular_threshold:</span>
<span class="sd">            | 0.002, optional</span>
<span class="sd">            | Threshold for use of the triangular solution.</span>
<span class="sd">            |  (if smaller use triangular solution, else use the non-triangular one -&gt; 3e-order poly)</span>
<span class="sd">        :max_iter:</span>
<span class="sd">            | _CCT_MAX_ITER, optional</span>
<span class="sd">            | Maximum number of iterations used by the cascading-lut or newton-raphson methods.</span>
<span class="sd">        :split_calculation_at_N:</span>
<span class="sd">            | _CCT_SPLIT_CALC_AT_N, optional</span>
<span class="sd">            | Split calculation when xyzw.shape[0] &gt; split_calculation_at_N. </span>
<span class="sd">            | Splitting speeds up the calculation. If None: no splitting is done.</span>
<span class="sd">        :lut:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Look-Up-Table with Ti, u,v,u&#39;,v&#39;,u&quot;,v&quot;,slope values of Planckians. </span>
<span class="sd">            | Options:</span>
<span class="sd">            |  - None: defaults to the lut specified in _CCT_LUT[&#39;ohno2014&#39;][&#39;lut_type_def&#39;].</span>
<span class="sd">            |  - list (lut,lut_kwargs): use this pre-calculated lut </span>
<span class="sd">            |       (add additional kwargs for the lut_generator_fcn(), defaults to None if omitted)</span>
<span class="sd">            |  - tuple: must be key (label) in :luts_dict: (pre-calculated dict of luts),</span>
<span class="sd">            |           if not: then a new lut will be generated from scratch using the info in the tuple.</span>
<span class="sd">            |  - str: must be key (label) in :luts_dict: (pre-calculated dict of luts)</span>
<span class="sd">            |  - ndarray [Nx1]: list of luts for which to generate a lut</span>
<span class="sd">            |  - ndarray [Nxn] with n&gt;3: pre-calculated lut (last col must contain slope of the isotemperature lines).</span>
<span class="sd">        :luts_dict:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Dictionary of pre-calculated luts for various cspaces and cmf sets.</span>
<span class="sd">            |  Must have structure luts_dict[cspace][cieobs][lut_label] with the</span>
<span class="sd">            |   lut part of a two-element list [lut, lut_kwargs]. It must contain</span>
<span class="sd">            |   at the top-level a key &#39;wl&#39; containing the wavelengths of the </span>
<span class="sd">            |   Planckians used to generate the luts in this dictionary.</span>
<span class="sd">            | If None: luts_dict defaults to _CCT_LUT[&#39;ohno2014&#39;][&#39;luts&#39;]    </span>
<span class="sd">        :cspace:</span>
<span class="sd">            | _CCT_SPACE, optional</span>
<span class="sd">            | Color space to do calculations in. </span>
<span class="sd">            | Options: </span>
<span class="sd">            |    - cspace string: </span>
<span class="sd">            |        e.g. &#39;Yuv60&#39; for use with luxpy.colortf()</span>
<span class="sd">            |    - tuple with forward (i.e. xyz_to..) [and backward (i.e. ..to_xyz)] functions </span>
<span class="sd">            |      (and an optional string describing the cspace): </span>
<span class="sd">            |        e.g. (forward, backward) or (forward, backward, cspace string) or (forward, cspace string) </span>
<span class="sd">            |    - dict with keys: &#39;fwtf&#39; (foward), &#39;bwtf&#39; (backward) [, optional: &#39;str&#39; (cspace string)]</span>
<span class="sd">            |  Note: if the backward tf is not supplied, optimization in cct_to_xyz() is done in the CIE 1976 u&#39;v&#39; diagram</span>
<span class="sd">        :cspace_kwargs:</span>
<span class="sd">            | _CCT_CSPACE_KWARGS, optional</span>
<span class="sd">            | Parameter nested dictionary for the forward and backward transforms.</span>
<span class="sd">        :ignore_wl_diff:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | When getting a lut from the dictionary, if differences are</span>
<span class="sd">            | detected in the wavelengts of the lut and the ones used to calculate any</span>
<span class="sd">            | plankcians then a new lut should be generated. Seting this to True ignores</span>
<span class="sd">            | these differences and proceeds anyway.</span>
<span class="sd">        :use_fast_duv:</span>
<span class="sd">            | _CCT_FAST_DUV, optional</span>
<span class="sd">            | If True: use a fast estimator of the Duv </span>
<span class="sd">            |   (one that avoids calculation of Planckians and uses the former</span>
<span class="sd">            |    best estimate&#39;s u,v coordinates. This method is accurate enough</span>
<span class="sd">            |    when the atol is small enough -&gt; as long as abs(T-T_former)&lt;=1K</span>
<span class="sd">            |    the Duv estimate should be ok.)</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | ndarray with:</span>
<span class="sd">            |    cct: out == &#39;cct&#39; (or 1)</span>
<span class="sd">            |    duv: out == &#39;duv&#39; (or -1)</span>
<span class="sd">            |    cct, duv: out == &#39;cct,duv&#39; (or 2)</span>
<span class="sd">            |    [cct,duv]: out == &quot;[cct,duv]&quot; (or -2) </span>
<span class="sd">            </span>
<span class="sd">            </span>
<span class="sd">    Note: </span>
<span class="sd">        1. Out-of-lut CCTs are encoded as negative CCTs (with as absolute value</span>
<span class="sd">        the value of the closest CCT from the lut.)</span>
<span class="sd">    </span>
<span class="sd">    References:</span>
<span class="sd">        1. `Ohno Y. Practical use and calculation of CCT and Duv. </span>
<span class="sd">        Leukos. 2014 Jan 2;10(1):47-55.</span>
<span class="sd">        &lt;http://www.tandfonline.com/doi/abs/10.1080/15502724.2014.839020&gt;`_</span>
<span class="sd">         </span>
<span class="sd">        2. `Li, C., Cui, G., Melgosa, M., Ruan, X., Zhang, Y., Ma, L., Xiao, K., &amp; Luo, M. R. (2016).</span>
<span class="sd">        Accurate method for computing correlated color temperature. </span>
<span class="sd">        Optics Express, 24(13), 14066–14078. </span>
<span class="sd">        &lt;https://doi.org/10.1364/OE.24.014066&gt;`_</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="k">return</span> <span class="n">_xyz_to_cct</span><span class="p">(</span><span class="n">xyzw</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;ohno2014&#39;</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> <span class="n">is_uv_input</span> <span class="o">=</span> <span class="n">is_uv_input</span><span class="p">,</span> 
                       <span class="n">cspace</span> <span class="o">=</span> <span class="n">cspace</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">cspace_kwargs</span><span class="p">,</span>
                       <span class="n">atol</span> <span class="o">=</span> <span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="n">rtol</span><span class="p">,</span> <span class="n">force_tolerance</span> <span class="o">=</span> <span class="n">force_tolerance</span><span class="p">,</span>
                       <span class="n">tol_method</span> <span class="o">=</span> <span class="n">tol_method</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span><span class="p">,</span>  
                       <span class="n">lut_resolution_reduction_factor</span> <span class="o">=</span> <span class="n">lut_resolution_reduction_factor</span><span class="p">,</span>
                       <span class="n">split_calculation_at_N</span> <span class="o">=</span> <span class="n">split_calculation_at_N</span><span class="p">,</span> 
                       <span class="n">lut</span> <span class="o">=</span> <span class="n">lut</span><span class="p">,</span> <span class="n">luts_dict</span> <span class="o">=</span> <span class="n">luts_dict</span><span class="p">,</span> 
                       <span class="n">ignore_wl_diff</span> <span class="o">=</span> <span class="n">ignore_wl_diff</span><span class="p">,</span> 
                       <span class="n">duv_triangular_threshold</span> <span class="o">=</span> <span class="n">duv_triangular_threshold</span><span class="p">,</span>
                       <span class="n">use_fast_duv</span> <span class="o">=</span> <span class="n">use_fast_duv</span><span class="p">,</span>
                       <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="c1"># pre-generate / load from disk / load from github some LUTs for Ohno2014:</span>
<span class="n">_initialize_lut</span><span class="p">(</span><span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;ohno2014&#39;</span><span class="p">,</span> <span class="n">lut_types</span> <span class="o">=</span> <span class="n">_unique_types</span><span class="p">([</span><span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;ohno2014&#39;</span><span class="p">][</span><span class="s1">&#39;lut_type_def&#39;</span><span class="p">],</span> <span class="p">((</span><span class="n">_CCT_LUT_MIN</span><span class="p">,</span> <span class="n">_CCT_LUT_MAX</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;%&#39;</span><span class="p">),)]</span> <span class="o">+</span> <span class="n">_CCT_SHARED_LUT_TYPES</span><span class="p">))</span>


<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># Li 2022 (i.e. update of Ohno 2014) related functions:</span>
<span class="c1">#------------------------------------------------------------------------------</span>
<span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;li2022&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;luts&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">}</span>
<span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;li2022&#39;</span><span class="p">][</span><span class="s1">&#39;lut_type_def&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">_CCT_LUT_MIN</span><span class="p">,</span> <span class="n">_CCT_LUT_MAX</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="s1">&#39;%&#39;</span><span class="p">),)</span>
<span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;li2022&#39;</span><span class="p">][</span><span class="s1">&#39;lut_vars&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;uv&#39;</span><span class="p">,</span><span class="s1">&#39;uvp&#39;</span><span class="p">,</span><span class="s1">&#39;uvpp&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="_generate_lut_li2022">
<a class="viewcode-back" href="../../../../color.html#luxpy.color.cct._generate_lut_li2022">[docs]</a>
<span class="k">def</span> <span class="nf">_generate_lut_li2022</span><span class="p">(</span><span class="n">lut</span><span class="p">,</span> 
                           <span class="n">uin</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">seamless_stitch</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
                           <span class="n">fallback_unit</span> <span class="o">=</span> <span class="n">_CCT_FALLBACK_UNIT</span><span class="p">,</span> <span class="n">fallback_n</span> <span class="o">=</span> <span class="n">_CCT_FALLBACK_N</span><span class="p">,</span>
                           <span class="n">resample_ndarray</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                           <span class="n">cct_max</span> <span class="o">=</span> <span class="n">_CCT_MAX</span><span class="p">,</span> <span class="n">cct_min</span> <span class="o">=</span> <span class="n">_CCT_MIN</span><span class="p">,</span>
                           <span class="n">luts_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">lut_type_def</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">lut_vars</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;uv&#39;</span><span class="p">,</span><span class="s1">&#39;uvp&#39;</span><span class="p">,</span><span class="s1">&#39;uvpp&#39;</span><span class="p">],</span>
                           <span class="n">cieobs</span> <span class="o">=</span>  <span class="n">_CIEOBS</span><span class="p">,</span> <span class="n">cspace_str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ignore_unequal_wl</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                           <span class="n">lut_generator_fcn</span> <span class="o">=</span> <span class="n">_generate_lut</span><span class="p">,</span> <span class="n">lut_generator_kwargs</span> <span class="o">=</span> <span class="p">{},</span>
                           <span class="n">cspace</span> <span class="o">=</span> <span class="n">_CCT_CSPACE</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">_CCT_CSPACE_KWARGS</span><span class="p">,</span>
                           <span class="n">f_corr</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ignore_f_corr_is_None</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span><span class="n">duv_triangular_threshold</span> <span class="o">=</span> <span class="mf">0.002</span><span class="p">,</span>
                           <span class="n">ignore_wl_diff</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Lut generator function for li2022 (= updated ohno2014). </span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :...: </span>
<span class="sd">            | see docstring for _generate_lut</span>
<span class="sd">        :f_corr:</span>
<span class="sd">            | Tc,x correction factor for the non-triangular solution in Ohno2014.</span>
<span class="sd">            |   If None, it will be recalculated (note that it depends on the lut) for increased accuracy.</span>
<span class="sd">        :ignore_f_corr_is_None: </span>
<span class="sd">            |   If True, ignore f_corr is None, i.e. don&#39;t re-calculate f_corr.</span>
<span class="sd">                             </span>
<span class="sd">    Returns:</span>
<span class="sd">        :lut: </span>
<span class="sd">            | an ndarray with the lut </span>
<span class="sd">        :dict:</span>
<span class="sd">            | a dictionary with the (re-optmized) value for f_corr and for ignore_f_cor_is_None.)</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="c1"># get/estimate lut unit:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lut</span><span class="p">,</span><span class="nb">tuple</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lut</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">tuple</span><span class="p">):</span>
            <span class="n">fallback_unit_lut</span> <span class="o">=</span> <span class="n">lut</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fallback_unit_lut</span> <span class="o">=</span> <span class="n">lut</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fallback_unit_lut</span> <span class="o">=</span> <span class="n">_get_lut_characteristics</span><span class="p">(</span><span class="n">lut</span><span class="p">,</span><span class="n">force_au</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">fallback_unit_lut</span> <span class="o">==</span> <span class="s1">&#39;au&#39;</span><span class="p">:</span> <span class="n">fallback_unit_lut</span> <span class="o">=</span> <span class="n">_CCT_FALLBACK_UNIT</span>
        
    <span class="c1"># generate lut:</span>
    <span class="n">lut</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_generate_lut</span><span class="p">(</span><span class="n">lut</span><span class="p">,</span> <span class="n">uin</span> <span class="o">=</span> <span class="n">uin</span><span class="p">,</span> <span class="n">seamless_stitch</span> <span class="o">=</span> <span class="n">seamless_stitch</span><span class="p">,</span> 
                        <span class="n">fallback_unit</span> <span class="o">=</span> <span class="n">fallback_unit_lut</span><span class="p">,</span> <span class="n">fallback_n</span> <span class="o">=</span> <span class="n">fallback_n</span><span class="p">,</span>
                        <span class="n">resample_ndarray</span> <span class="o">=</span> <span class="n">resample_ndarray</span><span class="p">,</span> <span class="n">cct_max</span> <span class="o">=</span> <span class="n">cct_max</span><span class="p">,</span> <span class="n">cct_min</span> <span class="o">=</span> <span class="n">cct_min</span><span class="p">,</span>
                        <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">lut_vars</span> <span class="o">=</span> <span class="n">lut_vars</span><span class="p">,</span>
                        <span class="n">cspace</span> <span class="o">=</span>  <span class="n">cspace</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">cspace_kwargs</span><span class="p">)</span>        
    
    <span class="c1"># No f_corr needed for high resolution luts:</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">lut</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span><span class="mi">6</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">lut</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span><span class="mi">6</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">lut</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">lut</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mi">6</span><span class="p">)))</span> <span class="o">|</span> <span class="p">(</span><span class="n">fallback_unit_lut</span> <span class="o">==</span> <span class="s1">&#39;K&#39;</span><span class="p">):</span> <span class="c1"># K scale</span>
        <span class="k">if</span> <span class="n">lut</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">lut</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">f_corr</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">fallback_unit_lut</span> <span class="o">==</span> <span class="s1">&#39;%&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="n">lut</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">lut</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.25</span><span class="p">:</span>
            <span class="n">f_corr</span> <span class="o">=</span> <span class="mi">1</span>
        
    <span class="c1"># Get correction factor for Tx in parabolic solution:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">f_corr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span> 
        <span class="k">if</span> <span class="p">(</span><span class="n">ignore_f_corr_is_None</span> <span class="o">==</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">f_corr</span> <span class="o">=</span> <span class="n">get_correction_factor_for_Tx</span><span class="p">(</span><span class="n">lut</span><span class="p">,</span> 
                                                  <span class="n">uin</span> <span class="o">=</span> <span class="n">uin</span><span class="p">,</span> 
                                                  <span class="n">seamless_stitch</span> <span class="o">=</span> <span class="n">seamless_stitch</span><span class="p">,</span> 
                                                  <span class="n">fallback_unit</span> <span class="o">=</span> <span class="n">fallback_unit_lut</span><span class="p">,</span>
                                                  <span class="n">fallback_n</span> <span class="o">=</span> <span class="n">lut</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span>
                                                  <span class="n">resample_ndarray</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                                  <span class="n">cct_max</span> <span class="o">=</span> <span class="n">cct_max</span><span class="p">,</span> 
                                                  <span class="n">cct_min</span> <span class="o">=</span> <span class="n">cct_min</span><span class="p">,</span>
                                                  <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> 
                                                  <span class="n">lut_vars</span> <span class="o">=</span> <span class="n">lut_vars</span><span class="p">,</span>
                                                  <span class="n">cspace</span> <span class="o">=</span>  <span class="n">cspace</span><span class="p">,</span> 
                                                  <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">cspace_kwargs</span><span class="p">,</span>
                                                  <span class="n">ignore_wl_diff</span> <span class="o">=</span> <span class="n">ignore_wl_diff</span><span class="p">,</span>
                                                  <span class="n">duv_triangular_threshold</span> <span class="o">=</span> <span class="n">duv_triangular_threshold</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span> 
            <span class="n">f_corr</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="c1"># use this a backup value</span>


    <span class="k">return</span> <span class="nb">list</span><span class="p">([</span><span class="n">lut</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;f_corr&#39;</span><span class="p">:</span><span class="n">f_corr</span><span class="p">,</span><span class="s1">&#39;ignore_f_corr_is_None&#39;</span><span class="p">:</span><span class="n">ignore_f_corr_is_None</span><span class="p">}])</span></div>


<span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;li2022&#39;</span><span class="p">][</span><span class="s1">&#39;_generate_lut&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_generate_lut_li2022</span>

<span class="k">def</span> <span class="nf">get_correction_factor_for_Tx_li2022</span><span class="p">(</span><span class="n">lut</span><span class="p">,</span> <span class="n">lut_fine</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">cctduv</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                 <span class="n">uin</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">seamless_stitch</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
                                 <span class="n">fallback_unit</span> <span class="o">=</span> <span class="n">_CCT_FALLBACK_UNIT</span><span class="p">,</span> <span class="n">fallback_n</span> <span class="o">=</span> <span class="n">_CCT_FALLBACK_N</span><span class="p">,</span>
                                 <span class="n">resample_ndarray</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                 <span class="n">cct_max</span> <span class="o">=</span> <span class="n">_CCT_MAX</span><span class="p">,</span> <span class="n">cct_min</span> <span class="o">=</span> <span class="n">_CCT_MIN</span><span class="p">,</span>
                                 <span class="n">luts_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">lut_type_def</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">lut_vars</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;uv&#39;</span><span class="p">,</span><span class="s1">&#39;uvp&#39;</span><span class="p">,</span><span class="s1">&#39;uvpp&#39;</span><span class="p">],</span>
                                 <span class="n">cieobs</span> <span class="o">=</span>  <span class="n">_CIEOBS</span><span class="p">,</span> <span class="n">cspace_str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ignore_unequal_wl</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                                 <span class="n">lut_generator_fcn</span> <span class="o">=</span> <span class="n">_generate_lut</span><span class="p">,</span> <span class="n">lut_generator_kwargs</span> <span class="o">=</span> <span class="p">{},</span>
                                 <span class="n">cspace</span> <span class="o">=</span> <span class="n">_CCT_CSPACE</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">_CCT_CSPACE_KWARGS</span><span class="p">,</span>
                                 <span class="n">f_corr</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ignore_f_corr_is_None</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span><span class="n">duv_triangular_threshold</span><span class="o">=</span><span class="mf">0.002</span><span class="p">,</span>
                                 <span class="n">ignore_wl_diff</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                 <span class="n">verbosity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Ohno&#39;s 2014 method uses a correction factor to correct the</span>
<span class="sd">    calculated CCT. However, this factor depends on the lut used. This function</span>
<span class="sd">    optimizes a new correction factor. Not using the right f_corr can lead to errors</span>
<span class="sd">    of several Kelvin. (it generates a finer resolution lut and optimizes the correction</span>
<span class="sd">                        factor such that predictions of the working lut for eacg of the</span>
<span class="sd">                        entries in this fine-resolution lut is minimized.)</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :lut:</span>
<span class="sd">            | ndarray with lut to optimize factor for.</span>
<span class="sd">        :...: </span>
<span class="sd">            | see docstring for _generate_lut</span>
<span class="sd">        :f_corr:</span>
<span class="sd">            | Tc,x correction factor for the non-triangular solution in Ohno2014.</span>
<span class="sd">            |   If None, it will be recalculated (note that it depends on the lut) for increased accuracy.</span>
<span class="sd">        :ignore_f_corr_is_None: </span>
<span class="sd">            |   If True, ignore f_corr is None, i.e. don&#39;t re-calculate f_corr.</span>
<span class="sd">                             </span>

<span class="sd">    Returns:</span>
<span class="sd">         :f_corr:</span>
<span class="sd">             | Tc,x correction factor.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">cctduv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    
        <span class="c1"># Generate a finer resolution lut of ccts to estimate the f_corr correction factor:    </span>
        <span class="k">if</span> <span class="n">lut_fine</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lut_fine</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_generate_lut</span><span class="p">(</span><span class="n">lut</span><span class="p">,</span> <span class="n">uin</span> <span class="o">=</span> <span class="n">uin</span><span class="p">,</span> <span class="n">seamless_stitch</span> <span class="o">=</span> <span class="n">seamless_stitch</span><span class="p">,</span> 
                                        <span class="n">fallback_unit</span> <span class="o">=</span> <span class="n">fallback_unit</span><span class="p">,</span> <span class="n">fallback_n</span> <span class="o">=</span> <span class="n">fallback_n</span><span class="p">,</span>
                                        <span class="n">resample_ndarray</span> <span class="o">=</span> <span class="n">resample_ndarray</span><span class="p">,</span> <span class="n">cct_max</span> <span class="o">=</span> <span class="n">cct_max</span><span class="p">,</span> <span class="n">cct_min</span> <span class="o">=</span> <span class="n">cct_min</span><span class="p">,</span>
                                        <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> 
                                        <span class="n">cspace</span> <span class="o">=</span>  <span class="n">cspace</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">cspace_kwargs</span><span class="p">,</span>
                                        <span class="n">lut_vars</span> <span class="o">=</span> <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;li2022&#39;</span><span class="p">][</span><span class="s1">&#39;lut_vars&#39;</span><span class="p">])</span>
    
        <span class="c1"># add Duv offsets to ccts from finer lut:</span>
        <span class="n">cct</span> <span class="o">=</span> <span class="n">lut_fine</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,:</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">duv</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">cctduv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">cct</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">cct</span><span class="p">)</span><span class="o">*</span><span class="n">duv</span><span class="p">))</span>
        <span class="c1">#cctduv = np.vstack((cctduv,np.hstack((cct,-np.ones_like(cct)*duv))))</span>
        <span class="k">while</span> <span class="n">duv</span> <span class="o">&lt;=</span> <span class="mf">0.05</span><span class="p">:</span>
            <span class="n">duv</span> <span class="o">=</span> <span class="n">duv</span> <span class="o">+</span> <span class="mf">0.001</span>
            <span class="n">cctduv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">cctduv</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">cct</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">cct</span><span class="p">)</span><span class="o">*</span><span class="n">duv</span><span class="p">))))</span>
            <span class="n">cctduv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">cctduv</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">cct</span><span class="p">,</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">cct</span><span class="p">)</span><span class="o">*</span><span class="n">duv</span><span class="p">))))</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">cctduv</span><span class="p">)</span>
        <span class="n">cctduv</span> <span class="o">=</span> <span class="n">cctduv</span><span class="p">[:</span><span class="nb">min</span><span class="p">(</span><span class="n">cctduv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">max</span><span class="p">(</span><span class="n">lut_fine</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1000</span><span class="p">)),:]</span>
        
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">cct_to_xyz</span><span class="p">(</span><span class="n">cctduv</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> <span class="n">cspace</span> <span class="o">=</span> <span class="n">cspace</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">cspace_kwargs</span><span class="p">)</span>
        
    
    <span class="c1"># define shorthand lambda fcn:</span>
    <span class="n">rr</span> <span class="o">=</span> <span class="mi">10</span> <span class="c1"># rounding of f_corr</span>
    <span class="n">TxDuvx_p</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_xyz_to_cct</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;li2022&#39;</span><span class="p">,</span> 
                                     <span class="n">lut</span> <span class="o">=</span> <span class="p">[</span><span class="n">lut</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;f_corr&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">rr</span><span class="p">)}],</span> 
                                     <span class="n">is_uv_input</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span><span class="c1">#True, </span>
                                     <span class="n">force_tolerance</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">tol_method</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                     <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;[cct,duv]&#39;</span><span class="p">,</span>
                                     <span class="n">duv_triangular_threshold</span> <span class="o">=</span> <span class="n">duv_triangular_threshold</span><span class="p">,</span> <span class="c1"># force use of parabolic</span>
                                     <span class="n">lut_resolution_reduction_factor</span> <span class="o">=</span> <span class="n">_CCT_LUT_RESOLUTION_REDUCTION_FACTOR</span><span class="p">,</span>
                                     <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">ignore_wl_diff</span> <span class="o">=</span> <span class="n">ignore_wl_diff</span><span class="p">,</span>
                                     <span class="n">cspace</span> <span class="o">=</span> <span class="n">cspace</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">cspace_kwargs</span><span class="p">,</span>
                                     <span class="n">luts_dict</span> <span class="o">=</span> <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;li2022&#39;</span><span class="p">][</span><span class="s1">&#39;luts&#39;</span><span class="p">],</span>
                                     <span class="p">)</span>
    
    <span class="n">T</span> <span class="o">=</span> <span class="n">cctduv</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> 
    <span class="n">Duv</span> <span class="o">=</span> <span class="n">cctduv</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="c1">#0.0</span>
    
    <span class="c1"># define objective function:</span>
    <span class="k">def</span> <span class="nf">optfcn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Duv</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span><span class="p">):</span>
        <span class="n">f_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">f_corr</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span> <span class="n">f_corr</span> <span class="o">=</span> <span class="mi">100</span> <span class="c1"># limit search, avoid invalid values</span>
        <span class="n">TxDuvx</span> <span class="o">=</span> <span class="n">TxDuvx_p</span><span class="p">(</span><span class="n">f_corr</span><span class="p">)</span>
        <span class="n">Tx</span><span class="p">,</span><span class="n">Duvx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">TxDuvx</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span><span class="n">TxDuvx</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># abs needed as out_of_lut&#39;s are encode as negative!</span>
        <span class="n">dT2</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span><span class="o">-</span><span class="n">Tx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">dDuv2</span> <span class="o">=</span> <span class="p">(</span><span class="n">Duv</span> <span class="o">-</span> <span class="n">Duvx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">F</span> <span class="o">=</span> <span class="p">(</span><span class="n">dT2</span><span class="o">/</span><span class="mi">1000</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">dDuv2</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;F&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">F</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">eval</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        
    <span class="c1"># setup and run optimization:    </span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;maxiter&#39;</span><span class="p">:</span> <span class="mf">1e3</span><span class="p">,</span> <span class="s1">&#39;maxfev&#39;</span><span class="p">:</span> <span class="mf">1e3</span><span class="p">,</span>  <span class="s1">&#39;xatol&#39;</span><span class="p">:</span> <span class="mf">1e-6</span><span class="p">,</span> <span class="s1">&#39;fatol&#39;</span><span class="p">:</span> <span class="mf">1e-6</span><span class="p">}</span>
    <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span> <span class="c1"># lazy import</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">optfcn</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">Duv</span><span class="p">,</span><span class="s1">&#39;F&#39;</span><span class="p">),</span><span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;Nelder-Mead&#39;</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="n">options</span><span class="p">)</span>
    <span class="n">f_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">rr</span><span class="p">)</span>
    <span class="n">F</span><span class="p">,</span> <span class="n">dT2</span><span class="p">,</span> <span class="n">dDuv2</span><span class="p">,</span> <span class="n">Tx</span><span class="p">,</span> <span class="n">Duvx</span> <span class="o">=</span> <span class="n">optfcn</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">T</span><span class="p">,</span> <span class="n">Duv</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;F,dT2,dDuv2,Tx,Duvx&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> 
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span> <span class="c1"># lazy import</span>
        <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">dT2</span><span class="o">**</span><span class="mf">0.5</span><span class="p">,</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;dT (f_corr = </span><span class="si">{:1.5f}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f_corr</span><span class="p">))</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;dT&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;T (K)&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">dDuv2</span><span class="o">**</span><span class="mf">0.5</span><span class="p">,</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;dDuv (f_corr = </span><span class="si">{:1.5f}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f_corr</span><span class="p">))</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;dDuv&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;T (K)&#39;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> 
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    f_corr = </span><span class="si">{:1.12f}</span><span class="s1">: rmse dT=</span><span class="si">{:1.4f}</span><span class="s1">, dDuv=</span><span class="si">{:1.6f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f_corr</span><span class="p">,</span> <span class="n">dT2</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">**</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">dDuv2</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">**</span><span class="mf">0.5</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">f_corr</span>



<span class="k">def</span> <span class="nf">_uv_to_Tx_li2022</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">lut</span><span class="p">,</span> <span class="n">lut_n_cols</span><span class="p">,</span> <span class="n">ns</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out_of_lut</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                       <span class="n">f_corr</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">duv_triangular_threshold</span> <span class="o">=</span> <span class="mf">0.002</span><span class="p">,</span>
                       <span class="n">uvwbar</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Calculate Tx from u,v and lut using li2022.</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="c1"># get uBB, vBB from lut:</span>
    <span class="n">TBB</span><span class="p">,</span> <span class="n">uBB</span><span class="p">,</span> <span class="n">vBB</span>  <span class="o">=</span> <span class="n">lut</span><span class="p">[:,</span><span class="mi">0</span><span class="p">::</span><span class="n">lut_n_cols</span><span class="p">],</span> <span class="n">lut</span><span class="p">[:,</span><span class="mi">1</span><span class="p">::</span><span class="n">lut_n_cols</span><span class="p">],</span> <span class="n">lut</span><span class="p">[:,</span><span class="mi">2</span><span class="p">::</span><span class="n">lut_n_cols</span><span class="p">]</span>
    <span class="n">upBB</span><span class="p">,</span> <span class="n">vpBB</span><span class="p">,</span> <span class="n">uppBB</span><span class="p">,</span> <span class="n">vppBB</span> <span class="o">=</span> <span class="n">lut</span><span class="p">[:,</span><span class="mi">3</span><span class="p">::</span><span class="n">lut_n_cols</span><span class="p">],</span> <span class="n">lut</span><span class="p">[:,</span><span class="mi">4</span><span class="p">::</span><span class="n">lut_n_cols</span><span class="p">],</span> <span class="n">lut</span><span class="p">[:,</span><span class="mi">5</span><span class="p">::</span><span class="n">lut_n_cols</span><span class="p">],</span> <span class="n">lut</span><span class="p">[:,</span><span class="mi">6</span><span class="p">::</span><span class="n">lut_n_cols</span><span class="p">]</span>
    <span class="n">idx_sources</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    
    <span class="c1"># calculate distances to coordinates in lut:</span>
    <span class="n">di</span> <span class="o">=</span> <span class="p">((</span><span class="n">u</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">uBB</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">vBB</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
    <span class="n">pn</span> <span class="o">=</span> <span class="n">di</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Deal with endpoints of lut + create intermediate variables </span>
    <span class="c1"># to save memory:</span>
    <span class="n">pn</span><span class="p">,</span> <span class="n">out_of_lut</span> <span class="o">=</span> <span class="n">_deal_with_lut_end_points</span><span class="p">(</span><span class="n">pn</span><span class="p">,</span> <span class="n">TBB</span><span class="p">,</span> <span class="n">out_of_lut</span><span class="p">)</span>

    <span class="n">TBB_m1</span><span class="p">,</span> <span class="n">TBB_0</span><span class="p">,</span> <span class="n">TBB_p1</span> <span class="o">=</span> <span class="n">_get_pns_from_x</span><span class="p">(</span><span class="n">TBB</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx_sources</span><span class="p">,</span> <span class="n">m0p</span> <span class="o">=</span> <span class="s1">&#39;m0p&#39;</span><span class="p">)</span>
    <span class="n">uBB_m1</span><span class="p">,</span> <span class="n">uBB_0</span><span class="p">,</span> <span class="n">uBB_p1</span> <span class="o">=</span> <span class="n">_get_pns_from_x</span><span class="p">(</span><span class="n">uBB</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx_sources</span><span class="p">,</span> <span class="n">m0p</span> <span class="o">=</span> <span class="s1">&#39;m0p&#39;</span><span class="p">)</span>
    <span class="n">vBB_m1</span><span class="p">,</span> <span class="n">vBB_0</span><span class="p">,</span> <span class="n">vBB_p1</span> <span class="o">=</span> <span class="n">_get_pns_from_x</span><span class="p">(</span><span class="n">vBB</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx_sources</span><span class="p">,</span> <span class="n">m0p</span> <span class="o">=</span> <span class="s1">&#39;m0p&#39;</span><span class="p">)</span>
    <span class="n">upBB_m1</span><span class="p">,</span> <span class="n">upBB_0</span><span class="p">,</span> <span class="n">upBB_p1</span> <span class="o">=</span> <span class="n">_get_pns_from_x</span><span class="p">(</span><span class="n">upBB</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx_sources</span><span class="p">,</span> <span class="n">m0p</span> <span class="o">=</span> <span class="s1">&#39;m0p&#39;</span><span class="p">)</span>
    <span class="n">vpBB_m1</span><span class="p">,</span> <span class="n">vpBB_0</span><span class="p">,</span> <span class="n">vpBB_p1</span> <span class="o">=</span> <span class="n">_get_pns_from_x</span><span class="p">(</span><span class="n">vpBB</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx_sources</span><span class="p">,</span> <span class="n">m0p</span> <span class="o">=</span> <span class="s1">&#39;m0p&#39;</span><span class="p">)</span>
    <span class="n">uppBB_m1</span><span class="p">,</span> <span class="n">uppBB_0</span><span class="p">,</span> <span class="n">uppBB_p1</span> <span class="o">=</span> <span class="n">_get_pns_from_x</span><span class="p">(</span><span class="n">uppBB</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx_sources</span><span class="p">,</span> <span class="n">m0p</span> <span class="o">=</span> <span class="s1">&#39;m0p&#39;</span><span class="p">)</span>
    <span class="n">vppBB_m1</span><span class="p">,</span> <span class="n">vppBB_0</span><span class="p">,</span> <span class="n">vppBB_p1</span> <span class="o">=</span> <span class="n">_get_pns_from_x</span><span class="p">(</span><span class="n">vppBB</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx_sources</span><span class="p">,</span> <span class="n">m0p</span> <span class="o">=</span> <span class="s1">&#39;m0p&#39;</span><span class="p">)</span>
    <span class="n">di_m1</span><span class="p">,</span> <span class="n">di_0</span><span class="p">,</span> <span class="n">di_p1</span> <span class="o">=</span> <span class="n">_get_pns_from_x</span><span class="p">(</span><span class="n">di</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx_sources</span><span class="p">,</span> <span class="n">m0p</span> <span class="o">=</span> <span class="s1">&#39;m0p&#39;</span><span class="p">)</span>
    
    <span class="c1">#---------------------------------------------</span>
    <span class="c1"># Triangular solution:        </span>
    <span class="n">l</span> <span class="o">=</span> <span class="p">((</span><span class="n">uBB_p1</span> <span class="o">-</span> <span class="n">uBB_m1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">vBB_p1</span> <span class="o">-</span> <span class="n">vBB_m1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
    <span class="n">l</span><span class="p">[</span><span class="n">l</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="n">_CCT_AVOID_ZERO_DIV</span> 
    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">di_m1</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">di_p1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">l</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">l</span><span class="p">)</span>
    <span class="c1"># uTx = uBB_m1 + (uBB_p1 - uBB_m1)*(x/l)</span>
    <span class="n">vTx</span> <span class="o">=</span> <span class="n">vBB_m1</span> <span class="o">+</span> <span class="p">(</span><span class="n">vBB_p1</span> <span class="o">-</span> <span class="n">vBB_m1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">l</span><span class="p">)</span>
    <span class="n">Txt</span> <span class="o">=</span> <span class="n">TBB_m1</span> <span class="o">+</span> <span class="p">(</span><span class="n">TBB_p1</span> <span class="o">-</span> <span class="n">TBB_m1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">l</span><span class="p">)</span> 
    <span class="n">Txt</span> <span class="o">=</span> <span class="n">Txt</span> <span class="o">*</span> <span class="n">f_corr</span> <span class="c1"># correction factor depends on the LUT !!!!! (0.99991 is for 1% Table I in paper, for smaller % correction factor is not needed)</span>
    <span class="n">Duvxt</span> <span class="o">=</span> <span class="p">(</span><span class="n">di_m1</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">Duvxt</span><span class="p">[</span><span class="n">Duvxt</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">Duvxt</span> <span class="o">=</span> <span class="p">(</span><span class="n">Duvxt</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">vTx</span><span class="p">)</span>
    <span class="c1"># _plot_triangular_solution(u,v,uBB,vBB,TBB,pn)</span>


    <span class="c1">#---------------------------------------------</span>
    <span class="c1"># Pm solution:</span>
    <span class="c1">#f_corr = 1 # force to 1</span>
    
    <span class="c1"># Get data for two shortest distances: </span>
    <span class="n">c_p1_m1</span> <span class="o">=</span> <span class="n">di_p1</span> <span class="o">&gt;</span> <span class="n">di_m1</span> <span class="c1"># if True: second shortest distance is at position m1 (m-1), so switch</span>
    <span class="n">d_1</span><span class="p">,</span> <span class="n">T_1</span><span class="p">,</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">v_1</span><span class="p">,</span> <span class="n">up_1</span><span class="p">,</span> <span class="n">vp_1</span><span class="p">,</span> <span class="n">upp_1</span><span class="p">,</span> <span class="n">vpp_1</span> <span class="o">=</span> <span class="n">di_0</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">TBB_0</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">uBB_0</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">vBB_0</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">upBB_0</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">vpBB_0</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">uppBB_0</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">vppBB_0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">d_2</span><span class="p">,</span> <span class="n">T_2</span><span class="p">,</span> <span class="n">u_2</span><span class="p">,</span> <span class="n">v_2</span><span class="p">,</span> <span class="n">up_2</span><span class="p">,</span> <span class="n">vp_2</span><span class="p">,</span> <span class="n">upp_2</span><span class="p">,</span> <span class="n">vpp_2</span> <span class="o">=</span> <span class="n">di_p1</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">TBB_p1</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">uBB_p1</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">vBB_p1</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">upBB_p1</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">vpBB_p1</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">uppBB_p1</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">vppBB_p1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">d_1</span><span class="p">[</span><span class="n">c_p1_m1</span><span class="p">],</span> <span class="n">d_2</span><span class="p">[</span><span class="n">c_p1_m1</span><span class="p">]</span> <span class="o">=</span> <span class="n">di_m1</span><span class="p">[</span><span class="n">c_p1_m1</span><span class="p">],</span> <span class="n">di_0</span><span class="p">[</span><span class="n">c_p1_m1</span><span class="p">]</span>
    <span class="n">T_1</span><span class="p">[</span><span class="n">c_p1_m1</span><span class="p">],</span> <span class="n">T_2</span><span class="p">[</span><span class="n">c_p1_m1</span><span class="p">]</span> <span class="o">=</span> <span class="n">TBB_m1</span><span class="p">[</span><span class="n">c_p1_m1</span><span class="p">],</span> <span class="n">TBB_0</span><span class="p">[</span><span class="n">c_p1_m1</span><span class="p">]</span>
    <span class="n">u_1</span><span class="p">[</span><span class="n">c_p1_m1</span><span class="p">],</span> <span class="n">u_2</span><span class="p">[</span><span class="n">c_p1_m1</span><span class="p">]</span> <span class="o">=</span> <span class="n">uBB_m1</span><span class="p">[</span><span class="n">c_p1_m1</span><span class="p">],</span> <span class="n">uBB_0</span><span class="p">[</span><span class="n">c_p1_m1</span><span class="p">]</span>
    <span class="n">v_1</span><span class="p">[</span><span class="n">c_p1_m1</span><span class="p">],</span> <span class="n">v_2</span><span class="p">[</span><span class="n">c_p1_m1</span><span class="p">]</span> <span class="o">=</span> <span class="n">vBB_m1</span><span class="p">[</span><span class="n">c_p1_m1</span><span class="p">],</span> <span class="n">vBB_0</span><span class="p">[</span><span class="n">c_p1_m1</span><span class="p">]</span>
    <span class="n">up_1</span><span class="p">[</span><span class="n">c_p1_m1</span><span class="p">],</span> <span class="n">up_2</span><span class="p">[</span><span class="n">c_p1_m1</span><span class="p">]</span> <span class="o">=</span> <span class="n">upBB_m1</span><span class="p">[</span><span class="n">c_p1_m1</span><span class="p">],</span> <span class="n">upBB_0</span><span class="p">[</span><span class="n">c_p1_m1</span><span class="p">]</span>
    <span class="n">vp_1</span><span class="p">[</span><span class="n">c_p1_m1</span><span class="p">],</span> <span class="n">vp_2</span><span class="p">[</span><span class="n">c_p1_m1</span><span class="p">]</span> <span class="o">=</span> <span class="n">vpBB_m1</span><span class="p">[</span><span class="n">c_p1_m1</span><span class="p">],</span> <span class="n">vpBB_0</span><span class="p">[</span><span class="n">c_p1_m1</span><span class="p">]</span>
    <span class="n">upp_1</span><span class="p">[</span><span class="n">c_p1_m1</span><span class="p">],</span> <span class="n">upp_2</span><span class="p">[</span><span class="n">c_p1_m1</span><span class="p">]</span> <span class="o">=</span> <span class="n">uppBB_m1</span><span class="p">[</span><span class="n">c_p1_m1</span><span class="p">],</span> <span class="n">uppBB_0</span><span class="p">[</span><span class="n">c_p1_m1</span><span class="p">]</span>
    <span class="n">vpp_1</span><span class="p">[</span><span class="n">c_p1_m1</span><span class="p">],</span> <span class="n">vpp_2</span><span class="p">[</span><span class="n">c_p1_m1</span><span class="p">]</span> <span class="o">=</span> <span class="n">vppBB_m1</span><span class="p">[</span><span class="n">c_p1_m1</span><span class="p">],</span> <span class="n">vppBB_0</span><span class="p">[</span><span class="n">c_p1_m1</span><span class="p">]</span>

    <span class="n">g_1</span><span class="p">,</span> <span class="n">g_2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">d_1</span> <span class="o">+</span> <span class="n">_CCT_AVOID_ZERO_DIV</span><span class="p">),</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">d_2</span> <span class="o">+</span> <span class="n">_CCT_AVOID_ZERO_DIV</span><span class="p">)</span>
    
    <span class="c1"># # Should be pre-calculated and stored in LUT:</span>
    <span class="c1"># _, u_1, v_1, up_1, vp_1, upp_1, vpp_1, _ = _get_uv_uvp_uvpp(T_1, uvwbar, wl, dl,  out = &#39;BB,BBp,BBpp&#39;)</span>
    <span class="c1"># _, u_2, v_2, up_2, vp_2, upp_2, vpp_2, _ = _get_uv_uvp_uvpp(T_2, uvwbar, wl, dl,  out = &#39;BB,BBp,BBpp&#39;)</span>
   
    <span class="n">e_1</span><span class="p">,</span> <span class="n">e_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">)</span><span class="o">*</span><span class="n">up_1</span> <span class="o">+</span> <span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">v_1</span><span class="p">)</span><span class="o">*</span><span class="n">vp_1</span><span class="p">,</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">)</span><span class="o">*</span><span class="n">up_2</span> <span class="o">+</span> <span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">v_2</span><span class="p">)</span><span class="o">*</span><span class="n">vp_2</span>
    <span class="n">gp_1</span><span class="p">,</span> <span class="n">gp_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">g_1</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">e_1</span><span class="p">,</span> <span class="p">(</span><span class="n">g_2</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">e_2</span> <span class="c1"># f**(-3/2) = (1/g**2)**(-3/2) = (g**2)**(3/2) = g**3</span>
    <span class="n">ep_1</span> <span class="o">=</span> <span class="o">-</span><span class="n">up_1</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">vp_1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">)</span><span class="o">*</span><span class="n">upp_1</span> <span class="o">+</span> <span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">v_1</span><span class="p">)</span><span class="o">*</span><span class="n">vpp_1</span>
    <span class="n">ep_2</span> <span class="o">=</span> <span class="o">-</span><span class="n">up_2</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">vp_2</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">)</span><span class="o">*</span><span class="n">upp_2</span> <span class="o">+</span> <span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">v_2</span><span class="p">)</span><span class="o">*</span><span class="n">vpp_2</span>
    <span class="n">q_1</span><span class="p">,</span> <span class="n">q_2</span> <span class="o">=</span> <span class="o">-</span><span class="n">gp_1</span><span class="o">*</span><span class="n">e_1</span> <span class="o">-</span> <span class="n">g_1</span><span class="o">*</span><span class="n">ep_1</span><span class="p">,</span> <span class="o">-</span><span class="n">gp_2</span><span class="o">*</span><span class="n">e_2</span> <span class="o">-</span> <span class="n">g_2</span><span class="o">*</span><span class="n">ep_2</span>

    <span class="n">hk</span> <span class="o">=</span> <span class="p">(</span><span class="n">T_2</span> <span class="o">-</span> <span class="n">T_1</span><span class="p">)</span> 
    <span class="n">Ak</span> <span class="o">=</span> <span class="p">(</span><span class="n">d_2</span> <span class="o">-</span> <span class="n">d_1</span><span class="p">)</span><span class="o">/</span><span class="n">hk</span> <span class="o">-</span> <span class="n">hk</span><span class="o">/</span><span class="mi">6</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_2</span> <span class="o">-</span> <span class="n">q_1</span><span class="p">)</span> <span class="c1"># Am, eq.7 </span>
    <span class="n">Bk</span> <span class="o">=</span> <span class="n">d_1</span> <span class="o">-</span> <span class="n">q_1</span><span class="o">*</span><span class="p">(</span><span class="n">hk</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">6</span>
    
    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">q_2</span> <span class="o">-</span> <span class="n">q_1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">hk</span><span class="p">)</span> 
    <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">q_1</span><span class="o">*</span><span class="n">T_2</span> <span class="o">-</span> <span class="n">q_2</span><span class="o">*</span><span class="n">T_1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">hk</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">q_2</span><span class="o">*</span><span class="n">T_1</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">q_1</span><span class="o">*</span><span class="n">T_2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">hk</span><span class="p">)</span> <span class="o">+</span> <span class="n">Ak</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">b</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="c1"># discriminant # avoid invalid value warning when taking the sqrt later on.</span>

    <span class="n">Txp_p</span><span class="p">,</span> <span class="n">Txp_m</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">+</span> <span class="p">(</span><span class="n">D</span><span class="o">**</span><span class="mf">0.5</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">-</span> <span class="p">(</span><span class="n">D</span><span class="o">**</span><span class="mf">0.5</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
    <span class="n">Spp_p</span> <span class="o">=</span>  <span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">Txp_p</span> <span class="o">+</span> <span class="n">b</span>  <span class="c1"># second deriv at Txp: check Spp(Topt) &gt; 0 !!</span>
    <span class="n">Txp</span> <span class="o">=</span> <span class="n">Txp_p</span> <span class="c1"># Spp(Topt) &gt; 0</span>
    <span class="n">Txp</span><span class="p">[</span><span class="n">Spp_p</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Txp_m</span><span class="p">[</span><span class="n">Spp_p</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Spp(Topt) &gt; 0</span>
    <span class="n">Txp_corr</span> <span class="o">=</span> <span class="n">Txp</span> <span class="o">*</span> <span class="n">f_corr</span> <span class="c1"># correction factor depends on the LUT !!!!! (0.99991 is for 1% Table I in paper, for smaller % correction factor is not needed)</span>
    <span class="n">Txp</span> <span class="o">=</span> <span class="n">Txp_corr</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">q_1</span><span class="o">*</span><span class="p">((</span><span class="n">T_2</span> <span class="o">-</span> <span class="n">Txp</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">6</span><span class="o">*</span><span class="n">hk</span><span class="p">)</span> <span class="o">+</span> <span class="n">q_2</span><span class="o">*</span><span class="p">((</span><span class="n">Txp</span> <span class="o">-</span> <span class="n">T_1</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">6</span><span class="o">*</span><span class="n">hk</span><span class="p">)</span> <span class="o">+</span> <span class="n">Ak</span><span class="o">*</span><span class="p">(</span><span class="n">Txp</span> <span class="o">-</span> <span class="n">T_1</span><span class="p">)</span> <span class="o">+</span> <span class="n">Bk</span> <span class="c1"># local approx of distance function </span>
    <span class="n">Duvxp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">vTx</span><span class="p">)</span> <span class="o">*</span> <span class="n">S</span>

    <span class="c1"># Select triangular (threshold=0), parabolic (threshold=inf) or </span>
    <span class="c1"># combined solution:</span>
    <span class="n">Tx</span><span class="p">,</span> <span class="n">Duvx</span> <span class="o">=</span> <span class="n">Txt</span><span class="p">,</span> <span class="n">Duvxt</span> 
    <span class="n">cnd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Duvx</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">duv_triangular_threshold</span>
    <span class="n">Tx</span><span class="p">[</span><span class="n">cnd</span><span class="p">],</span> <span class="n">Duvx</span><span class="p">[</span><span class="n">cnd</span><span class="p">]</span><span class="o">=</span> <span class="n">Txp</span><span class="p">[</span><span class="n">cnd</span><span class="p">],</span> <span class="n">Duvxp</span><span class="p">[</span><span class="n">cnd</span><span class="p">]</span>
            
    <span class="k">return</span> <span class="n">Tx</span><span class="p">,</span> <span class="n">Duvx</span><span class="p">,</span> <span class="n">out_of_lut</span><span class="p">,</span> <span class="p">(</span><span class="n">TBB_m1</span><span class="p">,</span><span class="n">TBB_p1</span><span class="p">)</span>


<span class="n">_CCT_UV_TO_TX_FCNS</span><span class="p">[</span><span class="s1">&#39;li2022&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">_uv_to_Tx_li2022</span>
    
<div class="viewcode-block" id="xyz_to_cct_li2022">
<a class="viewcode-back" href="../../../../color.html#luxpy.color.cct.xyz_to_cct_li2022">[docs]</a>
<span class="k">def</span> <span class="nf">xyz_to_cct_li2022</span><span class="p">(</span><span class="n">xyzw</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">_CIEOBS</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;cct&#39;</span><span class="p">,</span> <span class="n">is_uv_input</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                        <span class="n">atol</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="n">force_tolerance</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">tol_method</span> <span class="o">=</span> <span class="s1">&#39;newton-raphson&#39;</span><span class="p">,</span> 
                        <span class="n">lut_resolution_reduction_factor</span> <span class="o">=</span> <span class="n">_CCT_LUT_RESOLUTION_REDUCTION_FACTOR</span><span class="p">,</span>
                        <span class="n">duv_triangular_threshold</span> <span class="o">=</span> <span class="mf">0.002</span><span class="p">,</span>
                        <span class="n">split_calculation_at_N</span> <span class="o">=</span> <span class="n">_CCT_SPLIT_CALC_AT_N</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="n">_CCT_MAX_ITER</span><span class="p">,</span>
                        <span class="n">cspace</span> <span class="o">=</span> <span class="n">_CCT_CSPACE</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">_CCT_CSPACE_KWARGS</span><span class="p">,</span>
                        <span class="n">lut</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">luts_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ignore_wl_diff</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="n">use_fast_duv</span> <span class="o">=</span> <span class="n">_CCT_FAST_DUV</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert XYZ tristimulus values to correlated color temperature (CCT) and </span>
<span class="sd">    Duv (distance above (&gt;0) or below (&lt;0) the Planckian locus) </span>
<span class="sd">    using Li&#39;s 2022 update (proposal 2) of Ohno&#39;s 2014 method. </span>
<span class="sd">        </span>
<span class="sd">    Args:</span>
<span class="sd">        :xyzw: </span>
<span class="sd">            | ndarray of tristimulus values</span>
<span class="sd">        :cieobs: </span>
<span class="sd">            | luxpy._CIEOBS, optional</span>
<span class="sd">            | CMF set used to calculated xyzw.</span>
<span class="sd">        :out: </span>
<span class="sd">            | &#39;cct&#39; (or 1), optional</span>
<span class="sd">            | Determines what to return.</span>
<span class="sd">            | Other options: &#39;duv&#39; (or -1), &#39;cct,duv&#39;(or 2), &quot;[cct,duv]&quot; (or -2)</span>
<span class="sd">        :is_uv_input:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | If True: xyzw contain uv input data, not xyz data!</span>
<span class="sd">        :wl: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Wavelengths used when calculating Planckian radiators.</span>
<span class="sd">            | If None: use same wavelengths as CMFs in :cieobs:.</span>
<span class="sd">        :rtol: </span>
<span class="sd">            | 1e-5, float, optional</span>
<span class="sd">            | Stop search when cct a relative tolerance is reached.</span>
<span class="sd">            | The relative tolerance is calculated as dCCT/CCT_est, </span>
<span class="sd">            | with CCT_est the current intermediate estimate in the </span>
<span class="sd">            | search and with dCCT the difference between</span>
<span class="sd">            | the present and former estimates.</span>
<span class="sd">        :atol: </span>
<span class="sd">            | 0.1, optional</span>
<span class="sd">            | Stop search when cct a absolute tolerance (K) is reached.</span>
<span class="sd">        :force_tolerance:</span>
<span class="sd">            | True, optional</span>
<span class="sd">            | If False: search only using the list of CCTs in the used lut. </span>
<span class="sd">            |           Only one loop of the full algorithm is performed. </span>
<span class="sd">            |           Accuracy depends on CCT of test source and the location</span>
<span class="sd">            |           and spacing of the CCTs in the list.</span>
<span class="sd">            | If True:  search will use adjacent CCTs to test source to create a new LUT,</span>
<span class="sd">            |           (repeat the algoritm at higher resolution, progessively zooming in</span>
<span class="sd">            |            toward the ground-truth) for tol_method == &#39;cl&#39;; when </span>
<span class="sd">            |           tol_method == &#39;nr&#39; a newton-raphson method is used.</span>
<span class="sd">            |           Because the CCT for multiple source is calculated in one go,</span>
<span class="sd">            |           the atol and rtol values have to be met for all! </span>
<span class="sd">        :tol_method:</span>
<span class="sd">            | &#39;newton-raphson&#39;, optional</span>
<span class="sd">            | (Additional) method to try and achieve set tolerances. </span>
<span class="sd">            | Options: </span>
<span class="sd">            | - &#39;cl&#39;, &#39;cascading-lut&#39;: use increasingly higher CCT-resolution</span>
<span class="sd">            |       to &#39;zoom-in&#39; on the ground-truth.</span>
<span class="sd">            | - &#39;nr&#39;, &#39;newton-raphson&#39;: use the method as described in Li, 2016.</span>
<span class="sd">        :lut_resolution_reduction_factor:</span>
<span class="sd">            | _CCT_LUT_RESOLUTION_REDUCTION_FACTOR, optional</span>
<span class="sd">            | Number of times the interval spanned by the adjacent Tc in a search or lut</span>
<span class="sd">            | method is downsampled (the search process will then start again)</span>
<span class="sd">        :duv_triangular_threshold:</span>
<span class="sd">            | 0.002, optional</span>
<span class="sd">            | Threshold for use of the triangular solution </span>
<span class="sd">            |  (if smaller use triangular solution, else use the non-triangular (third order polynomial))</span>
<span class="sd">        :max_iter:</span>
<span class="sd">            | _CCT_MAX_ITER, optional</span>
<span class="sd">            | Maximum number of iterations used by the cascading-lut or newton-raphson methods.</span>
<span class="sd">        :split_calculation_at_N:</span>
<span class="sd">            | _CCT_SPLIT_CALC_AT_N, optional</span>
<span class="sd">            | Split calculation when xyzw.shape[0] &gt; split_calculation_at_N. </span>
<span class="sd">            | Splitting speeds up the calculation. If None: no splitting is done.</span>
<span class="sd">        :lut:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Look-Up-Table with Ti, u,v,u&#39;,v&#39;,u&quot;,v&quot;,slope values of Planckians. </span>
<span class="sd">            | Options:</span>
<span class="sd">            |  - None: defaults to the lut specified in _CCT_LUT[&#39;li2022&#39;][&#39;lut_type_def&#39;].</span>
<span class="sd">            |  - list (lut,lut_kwargs): use this pre-calculated lut </span>
<span class="sd">            |       (add additional kwargs for the lut_generator_fcn(), defaults to None if omitted)</span>
<span class="sd">            |  - tuple: must be key (label) in :luts_dict: (pre-calculated dict of luts),</span>
<span class="sd">            |           if not: then a new lut will be generated from scratch using the info in the tuple.</span>
<span class="sd">            |  - str: must be key (label) in :luts_dict: (pre-calculated dict of luts)</span>
<span class="sd">            |  - ndarray [Nx1]: list of luts for which to generate a lut</span>
<span class="sd">            |  - ndarray [Nxn] with n&gt;3: pre-calculated lut (last col must contain slope of the isotemperature lines).</span>
<span class="sd">        :luts_dict:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Dictionary of pre-calculated luts for various cspaces and cmf sets.</span>
<span class="sd">            |  Must have structure luts_dict[cspace][cieobs][lut_label] with the</span>
<span class="sd">            |   lut part of a two-element list [lut, lut_kwargs]. It must contain</span>
<span class="sd">            |   at the top-level a key &#39;wl&#39; containing the wavelengths of the </span>
<span class="sd">            |   Planckians used to generate the luts in this dictionary.</span>
<span class="sd">            | If None: luts_dict defaults to _CCT_LUT[&#39;li2022&#39;][&#39;luts&#39;]    </span>
<span class="sd">        :cspace:</span>
<span class="sd">            | _CCT_SPACE, optional</span>
<span class="sd">            | Color space to do calculations in. </span>
<span class="sd">            | Options: </span>
<span class="sd">            |    - cspace string: </span>
<span class="sd">            |        e.g. &#39;Yuv60&#39; for use with luxpy.colortf()</span>
<span class="sd">            |    - tuple with forward (i.e. xyz_to..) [and backward (i.e. ..to_xyz)] functions </span>
<span class="sd">            |      (and an optional string describing the cspace): </span>
<span class="sd">            |        e.g. (forward, backward) or (forward, backward, cspace string) or (forward, cspace string) </span>
<span class="sd">            |    - dict with keys: &#39;fwtf&#39; (foward), &#39;bwtf&#39; (backward) [, optional: &#39;str&#39; (cspace string)]</span>
<span class="sd">            |  Note: if the backward tf is not supplied, optimization in cct_to_xyz() is done in the CIE 1976 u&#39;v&#39; diagram</span>
<span class="sd">        :cspace_kwargs:</span>
<span class="sd">            | _CCT_CSPACE_KWARGS, optional</span>
<span class="sd">            | Parameter nested dictionary for the forward and backward transforms.</span>
<span class="sd">        :ignore_wl_diff:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | When getting a lut from the dictionary, if differences are</span>
<span class="sd">            | detected in the wavelengts of the lut and the ones used to calculate any</span>
<span class="sd">            | plankcians then a new lut should be generated. Seting this to True ignores</span>
<span class="sd">            | these differences and proceeds anyway.</span>
<span class="sd">        :use_fast_duv:</span>
<span class="sd">            | _CCT_FAST_DUV, optional</span>
<span class="sd">            | If True: use a fast estimator of the Duv </span>
<span class="sd">            |   (one that avoids calculation of Planckians and uses the former</span>
<span class="sd">            |    best estimate&#39;s u,v coordinates. This method is accurate enough</span>
<span class="sd">            |    when the atol is small enough -&gt; as long as abs(T-T_former)&lt;=1K</span>
<span class="sd">            |    the Duv estimate should be ok.)</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | ndarray with:</span>
<span class="sd">            |    cct: out == &#39;cct&#39; (or 1)</span>
<span class="sd">            |    duv: out == &#39;duv&#39; (or -1)</span>
<span class="sd">            |    cct, duv: out == &#39;cct,duv&#39; (or 2)</span>
<span class="sd">            |    [cct,duv]: out == &quot;[cct,duv]&quot; (or -2) </span>
<span class="sd">            </span>
<span class="sd">            </span>
<span class="sd">    Note: </span>
<span class="sd">        1. Out-of-lut CCTs are encoded as negative CCTs (with as absolute value</span>
<span class="sd">        the value of the closest CCT from the lut.)</span>
<span class="sd">    </span>
<span class="sd">    References:</span>
<span class="sd">        1. `Ohno Y. Practical use and calculation of CCT and Duv. </span>
<span class="sd">        Leukos. 2014 Jan 2;10(1):47-55.</span>
<span class="sd">        &lt;http://www.tandfonline.com/doi/abs/10.1080/15502724.2014.839020&gt;`_</span>
<span class="sd">         </span>
<span class="sd">        2. `Li, Y., Gao, C.,  Melgosa, M. and Li, C. (2022).</span>
<span class="sd">        Improved methods for computing CCT and Duv. </span>
<span class="sd">        LEUKOS, (in press). &lt;email://794962485@qq.com&gt;`_</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="k">return</span> <span class="n">_xyz_to_cct</span><span class="p">(</span><span class="n">xyzw</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;li2022&#39;</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> <span class="n">is_uv_input</span> <span class="o">=</span> <span class="n">is_uv_input</span><span class="p">,</span> 
                       <span class="n">cspace</span> <span class="o">=</span> <span class="n">cspace</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">cspace_kwargs</span><span class="p">,</span>
                       <span class="n">atol</span> <span class="o">=</span> <span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="n">rtol</span><span class="p">,</span> <span class="n">force_tolerance</span> <span class="o">=</span> <span class="n">force_tolerance</span><span class="p">,</span>
                       <span class="n">tol_method</span> <span class="o">=</span> <span class="n">tol_method</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span><span class="p">,</span>  
                       <span class="n">lut_resolution_reduction_factor</span> <span class="o">=</span> <span class="n">lut_resolution_reduction_factor</span><span class="p">,</span>
                       <span class="n">split_calculation_at_N</span> <span class="o">=</span> <span class="n">split_calculation_at_N</span><span class="p">,</span> 
                       <span class="n">lut</span> <span class="o">=</span> <span class="n">lut</span><span class="p">,</span> <span class="n">luts_dict</span> <span class="o">=</span> <span class="n">luts_dict</span><span class="p">,</span> 
                       <span class="n">ignore_wl_diff</span> <span class="o">=</span> <span class="n">ignore_wl_diff</span><span class="p">,</span> 
                       <span class="n">duv_triangular_threshold</span> <span class="o">=</span> <span class="n">duv_triangular_threshold</span><span class="p">,</span>
                       <span class="n">use_fast_duv</span> <span class="o">=</span> <span class="n">use_fast_duv</span><span class="p">,</span>
                       <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="c1"># pre-generate / load from disk / load from github some LUTs for Li2022:</span>
<span class="n">_initialize_lut</span><span class="p">(</span><span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;li2022&#39;</span><span class="p">,</span> <span class="n">lut_types</span> <span class="o">=</span> <span class="n">_unique_types</span><span class="p">([</span><span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;li2022&#39;</span><span class="p">][</span><span class="s1">&#39;lut_type_def&#39;</span><span class="p">],</span> <span class="p">((</span><span class="n">_CCT_LUT_MIN</span><span class="p">,</span> <span class="n">_CCT_LUT_MAX</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;%&#39;</span><span class="p">),)]</span> <span class="o">+</span> <span class="n">_CCT_SHARED_LUT_TYPES</span><span class="p">))</span>



<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># Li 2016:</span>
<span class="c1">#------------------------------------------------------------------------------</span>
<span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;li2016&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lut_vars&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;lut_type_def&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;luts&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span><span class="s1">&#39;_generate_lut&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">}</span>


<div class="viewcode-block" id="xyz_to_cct_li2016">
<a class="viewcode-back" href="../../../../color.html#luxpy.color.cct.xyz_to_cct_li2016">[docs]</a>
<span class="k">def</span> <span class="nf">xyz_to_cct_li2016</span><span class="p">(</span><span class="n">xyzw</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">_CIEOBS</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;cct&#39;</span><span class="p">,</span> <span class="n">is_uv_input</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                      <span class="n">atol</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="n">_CCT_MAX_ITER</span><span class="p">,</span> 
                      <span class="n">split_calculation_at_N</span> <span class="o">=</span> <span class="n">_CCT_SPLIT_CALC_AT_N</span><span class="p">,</span>
                      <span class="n">lut</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">luts_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ignore_wl_diff</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                      <span class="n">lut_resolution_reduction_factor</span> <span class="o">=</span> <span class="n">_CCT_LUT_RESOLUTION_REDUCTION_FACTOR</span><span class="p">,</span>
                      <span class="n">cspace</span> <span class="o">=</span> <span class="n">_CCT_CSPACE</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">_CCT_CSPACE_KWARGS</span><span class="p">,</span>
                      <span class="n">first_guess_mode</span> <span class="o">=</span> <span class="s1">&#39;robertson1968&#39;</span><span class="p">,</span> <span class="n">fgm_kwargs</span> <span class="o">=</span> <span class="p">{},</span> 
                      <span class="n">use_fast_duv</span> <span class="o">=</span> <span class="n">_CCT_FAST_DUV</span><span class="p">,</span>
                      <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert XYZ tristimulus values to correlated color temperature (CCT) and </span>
<span class="sd">    Duv(distance above (&gt; 0) or below ( &lt; 0) the Planckian locus) using the </span>
<span class="sd">    Newton-Raphson method described in Li et al. (2016).</span>
<span class="sd">        </span>
<span class="sd">    Args:</span>
<span class="sd">        :xyzw: </span>
<span class="sd">            | ndarray of tristimulus values</span>
<span class="sd">        :cieobs: </span>
<span class="sd">            | luxpy._CIEOBS, optional</span>
<span class="sd">            | CMF set used to calculated xyzw.</span>
<span class="sd">        :out: </span>
<span class="sd">            | &#39;cct&#39; (or 1), optional</span>
<span class="sd">            | Determines what to return.</span>
<span class="sd">            | Other options: &#39;duv&#39; (or -1), &#39;cct,duv&#39;(or 2), &quot;[cct,duv]&quot; (or -2)</span>
<span class="sd">        :is_uv_input:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | If True: xyzw contain uv input data, not xyz data!</span>
<span class="sd">        :wl: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Wavelengths used when calculating Planckian radiators.</span>
<span class="sd">            | If None: use same wavelengths as CMFs in :cieobs:.</span>
<span class="sd">        :rtol: </span>
<span class="sd">            | 1e-5, float, optional</span>
<span class="sd">            | Stop method when cct a relative tolerance is reached.</span>
<span class="sd">            | The relative tolerance is calculated as dCCT/CCT_est, </span>
<span class="sd">            | with CCT_est the current intermediate estimate in the </span>
<span class="sd">            | search and with dCCT the difference between</span>
<span class="sd">            | the present and former estimates.</span>
<span class="sd">        :atol: </span>
<span class="sd">            | 0.1, optional</span>
<span class="sd">            | Stop method when cct a absolute tolerance (K) is reached.</span>
<span class="sd">        :max_iter:</span>
<span class="sd">            | _CCT_MAX_ITER, optional</span>
<span class="sd">            | Maximum number of iterations used newton-raphson methods.</span>
<span class="sd">        :lut_resolution_reduction_factor:</span>
<span class="sd">            | _CCT_LUT_RESOLUTION_REDUCTION_FACTOR, optional</span>
<span class="sd">            | Number of times the interval spanned by the adjacent Tc in a search or lut</span>
<span class="sd">            | method is downsampled (the search process will then start again)</span>
<span class="sd">        :split_calculation_at_N:</span>
<span class="sd">            | _CCT_SPLIT_CALC_AT_N, optional</span>
<span class="sd">            | Split calculation when xyzw.shape[0] &gt; split_calculation_at_N. </span>
<span class="sd">            | Splitting speeds up the calculation. If None: no splitting is done.</span>
<span class="sd">        :lut:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Look-Up-Table with Ti, u,v,u&#39;,v&#39;,u&quot;,v&quot;,slope values of Planckians. </span>
<span class="sd">            | Options:</span>
<span class="sd">            |  - None: defaults to the lut specified in _CCT_LUT[first_guess_mode][&#39;lut_type_def&#39;].</span>
<span class="sd">            |  - list (lut,lut_kwargs): use this pre-calculated lut </span>
<span class="sd">            |       (add additional kwargs for the lut_generator_fcn(), defaults to None if omitted)</span>
<span class="sd">            |  - tuple: must be key (label) in :luts_dict: (pre-calculated dict of luts),</span>
<span class="sd">            |           if not: then a new lut will be generated from scratch using the info in the tuple.</span>
<span class="sd">            |  - str: must be key (label) in :luts_dict: (pre-calculated dict of luts)</span>
<span class="sd">            |  - ndarray [Nx1]: list of luts for which to generate a lut</span>
<span class="sd">            |  - ndarray [Nxn] with n&gt;3: pre-calculated lut (last col must contain slope of the isotemperature lines).</span>
<span class="sd">        :luts_dict:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Dictionary of pre-calculated luts for various cspaces and cmf sets.</span>
<span class="sd">            |  Must have structure luts_dict[cspace][cieobs][lut_label] with the</span>
<span class="sd">            |   lut part of a two-element list [lut, lut_kwargs]. It must contain</span>
<span class="sd">            |   at the top-level a key &#39;wl&#39; containing the wavelengths of the </span>
<span class="sd">            |   Planckians used to generate the luts in this dictionary.</span>
<span class="sd">            | If None: luts_dict defaults to _CCT_LUT[first_guess_mode][&#39;luts&#39;]    </span>
<span class="sd">        :cspace:</span>
<span class="sd">            | _CCT_SPACE, optional</span>
<span class="sd">            | Color space to do calculations in. </span>
<span class="sd">            | Options: </span>
<span class="sd">            |    - cspace string: </span>
<span class="sd">            |        e.g. &#39;Yuv60&#39; for use with luxpy.colortf()</span>
<span class="sd">            |    - tuple with forward (i.e. xyz_to..) [and backward (i.e. ..to_xyz)] functions </span>
<span class="sd">            |      (and an optional string describing the cspace): </span>
<span class="sd">            |        e.g. (forward, backward) or (forward, backward, cspace string) or (forward, cspace string) </span>
<span class="sd">            |    - dict with keys: &#39;fwtf&#39; (foward), &#39;bwtf&#39; (backward) [, optional: &#39;str&#39; (cspace string)]</span>
<span class="sd">            |  Note: if the backward tf is not supplied, optimization in cct_to_xyz() is done in the CIE 1976 u&#39;v&#39; diagram</span>
<span class="sd">        :cspace_kwargs:</span>
<span class="sd">            | _CCT_CSPACE_KWARGS, optional</span>
<span class="sd">            | Parameter nested dictionary for the forward and backward transforms.</span>
<span class="sd">        :ignore_wl_diff:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | When getting a lut from the dictionary, if differences are</span>
<span class="sd">            | detected in the wavelengts of the lut and the ones used to calculate any</span>
<span class="sd">            | plankcians then a new lut should be generated. Seting this to True ignores</span>
<span class="sd">            | these differences and proceeds anyway.</span>
<span class="sd">        :first_guess_mode:</span>
<span class="sd">            | &#39;robertson1968&#39;, optional</span>
<span class="sd">            | Method used to get an approximate (first guess) estimate of the cct,</span>
<span class="sd">            | after which the newton-raphson method is started.</span>
<span class="sd">            | Options: &#39;robertson1968&#39;, &#39;ohno2014&#39;, &#39;zhang2019&#39;</span>
<span class="sd">        :fgm_kwargs:</span>
<span class="sd">            | Dict with keyword arguments for the selected first_guess_mode.</span>
<span class="sd">        :use_fast_duv:</span>
<span class="sd">            | _CCT_FAST_DUV, optional</span>
<span class="sd">            | If True: use a fast estimator of the Duv </span>
<span class="sd">            |   (one that avoids calculation of Planckians and uses the former</span>
<span class="sd">            |    best estimate&#39;s u,v coordinates. This method is accurate enough</span>
<span class="sd">            |    when the atol is small enough -&gt; as long as abs(T-T_former)&lt;=1K</span>
<span class="sd">            |    the Duv estimate should be ok.)</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | ndarray with:</span>
<span class="sd">            |    cct: out == &#39;cct&#39; (or 1)</span>
<span class="sd">            |    duv: out == &#39;duv&#39; (or -1)</span>
<span class="sd">            |    cct, duv: out == &#39;cct,duv&#39; (or 2)</span>
<span class="sd">            |    [cct,duv]: out == &quot;[cct,duv]&quot; (or -2) </span>
<span class="sd">            </span>
<span class="sd">    Note: </span>
<span class="sd">        1. Out-of-lut (of first_guess_mode) CCTs are encoded as negative CCTs (with as absolute value</span>
<span class="sd">        the value of the closest CCT from the lut.)</span>
<span class="sd">    </span>
<span class="sd">    References:</span>
<span class="sd">        1. `Li, C., Cui, G., Melgosa, M., Ruan, X., Zhang, Y., Ma, L., Xiao, K., &amp; Luo, M. R. (2016).</span>
<span class="sd">        Accurate method for computing correlated color temperature. </span>
<span class="sd">        Optics Express, 24(13), 14066–14078. </span>
<span class="sd">        &lt;https://doi.org/10.1364/OE.24.014066&gt;`_</span>
<span class="sd">        </span>
<span class="sd">        2.  `Robertson, A. R. (1968). </span>
<span class="sd">        Computation of Correlated Color Temperature and Distribution Temperature. </span>
<span class="sd">        Journal of the Optical Society of America,  58(11), 1528–1535. </span>
<span class="sd">        &lt;https://doi.org/10.1364/JOSA.58.001528&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>  
    <span class="k">return</span> <span class="n">_xyz_to_cct</span><span class="p">(</span><span class="n">xyzw</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;li2016&#39;</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">,</span> 
                       <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> <span class="n">is_uv_input</span> <span class="o">=</span> <span class="n">is_uv_input</span><span class="p">,</span> 
                       <span class="n">cspace</span> <span class="o">=</span> <span class="n">cspace</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">cspace_kwargs</span><span class="p">,</span>
                       <span class="n">atol</span> <span class="o">=</span> <span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="n">rtol</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span><span class="p">,</span>  
                       <span class="n">lut_resolution_reduction_factor</span> <span class="o">=</span> <span class="n">lut_resolution_reduction_factor</span><span class="p">,</span>
                       <span class="n">split_calculation_at_N</span> <span class="o">=</span> <span class="n">split_calculation_at_N</span><span class="p">,</span> 
                       <span class="n">lut</span> <span class="o">=</span> <span class="n">lut</span><span class="p">,</span> <span class="n">luts_dict</span> <span class="o">=</span> <span class="n">luts_dict</span><span class="p">,</span> 
                       <span class="n">ignore_wl_diff</span> <span class="o">=</span> <span class="n">ignore_wl_diff</span><span class="p">,</span> 
                       <span class="n">first_guess_mode</span> <span class="o">=</span> <span class="n">first_guess_mode</span><span class="p">,</span>
                       <span class="n">use_fast_duv</span> <span class="o">=</span> <span class="n">use_fast_duv</span><span class="p">,</span>
                       <span class="o">**</span><span class="p">{</span><span class="o">**</span><span class="n">fgm_kwargs</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">})</span></div>


<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># Fibonacci search on lut:</span>
<span class="c1">#------------------------------------------------------------------------------</span>
<span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;fibonacci&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span> 
<span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;fibonacci&#39;</span><span class="p">][</span><span class="s1">&#39;lut_type_def&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">_CCT_LUT_MIN</span><span class="p">,</span><span class="n">_CCT_LUT_MAX</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="s1">&#39;K&#39;</span><span class="p">),)</span>
<span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;fibonacci&#39;</span><span class="p">][</span><span class="s1">&#39;lut_vars&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;uv&#39;</span><span class="p">]</span> <span class="c1"># with &#39;uv&#39; is faster than calculating the BB on the spot !</span>
<span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;fibonacci&#39;</span><span class="p">][</span><span class="s1">&#39;_generate_lut&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_generate_lut</span> 

    
<span class="k">def</span> <span class="nf">_fib_poly</span><span class="p">(</span><span class="n">a</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">d</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
        <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="n">t</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">:</span>
        <span class="n">n</span><span class="o">+=</span><span class="mi">1</span>
        <span class="n">f</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">n</span> 



<span class="k">def</span> <span class="nf">_uv_to_Tx_fibonacci</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">lut</span><span class="p">,</span> <span class="n">lut_n_cols</span><span class="p">,</span> <span class="n">ns</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out_of_lut</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                        <span class="n">max_iter</span> <span class="o">=</span> <span class="n">_CCT_MAX_ITER</span><span class="p">,</span> <span class="n">uvwbar</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                        <span class="n">atol</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="n">lut_vars</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;uv&#39;</span><span class="p">],</span>
                        <span class="n">fast_duv</span> <span class="o">=</span> <span class="n">_CCT_FAST_DUV</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Calculate Tx from u,v and lut using a fibonacci search of the lut.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get uBB, vBB from lut:</span>
    <span class="n">TBB</span> <span class="o">=</span> <span class="n">lut</span><span class="p">[:,</span><span class="mi">0</span><span class="p">::</span><span class="n">lut_n_cols</span><span class="p">]</span>
    <span class="k">if</span> <span class="s1">&#39;uv&#39;</span> <span class="ow">in</span> <span class="n">lut_vars</span><span class="p">:</span> 
        <span class="n">uBB</span><span class="p">,</span> <span class="n">vBB</span>  <span class="o">=</span> <span class="n">lut</span><span class="p">[:,</span><span class="mi">1</span><span class="p">::</span><span class="n">lut_n_cols</span><span class="p">],</span> <span class="n">lut</span><span class="p">[:,</span><span class="mi">2</span><span class="p">::</span><span class="n">lut_n_cols</span><span class="p">]</span> 
    
    <span class="k">def</span> <span class="nf">dsq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(((</span><span class="n">u</span> <span class="o">-</span> <span class="n">uBB</span><span class="p">[</span><span class="n">x</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">vBB</span><span class="p">[</span><span class="n">x</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(((</span><span class="n">u</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="n">uBB</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">c</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="n">vBB</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">c</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    
    
    <span class="c1"># get list of fibonacci nrs:</span>
    <span class="n">fib</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">_fib_poly</span><span class="p">(</span><span class="n">d</span> <span class="o">=</span> <span class="n">TBB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="n">fib_p</span> <span class="o">=</span> <span class="p">[</span><span class="n">fib</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="n">fib</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]]</span>
    
    <span class="n">tail</span> <span class="o">=</span> <span class="n">TBB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
    
    <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">*</span><span class="n">tail</span><span class="c1">#fib[-1]</span>
    <span class="n">dsql</span> <span class="o">=</span> <span class="n">dsq</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
    <span class="n">dsqr</span> <span class="o">=</span> <span class="n">dsq</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
    
    <span class="n">a</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="n">fib_p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dsqa</span> <span class="o">=</span> <span class="n">dsq</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    
    <span class="n">b</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="n">fib_p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">dsqb</span> <span class="o">=</span> <span class="n">dsq</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">iptr</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span> 
    <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">iptr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fib</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span> 
        <span class="n">iptr</span> <span class="o">-=</span> <span class="mi">1</span>
        
        <span class="n">fib_p</span> <span class="o">=</span> <span class="p">[</span><span class="n">fib</span><span class="p">[</span><span class="n">iptr</span><span class="p">],</span> <span class="n">fib</span><span class="p">[</span><span class="n">iptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>

        <span class="c1"># Make search range (l,b):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">dsqa</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">dsqb</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># dsqa &lt;= dsqb </span>
        <span class="n">right</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
        <span class="n">b</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
        <span class="n">dsqr</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">dsqb</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
        <span class="n">dsqb</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">dsqa</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
        <span class="n">a</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">left</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="n">fib_p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Check for a walking off the end.</span>
        <span class="c1"># AND if it does keep it to the left of b.        </span>
        <span class="n">c_e</span> <span class="o">=</span> <span class="n">a</span><span class="o">&gt;</span><span class="n">tail</span>
        <span class="n">a</span><span class="p">[</span><span class="n">c</span> <span class="o">&amp;</span> <span class="n">c_e</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">c</span> <span class="o">&amp;</span> <span class="n">c_e</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="n">dsqa</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">dsq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

        <span class="c1"># Make search range (a,r):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="o">~</span><span class="n">c</span> 
        <span class="n">left</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
        <span class="n">a</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
        <span class="n">dsql</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">dsqa</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
        <span class="n">dsqa</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">dsqb</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
        <span class="n">b</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">left</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="n">fib_p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Check for a walking off the end.</span>
        <span class="n">c_e</span> <span class="o">=</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="n">tail</span>
        <span class="n">b</span><span class="p">[</span><span class="n">c_e</span><span class="p">]</span> <span class="o">=</span> <span class="n">tail</span>
        <span class="n">dsqb</span><span class="p">[</span><span class="n">c</span> <span class="o">&amp;</span> <span class="n">c_e</span><span class="p">]</span> <span class="o">=</span> <span class="n">dsqr</span><span class="p">[</span><span class="n">c</span> <span class="o">&amp;</span> <span class="n">c_e</span><span class="p">]</span>

        <span class="n">dsqb</span><span class="p">[</span><span class="n">c</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">c_e</span><span class="p">]</span> <span class="o">=</span> <span class="n">dsq</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="n">c</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">c_e</span><span class="p">))</span>

               
    <span class="c1"># Get Tx, Tx_min, Tx_max, ux, vx, ...</span>
    <span class="n">Tx</span> <span class="o">=</span> <span class="n">TBB</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>     
    <span class="k">if</span> <span class="n">fast_duv</span><span class="p">:</span> 
        <span class="n">ux</span> <span class="o">=</span> <span class="n">uBB</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
        <span class="n">vx</span> <span class="o">=</span> <span class="n">vBB</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
    <span class="n">Tx_min</span> <span class="o">=</span> <span class="n">TBB</span><span class="p">[</span><span class="n">left</span><span class="p">]</span>
    <span class="n">Tx_max</span> <span class="o">=</span> <span class="n">TBB</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
    <span class="c1"># closest_index = a#.copy()</span>
    
    <span class="n">c</span> <span class="o">=</span> <span class="n">dsqa</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">dsqb</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Tx</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">TBB</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="n">c</span><span class="p">]]</span>
    <span class="k">if</span> <span class="n">fast_duv</span><span class="p">:</span> 
        <span class="n">ux</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">uBB</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="n">c</span><span class="p">]]</span>
        <span class="n">vx</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">vBB</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="n">c</span><span class="p">]]</span>
    <span class="n">Tx_min</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">TBB</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">c</span><span class="p">]]</span>
    <span class="n">Tx_max</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">TBB</span><span class="p">[</span><span class="n">right</span><span class="p">[</span><span class="n">c</span><span class="p">]]</span>
    <span class="c1"># closest_index[c] = b[c]</span>
        
        <span class="c1"># dTx = np.round(np.abs(Tx_max - Tx_min),11)</span>
    
        <span class="c1"># if (((dTx &lt;= atol).all() | ((dTx/Tx) &lt;= rtol).all())):</span>
        <span class="c1">#     break</span>
        

    <span class="k">if</span> <span class="n">fast_duv</span><span class="p">:</span>
        <span class="n">Duvx</span> <span class="o">=</span> <span class="n">_get_Duv_for_T_from_uvBB</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">ux</span><span class="p">,</span> <span class="n">vx</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Duvx</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">if</span> <span class="n">out_of_lut</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
        <span class="n">closest_endpoint</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Tx</span> <span class="o">-</span> <span class="n">TBB</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Tx</span> <span class="o">-</span> <span class="n">TBB</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])))</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">TBB_closest_end</span> <span class="o">=</span> <span class="n">TBB</span><span class="p">[</span><span class="n">closest_endpoint</span><span class="p">]</span>
        <span class="n">out_of_lut</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Tx</span> <span class="o">-</span> <span class="n">TBB_closest_end</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">TBB_closest_end</span> <span class="o">-</span> <span class="n">TBB</span><span class="p">[</span><span class="n">closest_endpoint</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">closest_endpoint</span><span class="o">==</span><span class="mi">0</span><span class="p">)]))</span>

    <span class="k">return</span> <span class="n">Tx</span><span class="p">,</span> <span class="n">Duvx</span><span class="p">,</span> <span class="n">out_of_lut</span><span class="p">,</span> <span class="p">(</span><span class="n">Tx_min</span><span class="p">,</span><span class="n">Tx_max</span><span class="p">)</span>

<span class="n">_CCT_UV_TO_TX_FCNS</span><span class="p">[</span><span class="s1">&#39;fibonacci&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_uv_to_Tx_fibonacci</span>

<div class="viewcode-block" id="xyz_to_cct_fibonacci">
<a class="viewcode-back" href="../../../../color.html#luxpy.color.cct.xyz_to_cct_fibonacci">[docs]</a>
<span class="k">def</span> <span class="nf">xyz_to_cct_fibonacci</span><span class="p">(</span><span class="n">xyzw</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">_CIEOBS</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;cct&#39;</span><span class="p">,</span> <span class="n">is_uv_input</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                        <span class="n">atol</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="n">force_tolerance</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">tol_method</span> <span class="o">=</span> <span class="s1">&#39;newton-raphson&#39;</span><span class="p">,</span> 
                        <span class="n">lut_resolution_reduction_factor</span> <span class="o">=</span> <span class="n">_CCT_LUT_RESOLUTION_REDUCTION_FACTOR</span><span class="p">,</span>
                        <span class="n">split_calculation_at_N</span> <span class="o">=</span> <span class="n">_CCT_SPLIT_CALC_AT_N</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="n">_CCT_MAX_ITER</span><span class="p">,</span>
                        <span class="n">cspace</span> <span class="o">=</span> <span class="n">_CCT_CSPACE</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">_CCT_CSPACE_KWARGS</span><span class="p">,</span>
                        <span class="n">lut</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">luts_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ignore_wl_diff</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="n">use_fast_duv</span> <span class="o">=</span> <span class="n">_CCT_FAST_DUV</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert XYZ tristimulus values to correlated color temperature (CCT) and </span>
<span class="sd">    Duv(distance above (&gt; 0) or below ( &lt; 0) the Planckian locus) using a </span>
<span class="sd">    Fibonacci search.</span>
<span class="sd">        </span>
<span class="sd">    Args:</span>
<span class="sd">        :xyzw: </span>
<span class="sd">            | ndarray of tristimulus values</span>
<span class="sd">        :cieobs: </span>
<span class="sd">            | luxpy._CIEOBS, optional</span>
<span class="sd">            | CMF set used to calculated xyzw.</span>
<span class="sd">        :out: </span>
<span class="sd">            | &#39;cct&#39; (or 1), optional</span>
<span class="sd">            | Determines what to return.</span>
<span class="sd">            | Other options: &#39;duv&#39; (or -1), &#39;cct,duv&#39;(or 2), &quot;[cct,duv]&quot; (or -2)</span>
<span class="sd">        :is_uv_input:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | If True: xyzw contain uv input data, not xyz data!</span>
<span class="sd">        :wl: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Wavelengths used when calculating Planckian radiators.</span>
<span class="sd">            | If None: use same wavelengths as CMFs in :cieobs:.</span>
<span class="sd">        :rtol: </span>
<span class="sd">            | 1e-5, float, optional</span>
<span class="sd">            | Stop search when cct a relative tolerance is reached.</span>
<span class="sd">            | The relative tolerance is calculated as dCCT/CCT_est, </span>
<span class="sd">            | with CCT_est the current intermediate estimate in the </span>
<span class="sd">            | search and with dCCT the difference between</span>
<span class="sd">            | the present and former estimates.</span>
<span class="sd">        :atol: </span>
<span class="sd">            | 0.1, optional</span>
<span class="sd">            | Stop search when cct a absolute tolerance (K) is reached.</span>
<span class="sd">        :force_tolerance:</span>
<span class="sd">            | True, optional</span>
<span class="sd">            | If False: search only using the list of CCTs in the used lut.</span>
<span class="sd">            |           Only one loop of the full algorithm is performed. </span>
<span class="sd">            |           Accuracy depends on CCT of test source and the location</span>
<span class="sd">            |           and spacing of the CCTs in the list.</span>
<span class="sd">            | If True:  search will use adjacent CCTs to test source to create a new LUT,</span>
<span class="sd">            |           (repeat the algoritm at higher resolution, progessively zooming in</span>
<span class="sd">            |            toward the ground-truth) for tol_method == &#39;cl&#39;; when </span>
<span class="sd">            |           tol_method == &#39;nr&#39; a newton-raphson method is used.</span>
<span class="sd">            |           Because the CCT for multiple source is calculated in one go,</span>
<span class="sd">            |           the atol and rtol values have to be met for all! </span>
<span class="sd">        :tol_method:</span>
<span class="sd">            | &#39;newton-raphson&#39;, optional</span>
<span class="sd">            | (Additional) method to try and achieve set tolerances. </span>
<span class="sd">            | Options: </span>
<span class="sd">            | - &#39;cl&#39;, &#39;cascading-lut&#39;: use increasingly higher CCT-resolution</span>
<span class="sd">            |       to &#39;zoom-in&#39; on the ground-truth.</span>
<span class="sd">            | - &#39;nr&#39;, &#39;newton-raphson&#39;: use the method as described in Li, 2016.</span>
<span class="sd">        :lut_resolution_reduction_factor:</span>
<span class="sd">            | _CCT_LUT_RESOLUTION_REDUCTION_FACTOR, optional</span>
<span class="sd">            | Number of times the interval spanned by the adjacent Tc in a search or lut</span>
<span class="sd">            | method is downsampled (the search process will then start again)</span>
<span class="sd">        :max_iter:</span>
<span class="sd">            | _CCT_MAX_ITER, optional</span>
<span class="sd">            | Maximum number of iterations used by the cascading-lut or newton-raphson methods.</span>
<span class="sd">        :split_calculation_at_N:</span>
<span class="sd">            | _CCT_SPLIT_CALC_AT_N, optional</span>
<span class="sd">            | Split calculation when xyzw.shape[0] &gt; split_calculation_at_N. </span>
<span class="sd">            | Splitting speeds up the calculation. If None: no splitting is done.</span>
<span class="sd">        :lut:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Look-Up-Table with Ti, u,v,u&#39;,v&#39;,u&quot;,v&quot;,slope values of Planckians. </span>
<span class="sd">            | Options:</span>
<span class="sd">            |  - None: defaults to the lut specified in _CCT_LUT[&#39;fibonacci&#39;][&#39;lut_type_def&#39;].</span>
<span class="sd">            |  - list (lut,lut_kwargs): use this pre-calculated lut </span>
<span class="sd">            |       (add additional kwargs for the lut_generator_fcn(), defaults to None if omitted)</span>
<span class="sd">            |  - tuple: must be key (label) in :luts_dict: (pre-calculated dict of luts),</span>
<span class="sd">            |           if not: then a new lut will be generated from scratch using the info in the tuple.</span>
<span class="sd">            |  - str: must be key (label) in :luts_dict: (pre-calculated dict of luts)</span>
<span class="sd">            |  - ndarray [Nx1]: list of luts for which to generate a lut</span>
<span class="sd">            |  - ndarray [Nxn] with n&gt;3: pre-calculated lut (last col must contain slope of the isotemperature lines).</span>
<span class="sd">        :luts_dict:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Dictionary of pre-calculated luts for various cspaces and cmf sets.</span>
<span class="sd">            |  Must have structure luts_dict[cspace][cieobs][lut_label] with the</span>
<span class="sd">            |   lut part of a two-element list [lut, lut_kwargs]. It must contain</span>
<span class="sd">            |   at the top-level a key &#39;wl&#39; containing the wavelengths of the </span>
<span class="sd">            |   Planckians used to generate the luts in this dictionary.</span>
<span class="sd">            | If None: luts_dict defaults to _CCT_LUT[&#39;fibonacci&#39;][&#39;luts&#39;]    </span>
<span class="sd">        :cspace:</span>
<span class="sd">            | _CCT_SPACE, optional</span>
<span class="sd">            | Color space to do calculations in. </span>
<span class="sd">            | Options: </span>
<span class="sd">            |    - cspace string: </span>
<span class="sd">            |        e.g. &#39;Yuv60&#39; for use with luxpy.colortf()</span>
<span class="sd">            |    - tuple with forward (i.e. xyz_to..) [and backward (i.e. ..to_xyz)] functions </span>
<span class="sd">            |      (and an optional string describing the cspace): </span>
<span class="sd">            |        e.g. (forward, backward) or (forward, backward, cspace string) or (forward, cspace string) </span>
<span class="sd">            |    - dict with keys: &#39;fwtf&#39; (foward), &#39;bwtf&#39; (backward) [, optional: &#39;str&#39; (cspace string)]</span>
<span class="sd">            |  Note: if the backward tf is not supplied, optimization in cct_to_xyz() is done in the CIE 1976 u&#39;v&#39; diagram</span>
<span class="sd">        :cspace_kwargs:</span>
<span class="sd">            | _CCT_CSPACE_KWARGS, optional</span>
<span class="sd">            | Parameter nested dictionary for the forward and backward transforms.</span>
<span class="sd">        :ignore_wl_diff:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | When getting a lut from the dictionary, if differences are</span>
<span class="sd">            | detected in the wavelengts of the lut and the ones used to calculate any</span>
<span class="sd">            | plankcians then a new lut should be generated. Seting this to True ignores</span>
<span class="sd">            | these differences and proceeds anyway.</span>
<span class="sd">        :use_fast_duv:</span>
<span class="sd">            | _CCT_FAST_DUV, optional</span>
<span class="sd">            | If True: use a fast estimator of the Duv </span>
<span class="sd">            |   (one that avoids calculation of Planckians and uses the former</span>
<span class="sd">            |    best estimate&#39;s u,v coordinates. This method is accurate enough</span>
<span class="sd">            |    when the atol is small enough -&gt; as long as abs(T-T_former)&lt;=1K</span>
<span class="sd">            |    the Duv estimate should be ok.)</span>

<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | ndarray with:</span>
<span class="sd">            |    cct: out == &#39;cct&#39; (or 1)</span>
<span class="sd">            |    duv: out == &#39;duv&#39; (or -1)</span>
<span class="sd">            |    cct, duv: out == &#39;cct,duv&#39; (or 2)</span>
<span class="sd">            |    [cct,duv]: out == &quot;[cct,duv]&quot; (or -2) </span>
<span class="sd">            </span>
<span class="sd">    Note: </span>
<span class="sd">        1. Out-of-lut CCTs (or close to) are encoded as negative CCTs (with as absolute value</span>
<span class="sd">        the value of the closest CCT from the lut.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="s1">&#39;luts&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;fibonacci&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Initializing (generate or download) Fibonacci LUTs on first use.&#39;</span><span class="p">)</span>
        <span class="n">init_fibonacci</span><span class="p">()</span> <span class="c1"># initialize LUTs for fibonacci</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">_xyz_to_cct</span><span class="p">(</span><span class="n">xyzw</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;fibonacci&#39;</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> <span class="n">is_uv_input</span> <span class="o">=</span> <span class="n">is_uv_input</span><span class="p">,</span> 
                       <span class="n">cspace</span> <span class="o">=</span> <span class="n">cspace</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">cspace_kwargs</span><span class="p">,</span>
                       <span class="n">atol</span> <span class="o">=</span> <span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="n">rtol</span><span class="p">,</span> <span class="n">force_tolerance</span> <span class="o">=</span> <span class="n">force_tolerance</span><span class="p">,</span>
                       <span class="n">tol_method</span> <span class="o">=</span> <span class="n">tol_method</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span><span class="p">,</span>  
                       <span class="n">lut_resolution_reduction_factor</span> <span class="o">=</span> <span class="n">lut_resolution_reduction_factor</span><span class="p">,</span>
                       <span class="n">split_calculation_at_N</span> <span class="o">=</span> <span class="n">split_calculation_at_N</span><span class="p">,</span> 
                       <span class="n">lut</span> <span class="o">=</span> <span class="n">lut</span><span class="p">,</span> <span class="n">luts_dict</span> <span class="o">=</span> <span class="n">luts_dict</span><span class="p">,</span> 
                       <span class="n">ignore_wl_diff</span> <span class="o">=</span> <span class="n">ignore_wl_diff</span><span class="p">,</span>
                       <span class="n">use_fast_duv</span> <span class="o">=</span> <span class="n">use_fast_duv</span><span class="p">,</span>
                       <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="c1"># pre-generate / load from disk / load from github some LUTs for fibonacci based search:</span>
<span class="c1"># BUT: only when its pkl file exists or when _CCT_LUT_CAL is True, otherwise let user init(download the LUT manually)!!</span>
<span class="k">def</span> <span class="nf">init_fibonacci</span><span class="p">(</span><span class="n">force_calc</span> <span class="o">=</span> <span class="n">_CCT_LUT_CALC</span><span class="p">):</span>
    <span class="n">_initialize_lut</span><span class="p">(</span><span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;fibonacci&#39;</span><span class="p">,</span> <span class="n">force_calc</span> <span class="o">=</span> <span class="n">force_calc</span><span class="p">,</span> <span class="n">lut_types</span> <span class="o">=</span> <span class="n">_unique_types</span><span class="p">([</span><span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;fibonacci&#39;</span><span class="p">][</span><span class="s1">&#39;lut_type_def&#39;</span><span class="p">]]</span> <span class="o">+</span> <span class="n">_CCT_SHARED_LUT_TYPES</span><span class="p">))</span>
<span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_CCT_LUT_PATH</span><span class="p">,</span><span class="s1">&#39;</span><span class="si">{:s}</span><span class="s1">_luts.pkl&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;fibonacci&#39;</span><span class="p">)))</span> <span class="o">|</span> <span class="p">(</span><span class="n">_CCT_LUT_CALC</span><span class="p">):</span>
    <span class="n">init_fibonacci</span><span class="p">(</span><span class="n">force_calc</span> <span class="o">=</span> <span class="n">_CCT_LUT_CALC</span><span class="p">)</span> 
    
<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># none method:</span>
<span class="c1">#------------------------------------------------------------------------------</span>
<span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;none&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;none&#39;</span><span class="p">][</span><span class="s1">&#39;lut_type_def&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">_CCT_LUT_MIN</span><span class="p">,</span> <span class="n">_CCT_LUT_MAX</span><span class="p">,</span> <span class="mf">0.50</span><span class="p">,</span> <span class="s1">&#39;%&#39;</span><span class="p">),)</span> <span class="c1"># default LUT</span>
<span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;none&#39;</span><span class="p">][</span><span class="s1">&#39;lut_vars&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;uv&#39;</span><span class="p">]</span>
<span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;none&#39;</span><span class="p">][</span><span class="s1">&#39;_generate_lut&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_generate_lut</span> 

<span class="k">def</span> <span class="nf">_uv_to_Tx_none</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">lut</span><span class="p">,</span> <span class="n">lut_n_cols</span><span class="p">,</span> <span class="n">ns</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out_of_lut</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Basically, do (almost) nothing to test common code in _xyz_to_cct.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Tx</span><span class="p">,</span> <span class="n">Duvx</span> <span class="o">=</span> <span class="mf">5000.31415</span><span class="p">,</span> <span class="mf">0.0</span> <span class="c1"># set Duv to something different from None (this way Duv is not calculated later one)</span>
    <span class="n">ones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">out_of_lut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Tx</span><span class="o">*</span><span class="n">ones</span><span class="p">,</span> <span class="n">Duvx</span><span class="p">,</span> <span class="n">out_of_lut</span><span class="p">,</span> <span class="p">((</span><span class="n">Tx</span><span class="o">-</span><span class="mi">100</span><span class="p">)</span><span class="o">*</span><span class="n">ones</span><span class="p">,</span> <span class="p">(</span><span class="n">Tx</span><span class="o">+</span><span class="mi">100</span><span class="p">)</span><span class="o">*</span><span class="n">ones</span><span class="p">)</span>

<span class="n">_CCT_UV_TO_TX_FCNS</span><span class="p">[</span><span class="s1">&#39;none&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_uv_to_Tx_none</span>

<span class="k">if</span> <span class="p">(</span><span class="s1">&#39;robertson1968&#39;</span> <span class="ow">in</span> <span class="n">_CCT_LIST_OF_MODE_LUTS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_CCT_LUT_ONE_NPY_PER_MODE</span><span class="p">:</span>
    <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;none&#39;</span><span class="p">][</span><span class="s1">&#39;luts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;robertson1968&#39;</span><span class="p">][</span><span class="s1">&#39;luts&#39;</span><span class="p">])</span>
    

<span class="k">if</span> <span class="n">_CCT_LUT_ONE_NPY_PER_MODE</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
    <span class="c1">#------------------------------------------------------------------------------</span>
    <span class="c1"># Generate luts for all modes </span>
    <span class="c1"># (this takes up more memory due to 8-column luts, than only using the </span>
    <span class="c1">#  desired luts for each mode, if shared luts of 3 columns is more than 8/3 </span>
    <span class="c1">#  than it makes sense to use a single lut dict for all. With the 0.1 K lut</span>
    <span class="c1"># the shared approach results in a npy file of around 60 Mb for 4 cieobs,</span>
    <span class="c1"># while using the 0.1 K LUT only where needed, i.e. Fibonaci, the npy files</span>
    <span class="c1"># together are only around 23 Mb, only very large for Fibonacci. Additional</span>
    <span class="c1"># advantage of separating the luts for each mode is that the Fibonacci could</span>
    <span class="c1"># excluded from the luxpy distribution and downloaded when needed.)</span>
    <span class="c1">#-----------------------------------------------------------------------------------------------------------------------------</span>
    <span class="c1"># Generate 1 lut dictionary for all modes </span>
    <span class="c1"># (later copy and adjust as needed on a mode per mode basis)</span>
    <span class="c1"># (reduce memory and storage consumption and speed up re-calculation of luts):</span>
    <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;all_modes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;all_modes&#39;</span><span class="p">][</span><span class="s1">&#39;lut_type_def&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">_CCT_LUT_MIN</span><span class="p">,</span> <span class="n">_CCT_LUT_MAX</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;%&#39;</span><span class="p">),)</span> <span class="c1"># default LUT</span>
    <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;all_modes&#39;</span><span class="p">][</span><span class="s1">&#39;lut_vars&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="s1">&#39;uv&#39;</span><span class="p">,</span><span class="s1">&#39;uvp&#39;</span><span class="p">,</span><span class="s1">&#39;uvpp&#39;</span><span class="p">,</span><span class="s1">&#39;iso-T-slope&#39;</span><span class="p">]</span>
    <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;all_modes&#39;</span><span class="p">][</span><span class="s1">&#39;_generate_lut&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_generate_lut</span> 
    
    <span class="n">all_modes_luts_exist</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_CCT_LUT_PATH</span><span class="p">,</span><span class="s1">&#39;all_modes_luts.pkl&#39;</span><span class="p">))</span>
    <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;all_modes&#39;</span><span class="p">][</span><span class="s1">&#39;luts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">generate_luts</span><span class="p">(</span><span class="n">types</span> <span class="o">=</span> <span class="n">_unique_types</span><span class="p">([</span><span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;all_modes&#39;</span><span class="p">][</span><span class="s1">&#39;lut_type_def&#39;</span><span class="p">]]</span> <span class="o">+</span> <span class="n">_CCT_SHARED_LUT_TYPES</span><span class="p">),</span>
                                                  <span class="n">lut_file</span> <span class="o">=</span><span class="s1">&#39;all_modes_luts.pkl&#39;</span><span class="p">,</span> 
                                                  <span class="n">load</span> <span class="o">=</span>  <span class="p">(</span><span class="n">all_modes_luts_exist</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">_CCT_LUT_CALC</span><span class="o">==</span><span class="kc">False</span><span class="p">)),</span> 
                                                  <span class="n">lut_path</span> <span class="o">=</span> <span class="n">_CCT_LUT_PATH</span><span class="p">,</span> 
                                                  <span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">_CCT_LIST_OF_CIEOBS_LUTS</span><span class="p">,</span>
                                                  <span class="n">cspace</span> <span class="o">=</span> <span class="p">[</span><span class="n">_CCT_CSPACE</span><span class="p">],</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="p">[</span><span class="n">_CCT_CSPACE_KWARGS</span><span class="p">],</span>
                                                  <span class="n">lut_vars</span> <span class="o">=</span> <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;all_modes&#39;</span><span class="p">][</span><span class="s1">&#39;lut_vars&#39;</span><span class="p">],</span>
                                                  <span class="n">verbosity</span> <span class="o">=</span> <span class="n">_CCT_VERBOSITY_LUT_GENERATION</span><span class="p">,</span>
                                                  <span class="n">lut_generator_fcn</span> <span class="o">=</span> <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;ohno2014&#39;</span><span class="p">][</span><span class="s1">&#39;_generate_lut&#39;</span><span class="p">])</span>
    
    <span class="n">_copy_luts</span><span class="p">(</span><span class="s1">&#39;all_modes&#39;</span><span class="p">,</span> <span class="n">lut</span> <span class="o">=</span> <span class="n">_CCT_LUT</span><span class="p">)</span> <span class="c1"># 2015_2 -&gt; 2006_2, 2015_10 -&gt; 2006_10</span>
    <span class="c1">#------------------------------------------------------------------------------</span>
    
    <span class="c1"># Sample requested lut_vars from general &#39;all_modes&#39; luts for each mode:</span>
    <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;none&#39;</span><span class="p">][</span><span class="s1">&#39;luts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_sample_lut_vars</span><span class="p">(</span><span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;none&#39;</span><span class="p">][</span><span class="s1">&#39;lut_vars&#39;</span><span class="p">],</span> <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;all_modes&#39;</span><span class="p">][</span><span class="s1">&#39;luts&#39;</span><span class="p">])</span>
    <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;robertson1968&#39;</span><span class="p">][</span><span class="s1">&#39;luts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_sample_lut_vars</span><span class="p">(</span><span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;robertson1968&#39;</span><span class="p">][</span><span class="s1">&#39;lut_vars&#39;</span><span class="p">],</span> <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;all_modes&#39;</span><span class="p">][</span><span class="s1">&#39;luts&#39;</span><span class="p">])</span>
    <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;zhang2019&#39;</span><span class="p">][</span><span class="s1">&#39;luts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_sample_lut_vars</span><span class="p">(</span><span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;zhang2019&#39;</span><span class="p">][</span><span class="s1">&#39;lut_vars&#39;</span><span class="p">],</span> <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;all_modes&#39;</span><span class="p">][</span><span class="s1">&#39;luts&#39;</span><span class="p">])</span>
    <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;ohno2014&#39;</span><span class="p">][</span><span class="s1">&#39;luts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_sample_lut_vars</span><span class="p">(</span><span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;ohno2014&#39;</span><span class="p">][</span><span class="s1">&#39;lut_vars&#39;</span><span class="p">],</span> <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;all_modes&#39;</span><span class="p">][</span><span class="s1">&#39;luts&#39;</span><span class="p">])</span>
    <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;li2022&#39;</span><span class="p">][</span><span class="s1">&#39;luts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_sample_lut_vars</span><span class="p">(</span><span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;li2022&#39;</span><span class="p">][</span><span class="s1">&#39;lut_vars&#39;</span><span class="p">],</span> <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;all_modes&#39;</span><span class="p">][</span><span class="s1">&#39;luts&#39;</span><span class="p">])</span>
    <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;fibonacci&#39;</span><span class="p">][</span><span class="s1">&#39;luts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_sample_lut_vars</span><span class="p">(</span><span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;fibonacci&#39;</span><span class="p">][</span><span class="s1">&#39;lut_vars&#39;</span><span class="p">],</span> <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;all_modes&#39;</span><span class="p">][</span><span class="s1">&#39;luts&#39;</span><span class="p">])</span>



<span class="c1">#==============================================================================</span>
<span class="c1"># General wrapper function for the various methods: xyz_to_cct()</span>
<span class="c1">#==============================================================================</span>

<div class="viewcode-block" id="xyz_to_cct">
<a class="viewcode-back" href="../../../../color.html#luxpy.color.cct.xyz_to_cct">[docs]</a>
<span class="k">def</span> <span class="nf">xyz_to_cct</span><span class="p">(</span><span class="n">xyzw</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;robertson1968&#39;</span><span class="p">,</span>
               <span class="n">cieobs</span> <span class="o">=</span> <span class="n">_CIEOBS</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;cct&#39;</span><span class="p">,</span> <span class="n">is_uv_input</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
               <span class="n">atol</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="n">force_tolerance</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">tol_method</span> <span class="o">=</span> <span class="s1">&#39;newton-raphson&#39;</span><span class="p">,</span> 
               <span class="n">lut_resolution_reduction_factor</span> <span class="o">=</span> <span class="n">_CCT_LUT_RESOLUTION_REDUCTION_FACTOR</span><span class="p">,</span>
               <span class="n">split_calculation_at_N</span> <span class="o">=</span> <span class="n">_CCT_SPLIT_CALC_AT_N</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="n">_CCT_MAX_ITER</span><span class="p">,</span>
               <span class="n">cspace</span> <span class="o">=</span> <span class="n">_CCT_CSPACE</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">_CCT_CSPACE_KWARGS</span><span class="p">,</span>
               <span class="n">lut</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">luts_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ignore_wl_diff</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
               <span class="n">duv_triangular_threshold</span> <span class="o">=</span> <span class="mf">0.002</span><span class="p">,</span>
               <span class="n">first_guess_mode</span> <span class="o">=</span> <span class="s1">&#39;robertson1968&#39;</span><span class="p">,</span> <span class="n">fgm_kwargs</span> <span class="o">=</span> <span class="p">{},</span>
               <span class="n">use_fast_duv</span> <span class="o">=</span> <span class="n">_CCT_FAST_DUV</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert XYZ tristimulus values to correlated color temperature (CCT) and </span>
<span class="sd">    Duv (distance above (&gt;0) or below (&lt;0) the Planckian locus) using a number</span>
<span class="sd">    of modes (methods). </span>
<span class="sd">        </span>
<span class="sd">    Args:</span>
<span class="sd">        :xyzw: </span>
<span class="sd">            | ndarray of tristimulus values</span>
<span class="sd">        :mode:</span>
<span class="sd">            | &#39;robertson1968&#39;, optional</span>
<span class="sd">            | String with name of method to use.</span>
<span class="sd">            | Options: &#39;robertson1968&#39;, &#39;ohno2014&#39;, &#39;li2016&#39;, &#39;li2022&#39;,&#39;zhang2019&#39;, &#39;fibonacci&#39;,</span>
<span class="sd">            |       (also, but see note below: &#39;mcamy1992&#39;, &#39;hernandez1999&#39;)</span>
<span class="sd">            | Note: first_guess_mode for li2016 can also be specified using a &#39;:&#39; separator,</span>
<span class="sd">            |        e.g. &#39;li2016:robertson1968&#39;</span>
<span class="sd">        :cieobs: </span>
<span class="sd">            | luxpy._CIEOBS, optional</span>
<span class="sd">            | CMF set used to calculated xyzw.</span>
<span class="sd">        :out: </span>
<span class="sd">            | &#39;cct&#39; (or 1), optional</span>
<span class="sd">            | Determines what to return.</span>
<span class="sd">            | Other options: &#39;duv&#39; (or -1), &#39;cct,duv&#39;(or 2), &quot;[cct,duv]&quot; (or -2)</span>
<span class="sd">        :is_uv_input:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | If True: xyzw contain uv input data, not xyz data!</span>
<span class="sd">        :wl: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Wavelengths used when calculating Planckian radiators.</span>
<span class="sd">            | If None: use same wavelengths as CMFs in :cieobs:.</span>
<span class="sd">        :rtol: </span>
<span class="sd">            | 1e-5, float, optional</span>
<span class="sd">            | Stop search when cct a relative tolerance is reached.</span>
<span class="sd">            | The relative tolerance is calculated as dCCT/CCT_est, </span>
<span class="sd">            | with CCT_est the current intermediate estimate in the </span>
<span class="sd">            | search and with dCCT the difference between</span>
<span class="sd">            | the present and former estimates.</span>
<span class="sd">        :atol: </span>
<span class="sd">            | 0.1, optional</span>
<span class="sd">            | Stop search when cct a absolute tolerance (K) is reached.</span>
<span class="sd">        :force_tolerance:</span>
<span class="sd">            | True, optional</span>
<span class="sd">            | If False: search only using the list of CCTs in the used lut. </span>
<span class="sd">            |           Only one loop of the full algorithm is performed. </span>
<span class="sd">            |           Accuracy depends on CCT of test source and the location</span>
<span class="sd">            |           and spacing of the CCTs in the list.</span>
<span class="sd">            | If True:  search will use adjacent CCTs to test source to create a new LUT,</span>
<span class="sd">            |           (repeat the algoritm at higher resolution, progessively zooming in</span>
<span class="sd">            |            toward the ground-truth) for tol_method == &#39;cl&#39;; when </span>
<span class="sd">            |           tol_method == &#39;nr&#39; a newton-raphson method is used.</span>
<span class="sd">            |           Because the CCT for multiple source is calculated in one go,</span>
<span class="sd">            |           the atol and rtol values have to be met for all! </span>
<span class="sd">        :tol_method:</span>
<span class="sd">            | &#39;newton-raphson&#39;, optional</span>
<span class="sd">            | (Additional) method to try and achieve set tolerances. </span>
<span class="sd">            | Options: </span>
<span class="sd">            | - &#39;cl&#39;, &#39;cascading-lut&#39;: use increasingly higher CCT-resolution</span>
<span class="sd">            |       to &#39;zoom-in&#39; on the ground-truth. (not for mode == &#39;li2016&#39;)</span>
<span class="sd">            | - &#39;nr&#39;, &#39;newton-raphson&#39;: use the method as described in Li, 2016.</span>
<span class="sd">        :lut_resolution_reduction_factor:</span>
<span class="sd">            | _CCT_LUT_RESOLUTION_REDUCTION_FACTOR, optional</span>
<span class="sd">            | Number of times the interval spanned by the adjacent Tc in a search or lut</span>
<span class="sd">            | method is downsampled (the search process will then start again)</span>
<span class="sd">        :max_iter:</span>
<span class="sd">            | _CCT_MAX_ITER, optional</span>
<span class="sd">            | Maximum number of iterations used by the cascading-lut or newton-raphson methods.</span>
<span class="sd">        :split_calculation_at_N:</span>
<span class="sd">            | _CCT_SPLIT_CALC_AT_N, optional</span>
<span class="sd">            | Split calculation when xyzw.shape[0] &gt; split_calculation_at_N. </span>
<span class="sd">            | Splitting speeds up the calculation. If None: no splitting is done.</span>
<span class="sd">        :lut:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Look-Up-Table with Ti, u,v,u&#39;,v&#39;,u&quot;,v&quot;,slope values of Planckians. </span>
<span class="sd">            | Options:</span>
<span class="sd">            |  - None: defaults to the lut specified in _CCT_LUT[mode][&#39;lut_type_def&#39;].</span>
<span class="sd">            |  - list (lut,lut_kwargs): use this pre-calculated lut </span>
<span class="sd">            |       (add additional kwargs for the lut_generator_fcn(), defaults to None if omitted)</span>
<span class="sd">            |  - tuple: must be key (label) in :luts_dict: (pre-calculated dict of luts),</span>
<span class="sd">            |           if not: then a new lut will be generated from scratch using the info in the tuple.</span>
<span class="sd">            |  - str: must be key (label) in :luts_dict: (pre-calculated dict of luts)</span>
<span class="sd">            |  - ndarray [Nx1]: list of luts for which to generate a lut</span>
<span class="sd">            |  - ndarray [Nxn] with n&gt;3: pre-calculated lut (last col must contain slope of the isotemperature lines).</span>
<span class="sd">        :luts_dict:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Dictionary of pre-calculated luts for various cspaces and cmf sets.</span>
<span class="sd">            |  Must have structure luts_dict[cspace][cieobs][lut_label] with the</span>
<span class="sd">            |   lut part of a two-element list [lut, lut_kwargs]. It must contain</span>
<span class="sd">            |   at the top-level a key &#39;wl&#39; containing the wavelengths of the </span>
<span class="sd">            |   Planckians used to generate the luts in this dictionary.</span>
<span class="sd">            | If None: the default dict for the mode is used </span>
<span class="sd">            |   (e.g. _CCT_LUT[&#39;ohno2014&#39;][&#39;lut_type_def&#39;], for mode==&#39;ohno2014&#39;).    </span>
<span class="sd">        :cspace:</span>
<span class="sd">            | _CCT_SPACE, optional</span>
<span class="sd">            | Color space to do calculations in. </span>
<span class="sd">            | Options: </span>
<span class="sd">            |    - cspace string: </span>
<span class="sd">            |        e.g. &#39;Yuv60&#39; for use with luxpy.colortf()</span>
<span class="sd">            |    - tuple with forward (i.e. xyz_to..) [and backward (i.e. ..to_xyz)] functions </span>
<span class="sd">            |      (and an optional string describing the cspace): </span>
<span class="sd">            |        e.g. (forward, backward) or (forward, backward, cspace string) or (forward, cspace string) </span>
<span class="sd">            |    - dict with keys: &#39;fwtf&#39; (foward), &#39;bwtf&#39; (backward) [, optional: &#39;str&#39; (cspace string)]</span>
<span class="sd">            |  Note: if the backward tf is not supplied, optimization in cct_to_xyz() is done in the CIE 1976 u&#39;v&#39; diagram</span>
<span class="sd">        :cspace_kwargs:</span>
<span class="sd">            | _CCT_CSPACE_KWARGS, optional</span>
<span class="sd">            | Parameter nested dictionary for the forward and backward transforms.</span>
<span class="sd">        :ignore_wl_diff:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | When getting a lut from the dictionary, if differences are</span>
<span class="sd">            | detected in the wavelengts of the lut and the ones used to calculate any</span>
<span class="sd">            | plankcians then a new lut should be generated. Seting this to True ignores</span>
<span class="sd">            | these differences and proceeds anyway.</span>
<span class="sd">        :duv_triangular_threshold:</span>
<span class="sd">            | 0.002, optional</span>
<span class="sd">            | Threshold for use of the triangular solution.</span>
<span class="sd">            |  (if smaller use triangular solution, else use the non-triangular one:  </span>
<span class="sd">            |     If mode == &#39;ohno2014&#39; -&gt; parabolic, if mode == &#39;li2022&#39; -&gt; 3e-order poly)</span>
<span class="sd">        :first_guess_mode:</span>
<span class="sd">            | &#39;robertson1968&#39;, optional (cfr. mode == &#39;li2016&#39;)</span>
<span class="sd">            | Method used to get an approximate (first guess) estimate of the cct,</span>
<span class="sd">            | after which the newton-raphson method is started.</span>
<span class="sd">            | Options: &#39;robertson1968&#39;, &#39;ohno2014&#39;, &#39;zhang2019&#39;,&#39;li2022&#39;</span>
<span class="sd">        :use_fast_duv:</span>
<span class="sd">            | _CCT_FAST_DUV, optional</span>
<span class="sd">            | If True: use a fast estimator of the Duv </span>
<span class="sd">            |   (one that avoids calculation of Planckians and uses the former</span>
<span class="sd">            |    best estimate&#39;s u,v coordinates. This method is accurate enough</span>
<span class="sd">            |    when the atol is small enough -&gt; as long as abs(T-T_former)&lt;=1K</span>
<span class="sd">            |    the Duv estimate should be ok.)</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | ndarray with:</span>
<span class="sd">            |    cct: out == &#39;cct&#39; (or 1)</span>
<span class="sd">            |    duv: out == &#39;duv&#39; (or -1)</span>
<span class="sd">            |    cct, duv: out == &#39;cct,duv&#39; (or 2)</span>
<span class="sd">            |    [cct,duv]: out == &quot;[cct,duv]&quot; (or -2) </span>
<span class="sd">            </span>

<span class="sd">    Note:</span>
<span class="sd">        1. Using the &#39;mcamy1992&#39; and &#39;hernandez1999&#39; options will result in additional</span>
<span class="sd">        errors when cieobs is different from &#39;1931_2&#39; as for these options the CCT </span>
<span class="sd">        is determined using a fixed set of equations optimized for the 1931 2° CMFs!!</span>
<span class="sd">        The only impact will be on the calculation of the Duv from the CCT. That does</span>
<span class="sd">        depend on the settings of cieobs and cspace! Change at own discretion.</span>
<span class="sd">        2. Out-of-lut CCTs are encoded as negative CCTs (with as absolute value</span>
<span class="sd">        the value of the closest CCT from the lut.)</span>
<span class="sd">    </span>
<span class="sd">    References:</span>
<span class="sd">        1.  `Robertson, A. R. (1968). </span>
<span class="sd">        Computation of Correlated Color Temperature and Distribution Temperature. </span>
<span class="sd">        Journal of the Optical Society of America,  58(11), 1528–1535. </span>
<span class="sd">        &lt;https://doi.org/10.1364/JOSA.58.001528&gt;`_</span>
<span class="sd">        </span>
<span class="sd">        2. Smet K.A.G., Royer M., Baxter D., Bretschneider E., Esposito E., Houser K., Luedtke W., Man K., Ohno Y. (2022),</span>
<span class="sd">        Recommended method for determining the correlated color temperature and distance from the Planckian Locus of a light source</span>
<span class="sd">        (in preparation, LEUKOS?)</span>
<span class="sd">        </span>
<span class="sd">        3. Baxter D., Royer M., Smet K.A.G. (2022)</span>
<span class="sd">        Modifications of the Robertson Method for Calculating Correlated Color Temperature to Improve Accuracy and Speed</span>
<span class="sd">        (in preparation, LEUKOS?)</span>
<span class="sd">         </span>
<span class="sd">        4. `Ohno Y. Practical use and calculation of CCT and Duv. </span>
<span class="sd">        Leukos. 2014 Jan 2;10(1):47-55.</span>
<span class="sd">        &lt;http://www.tandfonline.com/doi/abs/10.1080/15502724.2014.839020&gt;`_</span>
<span class="sd">        </span>
<span class="sd">        5. `Zhang, F. (2019). </span>
<span class="sd">        High-accuracy method for calculating correlated color temperature with </span>
<span class="sd">        a lookup table based on golden section search. </span>
<span class="sd">        Optik, 193, 163018. </span>
<span class="sd">        &lt;https://doi.org/https://doi.org/10.1016/j.ijleo.2019.163018&gt;`_</span>
<span class="sd">         </span>
<span class="sd">        6. `Li, C., Cui, G., Melgosa, M., Ruan, X., Zhang, Y., Ma, L., Xiao, K., &amp; Luo, M. R. (2016).</span>
<span class="sd">        Accurate method for computing correlated color temperature. </span>
<span class="sd">        Optics Express, 24(13), 14066–14078. </span>
<span class="sd">        &lt;https://doi.org/10.1364/OE.24.014066&gt;`_</span>
<span class="sd">        </span>
<span class="sd">        7. `McCamy, Calvin S. (April 1992). </span>
<span class="sd">        &quot;Correlated color temperature as an explicit function of </span>
<span class="sd">        chromaticity coordinates&quot;.</span>
<span class="sd">        Color Research &amp; Application. 17 (2): 142–144.</span>
<span class="sd">        &lt;http://onlinelibrary.wiley.com/doi/10.1002/col.5080170211/abstract&gt;`_</span>
<span class="sd">        </span>
<span class="sd">        8. `Hernández-Andrés, Javier; Lee, RL; Romero, J (September 20, 1999). </span>
<span class="sd">        Calculating Correlated Color Temperatures Across the Entire Gamut </span>
<span class="sd">        of Daylight and Skylight Chromaticities.</span>
<span class="sd">        Applied Optics. 38 (27), 5703–5709. P</span>
<span class="sd">        &lt;https://www.osapublishing.org/ao/abstract.cfm?uri=ao-38-27-5703&gt;`_</span>
<span class="sd">        </span>
<span class="sd">        9. `Li, Y., Gao, C.,  Melgosa, M. and Li, C. (2022).</span>
<span class="sd">        Improved methods for computing CCT and Duv. </span>
<span class="sd">        LEUKOS, (in press). &lt;email://794962485@qq.com&gt;`_</span>
<span class="sd">  </span>
<span class="sd">    &quot;&quot;&quot;</span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;mcamy1992&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;hernandez1999&#39;</span><span class="p">):</span>
        
        <span class="c1"># Very large LUT for fibonacci is not part of package, and is generated or downloaded on first use</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;fibonacci&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="s1">&#39;luts&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_CCT_LUT</span><span class="p">[</span><span class="s1">&#39;fibonacci&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Initializing (generate or download) Fibonacci LUTs on first use.&#39;</span><span class="p">)</span>
                <span class="n">init_fibonacci</span><span class="p">()</span> <span class="c1"># initialize LUTs for fibonacci</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">_xyz_to_cct</span><span class="p">(</span><span class="n">xyzw</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> <span class="n">is_uv_input</span> <span class="o">=</span> <span class="n">is_uv_input</span><span class="p">,</span> 
                           <span class="n">cspace</span> <span class="o">=</span> <span class="n">cspace</span><span class="p">,</span> <span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">cspace_kwargs</span><span class="p">,</span>
                           <span class="n">atol</span> <span class="o">=</span> <span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="n">rtol</span><span class="p">,</span> <span class="n">force_tolerance</span> <span class="o">=</span> <span class="n">force_tolerance</span><span class="p">,</span>
                           <span class="n">tol_method</span> <span class="o">=</span> <span class="n">tol_method</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span><span class="p">,</span>  
                           <span class="n">lut_resolution_reduction_factor</span> <span class="o">=</span> <span class="n">lut_resolution_reduction_factor</span><span class="p">,</span>
                           <span class="n">split_calculation_at_N</span> <span class="o">=</span> <span class="n">split_calculation_at_N</span><span class="p">,</span> 
                           <span class="n">lut</span> <span class="o">=</span> <span class="n">lut</span><span class="p">,</span> <span class="n">luts_dict</span> <span class="o">=</span> <span class="n">luts_dict</span><span class="p">,</span> 
                           <span class="n">ignore_wl_diff</span> <span class="o">=</span> <span class="n">ignore_wl_diff</span><span class="p">,</span> 
                           <span class="n">duv_triangular_threshold</span> <span class="o">=</span> <span class="n">duv_triangular_threshold</span><span class="p">,</span>
                           <span class="n">first_guess_mode</span> <span class="o">=</span> <span class="n">first_guess_mode</span><span class="p">,</span>
                           <span class="n">use_fast_duv</span> <span class="o">=</span> <span class="n">use_fast_duv</span><span class="p">,</span>
                           <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;mcamy1992&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xyz_to_cct_mcamy1992</span><span class="p">(</span><span class="n">xyzw</span><span class="p">,</span><span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span><span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span><span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">,</span>
                                    <span class="n">cspace</span> <span class="o">=</span> <span class="n">cspace</span><span class="p">,</span><span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">cspace_kwargs</span><span class="p">)</span>
    
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;hernandez1999&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xyz_to_cct_hernandez1999</span><span class="p">(</span><span class="n">xyzw</span><span class="p">,</span><span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span><span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span><span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">,</span>
                                    <span class="n">cspace</span> <span class="o">=</span> <span class="n">cspace</span><span class="p">,</span><span class="n">cspace_kwargs</span> <span class="o">=</span> <span class="n">cspace_kwargs</span><span class="p">)</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span> <span class="p">(</span><span class="s1">&#39;Request mode = </span><span class="si">{:s}</span><span class="s1"> not implemented.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span></div>


<span class="c1">#---------------------------------------------------------------------------------------------------</span>
<span class="k">def</span> <span class="nf">xyz_to_duv</span><span class="p">(</span><span class="n">xyzw</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;duv&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wraps xyz_to_cct, but with duv output. For kwargs info, see xyz_to_cct.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">xyz_to_cct</span><span class="p">(</span><span class="n">xyzw</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        

<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="cct_to_mired">
<a class="viewcode-back" href="../../../../color.html#luxpy.color.cct.cct_to_mired">[docs]</a>
<span class="k">def</span> <span class="nf">cct_to_mired</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert cct to Mired scale (or back). </span>

<span class="sd">    Args:</span>
<span class="sd">        :data: </span>
<span class="sd">            | ndarray with cct or Mired values.</span>

<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | ndarray ((10**6) / data)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">6</span><span class="p">,</span><span class="n">data</span><span class="p">)</span></div>

  


<span class="c1">#==============================================================================</span>
<span class="c1"># test code:</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
           
    <span class="kn">import</span> <span class="nn">luxpy</span> <span class="k">as</span> <span class="nn">lx</span> 
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span> <span class="c1"># lazy import</span>
    
    <span class="n">cieobs</span> <span class="o">=</span> <span class="s1">&#39;1931_2&#39;</span>
    
    <span class="c1"># cieobs = &#39;2015_10&#39;</span>

    <span class="c1"># ------------------------------</span>
    <span class="c1"># Setup some tests:</span>
    
    <span class="c1"># # test 1:</span>
    <span class="n">cct</span> <span class="o">=</span> <span class="mi">5000</span>    
    <span class="n">duvs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.05</span><span class="p">,</span><span class="o">-</span><span class="mf">0.025</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.025</span><span class="p">,</span><span class="mf">0.05</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
    <span class="c1"># duvs = np.array([[-0.03]]).T</span>
    <span class="n">ccts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">cct</span><span class="p">]</span><span class="o">*</span><span class="n">duvs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
    
    <span class="c1"># test 2:</span>
    <span class="c1"># duv = -0.04</span>
    <span class="c1"># duvs = np.array([[0,*[duv]*(ccts.shape[0]-1)]]).T</span>
    <span class="c1"># ccts = np.array([[1000,1050,1100,1150,1200,1250,1300,1350,1400,1450,1500,1550,1600,1650,1700,1750,1800,1850,1900,1950,2000, 3500, 4500.0, 5500, 6500, 15500,25500,35500,45500,50500]]).T</span>

    <span class="c1"># test 3:</span>
    <span class="c1"># ccts = np.array([[1625.92608972303,1626.26, 3500, 4500.0, 5500, 6500, 15500,25500,35500,45500,50500]]).T</span>
    <span class="c1"># duvs = np.array([[duv]*ccts.shape[0]]).T</span>
    <span class="c1"># duvs[0] = 0.0037117089512229</span>
    
    <span class="n">cctsduvs_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">ccts</span><span class="p">,</span><span class="n">duvs</span><span class="p">))</span>

    <span class="c1"># # Test 4 (from disk): &#39;ref_cct_duv_1500-40000K.csv&#39; or &#39;test_rob_error.csv&#39;</span>
    <span class="c1"># # cctsduvs_t = lx.utils.loadtxt(&#39;test_rob_error.csv&#39;,header=None)</span>
    <span class="c1"># cctsduvs_t = lx.utils.loadtxt(&#39;ref_cct_duv_1500-40000K.csv&#39;,header=&#39;infer&#39;)</span>
    <span class="c1"># cctsduvs_t = cctsduvs_t[cctsduvs_t[:,0] &lt;= 40000,:2]</span>
    <span class="c1"># # cctsduvs_t = cctsduvs_t[(cctsduvs_t[:,0] &gt;= 2000) &amp; (cctsduvs_t[:,0] &lt;= 20000),:2]</span>
    <span class="c1"># # cctsduvs_t = cctsduvs_t[(cctsduvs_t[:,1] &gt;= -0.03) &amp; (cctsduvs_t[:,1] &lt;= 0.03),:2]</span>

    <span class="c1"># ccts, duvs = cctsduvs_t[:,:1], cctsduvs_t[:,1:2]</span>
    
    
    <span class="c1">#--------------------------------</span>
    <span class="c1"># Backward transform from CCT,Duv to xyz to generate test xyz for forward tf:</span>
    <span class="n">cct_offset</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cct_to_xyz:&#39;</span><span class="p">)</span>
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">cct_to_xyz</span><span class="p">(</span><span class="n">ccts</span> <span class="o">=</span> <span class="n">ccts</span><span class="p">,</span> <span class="n">duv</span> <span class="o">=</span> <span class="n">duvs</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">cct_offset</span> <span class="o">=</span> <span class="n">cct_offset</span><span class="p">)</span>
    <span class="c1"># Yuv60 = lx.xyz_to_Yuv60(xyz)</span>
    <span class="c1"># Yuv60 = np.round(Yuv60,4)</span>
    <span class="c1"># xyz = lx.Yuv60_to_xyz(Yuv60)</span>
    <span class="c1"># print(&#39;Yuv60:&#39;, Yuv60)</span>
    
    <span class="c1">#--------------------------------</span>
    <span class="c1"># Forward transform from xyz to CCT,Duv using Robertson 1968 or several other methods:</span>
    <span class="n">modes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;robertson1968&#39;</span><span class="p">]</span> <span class="c1">#[&#39;robertson1968&#39;,&#39;ohno2014&#39;,&#39;zhang2019&#39;,&#39;fibonacci&#39;]</span>
    <span class="n">lut</span> <span class="o">=</span> <span class="p">((</span><span class="mf">1000.0</span><span class="p">,</span><span class="mf">41000.0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;%&#39;</span><span class="p">),)</span> <span class="c1">#_CCT_LUT[modes[0]][&#39;lut_type_def&#39;]</span>
    <span class="c1"># lut = ((1000.0,41000.0,1,&#39;%&#39;),) #_CCT_LUT[modes[0]][&#39;lut_type_def&#39;]</span>
    <span class="c1"># lut_m = _CCT_LUT[&#39;robertson1968&#39;][&#39;luts&#39;][&#39;Yuv60&#39;][&#39;1931_2&#39;][((1000.0,41000.0,1,&#39;%&#39;),)]</span>
    <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">modes</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;mode:&#39;</span><span class="p">,</span><span class="n">mode</span><span class="p">)</span>
        <span class="n">cctsduvs</span> <span class="o">=</span> <span class="n">xyz_to_cct</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">,</span><span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;[cct,duv]&#39;</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">_WL3</span><span class="p">,</span> 
                              <span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">,</span> <span class="n">force_tolerance</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                              <span class="n">tol_method</span> <span class="o">=</span> <span class="s1">&#39;nr&#39;</span><span class="p">,</span>
                              <span class="n">lut</span> <span class="o">=</span> <span class="n">lut</span><span class="p">,</span> <span class="c1">#((_CCT_LUT_MIN,_CCT_LUT_MAX,0.1,&#39;K&#39;),),</span>
                              <span class="n">split_calculation_at_N</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                              <span class="n">use_fast_duv</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    
    <span class="c1"># Out of LUT conversions are coded with a negative CCT, so make positive again before calculating error:</span>
    <span class="n">cctsduvs_</span> <span class="o">=</span> <span class="n">cctsduvs</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span><span class="n">cctsduvs_</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cctsduvs_</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># outof gamut ccts are encoded as negative!!</span>
    
    <span class="c1">#--------------------------------</span>
    <span class="c1"># Close loop: Backward transform from CCT,Duv (obtained from forward tf) to xyz</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cct_to_xyz2&#39;</span><span class="p">)</span>
    <span class="n">xyz_</span> <span class="o">=</span> <span class="n">cct_to_xyz</span><span class="p">(</span><span class="n">cctsduvs_</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">cct_offset</span> <span class="o">=</span> <span class="n">cct_offset</span><span class="p">)</span>
    
    <span class="c1">#--------------------------------</span>
    <span class="c1"># Calculate CCT,Duv and XYZ errors:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cctsduvs_t:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">cctsduvs_t</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cctsduvs:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">cctsduvs</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Dcctsduvs:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">cctsduvs_</span> <span class="o">-</span> <span class="n">cctsduvs_t</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Dxyz:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">xyz</span> <span class="o">-</span> <span class="n">xyz_</span><span class="p">)</span>
    
    <span class="c1">#---------------------------------</span>
    <span class="c1"># Make a plot of the errors:    </span>
    <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cctsduvs_</span> <span class="o">-</span> <span class="n">cctsduvs_t</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ccts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">[:,</span><span class="n">i</span><span class="p">],</span><span class="s1">&#39;o&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">*</span><span class="n">lut</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="mi">2</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span><span class="s1">&#39;r.&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="n">d</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">*</span><span class="mf">1.1</span><span class="p">,</span><span class="n">d</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">*</span><span class="mf">1.1</span><span class="p">])</span>
    
  
    <span class="n">xyz_to_cct_</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">xyz</span><span class="p">:</span> <span class="n">xyz_to_cct</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">,</span><span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;[cct,duv]&#39;</span><span class="p">,</span> 
                          <span class="n">force_tolerance</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">lut</span> <span class="o">=</span> <span class="n">lut</span><span class="p">,</span><span class="n">split_calculation_at_N</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    
    
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Kevin A.G. Smet.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>