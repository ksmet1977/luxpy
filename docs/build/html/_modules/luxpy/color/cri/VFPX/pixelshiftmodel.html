

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>luxpy.color.cri.VFPX.pixelshiftmodel &mdash; LuxPy 1.5.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../../" src="../../../../../_static/documentation_options.js"></script>
        <script src="../../../../../_static/jquery.js"></script>
        <script src="../../../../../_static/underscore.js"></script>
        <script src="../../../../../_static/doctools.js"></script>
        <script src="../../../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../../index.html" class="icon icon-home"> LuxPy
          

          
          </a>

          
            
            
              <div class="version">
                1.5.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../license.html">License: GPLv3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../required_packages.html">Imported (required) packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../luxpy_structure.html">Luxpy package structure</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">LuxPy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../../index.html">Module code</a> &raquo;</li>
        
      <li>luxpy.color.cri.VFPX.pixelshiftmodel</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for luxpy.color.cri.VFPX.pixelshiftmodel</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">########################################################################</span>
<span class="c1"># &lt;LUXPY: a Python package for lighting and color science.&gt;</span>
<span class="c1"># Copyright (C) &lt;2017&gt;  &lt;Kevin A.G. Smet&gt; (ksmet1977 at gmail.com)</span>
<span class="c1">#</span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#########################################################################</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module with functions related to color rendering Pixel models</span>
<span class="sd">=============================================================</span>

<span class="sd"> :get_pixel_coordinates(): Get pixel coordinates corresponding to array of </span>
<span class="sd">                           jab color coordinates.</span>

<span class="sd"> :PX_colorshift_model(): Pixelates the color space </span>
<span class="sd">                         and calculates the color shifts in each pixel.</span>

<span class="sd">.. codeauthor:: Kevin A.G. Smet (ksmet1977 at gmail.com)</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">luxpy.utils</span> <span class="kn">import</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">.vectorshiftmodel</span> <span class="kn">import</span> <span class="n">_VF_DELTAR</span><span class="p">,</span> <span class="n">_VF_MAXR</span><span class="p">,</span> <span class="n">generate_grid</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;get_pixel_coordinates&#39;</span><span class="p">,</span><span class="s1">&#39;PX_colorshift_model&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="get_pixel_coordinates"><a class="viewcode-back" href="../../../../../color.html#luxpy.color.cri.VFPX.get_pixel_coordinates">[docs]</a><span class="k">def</span> <span class="nf">get_pixel_coordinates</span><span class="p">(</span><span class="n">jab</span><span class="p">,</span> <span class="n">jab_ranges</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">jab_deltas</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">limit_grid_radius</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get pixel coordinates corresponding to array of jab color coordinates.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :jab: </span>
<span class="sd">            | ndarray of color coordinates</span>
<span class="sd">        :jab_ranges:</span>
<span class="sd">            | None or ndarray, optional</span>
<span class="sd">            | Specifies the pixelization of color space.</span>
<span class="sd">            |    (ndarray.shape = (3,3), with  first axis: J,a,b, and second </span>
<span class="sd">                 axis: min, max, delta)</span>
<span class="sd">        :jab_deltas:</span>
<span class="sd">            | float or ndarray, optional</span>
<span class="sd">            | Specifies the sampling range. </span>
<span class="sd">            | A float uses jab_deltas as the maximum Euclidean distance to select</span>
<span class="sd">            | samples around each pixel center. A ndarray of 3 deltas, uses</span>
<span class="sd">            | a city block sampling around each pixel center.</span>
<span class="sd">        :limit_grid_radius: </span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | A value of zeros keeps grid as specified by axr,bxr.</span>
<span class="sd">            | A value &gt; 0 only keeps (a,b) coordinates within :limit_grid_radius: </span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | gridp, idxp, jabp, samplenrs, samplesIDs</span>
<span class="sd">            |   - :gridp: ndarray with coordinates of all pixel centers.</span>
<span class="sd">            |   - :idxp: list[int] with pixel index for each non-empty pixel</span>
<span class="sd">            |   - :jabp: ndarray with center color coordinates of non-empty pixels</span>
<span class="sd">            |   - :samplenrs: list[list[int]] with sample numbers belong to each </span>
<span class="sd">            |                 non-empty pixel</span>
<span class="sd">            |   - :sampleIDs: summarizing list, </span>
<span class="sd">            |                 with column order: &#39;idxp, jabp, samplenrs&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">jab_deltas</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">jab_deltas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">_VF_DELTAR</span><span class="p">,</span><span class="n">_VF_DELTAR</span><span class="p">,</span><span class="n">_VF_DELTAR</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">jab_ranges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">jab_ranges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(([</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="n">jab_deltas</span><span class="p">[</span><span class="mi">0</span><span class="p">]],[</span><span class="o">-</span><span class="n">_VF_MAXR</span><span class="p">,</span><span class="n">_VF_MAXR</span><span class="o">+</span><span class="n">jab_deltas</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">jab_deltas</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="o">-</span><span class="n">_VF_MAXR</span><span class="p">,</span><span class="n">_VF_MAXR</span><span class="o">+</span><span class="n">jab_deltas</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">jab_deltas</span><span class="p">[</span><span class="mi">2</span><span class="p">]]))</span>
    
    <span class="c1"># Get pixel grid:</span>
    <span class="n">gridp</span> <span class="o">=</span> <span class="n">generate_grid</span><span class="p">(</span><span class="n">jab_ranges</span> <span class="o">=</span> <span class="n">jab_ranges</span><span class="p">,</span> <span class="n">limit_grid_radius</span> <span class="o">=</span> <span class="n">limit_grid_radius</span><span class="p">)</span> 

    <span class="c1"># determine pixel coordinates of each sample in jab:</span>
    <span class="n">samplesIDs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">gridp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        
        <span class="c1"># get pixel coordinates:</span>
        <span class="n">jp</span> <span class="o">=</span> <span class="n">gridp</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ap</span> <span class="o">=</span> <span class="n">gridp</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">bp</span> <span class="o">=</span> <span class="n">gridp</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
        <span class="c1">#Cp = np.sqrt(ap**2+bp**2)</span>
                      
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">jab_deltas</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="n">sampleID</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(((</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">jab</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">jp</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">jab_deltas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">jab</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ap</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">jab_deltas</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">jab</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">bp</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">jab_deltas</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sampleID</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">jab</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">jp</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">jab</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ap</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">jab</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">bp</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">jab_deltas</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">sampleID</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">samplesIDs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">idx</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">jp</span><span class="p">,</span><span class="n">ap</span><span class="p">,</span><span class="n">bp</span><span class="p">]),</span><span class="n">sampleID</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
       
    <span class="n">idxp</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">samplesIDs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">samplesIDs</span><span class="p">))]</span>
    <span class="n">jabp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">samplesIDs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">samplesIDs</span><span class="p">))])</span>
    <span class="n">samplenrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">samplesIDs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">4</span><span class="p">:],</span><span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">samplesIDs</span><span class="p">))]</span>
    
    <span class="k">return</span> <span class="n">gridp</span><span class="p">,</span> <span class="n">idxp</span><span class="p">,</span><span class="n">jabp</span><span class="p">,</span><span class="n">samplenrs</span><span class="p">,</span> <span class="n">samplesIDs</span></div>


<div class="viewcode-block" id="PX_colorshift_model"><a class="viewcode-back" href="../../../../../color.html#luxpy.color.cri.VFPX.PX_colorshift_model">[docs]</a><span class="k">def</span> <span class="nf">PX_colorshift_model</span><span class="p">(</span><span class="n">Jabt</span><span class="p">,</span><span class="n">Jabr</span><span class="p">,</span> <span class="n">jab_ranges</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">jab_deltas</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="n">limit_grid_radius</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pixelates the color space and calculates the color shifts in each pixel.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :Jabt: </span>
<span class="sd">            | ndarray with color coordinates under the (single) test SPD.</span>
<span class="sd">        :Jabr: </span>
<span class="sd">            | ndarray with color coordinates under the (single) reference SPD.  </span>
<span class="sd">        :jab_ranges:</span>
<span class="sd">            | None or ndarray, optional</span>
<span class="sd">            | Specifies the pixelization of color space.</span>
<span class="sd">            | (ndarray.shape = (3,3), with  first axis: J,a,b, and second </span>
<span class="sd">            | axis: min, max, delta)</span>
<span class="sd">        :jab_deltas:</span>
<span class="sd">            | float or ndarray, optional</span>
<span class="sd">            | Specifies the sampling range. </span>
<span class="sd">            | A float uses jab_deltas as the maximum Euclidean distance to select</span>
<span class="sd">            | samples around each pixel center. A ndarray of 3 deltas, uses</span>
<span class="sd">            | a city block sampling around each pixel center.</span>
<span class="sd">        :limit_grid_radius:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | A value of zeros keeps grid as specified by axr,bxr.</span>
<span class="sd">            | A value &gt; 0 only keeps (a,b) coordinates within :limit_grid_radius:</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | dict with the following keys:</span>
<span class="sd">            |   - &#39;Jab&#39;: dict with with ndarrays for:</span>
<span class="sd">            |        Jabt, Jabr, DEi, DEi_ab (only ab-coordinates), DEa (mean) </span>
<span class="sd">            |         and DEa_ab</span>
<span class="sd">            |   - &#39;vshifts&#39;: dict with:</span>
<span class="sd">            |      * &#39;vectorshift&#39;: ndarray with vector shifts between average</span>
<span class="sd">            |                       Jabt and Jabr for each pixel</span>
<span class="sd">            |      * &#39;vectorshift_ab&#39;: ndarray with vector shifts averaged </span>
<span class="sd">            |                          over J for each pixel</span>
<span class="sd">            |      * &#39;vectorshift_ab_J0&#39;: ndarray with vector shifts averaged </span>
<span class="sd">            |                             over J for each pixel of J=0 plane.</span>
<span class="sd">            |      * &#39;vectorshift_len&#39;: length of &#39;vectorshift&#39;</span>
<span class="sd">            |      * &#39;vectorshift_ab_len&#39;: length of &#39;vectorshift_ab&#39;</span>
<span class="sd">            |      * &#39;vectorshift_ab_J0_len&#39;: length of &#39;vectorshift_ab_J0&#39;</span>
<span class="sd">            |      * &#39;vectorshift_len_DEnormed&#39;: length of &#39;vectorshift&#39; </span>
<span class="sd">            |                                    normalized to &#39;DEa&#39;</span>
<span class="sd">            |      * &#39;vectorshift_ab_len_DEnormed&#39;: length of &#39;vectorshift_ab&#39; </span>
<span class="sd">            |                                       normalized to &#39;DEa_ab&#39;</span>
<span class="sd">            |      * &#39;vectorshift_ab_J0_len_DEnormed&#39;: length of &#39;vectorshift_ab_J0&#39; </span>
<span class="sd">            |                                          normalized to &#39;DEa_ab&#39;</span>
<span class="sd">            |   - &#39;pixeldata&#39;: dict with pixel info:</span>
<span class="sd">            |      * &#39;grid&#39; ndarray with coordinates of all pixel centers.</span>
<span class="sd">            |      * &#39;idx&#39;: list[int] with pixel index for each non-empty pixel</span>
<span class="sd">            |      * &#39;Jab&#39;: ndarray with center coordinates of non-empty pixels</span>
<span class="sd">            |      * &#39;samplenrs&#39;: list[list[int]] with sample numbers belong to </span>
<span class="sd">            |                     each non-empty pixel</span>
<span class="sd">            |      * &#39;IDs: summarizing list, </span>
<span class="sd">            |              with column order: &#39;idxp, jabp, samplenrs&#39;</span>
<span class="sd">            |  - &#39;fielddata&#39; : dict with dicts containing data on the calculated </span>
<span class="sd">            |                  vector-field and circle-fields </span>
<span class="sd">            |      * &#39;vectorfield&#39;: dict with ndarrays for the ab-coordinates </span>
<span class="sd">            |         under the ref. (axr, bxr) and test (axt, bxt) illuminants,</span>
<span class="sd">            |         centered at the pixel centers corresponding to the </span>
<span class="sd">                      ab-coordinates of the reference illuminant.</span>
<span class="sd">     &quot;&quot;&quot;</span>
    
    
    
    <span class="c1"># get pixelIDs of all samples under ref. conditions:</span>
    <span class="n">gridp</span><span class="p">,</span><span class="n">idxp</span><span class="p">,</span> <span class="n">jabp</span><span class="p">,</span> <span class="n">pixelsamplenrs</span><span class="p">,</span> <span class="n">pixelIDs</span> <span class="o">=</span> <span class="n">get_pixel_coordinates</span><span class="p">(</span><span class="n">Jabr</span><span class="p">,</span> <span class="n">jab_ranges</span> <span class="o">=</span> <span class="n">jab_ranges</span><span class="p">,</span> <span class="n">jab_deltas</span> <span class="o">=</span> <span class="n">jab_deltas</span><span class="p">,</span> <span class="n">limit_grid_radius</span> <span class="o">=</span> <span class="n">limit_grid_radius</span><span class="p">)</span>

    <span class="c1"># get average Jab coordinates for each pixel:</span>
    <span class="n">Npixels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">idxp</span><span class="p">)</span> <span class="c1"># number of non-empty pixels</span>
    <span class="n">Jabr_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">gridp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">3</span><span class="p">));</span><span class="n">Jabr_avg</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">Jabt_avg</span> <span class="o">=</span> <span class="n">Jabr_avg</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Npixels</span><span class="p">):</span>
        <span class="n">Jabr_avg</span><span class="p">[</span><span class="n">idxp</span><span class="p">[</span><span class="n">i</span><span class="p">],:]</span> <span class="o">=</span> <span class="n">Jabr</span><span class="p">[</span><span class="n">pixelsamplenrs</span><span class="p">[</span><span class="n">i</span><span class="p">],:]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">Jabt_avg</span><span class="p">[</span><span class="n">idxp</span><span class="p">[</span><span class="n">i</span><span class="p">],:]</span> <span class="o">=</span> <span class="n">Jabt</span><span class="p">[</span><span class="n">pixelsamplenrs</span><span class="p">[</span><span class="n">i</span><span class="p">],:]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1">#jabtemp = Jabr[pixelsamplenrs[i],:]</span>
        <span class="c1">#jabtempm = Jabr_avg[idxp[i],:]</span>
            
    <span class="c1"># calculate Jab vector shift:    </span>
    <span class="n">vectorshift</span> <span class="o">=</span> <span class="n">Jabt_avg</span> <span class="o">-</span> <span class="n">Jabr_avg</span>
    
    <span class="c1"># calculate ab vector shift:</span>
    <span class="n">uabs</span> <span class="o">=</span> <span class="n">gridp</span><span class="p">[</span><span class="n">gridp</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="c1">#np.unique(gridp[:,1:3],axis=0)</span>
    <span class="n">vectorshift_ab_J0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">uabs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">));</span><span class="n">vectorshift_ab_J0</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">vectorshift_ab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">vectorshift</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">));</span><span class="n">vectorshift_ab</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">uabs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="p">(</span><span class="n">gridp</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">uabs</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cond</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">vectorshift</span><span class="p">[</span><span class="n">cond</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">()):</span> <span class="c1">#last condition is to avoid warning of taking nanmean of empty slice when all are NaNs</span>
            <span class="n">vectorshift_ab_J0</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">vectorshift</span><span class="p">[</span><span class="n">cond</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">vectorshift_ab</span><span class="p">[</span><span class="n">cond</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">vectorshift</span><span class="p">[</span><span class="n">cond</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
   
    <span class="c1"># Calculate length of shift vectors:</span>
    <span class="n">vectorshift_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">vectorshift</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="n">vectorshift</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">vectorshift_ab_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">vectorshift_ab</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="n">vectorshift_ab</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">vectorshift_ab_J0_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">vectorshift_ab_J0</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="n">vectorshift_ab_J0</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    
    <span class="c1"># Calculate average DE for normalization of vectorshifts</span>
    <span class="n">DEi_Jab_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(((</span><span class="n">Jabt</span><span class="o">-</span><span class="n">Jabr</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="n">Jabr</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">DE_Jab_avg</span> <span class="o">=</span> <span class="n">DEi_Jab_avg</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> 
    <span class="n">DEi_ab_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(((</span><span class="n">Jabt</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">Jabr</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="n">Jabr</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">DE_ab_avg</span> <span class="o">=</span> <span class="n">DEi_ab_avg</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> 

    <span class="c1"># calculate vectorfield:</span>
    <span class="n">axr</span> <span class="o">=</span> <span class="n">uabs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">bxr</span> <span class="o">=</span> <span class="n">uabs</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">axt</span> <span class="o">=</span> <span class="n">axr</span> <span class="o">+</span> <span class="n">vectorshift_ab_J0</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">bxt</span> <span class="o">=</span> <span class="n">bxr</span> <span class="o">+</span> <span class="n">vectorshift_ab_J0</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>

    <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Jab&#39;</span> <span class="p">:</span> <span class="p">{</span><span class="s1">&#39;Jabr&#39;</span><span class="p">:</span> <span class="n">Jabr_avg</span><span class="p">,</span> <span class="s1">&#39;Jabt&#39;</span><span class="p">:</span> <span class="n">Jabt_avg</span><span class="p">,</span> 
                    <span class="s1">&#39;DEi&#39;</span> <span class="p">:</span> <span class="n">DEi_Jab_avg</span><span class="p">,</span> <span class="s1">&#39;DEi_ab&#39;</span><span class="p">:</span> <span class="n">DEi_ab_avg</span><span class="p">,</span>
                    <span class="s1">&#39;DEa&#39;</span> <span class="p">:</span> <span class="n">DE_Jab_avg</span><span class="p">,</span> <span class="s1">&#39;DEa_ab&#39;</span> <span class="p">:</span> <span class="n">DE_ab_avg</span><span class="p">},</span> 
           <span class="s1">&#39;vshifts&#39;</span> <span class="p">:</span> <span class="p">{</span><span class="s1">&#39;vectorshift&#39;</span> <span class="p">:</span> <span class="n">vectorshift</span><span class="p">,</span> <span class="s1">&#39;vectorshift_ab&#39;</span> <span class="p">:</span> <span class="n">vectorshift_ab</span><span class="p">,</span> 
                        <span class="s1">&#39;vectorshift_ab_J0&#39;</span> <span class="p">:</span> <span class="n">vectorshift_ab_J0</span><span class="p">,</span>
                        <span class="s1">&#39;vectorshift_len&#39;</span> <span class="p">:</span> <span class="n">vectorshift_len</span><span class="p">,</span> <span class="s1">&#39;vectorshift_ab_len&#39;</span> <span class="p">:</span> <span class="n">vectorshift_ab_len</span><span class="p">,</span>
                        <span class="s1">&#39;vectorshift_ab_J0_len&#39;</span> <span class="p">:</span> <span class="n">vectorshift_ab_J0_len</span><span class="p">,</span>
                         <span class="s1">&#39;vectorshift_len_DEnormed&#39;</span> <span class="p">:</span> <span class="n">vectorshift_len</span><span class="o">/</span><span class="n">DE_Jab_avg</span><span class="p">,</span> 
                         <span class="s1">&#39;vectorshift_ab_len_DEnormed&#39;</span> <span class="p">:</span> <span class="n">vectorshift_ab_len</span><span class="o">/</span><span class="n">DE_ab_avg</span><span class="p">,</span> 
                         <span class="s1">&#39;vectorshift_ab_J0_len_DEnormed&#39;</span> <span class="p">:</span> <span class="n">vectorshift_ab_J0_len</span><span class="o">/</span><span class="n">DE_ab_avg</span><span class="p">},</span>
           <span class="s1">&#39;pixeldata&#39;</span> <span class="p">:</span> <span class="p">{</span><span class="s1">&#39;grid&#39;</span> <span class="p">:</span> <span class="n">gridp</span><span class="p">,</span> <span class="s1">&#39;idx&#39;</span> <span class="p">:</span> <span class="n">idxp</span><span class="p">,</span><span class="s1">&#39;Jab&#39;</span><span class="p">:</span> <span class="n">jabp</span><span class="p">,</span> 
                          <span class="s1">&#39;samplenrs&#39;</span> <span class="p">:</span> <span class="n">pixelsamplenrs</span><span class="p">,</span><span class="s1">&#39;IDs&#39;</span><span class="p">:</span> <span class="n">pixelIDs</span><span class="p">},</span>
           <span class="s1">&#39;fielddata&#39;</span> <span class="p">:</span> <span class="p">{</span><span class="s1">&#39;vectorfield&#39;</span> <span class="p">:</span> <span class="p">{</span><span class="s1">&#39;axr&#39;</span> <span class="p">:</span> <span class="n">axr</span><span class="p">,</span> <span class="s1">&#39;bxr&#39;</span> <span class="p">:</span> <span class="n">bxr</span><span class="p">,</span> <span class="s1">&#39;axt&#39;</span> <span class="p">:</span> <span class="n">axt</span><span class="p">,</span> <span class="s1">&#39;bxt&#39;</span> <span class="p">:</span> <span class="n">bxt</span><span class="p">}}</span>
           <span class="p">}</span>
    <span class="k">return</span> <span class="n">data</span></div>

</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Kevin A.G. Smet

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>